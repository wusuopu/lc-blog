<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[龍昌博客]]></title>
  <link href="http://www.xefan.com/atom.xml" rel="self"/>
  <link href="http://www.xefan.com/"/>
  <updated>2015-05-13T23:10:33+08:00</updated>
  <id>http://www.xefan.com/</id>
  <author>
    <name><![CDATA[龍昌]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Ruby 3.0的未来]]></title>
    <link href="http://www.xefan.com/archives/84144.html"/>
    <updated>2015-05-13T21:33:08+08:00</updated>
    <id>http://www.xefan.com/archives/84144-Ruby 3.0的未来</id>
    <content type="html"><![CDATA[<p>原文地址：<a href="http://hrnabi.com/2015/05/12/7035/  ">http://hrnabi.com/2015/05/12/7035/  </a>
谁日语好的为大家做下贡献，把原文翻译一下吧。</p>

<p>反正我不会日语，根据文中的一些汉字连蒙带猜的，大致看了一遍，现在简单总结一下。
如果有总结得不对的，本人不负责哦。</p>

<p>看来要玩好Ruby不仅需要学英语，也还得学日语啊。</p>

<hr />

<p>在2014年9月举行的 RubyKaigi 2014 大会上，Matz在演讲过程中首次提到了 Ruby 3.0。<br/>
文中说的Ruby 3.0的三个工作方向：</p>

<ul>
<li>Concurrency (并行性)</li>
<li>JIT (即时编译)</li>
<li>Static typing (静态类型)</li>
</ul>


<p>Ruby要引入静态类型检查？<br/>
Matz说，在20世纪出生的语言大多是脚本语言，如：Ruby、PHP和Perl、JavaScript，这些都不是静态类型的。
另一方面，最近推出的如Scala和Dart、Go是属于静态类型的。
在Ruby中可以考虑引入Python这种通过注释来进行检查的方法。</p>

<p>Ruby要引入并行计算？<br/>
Matz详细讨论了静态类型，但没有提到并行计算。详细的内容是由笹田氏来说的。<br/>
（这部分内容我没看懂，只是大概知道这位笹田氏的博士论文与这个相关。）<br/>
关于并行计算，Matz提到了Erlang和Scala的actor模型。</p>

<p>最后期待下一个Ruby开发者大会。</p>

<hr />

<p>好了，我只看懂了这么多。其余的各位感兴趣的自己去看原文吧。
(怎么感觉好坑啊，这总结得跟没总结一样啊。没办法了我的日语水平有限。)</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Ruby中一些重要的钩子方法]]></title>
    <link href="http://www.xefan.com/archives/84143.html"/>
    <updated>2015-04-30T22:35:42+08:00</updated>
    <id>http://www.xefan.com/archives/84143-Ruby中一些重要的钩子方法</id>
    <content type="html"><![CDATA[<p>Ruby的哲学理念是基于一个基本的要素，那就是让程序员快乐。Ruby非常注重程序员的快乐，并且也提供了许多不同的方法来实现它。
它的元编程能力能够让程序员编写在运行时动态生成的代码。它的线程功能使得程序员有一种优雅的的方式编写多线程代码。
它的钩子方法能让程序员在程序运行时扩展它的行为。</p>

<p>上述的这些特性，以及一些其他很酷的语言方面，使得Ruby成为编写代码的优先选择之一。
本文将探讨Ruby中的一些重要的钩子方法。我们将从不同方面讨论钩子方法，如它们是什么，它们用于什么，以及我们如何使用它们来解决不同的问题。
我们同时也了解一下一些流行的Ruby框架/Gem包/库是如何使用它们来提供非常酷的特性的。</p>

<p>我们开始吧。</p>

<h1>什么是钩子方法？</h1>

<p>钩子方法提供了一种方式用于在程序运行时扩展程序的行为。
假设有这样的功能，可以在无论何时一个子类继承了一些特定的父类时收到通知，
或者是比较优雅地处理一个对象上的不可调用的方法而不是让编译器抛出异常。
这些情况就是使用钩子方法，但是它们的用法并不仅限于此。
不同的框架/库使用了不同的钩子方法来实现它们的功能。</p>

<p>在本文中我们将会讨论如下几个钩子方法：</p>

<ul>
<li>included</li>
<li>extended</li>
<li>prepended</li>
<li>inherited</li>
<li>method_missing</li>
</ul>


<h2>included</h2>

<p>Ruby给我们提供了一种方式使用 <code>模块(modules)</code> （在其他语言中被称作 <code>混入类(mixins)</code>）来编写模块化的代码供其他的 <code>模块</code>/<code>类</code> 使用。
<code>模块</code> 的概念很简单，它就是一个可以在其他地方使用的独立代码块。</p>

<p>例如，如果我们想要编写一些代码在任何时候调用特定的方法都会返回一个静态字符串。
我们姑且将这个方法称作 <code>name</code>。你可能在其他地方也会想使用同一块代码。
这样最好是新建一个模块。让我们来创建一个：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="k">module</span> <span class="nn">Person</span>
</span><span class='line'>  <span class="k">def</span> <span class="nf">name</span>
</span><span class='line'>    <span class="nb">puts</span> <span class="s2">&quot;My name is Person&quot;</span>
</span><span class='line'>  <span class="k">end</span>
</span><span class='line'><span class="k">end</span>
</span></code></pre></td></tr></table></div></figure>


<p>这是一个非常简单的模块，仅有一个 <code>name</code> 方法用于返回一个静态字符串。在我们的程序中使用这个模块：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="k">class</span> <span class="nc">User</span>
</span><span class='line'>  <span class="kp">include</span> <span class="no">Person</span>
</span><span class='line'><span class="k">end</span>
</span></code></pre></td></tr></table></div></figure>


<p>Ruby提供了一些不同的方法来使用<code>模块</code>。<code>include</code> 是其中之一。<code>include</code> 所做的就是将在 <code>module</code> 内定义的方法在一个 <code>class</code> 的实例变量上可用。
在我们的例子中，是将 <code>Person</code> 模块中定义的方法变为一个 <code>User</code> 类实例对象的方法。
这就相当于我们是将 <code>name</code> 方法写在 <code>User</code> 类里一样，但是定义在 <code>module</code> 里的好处是可复用。
要调用 <code>name</code> 方法我们需要创建一个 <code>User</code> 的实例对象，然后再在这个对象上调用 <code>name</code> 方法。例如：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="no">User</span><span class="o">.</span><span class="n">new</span><span class="o">.</span><span class="n">name</span>
</span><span class='line'><span class="o">=&gt;</span> <span class="no">My</span> <span class="nb">name</span> <span class="n">is</span> <span class="no">Person</span>
</span></code></pre></td></tr></table></div></figure>


<p>让我们看看基于 <code>include</code> 的钩子方法。<code>included</code> 是Ruby提供的一个钩子方法，当你在一些 <code>module</code> 或者 <code>class</code> 中 <code>include</code> 了一个 <code>module</code> 时它会被调用。
更新 <code>Person</code> 模块：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="k">module</span> <span class="nn">Person</span>
</span><span class='line'>  <span class="k">def</span> <span class="nc">self</span><span class="o">.</span><span class="nf">included</span><span class="p">(</span><span class="n">base</span><span class="p">)</span>
</span><span class='line'>    <span class="nb">puts</span> <span class="s2">&quot;</span><span class="si">#{</span><span class="n">base</span><span class="si">}</span><span class="s2"> included </span><span class="si">#{</span><span class="nb">self</span><span class="si">}</span><span class="s2">&quot;</span>
</span><span class='line'>  <span class="k">end</span>
</span><span class='line'>
</span><span class='line'>  <span class="k">def</span> <span class="nf">name</span>
</span><span class='line'>    <span class="s2">&quot;My name is Person&quot;</span>
</span><span class='line'>  <span class="k">end</span>
</span><span class='line'><span class="k">end</span>
</span></code></pre></td></tr></table></div></figure>


<p>你可以看到一个新的方法 <code>included</code> 被定义为 <code>Person</code> 模块的类方法。当你在其他的模块或者类中执行 <code>include Person</code> 时，这个 <code>included</code> 方法会被调用。
该方法接收的一个参数是对包含该模块的类的引用。试试运行 <code>User.new.name</code>，你会看到如下的输出：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="no">User</span> <span class="n">included</span> <span class="no">Person</span>
</span><span class='line'><span class="no">My</span> <span class="nb">name</span> <span class="n">is</span> <span class="no">Person</span>
</span></code></pre></td></tr></table></div></figure>


<p>正如你所见，<code>base</code> 返回的是包含该模块的类名。现在我们有了一个包含 <code>Person</code> 模块的类的引用，我们可以通过元编程来实现我们想要的功能。
让我们来看看 <strong>Devise</strong>是如何使用 <code>included</code> 钩子的。</p>

<h3>Devise中的 <code>included</code></h3>

<p>Devise是Ruby中使用最广泛的身份验证gem包之一。它主要是由我喜欢的程序员 <a href="https://twitter.com/josevalim">José Valim</a> 开发的，现在是由一些了不起的贡献者在维护。
Devise为我们提供了从注册到登录，从忘记密码到找回密码等等完善的功能。它可以让我们在用户模型中使用简单的语法来配置各种模块：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="n">devise</span> <span class="ss">:database_authenticatable</span><span class="p">,</span> <span class="ss">:registerable</span><span class="p">,</span> <span class="ss">:validatable</span>
</span></code></pre></td></tr></table></div></figure>


<p>在我们模型中使用的 <code>devise</code> 方法在<a href="https://github.com/plataformatec/devise/blob/v3.4.1/lib/devise/models.rb#L77">这里</a>定义。
为了方便我将这段代码粘贴在下面：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="k">def</span> <span class="nf">devise</span><span class="p">(</span><span class="o">*</span><span class="n">modules</span><span class="p">)</span>
</span><span class='line'>  <span class="n">options</span> <span class="o">=</span> <span class="n">modules</span><span class="o">.</span><span class="n">extract_options!</span><span class="o">.</span><span class="n">dup</span>
</span><span class='line'>
</span><span class='line'>  <span class="n">selected_modules</span> <span class="o">=</span> <span class="n">modules</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="o">&amp;</span><span class="ss">:to_sym</span><span class="p">)</span><span class="o">.</span><span class="n">uniq</span><span class="o">.</span><span class="n">sort_by</span> <span class="k">do</span> <span class="o">|</span><span class="n">s</span><span class="o">|</span>
</span><span class='line'>    <span class="no">Devise</span><span class="o">::</span><span class="no">ALL</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="o">||</span> <span class="o">-</span><span class="mi">1</span>  <span class="c1"># follow Devise::ALL order</span>
</span><span class='line'>  <span class="k">end</span>
</span><span class='line'>
</span><span class='line'>  <span class="n">devise_modules_hook!</span> <span class="k">do</span>
</span><span class='line'>    <span class="kp">include</span> <span class="no">Devise</span><span class="o">::</span><span class="no">Models</span><span class="o">::</span><span class="no">Authenticatable</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">selected_modules</span><span class="o">.</span><span class="n">each</span> <span class="k">do</span> <span class="o">|</span><span class="n">m</span><span class="o">|</span>
</span><span class='line'>      <span class="n">mod</span> <span class="o">=</span> <span class="no">Devise</span><span class="o">::</span><span class="no">Models</span><span class="o">.</span><span class="n">const_get</span><span class="p">(</span><span class="n">m</span><span class="o">.</span><span class="n">to_s</span><span class="o">.</span><span class="n">classify</span><span class="p">)</span>
</span><span class='line'>
</span><span class='line'>      <span class="k">if</span> <span class="n">mod</span><span class="o">.</span><span class="n">const_defined?</span><span class="p">(</span><span class="s2">&quot;ClassMethods&quot;</span><span class="p">)</span>
</span><span class='line'>        <span class="n">class_mod</span> <span class="o">=</span> <span class="n">mod</span><span class="o">.</span><span class="n">const_get</span><span class="p">(</span><span class="s2">&quot;ClassMethods&quot;</span><span class="p">)</span>
</span><span class='line'>        <span class="kp">extend</span> <span class="n">class_mod</span>
</span><span class='line'>
</span><span class='line'>        <span class="k">if</span> <span class="n">class_mod</span><span class="o">.</span><span class="n">respond_to?</span><span class="p">(</span><span class="ss">:available_configs</span><span class="p">)</span>
</span><span class='line'>          <span class="n">available_configs</span> <span class="o">=</span> <span class="n">class_mod</span><span class="o">.</span><span class="n">available_configs</span>
</span><span class='line'>          <span class="n">available_configs</span><span class="o">.</span><span class="n">each</span> <span class="k">do</span> <span class="o">|</span><span class="n">config</span><span class="o">|</span>
</span><span class='line'>            <span class="k">next</span> <span class="k">unless</span> <span class="n">options</span><span class="o">.</span><span class="n">key?</span><span class="p">(</span><span class="n">config</span><span class="p">)</span>
</span><span class='line'>            <span class="nb">send</span><span class="p">(</span><span class="ss">:&quot;</span><span class="si">#{</span><span class="n">config</span><span class="si">}</span><span class="ss">=&quot;</span><span class="p">,</span> <span class="n">options</span><span class="o">.</span><span class="n">delete</span><span class="p">(</span><span class="n">config</span><span class="p">))</span>
</span><span class='line'>          <span class="k">end</span>
</span><span class='line'>        <span class="k">end</span>
</span><span class='line'>      <span class="k">end</span>
</span><span class='line'>
</span><span class='line'>      <span class="kp">include</span> <span class="n">mod</span>
</span><span class='line'>    <span class="k">end</span>
</span><span class='line'>
</span><span class='line'>    <span class="nb">self</span><span class="o">.</span><span class="n">devise_modules</span> <span class="o">|=</span> <span class="n">selected_modules</span>
</span><span class='line'>    <span class="n">options</span><span class="o">.</span><span class="n">each</span> <span class="p">{</span> <span class="o">|</span><span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="o">|</span> <span class="nb">send</span><span class="p">(</span><span class="ss">:&quot;</span><span class="si">#{</span><span class="n">key</span><span class="si">}</span><span class="ss">=&quot;</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span> <span class="p">}</span>
</span><span class='line'>  <span class="k">end</span>
</span><span class='line'><span class="k">end</span>
</span></code></pre></td></tr></table></div></figure>


<p>在我们的模型中传给 <code>devise</code> 方法的模块名将会作为一个数组保存在 <code>*modules</code> 中。
对于传入的模块调用 <code>extract_options!</code> 方法提取可能传入的选项。
在11行中调用 <code>each</code> 方法，并且每个模块在代码块中用 <code>m</code> 表示。
在12行中 <code>m</code> 将会转化为一个常量（类名），因此使用 <code>m.to.classify</code> 一个例如 <code>:validatable</code> 这样的符号会变为 <code>Validatable</code> 。
随便说一下 <code>classify</code> 是ActiveSupport的方法。<br/>
<code>Devise::Models.const_get(m.to_classify)</code> 会获取该模块的引用，并赋值给 <code>mod</code>。
在27行使用 <code>include mod</code> 包含该模块。
例子中的 <code>Validatable</code> 模块是定义在<a href="https://github.com/plataformatec/devise/blob/v3.4.1/lib/devise/models/validatable.rb">这是</a>。
<code>Validatable</code> 的 <code>included</code> 钩子方法定义如下：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="k">def</span> <span class="nc">self</span><span class="o">.</span><span class="nf">included</span><span class="p">(</span><span class="n">base</span><span class="p">)</span>
</span><span class='line'>  <span class="n">base</span><span class="o">.</span><span class="n">extend</span> <span class="no">ClassMethods</span>
</span><span class='line'>  <span class="n">assert_validations_api!</span><span class="p">(</span><span class="n">base</span><span class="p">)</span>
</span><span class='line'>
</span><span class='line'>  <span class="n">base</span><span class="o">.</span><span class="n">class_eval</span> <span class="k">do</span>
</span><span class='line'>    <span class="n">validates_presence_of</span>   <span class="ss">:email</span><span class="p">,</span> <span class="k">if</span><span class="p">:</span> <span class="ss">:email_required?</span>
</span><span class='line'>    <span class="n">validates_uniqueness_of</span> <span class="ss">:email</span><span class="p">,</span> <span class="ss">allow_blank</span><span class="p">:</span> <span class="kp">true</span><span class="p">,</span> <span class="k">if</span><span class="p">:</span> <span class="ss">:email_changed?</span>
</span><span class='line'>    <span class="n">validates_format_of</span>     <span class="ss">:email</span><span class="p">,</span> <span class="ss">with</span><span class="p">:</span> <span class="n">email_regexp</span><span class="p">,</span> <span class="ss">allow_blank</span><span class="p">:</span> <span class="kp">true</span><span class="p">,</span> <span class="k">if</span><span class="p">:</span> <span class="ss">:email_changed?</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">validates_presence_of</span>     <span class="ss">:password</span><span class="p">,</span> <span class="k">if</span><span class="p">:</span> <span class="ss">:password_required?</span>
</span><span class='line'>    <span class="n">validates_confirmation_of</span> <span class="ss">:password</span><span class="p">,</span> <span class="k">if</span><span class="p">:</span> <span class="ss">:password_required?</span>
</span><span class='line'>    <span class="n">validates_length_of</span>       <span class="ss">:password</span><span class="p">,</span> <span class="ss">within</span><span class="p">:</span> <span class="n">password_length</span><span class="p">,</span> <span class="ss">allow_blank</span><span class="p">:</span> <span class="kp">true</span>
</span><span class='line'>  <span class="k">end</span>
</span><span class='line'><span class="k">end</span>
</span></code></pre></td></tr></table></div></figure>


<p>此时模型是 <code>base</code>。在第5行的 <code>class_eval</code> 代码块会以该类作为上下文进行求值运算。
通过 <code>class_eval</code> 编写的代码与直接打开该类的文件将代码粘贴进去效果是一样的。
Devise是通过 <code>class_eval</code> 将验证包含到我们的用户模型中的。</p>

<p>当我们试着使用Devise注册或者登录时，我们会看到这些验证，但是我们并没有编写这些验证代码。
Devise是利用了 <code>included</code> 钩子来实现这些的。非常的优雅吧。</p>

<h2>extended</h2>

<p>Ruby也允许开发者 <code>扩展(extend)</code> 一个模块，这与 <code>包含(include)</code> 有点不同。
<code>extend</code> 是将定义在 <code>模块(module)</code> 内的方法应用为类的方法，而不是实例的方法。
让我们来看一个简单的例子：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="k">module</span> <span class="nn">Person</span>
</span><span class='line'>  <span class="k">def</span> <span class="nf">name</span>
</span><span class='line'>    <span class="s2">&quot;My name is Person&quot;</span>
</span><span class='line'>  <span class="k">end</span>
</span><span class='line'><span class="k">end</span>
</span><span class='line'>
</span><span class='line'><span class="k">class</span> <span class="nc">User</span>
</span><span class='line'>  <span class="kp">extend</span> <span class="no">Person</span>
</span><span class='line'><span class="k">end</span>
</span><span class='line'>
</span><span class='line'><span class="nb">puts</span> <span class="no">User</span><span class="o">.</span><span class="n">name</span> <span class="c1"># =&gt; My name is Person</span>
</span></code></pre></td></tr></table></div></figure>


<p>正如你所看到的，我们将 <code>Person</code> 模块内定义的 <code>name</code> 方法作为了 <code>User</code> 的类方法调用。
<code>extend</code> 将 <code>Person</code> 模块内的方法添加到了 <code>User</code> 类中。<code>extend</code> 同样也可以用于将模块内的方法作为单例方法(singleton methods)。
让我们再来看另外一个例子：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="c1"># We are using same Person module and User class from previous example.     </span>
</span><span class='line'>
</span><span class='line'><span class="n">u1</span> <span class="o">=</span> <span class="no">User</span><span class="o">.</span><span class="n">new</span>
</span><span class='line'><span class="n">u2</span> <span class="o">=</span> <span class="no">User</span><span class="o">.</span><span class="n">new</span>
</span><span class='line'>
</span><span class='line'><span class="n">u1</span><span class="o">.</span><span class="n">extend</span> <span class="no">Person</span>
</span><span class='line'>
</span><span class='line'><span class="nb">puts</span> <span class="n">u1</span><span class="o">.</span><span class="n">name</span> <span class="c1"># =&gt; My name is Person</span>
</span><span class='line'><span class="nb">puts</span> <span class="n">u2</span><span class="o">.</span><span class="n">name</span> <span class="c1"># =&gt; undefined method `name&#39; for #&lt;User:0x007fb8aaa2ab38&gt; (NoMethodError)</span>
</span></code></pre></td></tr></table></div></figure>


<p>我们创建了两个 <code>User</code> 的实例对象，并将 <code>Person</code> 作为参数在 <code>u1</code> 上调用 <code>extend</code> 方法。
使用这种调用方式，<code>Person</code> 的 <code>name</code> 方法仅对 <code>u1</code> 有效，对于其他实例是无效的。</p>

<p>正如 <code>included</code> 一样，与 <code>extend</code> 相对应的钩子方法是 <code>extended</code>。
当一个模块被其他模块或者类执行了 <code>extend</code> 操作时，该方法将会被调用。
让我们来看一个例子：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="c1"># Modified version of Person module</span>
</span><span class='line'>
</span><span class='line'><span class="k">module</span> <span class="nn">Person</span>
</span><span class='line'>  <span class="k">def</span> <span class="nc">self</span><span class="o">.</span><span class="nf">extended</span><span class="p">(</span><span class="n">base</span><span class="p">)</span>
</span><span class='line'>    <span class="nb">puts</span> <span class="s2">&quot;</span><span class="si">#{</span><span class="n">base</span><span class="si">}</span><span class="s2"> extended </span><span class="si">#{</span><span class="nb">self</span><span class="si">}</span><span class="s2">&quot;</span>
</span><span class='line'>  <span class="k">end</span>
</span><span class='line'>
</span><span class='line'>  <span class="k">def</span> <span class="nf">name</span>
</span><span class='line'>    <span class="s2">&quot;My name is Person&quot;</span>
</span><span class='line'>  <span class="k">end</span>
</span><span class='line'><span class="k">end</span>
</span><span class='line'>
</span><span class='line'><span class="k">class</span> <span class="nc">User</span>
</span><span class='line'>  <span class="kp">extend</span> <span class="no">Person</span>
</span><span class='line'><span class="k">end</span>
</span></code></pre></td></tr></table></div></figure>


<p>该代码的运行结果是输出 <code>User extended Person</code>。</p>

<p>关于 <code>extended</code> 的介绍已经完了，让我们来看看 <code>ActiveRecord</code> 是如何使用它的。</p>

<h3>ActiveRecord中的 <code>extended</code></h3>

<p><code>ActiveRecord</code> 是在 Ruby 以及 Rails 中广泛使用的ORM框架。它具有许多酷的特性，
因此使用它在很多情况下成为了ORM的首选。让我们进入 <code>ActiveRecord</code> 内部看看 <code>ActiveRecord</code> 是如何使用回调的。
(我们使用的是 Rails v3.2.21)</p>

<p><code>ActiveRecord</code> 在<a href="https://github.com/rails/rails/blob/v3.2.21/activerecord/lib/active_record/callbacks.rb#L246">这里</a> <code>extend</code> 了 <code>ActiveRecord::Models</code> 模块。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="kp">extend</span> <span class="no">ActiveModel</span><span class="o">::</span><span class="no">Callbacks</span>
</span></code></pre></td></tr></table></div></figure>


<p><code>ActiveModel</code> 提供了一套在模型类中使用的接口。它们允许 ActionPack 与不是 ActiveRecord 的模型进行交互。
在<a href="https://github.com/rails/rails/blob/v3.2.21/activemodel/lib/active_model/callbacks.rb#L49-L53">这里</a>， <code>ActiveModel::Callbacks</code> 内部你将会看到如下代码：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="k">def</span> <span class="nc">self</span><span class="o">.</span><span class="nf">extended</span><span class="p">(</span><span class="n">base</span><span class="p">)</span>
</span><span class='line'>  <span class="n">base</span><span class="o">.</span><span class="n">class_eval</span> <span class="k">do</span>
</span><span class='line'>    <span class="kp">include</span> <span class="no">ActiveSupport</span><span class="o">::</span><span class="no">Callbacks</span>
</span><span class='line'>  <span class="k">end</span>
</span><span class='line'><span class="k">end</span>
</span></code></pre></td></tr></table></div></figure>


<p><code>ActiveModel::Callbacks</code> 对 <code>base</code> 即就是 <code>ActiveRecord::Callbacks</code> 调用了 <code>class_eval</code> 方法，
并包含了 <code>ActiveSupport::Callbacks</code> 模块。我们前面已经提到过了，对一个类调用 <code>class_eval</code> 与手动地将代码写在这个类里是一样的。
<code>ActiveSupport::Callbacks</code> 为 <code>ActiveRecord::Callbacks</code> 提供了 Rails 中的回调方法。</p>

<p>这里我们讨论了 <code>extend</code> 方法，以及与之对应的钩子 <code>extended</code>。并且也了解了 <code>ActiveRecord</code> / <code>ActiveModel</code>
是如何使用上述方法为我们提供可用功能的。</p>

<h2>prepended</h2>

<p>另一个使用定义在模块内部方法的方式称为 <code>prepend</code>。<code>prepend</code> 是在Ruby 2.0中引入的，并且与 <code>include</code> 和 <code>extend</code> 很不一样。
使用 <code>include</code> 和 <code>extend</code> 引入的方法可以被目标模块/类重新定义覆盖。
例如，如果我们在某个模块中定义了一个名为 <code>name</code> 的方法，并且在目标模块/类中也定义同名的方法。
那么这个在我们类在定义的 <code>name</code> 方法将会覆盖模块中的。而 <code>prepend</code> 是不一样的，它会将 <code>prepend</code> 引入的模块
中的方法覆盖掉我们模块/类中定义的方法。让我们来看一个简单的例子：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="k">module</span> <span class="nn">Person</span>
</span><span class='line'>  <span class="k">def</span> <span class="nf">name</span>
</span><span class='line'>    <span class="s2">&quot;My name belongs to Person&quot;</span>
</span><span class='line'>  <span class="k">end</span>
</span><span class='line'><span class="k">end</span>
</span><span class='line'>
</span><span class='line'><span class="k">class</span> <span class="nc">User</span>
</span><span class='line'>  <span class="kp">include</span> <span class="no">Person</span>
</span><span class='line'>  <span class="k">def</span> <span class="nf">name</span>
</span><span class='line'>    <span class="s2">&quot;My name belongs to User&quot;</span>
</span><span class='line'>  <span class="k">end</span>
</span><span class='line'><span class="k">end</span>
</span><span class='line'>
</span><span class='line'><span class="nb">puts</span> <span class="no">User</span><span class="o">.</span><span class="n">new</span><span class="o">.</span><span class="n">name</span>
</span><span class='line'><span class="o">=&gt;</span> <span class="no">My</span> <span class="nb">name</span> <span class="n">belongs</span> <span class="n">to</span> <span class="no">User</span>
</span></code></pre></td></tr></table></div></figure>


<p>现在再来看看 <code>prepend</code> 的情况：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="k">module</span> <span class="nn">Person</span>
</span><span class='line'>  <span class="k">def</span> <span class="nf">name</span>
</span><span class='line'>    <span class="s2">&quot;My name belongs to Person&quot;</span>
</span><span class='line'>  <span class="k">end</span>
</span><span class='line'><span class="k">end</span>
</span><span class='line'>
</span><span class='line'><span class="k">class</span> <span class="nc">User</span>
</span><span class='line'>  <span class="n">prepend</span> <span class="no">Person</span>
</span><span class='line'>  <span class="k">def</span> <span class="nf">name</span>
</span><span class='line'>    <span class="s2">&quot;My name belongs to User&quot;</span>
</span><span class='line'>  <span class="k">end</span>
</span><span class='line'><span class="k">end</span>
</span><span class='line'>
</span><span class='line'><span class="nb">puts</span> <span class="no">User</span><span class="o">.</span><span class="n">new</span><span class="o">.</span><span class="n">name</span>
</span><span class='line'><span class="o">=&gt;</span> <span class="no">My</span> <span class="nb">name</span> <span class="n">belongs</span> <span class="n">to</span> <span class="no">Person</span>
</span></code></pre></td></tr></table></div></figure>


<p>使用 <code>prepend Person</code> 会将 <code>User</code> 中的同名方法给覆盖掉，因此在终端输出的结果为 <code>My name belongs to Person</code>。
<code>prepend</code> 实际上是将方法添加到方法链的前端。在调用 <code>User</code> 类内定义的 <code>name</code> 方法时，会调用 <code>super</code> 从而调用 <code>Person</code> 模块的 <code>name</code>。</p>

<p>与 <code>prepend</code> 对应的回调名为（你应该猜到了） <code>prepended</code>。当一个模块被预置到另一个模块/类中时它会被调用。
我们来看下效果。更新 <code>Person</code> 模块的定义：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="k">module</span> <span class="nn">Person</span>
</span><span class='line'>  <span class="k">def</span> <span class="nc">self</span><span class="o">.</span><span class="nf">prepended</span><span class="p">(</span><span class="n">base</span><span class="p">)</span>
</span><span class='line'>    <span class="nb">puts</span> <span class="s2">&quot;</span><span class="si">#{</span><span class="nb">self</span><span class="si">}</span><span class="s2"> prepended to </span><span class="si">#{</span><span class="n">base</span><span class="si">}</span><span class="s2">&quot;</span>
</span><span class='line'>  <span class="k">end</span>
</span><span class='line'>
</span><span class='line'>  <span class="k">def</span> <span class="nf">name</span>
</span><span class='line'>    <span class="s2">&quot;My name belongs to Person&quot;</span>
</span><span class='line'>  <span class="k">end</span>
</span><span class='line'><span class="k">end</span>
</span></code></pre></td></tr></table></div></figure>


<p>你再运行这段代码应该会看到如下结果：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="no">Person</span> <span class="n">prepended</span> <span class="n">to</span> <span class="no">User</span>
</span><span class='line'><span class="no">My</span> <span class="nb">name</span> <span class="n">belongs</span> <span class="n">to</span> <span class="no">Person</span>
</span></code></pre></td></tr></table></div></figure>


<p><code>prepend</code> 的引入是为了去除 <code>alias_method_chain</code> hack的丑陋，它曾被Rails以及其他库广泛地使用以达到与 <code>prepend</code> 相同的功能。
因为 <code>prepend</code> 只有在 Ruby >= 2.0 的版本中才能使用，因此如果你打算使用 <code>prepend</code> 的话，那么你就应该升级你的Ruby版本。</p>

<h2>inherited</h2>

<p>继承是面向对象中一个最重要的概念。Ruby是一门面向对象的编程语言，并且提供了从基/父类继承一个子类的功能。
我们来看一个简单的例子：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="k">class</span> <span class="nc">Person</span>
</span><span class='line'>  <span class="k">def</span> <span class="nf">name</span>
</span><span class='line'>     <span class="s2">&quot;My name is Person&quot;</span>
</span><span class='line'>  <span class="k">end</span>
</span><span class='line'><span class="k">end</span>
</span><span class='line'>
</span><span class='line'><span class="k">class</span> <span class="nc">User</span> <span class="o">&lt;</span> <span class="no">Person</span>
</span><span class='line'><span class="k">end</span>
</span><span class='line'>
</span><span class='line'><span class="nb">puts</span> <span class="no">User</span><span class="o">.</span><span class="n">new</span><span class="o">.</span><span class="n">name</span> <span class="c1"># =&gt; My name is Person</span>
</span></code></pre></td></tr></table></div></figure>


<p>我们创建了一个 <code>Person</code> 类和一个子类 <code>User</code>。在 <code>Person</code> 中定义的方法也成为了 <code>User</code> 的一部分。
这是非常简单的继承。你可能会好奇，是否有什么方法可以在一个类被其他类继承时收到通知呢？
是的，Ruby有一个名为 <code>inherited</code> 的钩子可以实现。我们再看看这个例子：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="k">class</span> <span class="nc">Person</span>
</span><span class='line'>  <span class="k">def</span> <span class="nc">self</span><span class="o">.</span><span class="nf">inherited</span><span class="p">(</span><span class="n">child_class</span><span class="p">)</span>
</span><span class='line'>    <span class="nb">puts</span> <span class="s2">&quot;</span><span class="si">#{</span><span class="n">child_class</span><span class="si">}</span><span class="s2"> inherits </span><span class="si">#{</span><span class="nb">self</span><span class="si">}</span><span class="s2">&quot;</span>
</span><span class='line'>  <span class="k">end</span>
</span><span class='line'>
</span><span class='line'>  <span class="k">def</span> <span class="nf">name</span>
</span><span class='line'>    <span class="s2">&quot;My name is Person&quot;</span>
</span><span class='line'>  <span class="k">end</span>
</span><span class='line'><span class="k">end</span>
</span><span class='line'>
</span><span class='line'><span class="k">class</span> <span class="nc">User</span> <span class="o">&lt;</span> <span class="no">Person</span>
</span><span class='line'><span class="k">end</span>
</span><span class='line'>
</span><span class='line'><span class="nb">puts</span> <span class="no">User</span><span class="o">.</span><span class="n">new</span><span class="o">.</span><span class="n">name</span>
</span></code></pre></td></tr></table></div></figure>


<p>正如你所见，当 <code>Person</code> 类被其他子类继承时 <code>inherited</code> 类方法将会被调用。
运行以上代码结果如下：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="no">User</span> <span class="n">inherits</span> <span class="no">Person</span>
</span><span class='line'><span class="no">My</span> <span class="nb">name</span> <span class="n">is</span> <span class="no">Person</span>
</span></code></pre></td></tr></table></div></figure>


<p>让我们看看 <code>Rails</code> 在它的代码中是如何使用 <code>inherited</code> 的。</p>

<h3>Rails中的 <code>inherited</code></h3>

<p>Rails应用中有一个重要的类名为 <code>Application</code> ，定义中 <strong>config/application.rb</strong> 文件内。
这个类执行了许多不同的任务，如运行所有的Railties，引擎以及插件的初始化。
关于 <code>Application</code> 类的一个有趣的事件是，在同一个进程中不能运行两个实例。
如果我们尝试修改这个行为，Rails将会抛出一个异常。让我们来看看Rails是如何实现这个特性的。</p>

<p><code>Application</code> 类继承自 <code>Rails::Application</code>，它是在<a href="https://github.com/rails/rails/blob/v3.2.21/railties/lib/rails/application.rb">这里</a>定义的。
在62行定义了 <code>inherited</code> 钩子，它会在我们的Rails应用 <code>Application</code> 类继承 <code>Rails::Application</code> 时被调用。
<code>inherited</code> 钩子的代码如下：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="k">class</span> <span class="o">&lt;&lt;</span> <span class="nb">self</span>
</span><span class='line'>  <span class="k">def</span> <span class="nf">inherited</span><span class="p">(</span><span class="n">base</span><span class="p">)</span>
</span><span class='line'>    <span class="k">raise</span> <span class="s2">&quot;You cannot have more than one Rails::Application&quot;</span> <span class="k">if</span> <span class="no">Rails</span><span class="o">.</span><span class="n">application</span>
</span><span class='line'>    <span class="k">super</span>
</span><span class='line'>    <span class="no">Rails</span><span class="o">.</span><span class="n">application</span> <span class="o">=</span> <span class="n">base</span><span class="o">.</span><span class="n">instance</span>
</span><span class='line'>    <span class="no">Rails</span><span class="o">.</span><span class="n">application</span><span class="o">.</span><span class="n">add_lib_to_load_path!</span>
</span><span class='line'>    <span class="no">ActiveSupport</span><span class="o">.</span><span class="n">run_load_hooks</span><span class="p">(</span><span class="ss">:before_configuration</span><span class="p">,</span> <span class="n">base</span><span class="o">.</span><span class="n">instance</span><span class="p">)</span>
</span><span class='line'>  <span class="k">end</span>
</span><span class='line'><span class="k">end</span>
</span></code></pre></td></tr></table></div></figure>


<p><code>class &lt;&lt; self</code> 是Ruby中的另一个定义类方法的方式。在 <code>inherited</code> 中的第1行是检查 <code>Rails.application</code> 是否已存在。
如果存在则抛出异常。第一次运行这段代码时 <code>Rails.application</code> 会返回false然后调用 <code>super</code>。
在这里 <code>super</code> 即是 <code>Rails::Engine</code> 的 <code>inherited</code> 钩子，因为 <code>Rails::Application</code> 继承自 <code>Rails::Engine</code>。</p>

<p>在下一行，你会看到 <code>Rails.application</code> 被赋值为 <code>base.instance</code> 。其余就是设置Rails应用了。</p>

<p>这就是Rails如何巧妙地使用 <code>inherited</code> 钩子来实现我们的Rails <code>Application</code> 类的单实例。</p>

<h2>method_missing</h2>

<p><code>method_missing</code> 可能是Ruby中使用最广的钩子。在许多流行的Ruby框架/gem包/库中都有使用它。
当我们试图访问一个对象上不存在的方法时则会调用这个钩子方法。
让我们来看一个简单的例子：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="k">class</span> <span class="nc">Person</span>
</span><span class='line'>  <span class="k">def</span> <span class="nf">name</span>
</span><span class='line'>    <span class="s2">&quot;My name is Person&quot;</span>
</span><span class='line'>  <span class="k">end</span>
</span><span class='line'><span class="k">end</span>
</span><span class='line'>
</span><span class='line'><span class="nb">p</span> <span class="o">=</span> <span class="no">Person</span><span class="o">.</span><span class="n">new</span>
</span><span class='line'>
</span><span class='line'><span class="nb">puts</span> <span class="nb">p</span><span class="o">.</span><span class="n">name</span>     <span class="c1"># =&gt; My name is Person </span>
</span><span class='line'><span class="nb">puts</span> <span class="nb">p</span><span class="o">.</span><span class="n">address</span>  <span class="c1"># =&gt; undefined method `address&#39; for #&lt;Person:0x007fb730a2b450&gt; (NoMethodError)</span>
</span></code></pre></td></tr></table></div></figure>


<p>我们定义了一个简单的 <code>Person</code> 类， 它只有一个 <code>name</code> 方法。然后创建一个 <code>Person</code> 的实例对象，
并分别调用 <code>name</code> 和 <code>address</code>　两个方法。因为 <code>Person</code> 中定义了 <code>name</code>，因此这个运行没问题。
然而 <code>Person</code> 并没有定义 <code>address</code>，这将会抛出一个异常。
<code>method_missing</code> 钩子可以优雅地捕捉到这些未定义的方法，避免此类异常。
让我们修改一下 <code>Person</code> 类：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="k">class</span> <span class="nc">Person</span>
</span><span class='line'>  <span class="k">def</span> <span class="nf">method_missing</span><span class="p">(</span><span class="n">sym</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>
</span><span class='line'>     <span class="s2">&quot;</span><span class="si">#{</span><span class="n">sym</span><span class="si">}</span><span class="s2"> not defined on </span><span class="si">#{</span><span class="nb">self</span><span class="si">}</span><span class="s2">&quot;</span>
</span><span class='line'>  <span class="k">end</span>
</span><span class='line'>
</span><span class='line'>  <span class="k">def</span> <span class="nf">name</span>
</span><span class='line'>    <span class="s2">&quot;My name is Person&quot;</span>
</span><span class='line'>  <span class="k">end</span>
</span><span class='line'><span class="k">end</span>
</span><span class='line'>
</span><span class='line'><span class="nb">p</span> <span class="o">=</span> <span class="no">Person</span><span class="o">.</span><span class="n">new</span>
</span><span class='line'>
</span><span class='line'><span class="nb">puts</span> <span class="nb">p</span><span class="o">.</span><span class="n">name</span>     <span class="c1"># =&gt; My name is Person</span>
</span><span class='line'><span class="nb">puts</span> <span class="nb">p</span><span class="o">.</span><span class="n">address</span>  <span class="c1"># =&gt; address not defined on #&lt;Person:0x007fb2bb022fe0&gt;</span>
</span></code></pre></td></tr></table></div></figure>


<p><code>method_missing</code> 接收两个参数：被调用的方法名和传递给该方法的参数。
首先Ruby会寻找我们试图调用的方法，如果方法没找到则会寻找 <code>method_missing</code> 方法。
现在我们重载了 <code>Person</code> 中的 <code>method_missing</code>，因此Ruby将会调用它而不是抛出异常。</p>

<p>让我们来看看 <code>Rake</code> 是如何使用 <code>method_missing</code> 的。</p>

<h3>Rake中的 <code>method_missing</code></h3>

<p><code>Rake</code> 是Ruby中使用最广泛的gem包之一。<code>Rake</code> 使用 <code>method_missing</code> 来提供访问传递给Rake任务的参数。
首先创建一个简单的rake任务：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="n">task</span> <span class="ss">:hello</span> <span class="k">do</span>
</span><span class='line'>  <span class="nb">puts</span> <span class="s2">&quot;Hello&quot;</span>
</span><span class='line'><span class="k">end</span>
</span></code></pre></td></tr></table></div></figure>


<p>如果你通过调用 <code>rake hello</code> 来执行这个任务，你会看到输出 <code>Hello</code>。
让我们扩展这个rake任务，以便接收一个参数（一个人名）并向他打招呼：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="n">task</span> <span class="ss">:hello</span><span class="p">,</span> <span class="ss">:name</span> <span class="k">do</span> <span class="o">|</span><span class="n">t</span><span class="p">,</span> <span class="n">args</span><span class="o">|</span>
</span><span class='line'>  <span class="nb">puts</span> <span class="s2">&quot;Hello </span><span class="si">#{</span><span class="n">args</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s2">&quot;</span>
</span><span class='line'><span class="k">end</span>
</span></code></pre></td></tr></table></div></figure>


<p><code>t</code> 是任务名，<code>args</code> 保存了传递过来的参数。正如你所见，我们调用 <code>args.name</code> 来获取传递给 <code>hello</code> 任务的 <code>name</code> 参数。
运行该任务，并传递一个参数：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="n">rake</span> <span class="n">hello</span><span class="o">[</span><span class="s2">&quot;Imran Latif&quot;</span><span class="o">]</span>
</span><span class='line'><span class="o">=&gt;</span> <span class="no">Hello</span> <span class="no">Imran</span> <span class="no">Latif</span>
</span></code></pre></td></tr></table></div></figure>


<p>让我们来看看 <code>Rake</code> 是如何使用 <code>method_missing</code> 为我们提供了传递给任务的参数的。</p>

<p>在上面任务中的 <code>args</code> 对象是一个 <code>Rake::TaskArguments</code> 实例，它是在<a href="https://github.com/ruby/rake/blob/v10.4.2/lib/rake/task_arguments.rb">这里</a>所定义。
这个类负责管理传递给Rake任务的参数。查看 <code>Rake::TaskArguments</code> 的代码，你会发现并没有定义相关的方法将参数传给任务。
那么 <code>Rake</code> 是如何将参数提供给任务的呢？答案是 <code>Rake</code> 是使用了 <code>method_missing</code> 巧妙地实现了这个功能。
看看第64行 <code>method_missing</code> 的定义：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="k">def</span> <span class="nf">method_missing</span><span class="p">(</span><span class="n">sym</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>
</span><span class='line'>  <span class="n">lookup</span><span class="p">(</span><span class="n">sym</span><span class="o">.</span><span class="n">to_sym</span><span class="p">)</span>
</span><span class='line'><span class="k">end</span>
</span></code></pre></td></tr></table></div></figure>


<p>在这个类中定义 <code>method_missing</code> 是为了保证能够访问到那些未定义的方法，而不是由Ruby抛出异常。
在 <code>method_missing</code> 中它调用了 <code>lookup</code> 方法：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="k">def</span> <span class="nf">lookup</span><span class="p">(</span><span class="nb">name</span><span class="p">)</span>
</span><span class='line'>  <span class="k">if</span> <span class="vi">@hash</span><span class="o">.</span><span class="n">has_key?</span><span class="p">(</span><span class="nb">name</span><span class="p">)</span>
</span><span class='line'>   <span class="vi">@hash</span><span class="o">[</span><span class="nb">name</span><span class="o">]</span>
</span><span class='line'>  <span class="k">elsif</span> <span class="vi">@parent</span>
</span><span class='line'>    <span class="vi">@parent</span><span class="o">.</span><span class="n">lookup</span><span class="p">(</span><span class="nb">name</span><span class="p">)</span>
</span><span class='line'>  <span class="k">end</span>
</span><span class='line'><span class="k">end</span>
</span></code></pre></td></tr></table></div></figure>


<p><code>method_missing</code> 调用 <code>lookup</code>，并将方法名以 <code>Symbol(符号)</code> 的形式传递给它。
<code>lookup</code> 方法将会在 <code>@hash</code> 中进行查找，它是在 <code>Rake::TaskArguments</code> 的构造函数中创建的。
如果 <code>@hash</code> 中包含该参数则返回，如果在 <code>@hash</code> 中没有则 <code>Rake</code> 会尝试调用 <code>@parent</code> 的 <code>lookup</code>。
如果该参数没有找到，则什么都不返回。</p>

<p>这就是 <code>Rake</code> 如何巧妙地使用 <code>method_missing</code> 提供了访问传递给Rake任务的参数的。
感谢<a href="https://twitter.com/jimweirich">Jim Weirich</a>编写了Rake。</p>

<h1>结束语</h1>

<p>我们讨论了5个重要的Ruby钩子方法，探索了它们是如何工作的，以及一些流行的框架/gem包是如何使用它们来提供一些优雅的功能。
我希望你能喜欢这篇文章。请在评论中告诉我们你所喜欢的Ruby钩子，以及你使用它们所解决的问题。</p>

<p>原文地址： <a href="http://www.sitepoint.com/rubys-important-hook-methods/">http://www.sitepoint.com/rubys-important-hook-methods/</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[使用Unicorn部署rails应用]]></title>
    <link href="http://www.xefan.com/archives/84142.html"/>
    <updated>2015-04-05T20:47:15+08:00</updated>
    <id>http://www.xefan.com/archives/84142-使用Unicorn部署rails应用</id>
    <content type="html"><![CDATA[<p>玩 rails 也有段时间了，最近研究下怎么部署一个 rails 应用。在几年前的话要部署 rails 应用是件很麻烦的事，
但是近几年出现了一些比较好的工具可以方便的进行 rails 部署。如： Unicorn、thin、Passenger等。</p>

<p>Unicorn 是一个 Rack 应用的HTTP服务器。之前玩 Python 的时候也有一个 Gunicorn ，使用它来部署 Python 的 Web 应用
也很方便，可以参考我之前的那篇文件 <a href="84138.html">《使用gunicorn部署Django》</a> 。</p>

<p>接下来简单分享下使用 Nginx + Unicorn 来部署 rails 的配置。</p>

<h2>安装</h2>

<p>首先安装 unicorn 包： <code>$ gem install unicorn</code></p>

<p>然后编译一下静态文件：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ RAILS_ENV=production rake assets:clean
</span><span class='line'>$ RAILS_ENV=production rake assets:precompile</span></code></pre></td></tr></table></div></figure>


<p>下载配置文件： <code>$ curl -o config/unicorn.rb https://raw.github.com/defunkt/unicorn/master/examples/unicorn.conf.rb</code></p>

<p>接着根据情况修改相关配置，如： working_directory、listen 等。
例如我的是需要同时监听网络端口和 sock 文件，那么我的 listen 设置如下：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>listen "#{root_path}/tmp/sockets/unicorn.sock", :backlog =&gt; 64
</span><span class='line'>listen 8081, :tcp_nopush =&gt; true</span></code></pre></td></tr></table></div></figure>


<h2>配置 Nginx</h2>

<p>然后配置 Nginx 的反向代理，以下是我的 Nginx 配置示例：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>upstream rails_server {
</span><span class='line'>  server unix:/app_path/tmp/sockets/unicorn.sock fail_timeout=0;
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>server {
</span><span class='line'>  listen 80;
</span><span class='line'>  server_name webserver localhost;
</span><span class='line'>
</span><span class='line'>  root /app_path/public;
</span><span class='line'>
</span><span class='line'>  try_files $uri $uri @unicorn;
</span><span class='line'>
</span><span class='line'>  location @unicorn {
</span><span class='line'>    proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
</span><span class='line'>    proxy_set_header Host $http_host;
</span><span class='line'>    proxy_redirect off;
</span><span class='line'>    proxy_pass http://rails_server;
</span><span class='line'>  }
</span><span class='line'> 
</span><span class='line'>  location ~ /\.ht {
</span><span class='line'>    deny  all;
</span><span class='line'>  }
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<h2>启动服务</h2>

<p>配置完成之后，最后启动服务。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ bundle exec unicorn_rails -c config/unicorn.rb -D -E production
</span><span class='line'>$ sudo service nginx start</span></code></pre></td></tr></table></div></figure>


<p>然后再在浏览器中访问试试。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Vagrant使用笔记]]></title>
    <link href="http://www.xefan.com/archives/84141.html"/>
    <updated>2015-02-24T19:17:43+08:00</updated>
    <id>http://www.xefan.com/archives/84141-Vagrant使用笔记</id>
    <content type="html"><![CDATA[<p>Vgrant是一个基于 Ruby 使用 Virtualbox 进行创建和部署虚拟化环境的工具。
类似的工具之前有使用过 Docker。就我个人而言这两款工具之间，Docker是轻量级的VM，
因此性能应该会比较好，但是只能在64位的系统下使用。
而 Vgrant 是使用 Virtualbox 进行虚拟化，因此性能上不及 Docker，
不过它可以在32/64位的 Linux、Windows 等系统上运行。</p>

<p>我觉得 Vgrant 比较适合用于在开发环境中使用，而 Docker 比较适合用于生产环境。</p>

<h2>安装</h2>

<p>首先安装 virtualbox，然后再安装 Vgrant。</p>

<p>1.通过源代码安装</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>git clone https://github.com/mitchellh/vagrant
</span><span class='line'>cd vagrant
</span><span class='line'>bundle install
</span><span class='line'>rake install</span></code></pre></td></tr></table></div></figure>


<p>2.通过安装包安装<br/>
根据情况选择下载对应的安装包： <a href="http://www.vagrantup.com/downloads.html">http://www.vagrantup.com/downloads.html</a></p>

<p>注意：如果是 Windows 系统，可能还需要将 Vgrant 的路径添加到环境变量中，以便使用 vgrant 命令。</p>

<h2>使用</h2>

<p>Vagrant 的使用方法也很简单，基本如下：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class=''><span class='line'># 这里我先添加一个 ArchLinux 的镜像
</span><span class='line'>vagrant box add archlinux http://vagrant.srijn.net/archlinux-x64-2014-01-07.box
</span><span class='line'># 进行初始化
</span><span class='line'>vagrant init archlinux
</span><span class='line'># 运行虚拟机
</span><span class='line'>vagrant up
</span><span class='line'># 如果需要进行ssh连接到虚拟机中进行一些操作，可以执行该命令
</span><span class='line'>vagrant ssh</span></code></pre></td></tr></table></div></figure>


<p>其他的一些命令：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'># 关闭虚拟机
</span><span class='line'>vagrant halt
</span><span class='line'># 删除创建的虚拟机
</span><span class='line'>vagrant destroy</span></code></pre></td></tr></table></div></figure>


<p>vagrant的一些镜像： <a href="http://www.vagrantbox.es/">http://www.vagrantbox.es/</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Redis集群配置实例]]></title>
    <link href="http://www.xefan.com/archives/84140.html"/>
    <updated>2015-01-14T18:11:36+08:00</updated>
    <id>http://www.xefan.com/archives/84140-Redis集群配置实例</id>
    <content type="html"><![CDATA[<p>通过配置 redis 的主从集群可将请求的负荷分散到多台服务器上。</p>

<p>redis 的集群配置比较简单，以下是一个例子。
假设有如下三台主机：</p>

<ul>
<li>172.17.0.11 (主)</li>
<li>172.17.0.12 (从)</li>
<li>172.17.0.13 (从)</li>
</ul>


<p>在从服务器上添加如下配置：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>slaveof 172.17.0.11 6379</span></code></pre></td></tr></table></div></figure>


<p>如果主服务器设置了认证密码，那么还需要再添加一条配置：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>masterauth &lt;password&gt;</span></code></pre></td></tr></table></div></figure>


<p>然后分别启动三台服务器的 redis 服务即可。</p>

<p>接下来连接主服务器添加一些数据测试一下。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ redis-cli -h 172.17.0.11
</span><span class='line'>172.17.0.11:6379&gt; set foo1 bar1
</span><span class='line'>OK</span></code></pre></td></tr></table></div></figure>


<p>然后再连接到从服务器查询结果。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ redis-cli -h 172.17.0.12
</span><span class='line'>172.17.0.12:6379&gt; get foo1
</span><span class='line'>"bar1"</span></code></pre></td></tr></table></div></figure>


<p>这时发现数据已经同步过来了。</p>

<p>注意：从服务器默认是只读的。如果需要设置为可写，可将 <code>slave-read-only</code> 设置项的值设为 <code>no</code> 即可。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Mongodb分片配置实例]]></title>
    <link href="http://www.xefan.com/archives/84139.html"/>
    <updated>2014-12-29T16:52:37+08:00</updated>
    <id>http://www.xefan.com/archives/84139-Mongodb分片配置实例</id>
    <content type="html"><![CDATA[<p>数据分片即是从一个集合中选择一个片键(shard key)作为数据拆分的依据，原理与索引类似，然后将集合的数据拆分并保存到不同的服务器上。
以下通过一个例子来介绍一下Mongodb的分片配置。</p>

<p>有四台主机：</p>

<ul>
<li>172.17.0.6    (配置服务器)</li>
<li>172.17.0.7    (mongos)</li>
<li>172.17.0.8    (片服务器)</li>
<li>172.17.0.9    (片服务器)</li>
</ul>


<p>1.在 172.17.0.6 上启动 mongod 服务作为配置服务器；<br/>
修改配置，使其作为一个配置服务器，默认监听 27019 端口。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>configsvr = true</span></code></pre></td></tr></table></div></figure>


<p>启动服务 <code>$ service mongodb start</code></p>

<p>2.在 172.17.0.7 上启动 mongos 服务作为路由服务;<br/>
建立mongos进程。(可以有多台配置服务器)，用法如下：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ mongos --configdb &lt;config server hostnames&gt;[,&lt;config server hostnames&gt;]</span></code></pre></td></tr></table></div></figure>


<p>例如： <code>$ mongos --configdb 172.17.0.6:27019</code></p>

<p>注意：在同一个分片集群中的每个 mongos 必须使用相同的 configDB 配置。</p>

<p>3.添加分片<br/>
一个片服务既可以是单个 mongod 实例，也可以是一个副本集。<br/>
1).先分别在 172.17.0.8 和 172.17.0.9 上启动片服务器，即就是一个普通的 mongod 服务。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ service mongodb start</span></code></pre></td></tr></table></div></figure>


<p>2).使用 mongo 客户端连接到 mongos 服务</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ mongo --host &lt;hostname of machine running mongos&gt; --port &lt;port mongos listens on&gt;</span></code></pre></td></tr></table></div></figure>


<p>如： <code>$ mongo --host 172.17.0.7 --port 27017</code></p>

<p>3).在 mongo 客户端上执行命令添加分片：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>&gt; use admin
</span><span class='line'>&gt; db.auth(&lt;user&gt;, &lt;pswd&gt;)
</span><span class='line'>&gt; sh.addShard("172.17.0.8:27017")
</span><span class='line'>&gt; sh.addShard("172.17.0.9:27017")</span></code></pre></td></tr></table></div></figure>


<p>4.切片数据<br/>
1).首先对数据库进行切片<br/>
使用 mongo 客户端连接到 mongos ，执行命令打开数据库的分片功能，用法如下：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>&gt; sh.enableSharding("&lt;database&gt;")</span></code></pre></td></tr></table></div></figure>


<p>例如要打开 mydb 数据库的分片功能： <code>&gt; sh.enableSharding("mydb")</code></p>

<p>2).然后对数据集合进行切片<br/>
命令用法如下：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>&gt; sh.shardCollection("&lt;database&gt;.&lt;collection&gt;", shard-key-pattern)</span></code></pre></td></tr></table></div></figure>


<p><code>shard-key-pattern</code> 与索引的用法一样，例如，要对 mydb 数据库的 test 集合按照 <code>_id</code> 字段进行分片： <code>&gt; sh.shardCollection("mydb.test", {"_id": "hashed"})</code></p>

<p>接下来通过一个程序来测试一下，向数据库中添加10000条数据：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="c1">#!/usr/bin/env ruby</span>
</span><span class='line'><span class="c1">#-*- coding:utf-8 -*-</span>
</span><span class='line'>
</span><span class='line'><span class="nb">require</span> <span class="s2">&quot;mongo&quot;</span>
</span><span class='line'>
</span><span class='line'><span class="k">begin</span>
</span><span class='line'>  <span class="n">conn</span> <span class="o">=</span> <span class="no">Mongo</span><span class="o">::</span><span class="no">Connection</span><span class="o">.</span><span class="n">new</span> <span class="s1">&#39;172.17.0.7&#39;</span>
</span><span class='line'>  <span class="n">db</span> <span class="o">=</span> <span class="n">conn</span><span class="o">[</span><span class="s1">&#39;mydb&#39;</span><span class="o">]</span>
</span><span class='line'><span class="k">rescue</span> <span class="no">Exception</span><span class="o">=&gt;</span><span class="n">e</span>
</span><span class='line'>  <span class="nb">p</span> <span class="n">e</span>
</span><span class='line'>  <span class="nb">exit</span> <span class="mi">1</span>
</span><span class='line'><span class="k">end</span>
</span><span class='line'>
</span><span class='line'><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span>
</span><span class='line'><span class="k">while</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">10000</span>
</span><span class='line'>  <span class="n">d</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;no&#39;</span> <span class="o">=&gt;</span> <span class="n">i</span><span class="p">}</span>
</span><span class='line'>  <span class="n">d</span> <span class="o">=</span> <span class="n">db</span><span class="o">[</span><span class="s1">&#39;test&#39;</span><span class="o">].</span><span class="n">insert</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>
</span><span class='line'>  <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>
</span><span class='line'>  <span class="nb">puts</span> <span class="n">d</span>
</span><span class='line'><span class="k">end</span>
</span></code></pre></td></tr></table></div></figure>


<p>然后分别查看 172.17.0.8 和 172.17.0.9 的状态：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="mi">172</span><span class="o">.</span><span class="mi">17</span><span class="o">.</span><span class="mi">0</span><span class="o">.</span><span class="mi">8</span><span class="p">:</span>
</span><span class='line'><span class="o">&gt;</span> <span class="n">db</span><span class="o">.</span><span class="n">test</span><span class="o">.</span><span class="n">count</span><span class="p">()</span>
</span><span class='line'><span class="mi">4952</span>
</span><span class='line'>
</span><span class='line'><span class="mi">172</span><span class="o">.</span><span class="mi">17</span><span class="o">.</span><span class="mi">0</span><span class="o">.</span><span class="mi">9</span><span class="p">:</span>
</span><span class='line'><span class="o">&gt;</span> <span class="n">db</span><span class="o">.</span><span class="n">test</span><span class="o">.</span><span class="n">count</span><span class="p">()</span>
</span><span class='line'><span class="mi">5048</span>
</span></code></pre></td></tr></table></div></figure>


<p>数据基本上是平均的分布在两台服务器上。</p>

<p>参考： <a href="http://docs.mongodb.org/manual/tutorial/deploy-shard-cluster/">http://docs.mongodb.org/manual/tutorial/deploy-shard-cluster/</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[使用gunicorn部署Django]]></title>
    <link href="http://www.xefan.com/archives/84138.html"/>
    <updated>2014-12-13T21:03:27+08:00</updated>
    <id>http://www.xefan.com/archives/84138-使用gunicorn部署Django</id>
    <content type="html"><![CDATA[<p><a href="http://gunicorn.org/">Gunicorn</a> 是 Python的 一个 WSGI HTTP服务器，根据它的介绍说是它来自于 Ruby 的 Unicorn。可以方便的部署 Python 的 Web 程序，而且本身支持多种 Python 的框架，如 Django、Paster等。</p>

<p>通过介绍来看貌似很不错的样子，只可惜我现在不玩 Python 了，于是就简单体验一下。</p>

<h2>简单应用</h2>

<p>首先是安装，这个可以直接使用 <code>pip</code> 来完成：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ pip install gunicorn</span></code></pre></td></tr></table></div></figure>


<p>然后再根据官方文档的介绍部署一个简单的例子试试：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ cd examples
</span><span class='line'>$ cat test.py
</span><span class='line'># -*- coding: utf-8 -
</span><span class='line'>#
</span><span class='line'># This file is part of gunicorn released under the MIT license.
</span><span class='line'># See the NOTICE for more information.
</span><span class='line'>
</span><span class='line'>def app(environ, start_response):
</span><span class='line'>    """Simplest possible application object"""
</span><span class='line'>    data = 'Hello, World!\n'
</span><span class='line'>    status = '200 OK'
</span><span class='line'>    response_headers = [
</span><span class='line'>        ('Content-type','text/plain'),
</span><span class='line'>        ('Content-Length', str(len(data)))
</span><span class='line'>    ]
</span><span class='line'>    start_response(status, response_headers)
</span><span class='line'>    return iter([data])
</span><span class='line'>
</span><span class='line'>$ gunicorn -b 0.0.0.0:8000 --workers=2 test:app</span></code></pre></td></tr></table></div></figure>


<p>好的，现在程序运行起来了，可以访问 <a href="http://localhost:8000">http://localhost:8000</a> 看下效果。</p>

<p>gunicorn 也可以通过配置文件来设置一些内容， 一个配置文件是一个 python 脚本，格式类似 <code>.ini</code> 。通过 <code>-c</code> 参数指定要使用的配置文件。如：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'># config.ini
</span><span class='line'>bind = ["0.0.0.0:8000", "unix:///tmp/gunicorn.sock"]
</span><span class='line'>workers = 3 </span></code></pre></td></tr></table></div></figure>


<p>gunicorn 还能与 Django 和 Paster 应用集成：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ gunicorn --env DJANGO_SETTINGS_MODULE=myproject.settings myproject.wsgi:application
</span><span class='line'>$ gunicorn --paste development.ini -b :8080 --chdir /path/to/project</span></code></pre></td></tr></table></div></figure>


<h2>与 Nginx 部署</h2>

<p>gunicorn 本身也是一个 WSGI 应用，可以与 Nginx 一同使用。
以下是 Nginx + Gunicorn 部署 Django 的事例， Nginx 配置如下：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
</pre></td><td class='code'><pre><code class=''><span class='line'># nginx.conf
</span><span class='line'>http {
</span><span class='line'>    include mime.types;
</span><span class='line'>    default_type application/octet-stream;
</span><span class='line'>    access_log /tmp/nginx.access.log combined;
</span><span class='line'>    sendfile on;
</span><span class='line'>
</span><span class='line'>    upstream app_server {
</span><span class='line'>        server unix:/tmp/gunicorn.sock fail_timeout=0;
</span><span class='line'>        # For a TCP configuration:
</span><span class='line'>        # server 192.168.0.7:8000 fail_timeout=0;
</span><span class='line'>    }
</span><span class='line'>
</span><span class='line'>    server {
</span><span class='line'>        listen 80 default;
</span><span class='line'>        client_max_body_size 4G;
</span><span class='line'>        server_name _;
</span><span class='line'>
</span><span class='line'>        keepalive_timeout 5;
</span><span class='line'>
</span><span class='line'>        # path for static files
</span><span class='line'>        root /path/to/app/current/public;
</span><span class='line'>
</span><span class='line'>        location / {
</span><span class='line'>            # checks for static file, if not found proxy to app
</span><span class='line'>            try_files $uri @proxy_to_app;
</span><span class='line'>        }
</span><span class='line'>
</span><span class='line'>        location @proxy_to_app {
</span><span class='line'>            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
</span><span class='line'>            proxy_set_header Host $http_host;
</span><span class='line'>            proxy_redirect off;
</span><span class='line'>
</span><span class='line'>            proxy_pass   http://app_server;
</span><span class='line'>        }
</span><span class='line'>
</span><span class='line'>        error_page 500 502 503 504 /500.html;
</span><span class='line'>        location = /500.html {
</span><span class='line'>            root /path/to/app/current/public;
</span><span class='line'>        }
</span><span class='line'>    }
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>Gunicorn 的配置文件：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class=''><span class='line'># gunicorn.ini
</span><span class='line'>import os
</span><span class='line'>
</span><span class='line'>bind = ["0.0.0.0:8000", "unix:///tmp/gunicorn.sock"]
</span><span class='line'>workers = 3
</span><span class='line'>chdir = os.path.dirname(os.path.realpath(__file__))
</span><span class='line'>raw_env = ["DJANGO_SETTINGS_MODULE=app.settings"]
</span><span class='line'>accesslog = "/tmp/gunicorn-access.log"
</span><span class='line'>errorlog = "/tmp/gunicorn.log"
</span><span class='line'>daemon = True
</span><span class='line'>pidfile = "/tmp/gunicorn.pid"</span></code></pre></td></tr></table></div></figure>


<p>运行：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ gunicorn -c gunicorn.ini myproject.wsgi:application
</span><span class='line'>$ service nginx start</span></code></pre></td></tr></table></div></figure>


<h2>其他内容</h2>

<p>与 WSGI 应用一样，如果之后配置有改动可以向 gunicorn 服务进程发送 <code>HUP</code> 信号让其重新加载配置：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ kill -s HUP &lt;pid&gt;</span></code></pre></td></tr></table></div></figure>



]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Mongodb集群配置实例]]></title>
    <link href="http://www.xefan.com/archives/84137.html"/>
    <updated>2014-12-10T20:33:02+08:00</updated>
    <id>http://www.xefan.com/archives/84137-Mongodb集群配置实例</id>
    <content type="html"><![CDATA[<p>Mongodb的集群有两种，一个是主从复制，另一种是副本集。</p>

<h2>主从复制</h2>

<p>根据 Mongodb 的官方文档说明，在生产环境中建议使用副本集代替主从复制。 <a href="http://docs.mongodb.org/manual/core/master-slave/">http://docs.mongodb.org/manual/core/master-slave/</a></p>

<p>不过对于主从复制还是可以了解一下。假设有如下三台主机：</p>

<ul>
<li>172.17.0.4    (主)</li>
<li>172.17.0.5    (从)</li>
<li>172.17.0.6    (从)</li>
</ul>


<p>要进行主从复制的配置，首先修改主服务器的配置信息：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>master = true         # 以主服务器模式启动
</span><span class='line'>bind_ip = 0.0.0.0</span></code></pre></td></tr></table></div></figure>


<p>然后修改另两台从服务器配置信息：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>slave = true
</span><span class='line'>source = 172.17.0.4
</span><span class='line'>bind_ip = 0.0.0.0</span></code></pre></td></tr></table></div></figure>


<p>最后启动三台主机上的 Mongodb 服务，再通过一个简单的程序来测试一下。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="c1">#!/usr/bin/env ruby</span>
</span><span class='line'><span class="c1">#-*- coding:utf-8 -*-</span>
</span><span class='line'>
</span><span class='line'><span class="nb">require</span> <span class="s2">&quot;mongo&quot;</span>
</span><span class='line'>
</span><span class='line'><span class="k">begin</span>
</span><span class='line'>  <span class="n">conn</span> <span class="o">=</span> <span class="no">Mongo</span><span class="o">::</span><span class="no">Connection</span><span class="o">.</span><span class="n">new</span> <span class="s1">&#39;172.17.0.4&#39;</span>
</span><span class='line'>  <span class="n">db</span> <span class="o">=</span> <span class="n">conn</span><span class="o">[</span><span class="s1">&#39;test&#39;</span><span class="o">]</span>
</span><span class='line'><span class="k">rescue</span> <span class="no">Exception</span><span class="o">=&gt;</span><span class="n">e</span>
</span><span class='line'>  <span class="nb">p</span> <span class="n">e</span>
</span><span class='line'>  <span class="nb">exit</span> <span class="mi">1</span>
</span><span class='line'><span class="k">end</span>
</span><span class='line'>
</span><span class='line'><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span>
</span><span class='line'><span class="k">while</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">100</span>
</span><span class='line'>  <span class="n">d</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;no&#39;</span> <span class="o">=&gt;</span> <span class="n">i</span><span class="p">}</span>
</span><span class='line'>  <span class="n">d</span> <span class="o">=</span> <span class="n">db</span><span class="o">[</span><span class="s1">&#39;data&#39;</span><span class="o">].</span><span class="n">insert</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>
</span><span class='line'>  <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>
</span><span class='line'>  <span class="nb">puts</span> <span class="n">d</span>
</span><span class='line'><span class="k">end</span>
</span></code></pre></td></tr></table></div></figure>


<p>执行该脚本，向 <code>172.17.0.4</code> 主机的 Mongodb 中插入一些数据。然后发现数据被同步到了另外两台主机上。</p>

<p>主从之间安全认证：<br/>
如果启动了 <code>auth</code> 项，那么主从之间的认证需要使用 <code>keyFile</code> 选项。</p>

<p>执行如下命令生成 key 文件，并设置为只有 mongodb 的进程用户可读写：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="err">$</span> <span class="n">openssl</span> <span class="nb">rand</span> <span class="o">-</span><span class="n">base64</span> <span class="mi">741</span> <span class="o">&gt;</span> <span class="sr">/path/mon</span><span class="n">godb_keyFile</span>
</span><span class='line'><span class="err">$</span> <span class="n">chmow</span> <span class="mi">600</span> <span class="o">/</span><span class="n">path</span><span class="o">/</span><span class="n">mongodb_keyFile</span>
</span><span class='line'><span class="err">$</span> <span class="n">chown</span> <span class="ss">mongodb</span><span class="p">:</span><span class="n">mongodb</span> <span class="sr">/path/mon</span><span class="n">godb_keyFile</span>
</span></code></pre></td></tr></table></div></figure>


<p>将该文件复制到这三台主机中，然后分别修改主从的配置信息：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="n">keyFile</span> <span class="o">=</span> <span class="sr">/path/mon</span><span class="n">godb_keyFile</span>
</span></code></pre></td></tr></table></div></figure>


<h2>副本集</h2>

<p>同样的对于这三台主机，我们重新修改配置设置为副本集的形式。</p>

<ul>
<li>172.17.0.4</li>
<li>172.17.0.5</li>
<li>172.17.0.6</li>
</ul>


<p>首先修改配置文件，设置副本集的名字。<br/>
注意：副本集中所有主机设置的名字需要一样。这里我们设为 <code>myrepl0</code>。<br/>
注意：设置副本集之前各个 mongodb 的数据目录必须都为空。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="n">replSet</span> <span class="o">=</span> <span class="n">myrepl0</span>
</span></code></pre></td></tr></table></div></figure>


<p>接着启动所有 mongodb 服务，然后对副本集进行初始化。<br/>
连接任意一台 mongodb 服务，执行如下操作：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="o">&gt;</span> <span class="n">rs</span><span class="o">.</span><span class="n">initiate</span><span class="p">({</span><span class="s1">&#39;_id&#39;</span><span class="p">:</span> <span class="s1">&#39;myrepl0&#39;</span><span class="p">,</span> <span class="s1">&#39;members&#39;</span><span class="p">:</span> <span class="o">[</span>
</span><span class='line'>    <span class="p">{</span><span class="s1">&#39;_id&#39;</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;host&#39;</span><span class="p">:</span> <span class="s1">&#39;172.17.0.4:27017&#39;</span><span class="p">},</span>
</span><span class='line'>    <span class="p">{</span><span class="s1">&#39;_id&#39;</span><span class="p">:</span> <span class="mi">2</span><span class="p">,</span> <span class="s1">&#39;host&#39;</span><span class="p">:</span> <span class="s1">&#39;172.17.0.7:27017&#39;</span><span class="p">},</span>
</span><span class='line'>    <span class="p">{</span><span class="s1">&#39;_id&#39;</span><span class="p">:</span> <span class="mi">3</span><span class="p">,</span> <span class="s1">&#39;host&#39;</span><span class="p">:</span> <span class="s1">&#39;172.17.0.8:27017&#39;</span><span class="p">}</span>
</span><span class='line'><span class="o">]</span><span class="p">})</span>
</span></code></pre></td></tr></table></div></figure>


<p>现在副本集的初始化已完成，可以通过如下命令查看状态：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="o">&gt;</span> <span class="n">rs</span><span class="o">.</span><span class="n">status</span><span class="p">()</span>
</span></code></pre></td></tr></table></div></figure>


<p>在运行过程中可以随时添加或移除一个节点，如：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="n">rs</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="s2">&quot;172.17.0.8:27017&quot;</span><span class="p">)</span>
</span><span class='line'><span class="n">rs</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="s2">&quot;172.17.0.8:27017&quot;</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>


<p>可以再通过上面的程序添加一些数据。然后再连接到任意一台主机进行查询，看看数据是否已同步。</p>

<p>详细内容可参考文档： <a href="http://docs.mongodb.org/manual/core/replication/">http://docs.mongodb.org/manual/core/replication/</a></p>

<p>安全认证：</p>

<p>1.禁用 auth 选项和 replSet 选项再运行 mongodb</p>

<p>2.连接到该 mongodb 服务并创建用户</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="o">&gt;</span> <span class="n">use</span> <span class="n">admin</span>
</span><span class='line'><span class="n">switched</span> <span class="n">to</span> <span class="n">db</span> <span class="n">admin</span>
</span><span class='line'><span class="o">&gt;</span> <span class="n">db</span><span class="o">.</span><span class="n">addUser</span><span class="p">(</span><span class="s1">&#39;root&#39;</span><span class="p">,</span><span class="s1">&#39;root&#39;</span><span class="p">)</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>        <span class="s2">&quot;user&quot;</span> <span class="p">:</span> <span class="s2">&quot;root&quot;</span><span class="p">,</span>
</span><span class='line'>        <span class="s2">&quot;readOnly&quot;</span> <span class="p">:</span> <span class="kp">false</span><span class="p">,</span>
</span><span class='line'>        <span class="s2">&quot;pwd&quot;</span> <span class="p">:</span> <span class="s2">&quot;2a8025f0885adad5a8ce0044070032b3&quot;</span><span class="p">,</span>
</span><span class='line'>        <span class="s2">&quot;_id&quot;</span> <span class="p">:</span> <span class="no">ObjectId</span><span class="p">(</span><span class="s2">&quot;54745351f79804bd44b596fb&quot;</span><span class="p">)</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="o">&gt;</span>
</span></code></pre></td></tr></table></div></figure>


<p>3.重新以 auth、keyFile 和 replSet 模式启动 mongodb</p>

<p>4.连接到刚刚创建用户的 mongodb 服务</p>

<p>5.跟之前的步骤一样，配置副本集</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="o">&gt;</span> <span class="n">rs</span><span class="o">.</span><span class="n">initiate</span><span class="p">({</span><span class="s1">&#39;_id&#39;</span><span class="p">:</span> <span class="s1">&#39;myrepl0&#39;</span><span class="p">,</span> <span class="s1">&#39;members&#39;</span><span class="p">:</span> <span class="o">[</span>
</span><span class='line'>    <span class="p">{</span><span class="s1">&#39;_id&#39;</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;host&#39;</span><span class="p">:</span> <span class="s1">&#39;172.17.0.4:27017&#39;</span><span class="p">},</span>
</span><span class='line'>    <span class="p">{</span><span class="s1">&#39;_id&#39;</span><span class="p">:</span> <span class="mi">2</span><span class="p">,</span> <span class="s1">&#39;host&#39;</span><span class="p">:</span> <span class="s1">&#39;172.17.0.7:27017&#39;</span><span class="p">},</span>
</span><span class='line'>    <span class="p">{</span><span class="s1">&#39;_id&#39;</span><span class="p">:</span> <span class="mi">3</span><span class="p">,</span> <span class="s1">&#39;host&#39;</span><span class="p">:</span> <span class="s1">&#39;172.17.0.8:27017&#39;</span><span class="p">}</span>
</span><span class='line'><span class="o">]</span><span class="p">})</span>
</span></code></pre></td></tr></table></div></figure>


<p>参考： <a href="http://docs.mongodb.org/manual/tutorial/deploy-replica-set-with-auth/">http://docs.mongodb.org/manual/tutorial/deploy-replica-set-with-auth/</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[使用VIM进行PHP远程调试]]></title>
    <link href="http://www.xefan.com/archives/84136.html"/>
    <updated>2014-11-19T20:00:30+08:00</updated>
    <id>http://www.xefan.com/archives/84136-使用VIM进行PHP远程调试</id>
    <content type="html"><![CDATA[<p>最近在写 PHP 时感觉它的调试不是很方便，基本都是用的 <code>var_dump</code> 将信息输出到页面上进行调试。最终实现是受不了这种方式，就找了一下看看有没有什么简便的方法。
于是就找到了 <code>vdebug</code> 这个 vim 插件，使用它可以方便的进行远程调试。</p>

<p>根据 <code>vdebug</code> 的介绍，说是它可以用来调试基于 DBGP 协议的程序，比如： PHP、Python、Ruby等。
可能只是 DBGP 协议在 PHP 中用得比较多吧，因此看到的大部分介绍都是说的 PHP 调试。
关于 DBGP 协议的详细介绍可参考： <a href="http://xdebug.org/docs-dbgp.php">http://xdebug.org/docs-dbgp.php</a></p>

<p><strong>使用方法：</strong></p>

<p>首先是在 vim 中安装这个插件，下载地址： <a href="https://github.com/joonty/vdebug">https://github.com/joonty/vdebug</a></p>

<p>由于它的配置信息都写死在代码中的，因此我就 fork 了一份进行自定义的修改，如快捷键设置、远程主机名和端口号。</p>

<p>然后是安装 PHP 的 Xdebug 扩展，并配置一些参数信息。在 <code>php.ini</code> 配置文件中添加如下内容：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>xdebug.remote_enable=on
</span><span class='line'>xdebug.remote_handler=dbgp
</span><span class='line'>xdebug.remote_host=127.0.0.1
</span><span class='line'>xdebug.remote_port=9010</span></code></pre></td></tr></table></div></figure>


<p>注意：这里的主机名和端口号要与 <code>vdebug</code> 中的一致。</p>

<p>接着使用 vim 打开一个 php 文件，按 <code>&lt;F5&gt;</code> 键启动该插件进行调试。然后在浏览器中访问该 php 程序，
并加上 <code>XDEBUG_SESSION_START=1</code> 参数，如： <a href="http://127.0.0.1/test.php?XDEBUG_SESSION_START=1">http://127.0.0.1/test.php?XDEBUG_SESSION_START=1</a></p>

<p>现在就可以在 vim 中对 php 程序进行单步调试了。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Nginx + Uwsgi + Django环境配置]]></title>
    <link href="http://www.xefan.com/archives/84135.html"/>
    <updated>2014-11-11T21:02:17+08:00</updated>
    <id>http://www.xefan.com/archives/84135-Nginx+uwsgi+Django环境配置</id>
    <content type="html"><![CDATA[<p>有段时间没折腾 Django 了，又有点生疏了。最近又部署了一下 Django 的环境，顺便作个笔记以便之后查阅。</p>

<p>首先安装 nginx、uwsgi 以及 uwsgi 的 python 插件。</p>

<p>然后新建一个 uwsgi 的配置文件：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>[uwsgi]
</span><span class='line'>uid = www-data
</span><span class='line'>chdir = /repo/django-blog
</span><span class='line'>virtualenv = /repo/django-blog/pyenv2.7/    # python虚拟环境，没有可以不设置
</span><span class='line'>env = DJANGO_SETTINGS_MODULE=blog.settings
</span><span class='line'>module = blog.wsgi:application
</span><span class='line'>master = true
</span><span class='line'>plugin = python
</span><span class='line'>pidfile = /tmp/blog-master.pid
</span><span class='line'>socket = /tmp/blog.sock
</span><span class='line'>enable-threads = true
</span><span class='line'>post-buffering=1024000
</span><span class='line'>post-buffering-busize=655360</span></code></pre></td></tr></table></div></figure>


<p>这里我们的 Django 项目代码位于 <code>/repo/django-blog</code> ，项目的配置文件为： <code>blog/settings.py</code> 。</p>

<p><code>virtualenv</code> 项表明我们使用的是 <code>virtualenv</code> 环境，也可以直接系统的 python 环境。不过还是建议使用虚拟环境，以免软件包版本冲突。</p>

<p><code>post-buffering</code> 和 <code>post-buffering-busize</code> 这两项设置了 POST 请求时缓冲区的大小，该值可根据自己的情况进行调整。之前遇到过由于缓冲区不足导致返回的内容不完整。</p>

<p>再安装对应的 python 依赖包，然后运行 uwsgi 服务。</p>

<p>接着修改 nginx 的配置：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>server {
</span><span class='line'>  listen 80;
</span><span class='line'>  server_name localhost;
</span><span class='line'>
</span><span class='line'>  client_max_body_size 50m;
</span><span class='line'>
</span><span class='line'>  access_log /var/log/nginx/blog-access.log;
</span><span class='line'>  error_log /var/log/nginx/blog-error.log;
</span><span class='line'>
</span><span class='line'>  location / {
</span><span class='line'>    uwsgi_pass unix:///tmp/blog.sock;
</span><span class='line'>    include uwsgi_params;
</span><span class='line'>  }
</span><span class='line'>
</span><span class='line'>  location /static {
</span><span class='line'>    alias /repo/django-blog/static/;
</span><span class='line'>  }
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>这个内容比较简单， <code>client_max_body_size</code> 项是用于设置 http 请求的 body 最大大小。如果你的程序中有文件上传的，那么就需要根据自身情况来设置允许上传文件的最大值。</p>

<p>最后再启动 nginx 服务。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[配置rails的vim环境]]></title>
    <link href="http://www.xefan.com/archives/84134.html"/>
    <updated>2014-11-08T16:02:58+08:00</updated>
    <id>http://www.xefan.com/archives/84134-配置rails的vim环境</id>
    <content type="html"><![CDATA[<p>今天分享一款 vim 的 rails 插件： <code>vim-rails</code> 。</p>

<p>使用该插件可以方便的在多个文件之间进行跳转。如在控制器的 action 上按 <code>gf</code> 键会自动跳转到对应的视图文件。</p>

<p>也可以使用 <code>:Emodel</code>, <code>:Eview</code>, <code>:Econtroller</code>, 命令在模型、视图以及控制器之间进行跳转。</p>

<p>该插件还提供了对 rails 的一些关键字的高亮。</p>

<p>并且还可以直接在 vim 中使用 <code>:Rails</code> 命令。</p>

<p>同时还有 <code>vim-rake</code> 和 <code>vim-bundler</code> 两个插件提供了 <code>rake</code> 和 <code>bundle</code> 的 vim 命令接口。</p>

<p>如果是用的 vundle 进行插件管理的话，可以直接在 .vimrc 配置中添加如下内容即可：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>Bundle 'tpope/vim-rails'
</span><span class='line'>Bundle 'tpope/vim-rake'
</span><span class='line'>Bundle 'tpope/vim-bundler'</span></code></pre></td></tr></table></div></figure>


<p>然后再在vim执行命令 :BundleInstall 即可。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[博客终于迁移完成了！]]></title>
    <link href="http://www.xefan.com/archives/84133.html"/>
    <updated>2014-11-04T21:04:32+08:00</updated>
    <id>http://www.xefan.com/archives/84133-博客终于迁移完成了！</id>
    <content type="html"><![CDATA[<p>折腾了两天，终于将博客从之前的WordPress迁移到Jekyll上来了。</p>

<p>我的博客是从2009年开始使用WordPress的，至今也有5年多了。最近感觉WordPress提供的文章编辑功能不是很方便，本来是想着改用别的博客系统的。但是一直纠结着始终没换。一是由于懒，感觉能用就行了，不想折腾了。二是由于找不到比较好的系统。</p>

<p>这样就纠结了一年多。最近突然发现了Octopress，感觉很不错。于是果断地选择迁移过来。</p>

<p>环境搭建好了之后，接下来就是数据的迁移了。原打算之前的数据都不要了，准备从头再来的。毕竟之前的文章也写得不咋滴。
也许是自己比较怀旧吧，最终还是写了一个脚本将WordPress的数据输出为Markdown文件。<br/>
程序地址： <a href="https://github.com/wusuopu/wordpress-to-octopress">https://github.com/wusuopu/wordpress-to-octopress</a></p>

<p>数据输出之后发现布局全乱了，又得重新调整一下格式。唉~~~~~，只是麻烦啊！</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[配置elixir的vim环境]]></title>
    <link href="http://www.xefan.com/archives/84132.html"/>
    <updated>2014-10-29T00:00:00+08:00</updated>
    <id>http://www.xefan.com/archives/84132-配置elixir的vim环境</id>
    <content type="html"><![CDATA[<p>elixir是建立在Erlang虚拟机之上的一种函数式编程语言。下面介绍elixir的两个vim插件。</p>


<p>首先是语法高亮支持： https://github.com/elixir-lang/vim-elixir</p>


<p>其次是snippets支持： https://github.com/carlosgaldino/elixir-snippets
这个需要先安装 snipMate 插件。</p>


<p>如果也是用的 vundle 进行插件管理的话，可以直接在 .vimrc 配置中添加如下内容即可：</p>


<pre><code>Bundle 'elixir-lang/vim-elixir'
Bundle 'carlosgaldino/elixir-snippets'

au BufNewFile,BufRead *.exs set ft=elixir
</code></pre>




<p>然后再在vim执行命令 :BundleInstall 即可。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[配置coffeescript的vim环境]]></title>
    <link href="http://www.xefan.com/archives/84130.html"/>
    <updated>2014-10-24T00:00:00+08:00</updated>
    <id>http://www.xefan.com/archives/84130-配置coffeescript的vim环境</id>
    <content type="html"><![CDATA[<p>coffeescript是构建在javascript基础上一门语言，它在运行时会编译在javascript。下面介绍vim用来开发coffeescript的两个插件。</p>


<p>首先是语法高亮支持： https://github.com/kchmck/vim-coffee-script</p>


<p>其次是snippets支持： https://github.com/carlosvillu/coffeScript-VIM-Snippets
这个需要先安装 snipMate 插件。</p>


<p>如果也是用的 vundle 进行插件管理的话，可以直接在 .vimrc 配置中添加如下内容即可：</p>


<pre><code>Bundle 'kchmck/vim-coffee-script'
Bundle 'carlosvillu/coffeScript-VIM-Snippets'

au BufNewFile,BufRead *.coffee set ft=coffee
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[VIM编译参数]]></title>
    <link href="http://www.xefan.com/archives/84127.html"/>
    <updated>2014-10-18T00:00:00+08:00</updated>
    <id>http://www.xefan.com/archives/84127-VIM编译参数</id>
    <content type="html"><![CDATA[<p>每次重装系统之后都要重新编译一次VIM，为了方便就将编译参数记录如下：</p>


<pre><code>./configure --prefix=/opt/vim --enable-acl --enable-cscope --enable-largefile --enable-multibyte --enable-sniff --enable-mzschemeinterp --enable-xim --enable-tclinterp --enable-perlinterp --enable-python3interp --enable-pythonint
erp --enable-rubyinterp --enable-netbeans --enable-gui --enable-luainterp --enable-nls --enable-xsmp --enable-xsmp-interact --enable-fontset --with-features=huge --with-x
</code></pre>




<p>上面的参数中启用了对tcl、perl、python、ruby、lau的支持。同时为了使用系统的剪切板还启用了对X的支持。</p>


<p>我的VIM配置文件： https://github.com/wusuopu/my-vimrc</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Docker使用笔记]]></title>
    <link href="http://www.xefan.com/archives/84124.html"/>
    <updated>2014-09-21T00:00:00+08:00</updated>
    <id>http://www.xefan.com/archives/84124-Docker使用笔记</id>
    <content type="html"><![CDATA[<p>docker是一个Linux下的应用容器引擎。使用它可以很方便地将程序以及依赖都打包到一个可移植的容器中。最后体验了一下，使用docker配置了一个Web开发环境。这样就不用担心每次重装系统之后都要重新配置开发环境。</p>


<h3>安装</h3>


<p>首先是安装docker应用程序，目前只有64位系统才能使用。</p>


<pre><code>$ [sudo] apt-get install apparmor apparmor-profiles apparmor-utils
$ [sudo] apt-get install aufs-tools
$ [sudo] apt-get install cgroup-lite

$ wget https://get.docker.io/builds/Linux/x86_64/docker-latest.tgz
$ [sudo] tar xf docker-latest.tgz -C /
</code></pre>


<h3>基本用法</h3>


<p>安装完成之后使用 <code>[sudo] docker -d</code> 命令启动docker的daemon进程。</p>


<p>以下是一些常用命令的用法介绍：</p>


<pre><code>docker version            # 查看版本
docker search TERM        # 搜索镜像
docker pull NAME[:TAG]    # 下载镜像
</code></pre>




<p>启动镜像：</p>


<pre><code>docker run [OPTIONS] IMAGE [COMMAND] [ARG...]
docker run IMAGE -t -i /bin/bash                        # 进入镜像的shell环境
docker run IMAGE -p 12345:8000 -t -i /bin/bash          # 进入镜像的shell环境，将主机的12345端口映射到容器的8000端口

</code></pre>




<p>容器与镜像管理：</p>


<pre><code>docker ps [OPTIONS]                              # 列出容器
docker images [OPTIONS] [NAME]                   # 列出镜像
docker rm [OPTIONS] CONTAINER [CONTAINER...]     # 删除容器
docker rmi IMAGE [IMAGE...]                      # 删除镜像

docker commit [OPTIONS] CONTAINER [REPOSITORY[:TAG]]    # 根据修改的容器创建一个新的镜像
docker commit -m &quot;centos&quot; f9ccb5cef3c0 wusuopu/centos6
docker push NAME[:TAG]                                  # 上传镜像
</code></pre>




<pre><code>docker inspect CONTAINER|IMAGE [CONTAINER|IMAGE...]     # 查看一个容器或者镜像的详细信息
docker logs CONTAINER     # 查看日志
docker start CONTAINER [CONTAINER...]                   # 启动镜像
docker stop CONTAINER [CONTAINER...]                    # 停止镜像
docker tag [OPTIONS] IMAGE [REGISTRYHOST/][USERNAME/]NAME[:TAG]   # 给镜像打tag
docker diff CONTAINER     # 查看容器文件系统的变化
docker cp CONTAINER:PATH HOSTPATH                       # 将文件从容器复制到主机
</code></pre>




<p>导入、导出：</p>


<pre><code>docker export CONTAINER                                 # 导出容器到标准输出
docker export red_panda &gt; latest.tar

docker import URL|- [REPOSITORY[:TAG]]                  # 导入文件为镜像
docker import http://example.com/exampleimage.tgz
cat exampleimage.tgz | sudo docker import - exampleimagelocal:new
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Nginx + Php + FastCGI配置]]></title>
    <link href="http://www.xefan.com/archives/84121.html"/>
    <updated>2014-08-01T00:00:00+08:00</updated>
    <id>http://www.xefan.com/archives/84121-nginx + php + FastCGI配置</id>
    <content type="html"><![CDATA[<p>最近在弄PHP，于是乎把配置过程作一个笔记以免忘了。</p>


<h2>PHP安装、配置</h2>


<p>我是通过源代码编译的形式进行安装的，基本步骤如下：</p>


<pre><code>$ tar xf php-5.5.12.tar.bz2
$ cd php-5.5.12
$ './configure'  '--prefix=/opt/myphp' '--with-mysql' '--enable-safe-mode' '--enable-ftp' '--enable-zip' '--with-jpeg-dir' '--with-bz2' '--with-png-dir' '--with-freetype-dir' '--with-iconv' '--with-libxml-dir' '--with-xmlrpc' '--with-zlib-dir' '--with-gd' '--enable-gd-native-ttf' '--with-curl' '--with-gettext' '--with-pear' '--enable-fpm' '--enable-fastcgi' '--with-ncurses' '--with-mcrypt' '--with-mhash' '--with-openssl' '--with-pcre-dir' '--enable-pdo' '--enable-phar' '--enable-json' '--enable-mbstring' '--with-pdo-mysql' '--with-pdo-sqlite' '--with-readline' '--enable-bcmath'
$ make
$ sudo make install
</code></pre>




<p>安装完成之后进入安装目录修改配置文件 lib/php.ini (没有则创建)，添加时区设置：</p>


<pre><code>date.timezone=Asia/Shanghai
</code></pre>




<p>然后运行PHP的FastCGI服务：</p>


<pre><code>./bin/php-cgi -b 9000
</code></pre>




<h2>nginx配置</h2>


<p>nginx可以直接从仓库进行安装：</p>


<pre><code>sudo pacman -S nginx
</code></pre>




<p>或者：</p>


<pre><code>sudo apt-get install nginx
</code></pre>




<p>安装完成之后修改配置，添加一条新的虚拟主机：</p>


<pre><code>server {
    listen 8000;
    server_name localhost;

    root /var/www;

    location / {
        index index.php;
    }

    location ~ \.php$ {
        fastcgi_pass   127.0.0.1:9000;
        fastcgi_index  index.php;  
        fastcgi_split_path_info ^(.+\.php)(/.*)$;
        include        fastcgi_params;
        fastcgi_param  SCRIPT_FILENAME  /var/www/$fastcgi_script_name;
    }

}
</code></pre>




<p>然后再创建文件 /var/www/index.php</p>


<pre><code>&lt;?php
  phpinfo();
?&gt;
</code></pre>




<p>现在通过浏览器访问 http://127.0.0.1:8000/ 应该就可以看到效果了。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[使用ruby开发vim插件]]></title>
    <link href="http://www.xefan.com/archives/84117.html"/>
    <updated>2014-07-03T00:00:00+08:00</updated>
    <id>http://www.xefan.com/archives/84117-使用ruby开发vim插件</id>
    <content type="html"><![CDATA[<p>作为一个Vimmer和Pythoner，之前折腾过用python编写vim插件。现在作为半个Rubist，又开始继续折腾。</p>


<p>在开始编写插件之前，你需要确认 Vim 是否支持 Ruby，通过以下命令来判别：</p>


<pre><code>$ vim --version | grep +ruby
</code></pre>


<p>如果输出为空，则表示你当前的vim不支持Ruby，需要重新编译一下，并启用对Ruby的支持。</p>


<p>顺便说下我当前的环境是：</p>


<ul>
<li>vim 7.4  </li>
<li>ruby 2.1.0  </li>
</ul>


<p>环境检查没有问题那么就开始吧。<br>
在~/.vim/plugin目录下创建一个 demo.vim 文件。</p>


<p>在开头写上以下代码：</p>


<pre><code>if !has('ruby')
    echo "Error: Required vim compiled with +ruby"
    finish
endif
</code></pre>


<p>这段代码就是用 VimL 编写的，它将检查 Vim 是否支持 Ruby。</p>


<p>接下来再判断该插件是否已经加载过了，以免重复加载：</p>


<pre><code>if exists('g:loaded_ruby_demo_plugin')
    finish
endif
let g:loaded_ruby_demo_plugin = 1
</code></pre>


<p>所有的检查都没有问题，则开始插件的正文了。先定义一个函数。</p>


<pre><code>function! DemoFun1()
ruby&lt;&lt;EOF
buf = VIM::Buffer.current
puts "current buffer name: #{buf.name} number: #{buf.number} length: #{buf.length}"
EOF
endfunction
</code></pre>


<p>function与endfunction是vim中用于定义函数的，在”ruby&lt;&lt;EOF”和”EOF”之间部分的是Ruby代码。这个例子是输出当前缓冲区的名字、编号以及总行数。<br>
执行命令:call DemoFun1()，应该就可以看到输出结果了。</p>


<p>然后再举个例子说下函数的参数处理。</p>


<pre><code>function! DemoFun2(arg1)
ruby&lt;&lt; EOF
puts "you input: #{VIM.evaluate('a:arg1')}"
EOF
endfunction
</code></pre>


<p>这里定义了一个函数接收一个参数，然后将其输出。使用 VIM.evaluate 将vim的变量转化为Ruby的变量。</p>


<p>为了方便我们再定义两个命令，以简化对这两个函数的调用。</p>


<pre><code>command! -nargs=0 DemoFun1 call DemoFun1()  
command! -nargs=1 -rang DemoFun2 call DemoFun2(&lt;f-args&gt;)
</code></pre>


<p>要获取完整的代码可以访问： https://gist.github.com/wusuopu/c1182efefa85d4f6839b</p>


<p>接下来再简单说下vim中Ruby的使用。</p>


<p>vim为Ruby提供了一个VIM模块，通过它可以在Ruby中访问vim的接口。同时还提供了两个全局变量：$curwin、$curbuf，它们分别代表了当前窗口对象以及当前缓冲区对象。</p>


<p>VIM模块中有 Buffer 和 Window 两个对象，分别是用来对缓冲区和窗口进行操作的。同时VIM模块还提供了message、set_option、command和evaluate四个函数。</p>


<p>想要查看更多的帮忙信息，可以在vim中执行如下命令：</p>


<pre><code>:help ruby
</code></pre>


<p>好了，先写这么多吧，其余的自己去尝试吧。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Vim的symfony2开发环境配置]]></title>
    <link href="http://www.xefan.com/archives/84114.html"/>
    <updated>2014-06-26T00:00:00+08:00</updated>
    <id>http://www.xefan.com/archives/84114-vim的symfony2开发环境配置</id>
    <content type="html"><![CDATA[<h2>安装</h2>


<p>最近在用Symfony2框架进行开发，正所谓工欲善其事必先利其器。为了提高开发效率，因此将vim配置为symfony的IDE。</p>


<p>我安装的是phpcomplete-extended-symfony这款插件 https://github.com/m2mdas/phpcomplete-extended-symfony</p>


<p>它有些依赖在文档中没写清楚，我也是折腾了好久才搞定的，于是做个笔记记录一下。</p>


<p>我总共安装了以下插件：</p>


<ul>
<li>neocomplete.vim  </li>
<li>vimproc.vim  </li>
<li>unite.vim  </li>
<li>phpcomplete.vim  </li>
<li>phpcomplete-extended  </li>
<li>phpcomplete-extended-symfony  </li>
<li>vim-twig  </li>
</ul>


<p>我是使用的Vundle进行vim插件管理，因此在 .vimrc 配置中添加以下内容：</p>


<pre><code>Bundle 'Shougo/neocomplete.vim'
Bundle 'Shougo/vimproc.vim'
Bundle 'Shougo/unite.vim'
Bundle 'shawncplus/phpcomplete.vim'
Bundle 'm2mdas/phpcomplete-extended'
Bundle 'm2mdas/phpcomplete-extended-symfony'
Bundle 'evidens/vim-twig'
</code></pre>


<p>然后再执行BundleInstall命令进行下载安装。</p>


<p>注意：vim-twig插件不是必需的，安装它只是为了编写twig模板时能够高亮。  </p>


<h2>使用</h2>


<p>接下来说说使用流程。</p>


<p>1.vimproc需要编译<br>
进行vimproc的安装目录，执行make命令进行编译。详细内容请阅读它的README文件。</p>


<p>2.安装ctags工具<br>
由于当前的ctags工具不支持PHP的新特性，如命名空间、traits、interface，于是就需要给ctags打补丁。  </p>


<p>下载打过补丁的ctags源代码：  </p>


<pre><code>$ wget "https://github.com/shawncplus/phpcomplete.vim/blob/master/misc/ctags-better-php-parser.tar.bz2?raw=true" -O ctags-better-php-parser.tar.bz2
</code></pre>


<p>编译安装：  </p>


<pre><code>$ tar xvjf ctags-better-php-parser.tar.bz2  
$ ./configure  
$ make  
$ sudo make install
</code></pre>


<p>3.安装 composer.phar  </p>


<pre><code>$ curl -s https://getcomposer.org/installer | php
</code></pre>


<p>4.修改vim配置<br>
在vim中添加如下配置：  </p>


<pre><code>au FileType php setlocal omnifunc=phpcomplete_extended#CompletePHP  
let g:phpcomplete_index_composer_command = 'composer.phar'
</code></pre>


<p>5.开始使用<br>
进入Symfony项目的根目录，执行命令生成tags文件：</p>


<pre><code>$ ctags -R --fields=+aimS --languages=php
</code></pre>


<p>然后使用vim打开该tags文件，根据提示创建索引文件。完成之后索引文件会创建在 .phpcomplete_extended 目录中。下次在项目的根目录下打开vim，如果提示 “Index Loaded.”则表示配置成功了。接下来编写代码时就会有补全提示以及use语句的自动补全了。</p>


<p><strong>注意：</strong>在使用该插件时需要把自动切换目录功能给禁用掉，添加设置： set autochdir! 。否则会出现无法加载索引，从而补全不了。这个问题在文档中没说，我也是折腾了好久才发现的。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Redis使用笔记]]></title>
    <link href="http://www.xefan.com/archives/84110.html"/>
    <updated>2014-06-21T00:00:00+08:00</updated>
    <id>http://www.xefan.com/archives/84110-Redis使用笔记</id>
    <content type="html"><![CDATA[<p>Redis是一个键值型数据库，之前花了些时间体验了一下Redis，感觉还是很不错的。而且Redis学习起来也很容易，差不多花几个小时应该就能入门了。当时我是看的<a href="https://github.com/karlseguin/the-little-redis-book">《the little redis book》</a>，初学者可以看看。</p>


<h2>安装</h2>


<p>下载软件包： http://redis.io/download</p>


<p>首先运行服务器程序：</p>


<pre><code>$ redis-server
</code></pre>


<p>程序默认是监听6379端口。</p>


<p>然后再运行客户端程序：</p>


<pre><code>$ redis-cli
</code></pre>


<h2>基本数据类型</h2>


<p>运行客户端程序连接上Redis服务之后，所有的操作都可以通过该命令行交互完成。</p>


<p>Redis有5种不同的数据类型：字符串、散列表、列表、集合、有序集合。所有的数据在Redis中都是以键值对的形式保存的。</p>


<p>以下介绍这几种类型数据的基本操作。</p>


<h3>String</h3>


<p>设置一个键的值为字符串：  </p>


<pre><code>set &lt;key&gt; &lt;value&gt;
</code></pre>


<p>获取该键的值：  </p>


<pre><code>get &lt;key&gt;
</code></pre>


<p>字符串相关的命令：  </p>


<pre><code>help @string
</code></pre>


<h3>Hashes</h3>


<p>设置一个散列值：  </p>


<pre><code>hset &lt;key&gt; &lt;k&gt; &lt;v&gt;
</code></pre>


<p>获取该键的值：  </p>


<pre><code>hget &lt;key&gt; &lt;k&gt;  
hgetall &lt;key&gt;
</code></pre>


<p>散列相关的命令：  </p>


<pre><code>help @hash
</code></pre>


<h3>Lists</h3>


<p>添加值：  </p>


<pre><code>lpush &lt;key&gt; &lt;v&gt;
</code></pre>


<p>移除值：  </p>


<pre><code>lpop &lt;key&gt;  
help @list
</code></pre>


<h3>Set</h3>


<p>添加值：  </p>


<pre><code>sadd &lt;key&gt; &lt;v&gt;[ &lt;v&gt; ..]  
help set
</code></pre>


<h3>Sorted Sets</h3>


<p>类似于集合(Set)，但是提供了排序（sorting）和秩划分（ranking）的功能。</p>


<p>添加值：  </p>


<pre><code>zadd key score member [score] [member]   
help @sorted_set
</code></pre>


<h2>其他</h2>


<h3>有效期</h3>


<p>设置某个值在seconds秒后到期：  </p>


<pre><code>expire &lt;key&gt; seconds
</code></pre>


<p>设置某个值在time时刻到期：  </p>


<pre><code>expireat &lt;key&gt; time
</code></pre>


<p>查看到期时间：  </p>


<pre><code>ttl &lt;key&gt;
</code></pre>


<p>清除到期时间：  </p>


<pre><code>persist &lt;key&gt;
</code></pre>


<h3>事务（Transactions）</h3>


<pre><code>multi  
do something  
exec
</code></pre>


<p>multi和exec之间的命令作为原子操作。</p>


<p>在multi之前调用watch可监听值的变化，若该值被其他客户端修改，事务将会运行失败。</p>


<h3>杂项</h3>


<p>选择数据库：</p>


<pre><code>select index
</code></pre>


<p>清除当前数据库所属key:</p>


<pre><code>flushdb
</code></pre>


<p>清除所有数据库所属key:</p>


<pre><code>flushall
</code></pre>


<p>查看key所储存的值的类型：</p>


<pre><code>type key
</code></pre>


<p>Redis相关的命令手册： http://redis.io/commands</p>


<h2>在应用程序中使用Redis</h2>


<p>Redis提供了多种语言的绑定，以Ruby为例：</p>


<pre><code>require 'redis'
r = Redis.new
r.set 'key', 1234
puts r.get 'key'
puts r.keys
</code></pre>


<p>输出结果应该为：</p>


<pre><code>"1234"
["key"]
</code></pre>

]]></content>
  </entry>
  
</feed>
