<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Tag: Js | 龍昌博客]]></title>
  <link href="http://www.xefan.com/tags/js/atom.xml" rel="self"/>
  <link href="http://www.xefan.com/"/>
  <updated>2015-08-22T17:56:18+08:00</updated>
  <id>http://www.xefan.com/</id>
  <author>
    <name><![CDATA[龍昌]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Riot.js之初体验]]></title>
    <link href="http://www.xefan.com/archives/84152.html"/>
    <updated>2015-08-21T09:55:14+08:00</updated>
    <id>http://www.xefan.com/archives/84152-Riot.js之初体验</id>
    <content type="html"><![CDATA[<p>Riot(<a href="http://riotjs.com/">http://riotjs.com/</a>)按照官方的介绍，它是一个类似于 React 的微型框架。
压缩之后的文件只有差不多 15K 的大小，相比其他基本上都是上百K大小的框架来说确实是很微型的。</p>

<p>同时它的官方还给出了与 React 和 Polymer 的对比，各位感兴趣可以看看： <a href="http://riotjs.com/compare/">http://riotjs.com/compare/</a></p>

<p>下面通过一个例子来体验一下。</p>

<p>先下载 Riot 库文件： <a href="https://raw.githubusercontent.com/riot/riot/master/riot+compiler.min.js  ">https://raw.githubusercontent.com/riot/riot/master/riot+compiler.min.js  </a>
然后新建一个文件 <code>index.html</code>，内容如下：</p>

<pre><code class="html">&lt;!DOCTYPE html&gt;
&lt;html&gt;
  &lt;head&gt;
    &lt;meta charset="utf-8"&gt;
    &lt;meta name="viewport" content="width=device-width"&gt;
    &lt;title&gt;Tabs exampe&lt;/title&gt;
    &lt;style type="text/css" media="screen"&gt;
      .tabContent__item{
        display:none;
      }
      .tabContent__item.is-active{
        display:block;
      }
    &lt;/style&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;riot-tabs&gt;&lt;/riot-tabs&gt;

    &lt;script src="tabs.tag" type="riot/tag"&gt;&lt;/script&gt;
    &lt;script src="riot+compiler.min.js"&gt;&lt;/script&gt;
    &lt;script type="text/javascript" charset="utf-8"&gt;
      riot.mount('riot-tabs');
    &lt;/script&gt;
  &lt;/body&gt;
&lt;/html&gt;
</code></pre>

<p>接着再创建文件 <code>tabs.tag</code>：</p>

<pre><code>&lt;riot-tabs&gt;
  &lt;h2&gt;Tabs&lt;/h2&gt;
  &lt;ul&gt;
    &lt;li each={ tab, i in tabs } class="tabItem { is-active: parent.isActiveTab(tab.ref) }" onclick={ parent.toggleTab }&gt;{tab.title}&lt;/li&gt;
  &lt;/ul&gt;
  &lt;div class="tabContent"&gt;
    &lt;div each={ tab, i in tabs } class="tabContent__item { is-active: parent.isActiveTab(tab.ref) }"&gt;{tab.content}&lt;/div&gt;
  &lt;/div&gt;

  this.tabs = [
    { title: 'Tab 1', ref: 'tab1', content: "(1) Lorem ipsum dolor" },
    { title: 'Tab 2', ref: 'tab2', content: "(2) Lorem ipsum dolor" },
    { title: 'Tab 3', ref: 'tab3', content: "(3) Lorem ipsum dolor" }
  ]

  this.activeTab = 'tab1'

  isActiveTab(tab) {
    return this.activeTab === tab
  }

  toggleTab(e) {
    this.activeTab = e.item.tab.ref
    return true
  }
&lt;/riot-tabs&gt;
</code></pre>

<p>这个是 javascript 与 html 的混合。当然还可以使用纯 js 的写法，将 <code>tabs.tag</code> 改为 <code>tabs.js</code>：</p>

<pre><code>riot.tag('riot-tabs', '&lt;h2&gt;Tabs&lt;/h2&gt; &lt;ul&gt; &lt;li each="{ tab, i in tabs }" class="tabItem { is-active: parent.isActiveTab(tab.ref) }" onclick="{ parent.toggleTab }"&gt;{tab.title}&lt;/li&gt; &lt;/ul&gt; &lt;div class="tabContent"&gt; &lt;div each="{ tab, i in tabs }" class="tabContent__item { is-active: parent.isActiveTab(tab.ref) }"&gt;{tab.content}&lt;/div&gt; &lt;/div&gt;', function(opts) {

  this.tabs = [
    { title: 'Tab 1', ref: 'tab1', content: "(1) Lorem ipsum dolor" },
    { title: 'Tab 2', ref: 'tab2', content: "(2) Lorem ipsum dolor" },
    { title: 'Tab 3', ref: 'tab3', content: "(3) Lorem ipsum dolor" }
  ];

  this.activeTab = 'tab1';

  this.isActiveTab = function(tab) {
    return this.activeTab === tab;
  }.bind(this);

  this.toggleTab = function(e) {
    this.activeTab = e.item.tab.ref;
    return true;
  }.bind(this);

});
</code></pre>

<p>同时将 <code>index.html</code> 中的 <code>&lt;script src="tabs.tag" type="riot/tag"&gt;&lt;/script&gt;</code> 修改为 <code>&lt;script src="tabs.js" type="riot/tag"&gt;&lt;/script&gt;</code> 。</p>

<p>好了，现在打开浏览器看下效果吧。</p>

<p>体验了一下，感觉它比 angular 之类的框架的学习成本要低。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[AngularJS学习笔记5——路由]]></title>
    <link href="http://www.xefan.com/archives/84151.html"/>
    <updated>2015-08-20T20:58:53+08:00</updated>
    <id>http://www.xefan.com/archives/84151-AngularJS学习笔记5——路由</id>
    <content type="html"><![CDATA[<p>angularjs 的 <code>ngRoute</code> 模块提供了前端路由的功能。
在 angularjs 1.3 中 route 模块被单独提取了出来，要使用其功能需要将引用进来。</p>

<pre><code>  &lt;script src="http://www.xefan.com/lib/angular-1.3.15.min.js"&gt;&lt;/script&gt;
  &lt;script src="http://www.xefan.com/lib/angular-route-1.3.15.min.js"&gt;&lt;/script&gt;
</code></pre>

<pre><code>var routeApp = angular.module('routeApp', ['ngRoute']);
routeApp.config(['$routeProvider',function ($routeProvider) {
    $routeProvider
    .when('/list', {
      templateUrl: 'list.html',
      controller: 'RouteListCtl'
    })
    .when('/list/:id', {
        templateUrl: 'detail.html',
        controller: 'RouteDetailCtl'
    })
    .otherwise({
      redirectTo: '/list'
    });
}]);
</code></pre>

<p>这里定义了两条路由规则，对应的视图模板分别为 list.html 和 detail.html</p>

<p>视图模板有三种定义方式：<br/>
方法1：编写在单独的文件中，然后 angularjs 通过 ajax 获取其内容；<br/>
方法2：直接在页面中使用 script 标签定义，如： <code>&lt;script type="text/ng-template" id="list.html"&gt; .... &lt;/script&gt;</code>；<br/>
方法3：使用 <code>$templateCache</code> 进行定义，如:<br/>
<code>
routeApp.run(function($templateCache) {
  $templateCache.put('list.html', '...');
});
</code></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[AngularJS学习笔记4——依赖注入]]></title>
    <link href="http://www.xefan.com/archives/84150.html"/>
    <updated>2015-08-19T13:33:33+08:00</updated>
    <id>http://www.xefan.com/archives/84150-AngularJS学习笔记4——依赖注入</id>
    <content type="html"><![CDATA[<h2>依赖注入</h2>

<p>之前有遇到过 angularjs 的代码压缩之后就报错了，通过查文档得知是因为 angularjs 是通过变量名来查找相应服务的。
而 js 代码压缩之后变量名就变化了，从而无法找到相应的服务而报错。因此就需要指明依赖服务。</p>

<pre><code>function SomeController($scope, $http) { ... }
</code></pre>

<p>例如以上代码就是定义了 <code>SomeController</code> 这个一个控制器，并依赖 <code>$scope</code> 和 <code>$http</code> 两个服务。
但是当该代码压缩之后，这两个参数名都变化了。因此还需要使用以下代码来指明所需的依赖。</p>

<pre><code>SomeController.$inject = ['$scope', '$http'];
</code></pre>

<p>或者另一个写法：</p>

<pre><code>angular.module('app', [])
       .controller('SomeController', ['$scope', '$http', function($scope, $http){

}]);
</code></pre>

<p>这样就可以保证我们的代码压缩之后也能正常运行了。</p>

<h2>自定义服务</h2>

<p>上面的 <code>$http</code> 服务为我们提供了 ajax 的功能。</p>

<p>需要自定义服务的可以使用 <code>module.factory</code> 方法或者 <code>module.service</code> 方法进行注册服务。
这两个方法稍微有些不同，一般我习惯使用 <code>module.factory</code> 。
然后在需要使用自定义服务的地方，将其添加到依赖列表中即可。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[AngularJS学习笔记3——表单]]></title>
    <link href="http://www.xefan.com/archives/84149.html"/>
    <updated>2015-08-18T18:32:35+08:00</updated>
    <id>http://www.xefan.com/archives/84149-AngularJS学习笔记3——表单</id>
    <content type="html"><![CDATA[<h2>双向绑定</h2>

<p>使用 <code>ngModel</code> 指令将输入框与 model 进行绑定，如： <code>&lt;input type="text" ng-model="text" name="text" /&gt;</code><br/>
当输入框或者 model 的值其中一方改变都会影响另一方。</p>

<h2>表单验证</h2>

<p>之前表单验证都是用的 jquery-validation 这个插件，这需要编写大量的 js 代码用于逻辑控制，
现在改用 angularjs 之后方便了许多，不过还是要编写大量的视图代码。</p>

<p>一个简单的例子： <a href="https://github.com/wusuopu/angularjs-practice/blob/master/static/form/validate.html">https://github.com/wusuopu/angularjs-practice/blob/master/static/form/validate.html</a></p>

<pre><code>    &lt;form action="#" name="user_form" ng-submit="submitForm(user_form.$valid, $event)" novalidate&gt;

        &lt;div class="form-group" ng-class="{'has-error' : user_form.name.$invalid &amp;&amp; user_form.name.$dirty, 'has-success' : user_form.name.$valid}"&gt;
            &lt;label&gt;Name&lt;/label&gt;
            &lt;input type="text" name="name" class="form-control" ng-model="formData.name" required&gt;
            &lt;p ng-show="user_form.name.$invalid &amp;&amp; user_form.name.$dirty" class="help-block"&gt;You name is required.&lt;/p&gt;
        &lt;/div&gt;
    .....
    &lt;/form&gt;
</code></pre>

<p>首先为 form 表单设置 <code>name</code> 属性，并设置 <code>novalidate</code> 属性禁止浏览器使用 HTML5 自带的验证功能。
然后对于需要验证的字段添加相应的验证属性，angularjs 内建的验证规则如下：</p>

<ul>
<li>email</li>
<li>max</li>
<li>maxlength</li>
<li>min</li>
<li>minlength</li>
<li>number</li>
<li>pattern</li>
<li>required</li>
<li>url</li>
<li>date</li>
<li>datetimelocal</li>
<li>time</li>
<li>week</li>
<li>month</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[AngularJS学习笔记2——模板]]></title>
    <link href="http://www.xefan.com/archives/84148.html"/>
    <updated>2015-08-14T22:00:21+08:00</updated>
    <id>http://www.xefan.com/archives/84148-AngularJS学习笔记2——模板</id>
    <content type="html"><![CDATA[<h2>ngRepeat</h2>

<p>对于一些需要循环遍历的对象可以使用 <code>ngRepeat</code> 指令。 如：</p>

<pre><code>  &lt;li ng-repeat="msg in messages"&gt; &lt;/li&gt;

  // 对于 messages 数组进行遍历
  $scope.messages =  [
    "第一条消息",
    "第二条消息",
    "第三条消息",
    "第四条消息",
    "第五条消息"
  ];
</code></pre>

<h2>ngSwitch</h2>

<p>使用 <code>ngSwitch</code> 指令在不同条件下显示不同内容。</p>

<p>&#8220;`</p>

<div ng-controller="ExampleController">
  <select ng-model="selection" ng-options="item for item in items">
  </select>
  <code>selection=</code>
  <hr/>
  <div class="animate-switch-container"
    ng-switch="selection">
      <div class="animate-switch" ng-switch-when="settings">Settings Div</div>
      <div class="animate-switch" ng-switch-when="home">Home Span</div>
      <div class="animate-switch" ng-switch-default>default</div>
  </div>
</div>




<script type="text/javascript">
angular.module('myApp', []).controller('ExampleController', ['$scope', function($scope) {
  $scope.items = ['settings', 'home', 'other'];
  $scope.selection = $scope.items[0];
}]);
</script>


<p>&#8220;`</p>

<h2>Filter</h2>

<p>使用 <code>filter</code> 指令过滤需要的内容，基本形式： <code></code>
如果有用过其他模板引擎的话（如：Jinja）应该很好理解的。</p>

<p>angularjs 提供了一些内置的过滤器：date, json, lowercase, uppercase 等。</p>

<h2>ngIf</h2>

<p>基本形式： <code>&lt;ANY ng-if="expression"&gt; ... &lt;/ANY&gt;</code>
当 <code>expression</code> 的值为真时才会输出该标签。</p>
]]></content>
  </entry>
  
</feed>
