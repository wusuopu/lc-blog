<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Tag: 翻译 | 龍昌博客]]></title>
  <link href="http://www.xefan.com/tags/翻译/atom.xml" rel="self"/>
  <link href="http://www.xefan.com/"/>
  <updated>2016-06-26T14:00:18+08:00</updated>
  <id>http://www.xefan.com/</id>
  <author>
    <name><![CDATA[龍昌]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[在Ruby中使用DATA和__END__将代码和数据混合]]></title>
    <link href="http://www.xefan.com/archives/84154.html"/>
    <updated>2015-08-23T10:12:08+08:00</updated>
    <id>http://www.xefan.com/archives/84154-在Ruby中使用DATA和__END__将代码和数据混合</id>
    <content type="html"><![CDATA[<p>之前一直不理解 <code>__END__</code> 的用法，现在看了这篇文章后才算是了解了，于是便翻译之。<br/>
《Mixing code and data in Ruby with DATA and __END__》: <a href="http://blog.honeybadger.io/data-and-end-in-ruby/">http://blog.honeybadger.io/data-and-end-in-ruby/</a></p>

<hr />

<p>你知道 Ruby 提供了一种方法在你的脚本中可以将源文件作为数据源来使用吗？当你在写一些一次性的脚本用于验证概念时这个小技巧会为你节约一些时间。让我们来看看吧。</p>

<h2>DATA 和 __END__</h2>

<p>在下面这个例子中，我使用了一个有趣的关键字 <code>__END__</code>。所有在 <code>__END__</code> 下面的内容将会被 Ruby 解释器所忽略。但是有趣的是 ruby 为你提供了一个称为 <code>DATA</code> 的 IO 对象，就像你可以读取其他任何文件一样，它能让你读取到 <code>__END__</code> 以下的所有内容。</p>

<p>下面这个例子中，我们遍历每一行并进行输出。</p>

<pre><code class="ruby">DATA.each_line do |line|
  puts line
end

__END__
Doom
Quake
Diablo
</code></pre>

<p>关于这个技术我最喜欢的实例是使用 <code>DATA</code> 来包含一个 ERB 模板。它同样也可用于 YAML、CSV等等。</p>

<pre><code class="ruby">require 'erb'

time = Time.now
renderer = ERB.new(DATA.read)
puts renderer.result()

__END__
The current time is &lt;%= time %&gt;.
</code></pre>

<p>实际上你也可以使用 <code>DATA</code> 来读取 <code>__END__</code> 关键字以上的内容。那是因为 <code>DATA</code> 实际上是一个指向了整个源文件，并定位到 <code>__END__</code> 关键字的位置。你可以试试看在输出之前将 IO 对象反转。下面这个例子将会输出整个源文件。</p>

<pre><code class="ruby">DATA.rewind
puts DATA.read # prints the entire source file

__END__
meh
</code></pre>

<h2>多文件问题</h2>

<p>这个技术最大的缺点是它只能用于单个文件的脚本，直接运行该文件，不能在其他文件进行导入。</p>

<p>下面这个例子，我们有两个文件，并且每个都有它们自己的 <code>__END__</code> 部分。然而却只有一个全局 <code>DATA</code> 对象。因此第二个文件的 <code>__END__</code> 部分刚访问不到了。</p>

<pre><code class="ruby"># first.rb
require "./second"

puts "First file\n----------------------"
puts DATA.read

print_second_data()

__END__
First end clause
</code></pre>

<pre><code class="ruby"># second.rb

def print_second_data
  puts "Second file\n----------------------"
  puts DATA.read # Won't output anything, since first.rb read the entire file
end

__END__

Second end clause
</code></pre>

<pre><code>snhorne ~/tmp $ ruby first.rb
First file
----------------------
First end clause

Second file
----------------------
</code></pre>

<h2>对于多文件的一个解决方案</h2>

<p>在 Sinatra 中有一个很酷的特性是它允许你在你应用的 <code>__END__</code> 部分添加多个内联模板。它看起来像下面这样：</p>

<pre><code class="ruby"># This code is from the Sinatra docs at http://www.sinatrarb.com/intro.html
require 'sinatra'

get '/' do
  haml :index
end

__END__

@@ layout
%html

  = yield

@@ index
%div.title Hello world.
</code></pre>

<p>sinatra 是如何实现的呢？毕竟你的应用可能是运行在 rack 上。在生产环境中你不能再通过 <code>ruby myapp.rb</code> 来运行！他们必须有一种在多文件中使用 <code>DATA</code> 的解决方案。</p>

<p>因此如果你稍微深入一下 Sinatra 的源代码，你会发现它们并没有使用 <code>DATA</code>。而是使用了跟下面这段代码类似的方案。</p>

<pre><code class="ruby"># I'm paraphrasing. See the original at https://github.com/sinatra/sinatra/blob/master/lib/sinatra/base.rb#L1284
app, data = File.read(__FILE__).split(/^__END__$/, 2)
</code></pre>

<p>实际上它比这个要更复杂一些，因为它们不想读取 <code>__FILE__</code>，它只是 <code>sinatra/base.rb</code> 文件。它们其实是需要获取调用了该方法的文件的内容。它们通过解析 <code>caller</code> 的结果来获取。</p>

<p><code>caller</code> 方法将会告诉你当前运行的方法是从哪调用的。这里是个简单的例子：</p>

<pre><code class="ruby">def some_method
  puts caller
end

some_method # =&gt; caller.rb:5:in `&lt;main&gt;'
</code></pre>

<p>现在可以简单地获取到文件名了，然后从该文件中再提取出与 <code>DATA</code> 等价的内容。</p>

<pre><code class="ruby">def get_caller_data
  puts File.read(caller.first.split(":").first).split("__END__", 2).last
end
</code></pre>

<h2>请善用它，不要作恶</h2>

<p>希望对于这些技巧你不要经常使用。它们不会使得代码干净、可维护。</p>

<p>然后，你偶尔需要一些又快又脏的实现一个一次性的脚本或者验证一些概念。此时 <code>DATA</code> 和 <code>__END__</code> 就非常有用了。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Unicorn是如何与nginx通讯的——介绍ruby中的unix Socket]]></title>
    <link href="http://www.xefan.com/archives/84146.html"/>
    <updated>2015-08-03T16:01:52+08:00</updated>
    <id>http://www.xefan.com/archives/84146-unicorn是如何与nginx通讯的——介绍ruby中的unix socket</id>
    <content type="html"><![CDATA[<p>Ruby 应用服务典型地是与一个 web 服务一同使用的，如 nginx。当用户请求你的 Rails 应用中的页面时，nginx 将请求指派给应用服务。
然而这个过程是如何完成的呢？nginx 与 unicorn 是如何通讯的呢？</p>

<p>最有效的一种选择是使用 unix 套接字(sockets)。让我们来看看它们是如何工作的！
在这篇文章中我们将从一个基本的套接字(sockets)开始，最后将创建一个使用 nginx 代理的简单应用服务。</p>

<p><img src="/wp-content/uploads/2015/07/socket.png" alt="socket" /></p>

<p><em>套接字(sockets)允许进程之间通过对一个文件读或者写进行相互通讯。</em>
<em>在这个例子中 Unicorn 创建 socket 并监听它的连接。然后 Nginx 就可以连接到这个 socket 并与 Unicorn 通讯了。</em></p>

<h2>什么是 unix socket？</h2>

<p>Unix socket 使得一个进程通过类似文件的方式与另一个进程进行通讯。它是 IPC(Interprocess Communication) 的一种。</p>

<p>要使得可以通过 socket 访问进程，首先需要创建一个 socket 并作为一个文件保存在磁盘中。
然后监听这个 socket 的连入连接。当接收到一个连接时，就可以使用<a href="http://ruby-doc.org/core-2.2.2/IO.html#method-i-readline">标准 IO 方法</a>进行读写数据。</p>

<p>Ruby 通过以下一组类提供了 unix socket 所需的所有内容：</p>

<ul>
<li>UNIXServer - 创建 socket 并保存到磁盘中，并且让你可以监听新连接。</li>
<li>UNIXSocket - 打开已存在的套接字(sockets)。</li>
</ul>


<p><strong>注意：</strong>还存在着其它类型的 socket，最突出的是 TCP socket。不过这篇文章只处理 unix socket。那么它们之间的区别是什么呢？unix  socket 具有文件名。</p>

<h2>最简单的 Socket</h2>

<p>我们接下来看两个小程序。</p>

<p>第一个是服务端，它创建一个 <code>UnixServer</code> 实例，然后使用 <code>server.accept</code> 等待连接。当收到连接后则相互问候。</p>

<p>需要说明一下，<code>accept</code> 和 <code>readline</code> 方法都会阻塞程序的执行，直到收到内容。</p>

<pre><code class="ruby">require "socket"

server = UNIXServer.new('/tmp/simple.sock')

puts "==== Waiting for connection"
socket = server.accept

puts "==== Got Request:"
puts socket.readline

puts "==== Sending Response"
socket.write("I read you loud and clear, good buddy!")

socket.close
</code></pre>

<p>这里我们有了服务端，现在还需要客户端。</p>

<p>在下面这个例子中，我们打开由服务端创建的 socket，然后使用普通的 IO 方法进行发送和接收问候。</p>

<pre><code class="ruby">require "socket"

socket = UNIXSocket.new('/tmp/simple.sock')

puts "==== Sending"
socket.write("Hello server, can you hear me?\n")

puts "==== Getting Response"
puts socket.readline

socket.close
</code></pre>

<p>演示一下程序，先运行服务端，然后再运行客户端。你可以看到以下结果：</p>

<p><img src="/wp-content/uploads/2015/07/simple_ruby_socket_example.png" alt="simple_ruby_socket_example" />
<em>简单的 Unix socket 服务端/客户端交互的例子。左边是客户端，右边是服务端。</em></p>

<h2>与 nginx 接合</h2>

<p>现在我们知道如何创建一个 unix socket 的服务端了，我们可以很容易地与 nginx 接合。</p>

<p>不相信我？让我们来做一个快速的概念验证吧。我修改上面的代码使其输出从 socket 接收到的所有内容。</p>

<pre><code class="ruby">require "socket"

# Create the socket and "save it" to the file system
server = UNIXServer.new('/tmp/socktest.sock')

# Wait until for a connection (by nginx)
socket = server.accept

# Read everything from the socket
while line = socket.readline
  puts line.inspect
end

socket.close
</code></pre>

<p>现在如果我修改 nginx 配置，将请求转发到 <code>/tmp/socktest.sock</code> socket 上。
我就能看到 nginx 发送来的数据了。(别担心，我们稍后会讨论它的配置的)</p>

<p>当我发起一个 web 请求时，nginx 将如下数据发送到我的服务端上：</p>

<p><img src="/wp-content/uploads/2015/07/request_http.png" alt="request_http" /></p>

<p>太酷了！这就是一个包含了额外头信息的 HTTP 请求。现在我们准备来构建一个真正的应用服务。
但是，首先让我们讨论一个 nginx 的配置吧。</p>

<h2>安装配置 Nginx</h2>

<p>如果你还没有安装 nginx 的话，请先安装。对于 OSX 可以 homebrew 简单完成：</p>

<pre><code>brew install nginx
</code></pre>

<p>现在我们配置 nginx 将 localhost:2048 的请求通过名为 <code>/tmp/socktest.sock</code> 的 socket 转发到上游服务端。
名字可以是任意的，它仅需要与我们 web 服务的 socket 名字匹配即可。</p>

<p>你可以将其保存至 <code>/tmp/nginx.conf</code> 并通过命令 <code>nginx -c /tmp/nginx.conf</code> 运行 nginx。</p>

<pre><code># Run nginx as a normal console program, not as a daemon
daemon off;

# Log errors to stdout
error_log /dev/stdout info;

events {} # Boilerplate

http {

  # Print the access log to stdout
  access_log /dev/stdout;

  # Tell nginx that there's an external server called @app living at our socket
  upstream app {
    server unix:/tmp/socktest.sock fail_timeout=0;
  }

  server {

    # Accept connections on localhost:2048
    listen 2048;
    server_name localhost;

    # Application root
    root /tmp;

    # If a path doesn't exist on disk, forward the request to @app
    try_files $uri/index.html $uri @app;

    # Set some configuration options on requests forwarded to @app
    location @app {
      proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
      proxy_set_header Host $http_host;
      proxy_redirect off;
      proxy_pass http://app;
    }

  }
}
</code></pre>

<p>以非后台模式运行 nginx。当你运行 nginx 时它应该看起来像如下这样：</p>

<p><img src="/wp-content/uploads/2015/07/nginx_non_daemon.png" alt="nginx_non_daemon" />
<em>Nginx 以非后台模式运行</em></p>

<h2>自定义应用服务</h2>

<p>既然我们已经知道了如何将 nginx 与我们程序进行连接，那么我们就来构建一个简单的应用服务。
当 nginx 将请求转发到我们的 socket 时，它是一个标准的 HTTP 请求。
经过一些处理后我可以决定 socket 是否会返回一个有效的 HTTP 响应，它会在浏览器中显示。</p>

<p>下面这个应用接受任何请求并显示时间戳。</p>

<pre><code class="ruby">require "socket"

# Connection creates the socket and accepts new connections
class Connection

  attr_accessor :path

  def initialize(path:)
    @path = path
    File.unlink(path) if File.exists?(path)
  end

  def server
    @server ||= UNIXServer.new(@path)
  end

  def on_request
    socket = server.accept
    yield(socket)
    socket.close
  end
end


# AppServer logs incoming requests and renders a view in response
class AppServer

  attr_reader :connection
  attr_reader :view

  def initialize(connection:, view:)
    @connection = connection
    @view = view
  end

  def run
    while true
      connection.on_request do |socket|
        while (line = socket.readline) != "\r\n"
          puts line
        end
        socket.write(view.render)
      end
    end
  end

end

# TimeView simply provides the HTTP response
class TimeView
  def render
%[HTTP/1.1 200 OK


The current timestamp is: #{ Time.now.to_i }

]
  end
end


AppServer.new(connection: Connection.new(path: '/tmp/socktest.sock'), view: TimeView.new).run
</code></pre>

<p>现在运行 nginx 和脚本，然后访问 localhost:2048。请求会发送到我的应用上，然后响应被浏览器渲染。太酷了！</p>

<p><img src="/wp-content/uploads/2015/07/appserver.png" alt="appserver" />
<em>HTTP 请求信息由我们的应用服务输出到 STDOUT</em></p>

<p>以下就是我们的劳动成果。</p>

<p><img src="/wp-content/uploads/2015/07/timestamp.png" alt="timestamp" />
<em>浏览器中显示服务端返回的时间戳</em></p>

<p>原文地址： <a href="http://blog.honeybadger.io/how-unicorn-talks-to-nginx-an-introduction-to-unix-sockets-in-ruby/">http://blog.honeybadger.io/how-unicorn-talks-to-nginx-an-introduction-to-unix-sockets-in-ruby/</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Ruby的内存陷阱]]></title>
    <link href="http://www.xefan.com/archives/84145.html"/>
    <updated>2015-05-14T21:24:21+08:00</updated>
    <id>http://www.xefan.com/archives/84145-Ruby的内存陷阱</id>
    <content type="html"><![CDATA[<p>Ruby有一套自动的内存管理机制。这在大多数情况下是不错的，但是有时它却是个麻烦。</p>

<p>Ruby的内存管理既简洁又笨重。它将对象（名为 <code>RVALUE</code>）存储在大约有16KB大小的堆中。
从底层上，<code>RVALUE</code> 是一个 <code>C</code> 的结构体，它包含了一个共同体表示不同的标准ruby对象。</p>

<p>因此在堆中存储着大小不超过40字节的 <code>RVALUE</code> 对象，如 <code>String</code>、<code>Array</code>、<code>Hash</code>等。
这意味着小的对象在堆中很合适，但是一旦它们达到到阈值，那么就需要在Ruby的堆之外再分配一片额外的内存。</p>

<p><strong>这块额外的内存空间是灵活的。一旦对象被垃圾回收了它就会被释放掉。但是堆本身的内存是不会被释放给操作系统的。</strong></p>

<p>让我们来看一个简单的例子：</p>

<pre><code class="ruby">def report
  puts 'Memory ' + `ps ax -o pid,rss | grep -E "^[[:space:]]*#{$$}"`
          .strip.split.map(&amp;:to_i)[1].to_s + 'KB'
end

report
big_var = " " * 10_000_000
report
big_var = nil
report
ObjectSpace.garbage_collect
sleep 1
report

# ⇒ Memory 11788KB
# ⇒ Memory 65188KB
# ⇒ Memory 65188KB
# ⇒ Memory 11788KB
</code></pre>

<p>这里我们分配了大量的内存，使用完后又释放给操作系统。这一切看起来似乎没有问题。现在让我们稍微修改一下代码：</p>

<pre><code class="ruby">-  big_var = " " * 10_000_000
+  big_var = 1_000_000.times.map(&amp;:to_s)
</code></pre>

<p>这只是一个简单的修改，不是吗。但是结果：</p>

<pre><code># ⇒ Memory 11788KB
# ⇒ Memory 65188KB
# ⇒ Memory 65188KB
# ⇒ Memory 57448KB
</code></pre>

<p>怎么回事？内存没有释放归还给操作系统。这是因为数组中的每个元素符合 <code>RVALUE</code> 的大小并存储在ruby的堆中。</p>

<p>在大多情况下这是正常的。现在ruby堆中多了许多空的位置，再次运行代码将不会再消耗额外的内存了。
每次我们处理 <code>big_var</code> 和一些空的堆时， <code>GC[:heap_used]</code>的值果然减小了。
对于这些操作Ruby是早有准备，注意这里是Ruby而不是操作系统。</p>

<p>因此，对于创建大量的符合40个字节的临时变量就要注意了：</p>

<pre><code>big_var = " " * 10_000_000
big_var.gsub(/\s/) { |c| '-' }
</code></pre>

<p>结果同样是Ruby的内存疯狂增长，并且这部分内存在程序运行期间是不会归还给操作系统的：</p>

<pre><code># ⇒ Memory 10156KB
# ⇒ Memory 13788KB
# ⇒ Memory 13788KB
# ⇒ Memory 12808KB
</code></pre>

<p>这个问题不是太重要，稍微注意一下即可。</p>

<p>原文地址：<a href="http://rocket-science.ru/hacking/2013/12/17/ruby-memory-pitfalls/">http://rocket-science.ru/hacking/2013/12/17/ruby-memory-pitfalls/</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[翻译]Ruby GTK教程8——贪吃蛇]]></title>
    <link href="http://www.xefan.com/archives/83975.html"/>
    <updated>2013-11-25T00:00:00+08:00</updated>
    <id>http://www.xefan.com/archives/83975-[翻译]Ruby GTK教程8——贪吃蛇</id>
    <content type="html"><![CDATA[<h1>贪吃蛇</h1>


<p>在这部分的Ruby GTK编程教程中我们将创建一个贪吃蛇游戏。</p>


<p>贪吃蛇是一个比较老的经典电子游戏。它第一次创建是在70年代后期。之后被移植到PC上。在这个游戏中玩家控制蛇，目标是尽可能多的吃掉苹果。蛇每吃掉一个苹果，身体就会变长。必须避免蛇撞到墙或者自己的身体。</p>


<h2>开发</h2>


<p>蛇的每块关节的大小为10像素。使用方向键控制蛇。初始，蛇有三块关节。游戏立即开始。当游戏结束后在窗口中央显示&#8221;Game Over&#8221;。</p>


<p><em>board.rb</em></p>


<pre><code>WIDTH = 300
HEIGHT = 270
DOT_SIZE = 10
ALL_DOTS = WIDTH * HEIGHT / (DOT_SIZE * DOT_SIZE)
RAND_POS = 26

$x = [0] * ALL_DOTS
$y = [0] * ALL_DOTS

class Board &lt; Gtk::DrawingArea

    def initialize
        super

        modify_bg Gtk::STATE_NORMAL, Gdk::Color.new(0, 0, 0)

        signal_connect "expose-event" do  
            on_expose
        end

        init_game
    end

    def on_timer

        if @inGame
            check_apple
            check_collision
            move
            queue_draw
            return true
        else
            return false
        end
    end

    def init_game

        @left = false
        @right = true
        @up = false
        @down = false
        @inGame = true
        @dots = 3

        for i in (0..@dots)
            $x[i] = 50 - i * 10
            $y[i] = 50
        end

        begin
            @dot = Cairo::ImageSurface.from_png "dot.png"
            @head = Cairo::ImageSurface.from_png "head.png"
            @apple = Cairo::ImageSurface.from_png "apple.png"
        rescue Exception =&gt; e
            puts "cannot load images"
            exit
        end

        locate_apple
        GLib::Timeout.add(100) { on_timer }

     end


    def on_expose

        cr = window.create_cairo_context

        if @inGame
            draw_objects cr
        else
            game_over cr
        end      
    end

    def draw_objects cr

        cr.set_source_rgb 0, 0, 0
        cr.paint

        cr.set_source @apple, @apple_x, @apple_y
        cr.paint

        for z in (0..@dots)
            if z == 0 
                cr.set_source @head, $x[z], $y[z]
                cr.paint
            else
                cr.set_source @dot, $x[z], $y[z]
                cr.paint
            end    
        end
    end

    def game_over cr

        w = allocation.width / 2
        h = allocation.height / 2

        cr.set_font_size 15
        te = cr.text_extents "Game Over"

        cr.set_source_rgb 65535, 65535, 65535

        cr.move_to w - te.width/2, h
        cr.show_text "Game Over"

    end


    def check_apple

        if $x[0] == @apple_x and $y[0] == @apple_y 
            @dots = @dots + 1
            locate_apple
        end
    end

    def move

        z = @dots

        while z &gt; 0
            $x[z] = $x[(z - 1)]
            $y[z] = $y[(z - 1)]
            z = z - 1
        end

        if @left
            $x[0] -= DOT_SIZE
        end

        if @right 
            $x[0] += DOT_SIZE
        end

        if @up
            $y[0] -= DOT_SIZE
        end

        if @down
            $y[0] += DOT_SIZE
        end

     end

    def check_collision

        z = @dots

        while z &gt; 0
            if z &gt; 4 and $x[0] == $x[z] and $y[0] == $y[z]
                @inGame = false
            end
            z = z - 1
        end

        if $y[0] &gt; HEIGHT - DOT_SIZE
            @inGame = false
        end

        if $y[0] &lt; 0
            @inGame = false
        end

        if $x[0] &gt; WIDTH - DOT_SIZE
            @inGame = false
        end

        if $x[0] &lt; 0
            @inGame = false
        end

    end

    def locate_apple

        r = rand(RAND_POS)
        @apple_x = r * DOT_SIZE
        r = rand(RAND_POS)
        @apple_y = r * DOT_SIZE
    end

    def on_key_down event

        key = event.keyval

        if key == Gdk::Keyval::GDK_Left and not @right
            @left = true
            @up = false
            @down = false
        end

        if key == Gdk::Keyval::GDK_Right and not @left
            @right = true
            @up = false
            @down = false
        end

        if key == Gdk::Keyval::GDK_Up and not @down
            @up = true
            @right = false
            @left = false
        end

        if key == Gdk::Keyval::GDK_Down and not @up
            @down = true
            @right = false
            @left = false
        end
    end   
end
</code></pre>


<p>首先我们定义一些全局变量。</p>


<p>WIDTH和HEIGHT常量决定了甲板的大小。DOT_SIZE是苹果和蛇的每个点的大小。ALL_DOTS常量定义了甲板可能包含的最大的点数量。RAND_POS常量用于计算苹果的随机位置。DELAY常量决定游戏速度。</p>


<pre><code>$x = [0] * ALL_DOTS
$y = [0] * ALL_DOTS
</code></pre>


<p>这两个数组存储了蛇所有关节的x、y坐标。</p>


<p><em>init_game</em>方法初始化变量、加载图片和启动timeout函数。</p>


<pre><code>if @inGame
    draw_objects cr
else
    game_over cr
end
</code></pre>


<p>在<em>on_expose_method</em>方法里我们检查<em>@inGame</em>变量。如果为true，绘制苹果和蛇。否则显示&#8221;Game over&#8221;文字。</p>


<pre><code>def draw_objects cr

    cr.set_source_rgb 0, 0, 0
    cr.paint

    cr.set_source @apple, @apple_x, @apple_y
    cr.paint

    for z in (0..@dots)
        if z == 0 
            cr.set_source @head, $x[z], $y[z]
            cr.paint
        else
            cr.set_source @dot, $x[z], $y[z]
            cr.paint
        end    
    end
end
</code></pre>


<p><em>draw_objects</em>方法绘制苹果和蛇。蛇的头部用红色的圆表示。</p>


<pre><code>def check_apple

    if $x[0] == @apple_x and $y[0] == @apple_y 
        @dots = @dots + 1
        locate_apple
    end
end
</code></pre>


<p><em>check_apple</em>方法查检蛇是否碰到苹果，如果是则增加蛇的关节并调用<em>locate_apple</em>方法随机放置一个新的苹果。</p>


<p><em>move</em>方法是游戏的关键算法。为了理解它，先看一下蛇是如何移动的。控制蛇头，可以使用方向键改变它的方向。其余的关节朝该方向前进。第二个关节移到到第一关节的位置，第三个关节到第二个等等。</p>


<pre><code>while z &gt; 0
    $x[z] = $x[(z - 1)]
    $y[z] = $y[(z - 1)]
    z = z - 1
end
</code></pre>


<p>这些代码将关节按照链状前进。</p>


<pre><code>if @left
    $x[0] -= DOT_SIZE
end
</code></pre>


<p>头部向左移动。</p>


<p><em>check_collision</em>方法中，我们检查蛇是否撞到了自己或者墙。</p>


<pre><code>while z &gt; 0
    if z &gt; 4 and $x[0] == $x[z] and $y[0] == $y[z]
        @inGame = false
    end
    z = z - 1
end
</code></pre>


<p>如果蛇撞到了自己，游戏结束。</p>


<pre><code>if $y[0] &gt; HEIGHT - DOT_SIZE
    @inGame = false
end
</code></pre>


<p>如果蛇撞到底部，游戏结束。</p>


<p><em>localte_apple</em>方法在甲板上随机定位一个苹果。</p>


<pre><code>r = rand(RAND_POS)
</code></pre>


<p>获取0到RAND_POS-1的一个随机数。</p>


<pre><code>@apple_x = r * DOT_SIZE
...
@apple_y = r * DOT_SIZE
</code></pre>


<p>这几行设置了苹果的x、y坐标。</p>


<pre><code>if @inGame
    check_apple
    check_collision
    move
    queue_draw
    return true
else
    return false
end
</code></pre>


<p>第140ms调用一次<em>on_timer</em>方法。如果游戏运行则调用三个组成游戏逻辑的方法。否则返回false，停止定时事件。</p>


<p>在Board类的<em>on_key_down</em>方法中我们判断按下的键。</p>


<pre><code>if key == Gdk::Keyval::GDK_Left and not @right
    @left = true
    @up = false
    @down = false
end
</code></pre>


<p>如果我们按的是左方向键，我们设置<em>left</em>变量为true。这个变量用于<em>move</em>方法改变蛇的坐标。同样注意，当蛇是朝右时，我们不能立即朝左。</p>


<p><em>nibbles.rb</em></p>


<pre><code>#!/usr/bin/ruby

# ZetCode Ruby GTK tutorial
#
# This is a simple nibbles game
# clone
#
# author: jan bodnar
# website: www.zetcode.com
# last modified: June 2009

require 'gtk2'
require 'board'

class RubyApp &gt; Gtk::Window
    def initialize
        super

        set_title "Nibbles"
        signal_connect "destroy" do 
            Gtk.main_quit 
        end

        @board = Board.new
        signal_connect "key-press-event" do |w, e|
            on_key_down(w, e)
        end

        add @board

        set_default_size 300, 270
        set_window_position Gtk::Window::POS_CENTER
        show_all
    end

    def on_key_down widget, event

        key = event.keyval
        @board.on_key_down event
    end
end

Gtk.init
    window = RubyApp.new
Gtk.main
</code></pre>


<p>在这个类我们启动了贪吃游戏。</p>


<pre><code>def on_key_down widget, event

    key = event.keyval
    @board.on_key_down event
end
</code></pre>


<p>在这个类的捕获按键事件然后委托Board类的<em>on_key_down method</em>方法进行处理。</p>


<p><img alt="image" src="http://zetcode.com/img/gui/rubygtk/nibbles.png"><br>
<em>图片：贪吃蛇</em></p>


<p>这是使用Ruby语言和GTK库编写的贪吃蛇计算机游戏。</p>


<hr>


<p>原文地址： <a href="http://zetcode.com/gui/rubygtk/nibbles/">http://zetcode.com/gui/rubygtk/nibbles/</a><br>
翻译：龙昌  admin@longchangjin.cn </p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[翻译]Ruby GTK教程7——自定义控件]]></title>
    <link href="http://www.xefan.com/archives/83972.html"/>
    <updated>2013-11-24T00:00:00+08:00</updated>
    <id>http://www.xefan.com/archives/83972-[翻译]Ruby GTK教程7——自定义控件</id>
    <content type="html"><![CDATA[<h1>自定义控件</h1>


<p>大多数套件通常只提供了最常用的控件，如按钮、文本控件、滑动条等。没有套件可以提供所有可能的控件。程序员必须自己创建这些。这是通过套件提供的绘制工具完成。这有两种可能。程序员可以修改或增强已存在的控件，或者从头开始创建一个自定义控件。</p>


<h2>Burning控件</h2>


<p>这个例子我们从头开始创建一个控件。这个控件可以在各种媒体烧定应用中看到，如Nero Burning ROM。</p>


<p><em>custom.rb</em></p>


<pre><code>#!/usr/bin/ruby

# ZetCode Ruby GTK tutorial 
#
# This example creates a burning
# custom widget
#
# author: jan bodnar
# website: zetcode.com 
# last edited: June 2009


require 'gtk2'

class Burning &lt; Gtk::DrawingArea

    def initialize(parent)
        @parent = parent

        super()

        @num = [ "75", "150", "225", "300", 
            "375", "450", "525", "600", "675" ]

        set_size_request 1, 30
        signal_connect "expose-event" do
            expose
        end
    end


    def expose

        cr = window.create_cairo_context
        draw_widget cr

    end

    def draw_widget cr

         cr.set_line_width 0.8

        cr.select_font_face("Courier", 
            Cairo::FONT_SLANT_NORMAL, Cairo::FONT_WEIGHT_NORMAL)
        cr.set_font_size 11

        width = allocation.width

        @cur_width = @parent.get_cur_value

        step = (width / 10.0).round

        till = (width / 750.0) * @cur_width
        full = (width / 750.0) * 700

        if @cur_width &gt;= 700

            cr.set_source_rgb(1.0, 1.0, 0.72)
            cr.rectangle(0, 0, full, 30)
            cr.clip
            cr.paint
            cr.reset_clip

            cr.set_source_rgb(1.0, 0.68, 0.68)
            cr.rectangle(full, 0, till-full, 30)
            cr.clip
            cr.paint
            cr.reset_clip

        else
            cr.set_source_rgb 1.0, 1.0, 0.72
            cr.rectangle 0, 0, till, 30
            cr.clip
            cr.paint
            cr.reset_clip
        end


        cr.set_source_rgb(0.35, 0.31, 0.24)

        for i in (1..@num.length)
            cr.move_to i*step, 0
            cr.line_to i*step, 5
            cr.stroke

            te = cr.text_extents @num[i-1]
            cr.move_to i*step-te.width/2, 15
            cr.text_path @num[i-1]
            cr.stroke
        end         
    end
end


class RubyApp &lt; Gtk::Window
    def initialize
        super

        set_title "Burning"
        signal_connect "destroy" do 
            Gtk.main_quit 
        end

        set_size_request 350, 200        
        set_window_position Gtk::Window::POS_CENTER

        @cur_value = 0

        vbox = Gtk::VBox.new false, 2

        scale = Gtk::HScale.new
        scale.set_range 0, 750
        scale.set_digits 0
        scale.set_size_request 160, 35
        scale.set_value @cur_value

        scale.signal_connect "value-changed" do |w|
            on_changed(w)
        end

        fix = Gtk::Fixed.new
        fix.put scale, 50, 50

        vbox.pack_start fix

        @burning = Burning.new(self)
        vbox.pack_start @burning, false, false, 0

        add vbox
        show_all
    end

    def on_changed widget

        @cur_value = widget.value
        @burning.queue_draw
    end

    def get_cur_value
        return @cur_value
    end
end

Gtk.init
    window = RubyApp.new
Gtk.main
</code></pre>


<p>我们将DrawingArea放在窗口的底部，并且手动绘制控件的条目。所有的重要代码放在draw_widget里，通过Burning类的expose方法调用。这个控件生动的显示了媒介的容量和剩余空间。这个控件通过刻度控件来控制。我们自定义控件的最小值为0,最大值为750。如果达到700，我们开始绘制红色。这通常表明超标了。</p>


<pre><code>@num = [ "75", "150", "225", "300", 
    "375", "450", "525", "600", "675" ]
</code></pre>


<p>这些数字显示在控件上。他们显示了媒介的容量。</p>


<pre><code>@cur_width = @parent.get_cur_value
</code></pre>


<p>通过父控件我们获得刻度控件的值。</p>


<pre><code>till = (width / 750.0) * @cur_width
full = (width / 750.0) * 700
</code></pre>


<p>我们使用width变量进行刻度值和自定义控件尺寸的转换。注意我们使用了浮点数，得到较大精度的绘制。<em>till</em>参数决定了绘制的总大小，它的值来自刻度控件。它是整个区域的比例。<em>full</em>参数决定了从什么位置开始绘制红色。</p>


<pre><code>cr.set_source_rgb(1.0, 1.0, 0.72)
cr.rectangle(0, 0, full, 30)
cr.clip
cr.paint
cr.reset_clip
</code></pre>


<p>绘制黄色矩形直到<em>full</em>点。</p>


<pre><code>te = cr.text_extents @num[i-1]
cr.move_to i*step-te.width/2, 15
cr.text_path @num[i-1]
cr.stroke
</code></pre>


<p>这些代码绘制了burning控件的数字。我们计算了文本恰当的位置。</p>


<pre><code>def on_changed widget

    @cur_value = widget.value
    @burning.queue_draw
end
</code></pre>


<p>我们获取刻度控件的值保存在<em>cur_value</em>变量中，稍后使用。重绘burning控件。</p>


<p><img alt="image" src="http://zetcode.com/img/gui/rubygtk/burning.png"><br>
<em>图片：Burning widget</em></p>


<p>在这一章中，我们创建了一个自定义控件。</p>


<hr>


<p>原文地址： <a href="http://zetcode.com/gui/rubygtk/customwidget/">http://zetcode.com/gui/rubygtk/customwidget/</a><br>
翻译：龙昌  admin@longchangjin.cn </p>

]]></content>
  </entry>
  
</feed>
