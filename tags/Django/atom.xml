<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Tag: Django | 龍昌博客]]></title>
  <link href="http://www.xefan.com/tags/Django/atom.xml" rel="self"/>
  <link href="http://www.xefan.com/"/>
  <updated>2014-11-11T21:21:26+08:00</updated>
  <id>http://www.xefan.com/</id>
  <author>
    <name><![CDATA[龍昌]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Nginx + Uwsgi + Django环境配置]]></title>
    <link href="http://www.xefan.com/archives/84135.html"/>
    <updated>2014-11-11T21:02:17+08:00</updated>
    <id>http://www.xefan.com/archives/84135-Nginx+uwsgi+Django环境配置</id>
    <content type="html"><![CDATA[<p>有段时间没折腾 Django 了，又有点生疏了。最近又部署了一下 Django 的环境，顺便作个笔记以便之后查阅。</p>

<p>首先安装 nginx、uwsgi 以及 uwsgi 的 python 插件。</p>

<p>然后新建一个 uwsgi 的配置文件：</p>

<pre><code>[uwsgi]
uid = www-data
chdir = /repo/django-blog
virtualenv = /repo/django-blog/pyenv2.7/    # python虚拟环境，没有可以不设置
env = DJANGO_SETTINGS_MODULE=blog.settings
module = blog.wsgi:application
master = true
plugin = python
pidfile = /tmp/blog-master.pid
socket = /tmp/blog.sock
enable-threads = true
post-buffering=1024000
post-buffering-busize=655360
</code></pre>

<p>这里我们的 Django 项目代码位于 <code>/repo/django-blog</code> ，项目的配置文件为： <code>blog/settings.py</code> 。</p>

<p><code>virtualenv</code> 项表明我们使用的是 <code>virtualenv</code> 环境，也可以直接系统的 python 环境。不过还是建议使用虚拟环境，以免软件包版本冲突。</p>

<p><code>post-buffering</code> 和 <code>post-buffering-busize</code> 这两项设置了 POST 请求时缓冲区的大小，该值可根据自己的情况进行调整。之前遇到过由于缓冲区不足导致返回的内容不完整。</p>

<p>再安装对应的 python 依赖包，然后运行 uwsgi 服务。</p>

<p>接着修改 nginx 的配置：</p>

<pre><code>server {
  listen 80;
  server_name localhost;

  client_max_body_size 50m;

  access_log /var/log/nginx/blog-access.log;
  error_log /var/log/nginx/blog-error.log;

  location / {
    uwsgi_pass unix:///tmp/blog.sock;
    include uwsgi_params;
  }

  location /static {
    alias /repo/django-blog/static/;
  }
}
</code></pre>

<p>这个内容比较简单， <code>client_max_body_size</code> 项是用于设置 http 请求的 body 最大大小。如果你的程序中有文件上传的，那么就需要根据自身情况来设置允许上传文件的最大值。</p>

<p>最后再启动 nginx 服务。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Scrapy框架学习笔记2—— Scrapy与Django结合]]></title>
    <link href="http://www.xefan.com/archives/83887.html"/>
    <updated>2013-10-07T00:00:00+08:00</updated>
    <id>http://www.xefan.com/archives/83887-Scrapy框架学习笔记2—— Scrapy与Django结合</id>
    <content type="html"><![CDATA[<p>前面也介绍过了Scrapy与Django的设计思想非常相似，因此这个两个结合也是比较容易的。<br/>
以下方法在Scrapy 0.18与Django 1.5下面测试是可以用的。</p>

<h3>1.首先设置Django的运行环境</h3>


<p>在settings.py中添加如下代码：</p>

<pre><code class="python">def setup_django_environment(path):
    import imp, os, sys
    from django.core.management import setup_environ
    m = imp.load_module('settings', *imp.find_module('settings', [path]))
    setup_environ(m)
    sys.path.append(os.path.abspath(os.path.join(path, os.path.pardir)))

setup_django_environment("/django/project/path")
</code></pre>

<p>注意：如果你的Django项目是用的sqlite数据库的话，那就需要设置为绝对路径，不能使用相对路径。</p>

<h3>2.创建django item</h3>


<p>首先在Django项目代码中创建一个Django的model，例如:</p>

<pre><code class="python">from django.db import models
class ScrapyModel(models.Model):
    title = models.CharField(max_length=200)
    link = models.CharField(max_length=200)
    desc = models.TextField()
</code></pre>

<p>然后在Scrapy项目中创建一个新的Item，只不过这次我们不再是继承自scrapy.item.Item，而是scrapy.contrib.djangoitem.DjangoItem:</p>

<pre><code class="python">class Test1DjItem(DjangoItem):
    django_model = ScrapyModel
</code></pre>

<p>用法与原来的Item相同，只是最后要执行一个save函数来调用django的save方法将数据存入数据库。</p>
]]></content>
  </entry>
  
</feed>
