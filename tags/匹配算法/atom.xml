<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Tag: 匹配算法 | 龍昌博客]]></title>
  <link href="http://www.xefan.com/tags/匹配算法/atom.xml" rel="self"/>
  <link href="http://www.xefan.com/"/>
  <updated>2015-04-05T21:18:11+08:00</updated>
  <id>http://www.xefan.com/</id>
  <author>
    <name><![CDATA[龍昌]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Python中的字符串匹配算法分析]]></title>
    <link href="http://www.xefan.com/archives/83873.html"/>
    <updated>2013-07-14T00:00:00+08:00</updated>
    <id>http://www.xefan.com/archives/83873-Python中的字符串匹配算法分析</id>
    <content type="html"><![CDATA[<p>在Python在str对象的find、index、replace等操作都是基于字符串匹配的。通过阅读Python的源代码可知，在Python中的字符串匹配算法是基于Boyer-Moore、Horspool和Sunday的混合。</p>

<p>关于它的详细介绍可以访问这个网页： <a href="http://effbot.org/zone/stringlib.htm">http://effbot.org/zone/stringlib.htm</a></p>

<p>用Python代码实现如下：</p>

<pre><code class="python">#!/usr/bin/env python
#-*- coding:utf-8 -*-


def make_delta1(p):
    ALPHABET_LEN = 256
    i = 0
    patternlen = len(p)
    delta1 = [0] * ALPHABET_LEN

    while i &lt; ALPHABET_LEN:
        delta1[i] = patternlen
        i += 1

    i = 0
    while i &lt; patternlen-1:
        delta1[ord(p[i])] = patternlen-1 - i
        i += 1
    return delta1


def find(s, p):
    # find first occurrence of p in s
    n = len(s)
    m = len(p)
    delta1 = make_delta1(p)
    skip = delta1[ord(p[m-1])]
    i = 0
    while i &lt;= n-m:
        if s[i+m-1] == p[m-1]:  # (boyer-moore)
            # potential match
            if s[i:i+m-1] == p[:m-1]:
                return i
            if s[i+m] not in p:
                i = i + m + 1   # (sunday)
            else:
                i = i + skip    # (horspool)
        else:
            # skip
            if s[i+m] not in p:
                i = i + m + 1   # (sunday)
            else:
                i = i + 1
    return -1                   # not found

if __name__ == '__main__':
    print find("HERE IS A SILMPLE EXAMPLE", "EXAMPLE")
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[字符串匹配算法（五）——Horspool算法]]></title>
    <link href="http://www.xefan.com/archives/83871.html"/>
    <updated>2013-07-14T00:00:00+08:00</updated>
    <id>http://www.xefan.com/archives/83871-字符串匹配算法（五）——Horspool算法</id>
    <content type="html"><![CDATA[<p>Horspool算法是Boyer-Moore算法的一个简化版，全名叫做Boyer-Moore-Horspool算法。</p>

<p>Horspool算法的基本思想是将文本串text中匹配窗口的最后一个字符跟模式串pattern中的最后一个字符比较。如果相等，继续从后向前对主串和模式串进行比较，直到完全相等或者在某个字符处不匹配为止 。如果不匹配，则根据文本串匹配窗口中的最后一个字符β在模式串中的下一个出现位置将窗口向右移动；若字符β没有在模式串中出现，则直接将整个模式串滑过这一位。</p>

<p>同样的举个例子来说明一下。假定文本串text为：”HERE IS A SIMPLE EXAMPLE”，长度为n；模式串pattern为：”EXAMPLE”，长度为m；现在要在text中搜索看看是否包含pattern。</p>

<p>1).</p>

<pre>
HERE I<span style="color: #ff0000;">S</span> A SIMPLE EXAMPLE
EXAMPL<span style="color: #ff0000;">E</span>
</pre>


<p>&rsquo;S&#8217;与&#8217;E&#8217;匹配失败，并且&rsquo;S&#8217;没有在pattern中出现，所以直接将pattern滑过&rsquo;S&#8217;这一位。</p>

<p>2).</p>

<pre>
HERE IS A SIM<span style="color: #ff0000;">P</span>LE EXAMPLE
       EXAMPL<span style="color: #ff0000;">E</span>
</pre>


<p>这时&#8217;P&#8217;与&#8217;E&#8217;匹配失败，但是&#8217;P&#8217;在模式串pattern中出现了，所以把pattern向右移，使得text中的&#8217;P&#8217;与pattern中的&#8217;P&#8217;对齐。</p>

<p>3).</p>

<pre>
HERE IS A SIM<span style="color: #00ff00;">P</span>L<span style="color: #ff0000;">E</span> EXAMPLE
         EXAM<span style="color: #00ff00;">P</span>L<span style="color: #ff0000;">E</span>
</pre>


<p>然后重复执行之前的操作。</p>

<p>用C语言实现如下。</p>

<pre><code class="c">#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;limits.h&gt;

/* Returns a pointer to the first occurrence of "needle"
 * within "haystack", or NULL if not found. Works like
 * memmem().
 */

/* Note: In this example needle is a C string. The ending
 * 0x00 will be cut off, so you could call this example with
 * boyermoore_horspool_memmem(haystack, hlen, "abc", sizeof("abc"))
 */
const unsigned char *
boyermoore_horspool_memmem(const unsigned char* haystack, size_t hlen,
                           const unsigned char* needle,   size_t nlen)
{
    int index = 0;
    size_t scan = 0;
    size_t bad_char_skip[UCHAR_MAX + 1]; /* Officially called:
                                          * bad character shift */

    /* Sanity checks on the parameters */
    if (nlen &lt;= 0 || !haystack || !needle)
        return NULL;

    /* ---- Preprocess ---- */
    /* Initialize the table to default value */
    /* When a character is encountered that does not occur
     * in the needle, we can safely skip ahead for the whole
     * length of the needle.
     */
    for (scan = 0; scan &lt;= UCHAR_MAX; scan = scan + 1)
        bad_char_skip[scan] = nlen;

    /* C arrays have the first byte at [0], therefore:
     * [nlen - 1] is the last byte of the array. */
    size_t last = nlen - 1;

    /* Then populate it with the analysis of the needle */
    for (scan = 0; scan &lt; last; scan = scan + 1)
        bad_char_skip[needle[scan]] = last - scan;

    /* ---- Do the matching ---- */

    /* Search the haystack, while the needle can still be within it. */
    while (hlen &gt;= nlen)
    {
        /* scan from the end of the needle */
        for (scan = last; haystack[scan] == needle[scan]; scan = scan - 1)
            if (scan == 0) /* If the first byte matches, we've found it. */
            {
                printf("index: %d\n", index-1);
                return haystack;
            }

        /* otherwise, we need to skip some bytes and start again.
           Note that here we are getting the skip value based on the last byte
           of needle, no matter where we didn't match. So if needle is: "abcd"
           then we are skipping based on 'd' and that value will be 4, and
           for "abcdd" we again skip on 'd' but the value will be only 1.
           The alternative of pretending that the mismatched character was
           the last character is slower in the normal case (E.g. finding
           "abcd" in "...azcd..." gives 4 by using 'd' but only
           4-2==2 using 'z'. */
        hlen     -= bad_char_skip[haystack[last]];
        index += bad_char_skip[haystack[last]];
        haystack += bad_char_skip[haystack[last]];
    }

    return NULL;
}


int main(int argc, char *argv[])
{
    char text[] = "HERE IS A SILMPLE EXAMPLE";
    char pattern[] = "EXAMPLE";
    char *result = boyermoore_horspool_memmem(text, strlen(text), pattern, strlen(pattern));
    if (result)
    {
        printf("result: %s\n", result);
    } else {
        printf("failed!\n");
    }
    return 0;
}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[字符串匹配算法（四）——Boyer-Moore算法]]></title>
    <link href="http://www.xefan.com/archives/83866.html"/>
    <updated>2013-07-14T00:00:00+08:00</updated>
    <id>http://www.xefan.com/archives/83866-字符串匹配算法（四）——Boyer-Moore算法</id>
    <content type="html"><![CDATA[<p>1977年，德克萨斯大学的Robert S. Boyer教授和J Strother Moore教授提出了另一种在O(n)时间复杂度内，完成字符串匹配的算法，其在绝大多数场合的性能表现，比KMP算法还要出色。</p>

<p>Boyer-Moore算法不仅高效，而且构思巧妙，文本编辑器的”查找”功能（Ctrl+F），大多采用的是该算法。</p>

<p>Boyer-Moore算法基本原理是从右向左扫描pattern；与KMP算法类似当遇到不匹配的字符时它也不需要对文本串text进行回溯，而是通过预先计算的Bad-character(坏字符)跳转表以及Good-suffix(好后缀)跳转表进行寻找最大的跳转长度。</p>

<p>下面以Moore教授的例子来讲解一下。这个例子的原始地址： <a href="http://www.cs.utexas.edu/~moore/best-ideas/string-searching/fstrpos-example.html">http://www.cs.utexas.edu/~moore/best-ideas/string-searching/fstrpos-example.html</a></p>

<p>假定文本串text为：”HERE IS A SIMPLE EXAMPLE”，长度为n；模式串pattern为：”EXAMPLE”，长度为m；现在要在text中搜索看看是否包含pattern。</p>

<p>1).</p>

<pre>
HERE I<span style="color: #ff0000;">S</span> A SIMPLE EXAMPLE
EXAMPL<span style="color: #ff0000;">E</span>
</pre>


<p>首先text与pattern左边对齐，从右边开始进行比较。这个方法比较巧妙，因为如果最右边的字符不匹配，那么就只要比较一次就可以知道前7个字符肯定是不相同的。</p>

<p>S与E不匹配，这时&rsquo;S&#8217;被称为Bad-character。并且&rsquo;S&#8217;不包含在pattern之中，这样就可以把pattern直接移动到text的&rsquo;S&#8217;的后一位。</p>

<p>2).</p>

<pre>
HERE IS A SIM<span style="color: #ff0000;">P</span>LE EXAMPLE
       EXAMPL<span style="color: #ff0000;">E</span>
</pre>


<p>仍然是从右边开始比较，发现&#8217;P&#8217;与&#8217;E&#8217;不匹配，因此&#8217;P&#8217;是Bad-character。但是&#8217;P&#8217;包含中pattern中，因此将pattern后移2位，把两个&#8217;P&#8217;对齐。注意这里后移时需要用到Bad-character跳转表，这个在后面再介绍。</p>

<p>3).</p>

<pre>
HERE IS A SIM<span style="color: #00ff00;">P</span>L<span style="color: #ff0000;">E</span> EXAMPLE
         EXAM<span style="color: #00ff00;">P</span>L<span style="color: #ff0000;">E</span>
</pre>


<p>再从右边开始比较，&#8217;E&#8217;与&#8217;E&#8217;相匹配，然后再比较下一个字符。</p>

<p>4).</p>

<pre>
HERE IS A S<span style="color: #00ff00;">I</span><span style="color: #ff0000;">MPLE</span> EXAMPLE
         EX<span style="color: #00ff00;">A</span><span style="color: #ff0000;">MPLE</span>
</pre>


<p>几次比较之后得到这样的结果，&#8217;A&#8217;与&#8217;I&#8217;不匹配，因此&#8217;I&#8217;是Bad-character。但是&#8217;MPLE&#8217;与&#8217;MPLE&#8217;是匹配的。我们尾部匹配的字符串称为Good-suffix(好后缀)。</p>

<p>5).
根据Bad-character的跳转方法，可以将pattern后移3位，变成如下形式。</p>

<pre>
HERE IS A SI<span style="color: #ff0000;">M</span>PLE EXAMPLE
            <span style="color: #ff0000;">E</span>XAMPLE
</pre>


<p>但是我们可以有更好的方法。这里&#8217;MPLE&#8217;为Good-suffix，根据Good-suffix跳转方法，将pattern后移6位，变成如下形式。同样的Good-suffix跳转表也将在后面介绍。</p>

<pre>
HERE IS A SIMPL<span style="color: #ff0000;">E</span> EXAM<span style="color: #ff0000;">P</span>LE
               <span style="color: #ff0000;">E</span>XAMPL<span style="color: #ff0000;">E</span>
</pre>


<p>6).
&lsquo;P&#8217;与&#8217;E&#8217;不匹配，因此&#8217;P&#8217;为Bad-character。再将pattern后移2位，最后变成：</p>

<pre>
HERE IS A SIMPLE EXAM<span style="color: #00ff00;">P</span>L<span style="color: #ff0000;">E</span>
                 EXAM<span style="color: #00ff00;">P</span>L<span style="color: #ff0000;">E</span>
</pre>


<p>至此整个字符串的匹配就完成了。</p>

<pre>
HERE IS A SIMPLE <span style="color: #ff0000;">EXAMPLE</span>
                 <span style="color: #ff0000;">EXAMPLE</span>
</pre>


<p>接下来介绍一下Bad-character和Good-suffix的跳转方法。<br/>
(1).对于Bad-character后移位数计算公式为：<br/>
delta1(x) = m ;x != pattern[j] (1 &lt;= j &lt;= m),即坏字符x中pattern中未出现<br/>
delta1(x) = m - max{k|pattern[k]=x, 1 &lt;=k&lt;=m} ;其他情况</p>

<p>例如上面的第2步时，&#8217;P&#8217;与&#8217;E&#8217;不匹配，因此&#8217;P&#8217;为Bad-character，在pattern中上次出现的位置为5,因此后移位数就是 7 - 5 = 2。</p>

<p>(2).对于Good-suffix后移位数计算方法为：<br/>
1.pattern中间的某一子字符串pattern[j-s+1:m-s] == pattern[j+1:m]，可将pattern右移s位；<br/>
2.pattern已比较部分pattern[j+1:m]的后缀pattern[s+1:m]与pattern的前缀pattern[1:m-s]相同，可将pattern右移s位。<br/>
满足上面情况的s的最小值为最佳右移距离。<br/>
delta2(j) = min{s|(pattern[j+1:m]=pattern[j-s+1:m-s])&amp;&amp;(pattern[j]!=pattern[j-s])(j&gt;s),pattern[s+1:m]=pattern<a href="j&amp;lt;=s">1:m-s</a>}</p>

<p>例如上面的第5步，满足的是情况2.pattern[6+1:7] == pattern[1:7-6] => pattern[7] == pattern[1]，即是&#8217;E&#8217; == &lsquo;E&#8217;，所以s为6。故右移6位。</p>

<p>在匹配过程中，取delta1和delta2中较大的那一个。</p>

<p>用C语言实现如下：</p>

<pre><code class="c">#include &lt;stdint.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;

#define ALPHABET_LEN 256
#define NOT_FOUND patlen
#define max(a, b) ((a &lt; b) ? b : a)

// delta1 table: delta1[c] contains the distance between the last
// character of pat and the rightmost occurence of c in pat.
// If c does not occur in pat, then delta1[c] = patlen.
// If c is at string[i] and c != pat[patlen-1], we can
// safely shift i over by delta1[c], which is the minimum distance
// needed to shift pat forward to get string[i] lined up 
// with some character in pat.
// this algorithm runs in alphabet_len+patlen time.
void make_delta1(int *delta1, uint8_t *pat, int32_t patlen) {
    int i;
    for (i=0; i &lt; ALPHABET_LEN; i++) {
        delta1[i] = NOT_FOUND;
    }
    for (i=0; i &lt; patlen-1; i++) {
        delta1[pat[i]] = patlen-1 - i;
    }
}

// true if the suffix of word starting from word[pos] is a prefix 
// of word
int is_prefix(uint8_t *word, int wordlen, int pos) {
    int i;
    int suffixlen = wordlen - pos;
    // could also use the strncmp() library function here
    for (i = 0; i &lt; suffixlen; i++) {
        if (word[i] != word[pos+i]) {
            return 0;
        }
    }
    return 1;
}

// length of the longest suffix of word ending on word[pos].
// suffix_length("dddbcabc", 8, 4) = 2
int suffix_length(uint8_t *word, int wordlen, int pos) {
    int i;
    // increment suffix length i to the first mismatch or beginning
    // of the word
    for (i = 0; (word[pos-i] == word[wordlen-1-i]) &amp;&amp; (i &lt; pos); i++);
    return i;
}

// delta2 table: given a mismatch at pat[pos], we want to align 
// with the next possible full match could be based on what we
// know about pat[pos+1] to pat[patlen-1].
//
// In case 1:
// pat[pos+1] to pat[patlen-1] does not occur elsewhere in pat,
// the next plausible match starts at or after the mismatch.
// If, within the substring pat[pos+1 .. patlen-1], lies a prefix
// of pat, the next plausible match is here (if there are multiple
// prefixes in the substring, pick the longest). Otherwise, the
// next plausible match starts past the character aligned with 
// pat[patlen-1].
// 
// In case 2:
// pat[pos+1] to pat[patlen-1] does occur elsewhere in pat. The
// mismatch tells us that we are not looking at the end of a match.
// We may, however, be looking at the middle of a match.
// 
// The first loop, which takes care of case 1, is analogous to
// the KMP table, adapted for a 'backwards' scan order with the
// additional restriction that the substrings it considers as 
// potential prefixes are all suffixes. In the worst case scenario
// pat consists of the same letter repeated, so every suffix is
// a prefix. This loop alone is not sufficient, however:
// Suppose that pat is "ABYXCDEYX", and text is ".....ABYXCDEYX".
// We will match X, Y, and find B != E. There is no prefix of pat
// in the suffix "YX", so the first loop tells us to skip forward
// by 9 characters.
// Although superficially similar to the KMP table, the KMP table
// relies on information about the beginning of the partial match
// that the BM algorithm does not have.
//
// The second loop addresses case 2. Since suffix_length may not be
// unique, we want to take the minimum value, which will tell us
// how far away the closest potential match is.
void make_delta2(int *delta2, uint8_t *pat, int32_t patlen) {
    int p;
    int last_prefix_index = patlen-1;

    // first loop
    for (p=patlen-1; p&gt;=0; p--) {
        if (is_prefix(pat, patlen, p+1)) {
            last_prefix_index = p+1;
        }
        delta2[p] = last_prefix_index + (patlen-1 - p);
    }

    // second loop
    for (p=0; p &lt; patlen-1; p++) {
        int slen = suffix_length(pat, patlen, p);
        if (pat[p - slen] != pat[patlen-1 - slen]) {
            delta2[patlen-1 - slen] = patlen-1 - p + slen;
        }
    }
}

uint8_t* boyer_moore (uint8_t *string, uint32_t stringlen, uint8_t *pat, uint32_t patlen) {
    int i;
    int delta1[ALPHABET_LEN];
    int *delta2 = malloc(patlen * sizeof(int));
    make_delta1(delta1, pat, patlen);
    make_delta2(delta2, pat, patlen);

    i = patlen-1;
    while (i &lt; stringlen) {
        int j = patlen-1;
        while (j &gt;= 0 &amp;&amp; (string[i] == pat[j])) {
            --i;
            --j;
        }
        if (j &lt; 0) {
            free(delta2);
            printf("index: %d\n", i);
            return (string + i+1);
        }

        i += max(delta1[string[i]], delta2[j]);
    }
    free(delta2);
    return NULL;
}

int main(int argc, char *argv[])
{

    char text[] = "HERE IS A SILMPLE EXAMPLE";
    char pattern[] = "EXAMPLE";
    char *result = boyer_moore(text, strlen(text), pattern, strlen(pattern));
    if (result)
    {
        printf("result: %s\n", result);
    } else {
        printf("failed!\n");
    }
    return 0;
}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[字符串匹配算法（三）——KMP算法]]></title>
    <link href="http://www.xefan.com/archives/83859.html"/>
    <updated>2013-07-13T00:00:00+08:00</updated>
    <id>http://www.xefan.com/archives/83859-字符串匹配算法（三）——KMP算法</id>
    <content type="html"><![CDATA[<p>KMP算法是常用的字符串匹配算法之一，是由Knuth、Pratt和Morris发明的。其中Knuth就是著名科学家Donald Knuth。</p>

<p>该算法可以在O(n+m)的时间数量级上完成模式匹配操作。与传统算法相比其改进在于每当一趟匹配过程中出现比较不相等时不用回溯目标字符串。</p>

<p>这个算法还是比较难理解，下面通过一个例子来讲解。
有一个目标字符串”BBC ABCDAB ABCDABCDABDE”，我想知道，里面是否包含另一个字符串”ABCDABD”？</p>

<p>1).</p>

<pre>
<span style="color: #ff0000;">B</span>BC ABCDAB ABCDABCDABDE
<span style="color: #ff0000;">A</span>BCDABD
</pre>


<p>首先目标字符串”BBC ABCDAB ABCDABCDABDE”的第一个字符与源字符串”ABCDABD”的第一个字符相比，不匹配，则目标字符串后移一位。</p>

<p>2).</p>

<pre>
B<span style="color: #ff0000;">B</span>C ABCDAB ABCDABCDABDE
 <span style="color: #ff0000;">A</span>BCDABD
</pre>


<p>B与A不匹配，再次后移。</p>

<p>3).</p>

<pre>
BBC <span style="color: #ff0000;">A</span>BCDAB ABCDABCDABDE
    <span style="color: #ff0000;">A</span>BCDABD
</pre>


<p>就这样直到有一个字符相同为止。</p>

<p>4).</p>

<pre>
BBC A<span style="color: #ff0000;">B</span>CDAB ABCDABCDABDE
    A<span style="color: #ff0000;">B</span>CDABD
</pre>


<p>接着比较下一个字符，还是相同的。再继续。</p>

<p>5).</p>

<pre>
BBC ABCDAB<span style="color: #ff0000;"> </span>ABCDABCDABDE
    ABCDAB<span style="color: #ff0000;">D</span>
</pre>


<p>这时又出现了字符不匹配的情况，如果是传统的算法的话就把目标字符串进行回溯，源字符串后移一位。变成如下情形：</p>

<pre>
BBC A<span style="color: #ff0000;">B</span>CDAB ABCDABCDABDE
     <span style="color: #ff0000;">A</span>BCDABD
</pre>


<p>毕竟这也是最容易理解的，但是这样一来很多字符又需要再重新比较一次。因此效率比较低。</p>

<p>6).
虽然D与空格不匹配，但是前面的ABCDAB是相匹配的。KMP算法就是利用这个已知信息，不要把“搜索”位置称回已经比较过的位置，而且继续比较之后的，这样就减少了重复的比较，提高了效率。继续向后移动变成如下情形：</p>

<pre>
BBC ABCDAB<span style="color: #ff0000;"> </span>ABCDABCDABDE
        AB<span style="color: #ff0000;">C</span>DABD
</pre>


<p>这个移动过程需要一张部分匹配表：</p>

<pre>
j        1234567
源字符串 ABCDABD
next[j]  0111123
</pre>


<p>因为前6个字符是匹配的，最后一个匹配的字符B对应next值为2,根据公式： 移动位数=已匹配字符数-对应的next值
因此将源字符串后移6-2=4位。</p>

<p>7).因为空格与C不相同，继续后移。</p>

<pre>
BBC ABCDAB<span style="color: #ff0000;"> </span>ABCDABCDABDE
          <span style="color: #ff0000;">A</span>BCDABD
</pre>


<p>8).空格与A不相同，继续重复之前的操作进行后移。</p>

<pre>
BBC ABCDAB ABCDAB<span style="color: #ff0000;">C</span>DABDE
           ABCDAB<span style="color: #ff0000;">D</span>
</pre>


<p>9).这里C与D不相同，继续用之前的方法进行后移。</p>

<pre>
BBC ABCDAB ABCDABCDAB<span style="color: #ff0000;">D</span>E
               ABCDAB<span style="color: #ff0000;">D</span>
</pre>


<p>最后匹配完成，字符串”BBC ABCDAB ABCDABCDABDE”里面包含字符串”ABCDABD”。</p>

<p>下面介绍一下部分匹配表的计算方法。<br/>
公式为：<br/>
next[j] = 0    (j=1)<br/>
next[j] = Max {k 1&lt;k&lt;j 且 &lsquo;p(1)&hellip;p(k-1)&rsquo; = &lsquo;p(j-k+1)&hellip;p(j-1)&rsquo;} (当此集合不为空时)<br/>
next[j] = 1    (其他情况)</p>

<p>然后根据公式讲解一下上面例子中的字符串的部分匹配表的计算。(注：这里讲解时是按照数组下标从1开始的，而在C语言中是从0开始的)</p>

<pre>
j        1234567
源字符串 ABCDABD
</pre>


<p>由公式得next[1] = 0， next[2] = 1， next[3] = 1， next[4] = 1， next[5] = 1。<br/>
当j=6时，p[1]=p<a href="%E5%8D%B3" title="A'='A">5</a> => k=2 => next[6] = 2。<br/>
当j=7时，p[1:2]=p<a href="%E5%8D%B3" title="AB'='AB">5:6</a> => k=3 => next[7] = 3。</p>

<p>用C语言实现如下：</p>

<pre><code class="c">#include &lt;stdio.h&gt;

// KMP算法的重点就是求next函数值
void make_next(const char *pattern, int len, unsigned int *next)
{
    int i=1, j=0;
    next[1] = 0;

    while (i &lt;= len) {
        if (j == 0 || pattern[i-1] == pattern[j-1]) {
            i++;
            j++;
            next[i] = j;
        } else {
            j = next[j];
        }
    }
}

int kmp_match(char *t, char *p, int next[], int len1, int len2)
{
    int i=0, j=0;
    while (i &lt; len1 &amp;&amp; j &lt; len2) {
        if (j == 0 || t[i] == p[j]) {
            i++;
            j++;
        } else {
            j = next[j];
        }
    }
    if (j &gt;= len2 ) return i - len2;
    return -1;
}

int main(int argc, char *argv[])
{
    char t[] = "BBC ABCDAB ABCDABCDABDE";
    char p[] = "ABCDABD";
    printf("t: %s\np: %s\n", t, p);
    int len = sizeof(p);
    int next[len];
    make_next(p, len-1, next);
    int i;
    for (i=1; i&lt;len; i++) {
        printf("%4d", next[i]);
    }
    printf("\n");
    printf("index: %d\n", kmp_match(t, p, next, sizeof(t)-1, len-1));
    return 0;
}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[字符串匹配算法（二）——Rabin-Karp算法]]></title>
    <link href="http://www.xefan.com/archives/83853.html"/>
    <updated>2013-07-11T00:00:00+08:00</updated>
    <id>http://www.xefan.com/archives/83853-字符串匹配算法（二）——Rabin-Karp算法</id>
    <content type="html"><![CDATA[<p>Rabin-Karp设计了一个巧妙的hash算法。用到的数学公式为：t(s+1) = (d(t(s)-T[s+1]h)+T[s+m+1]) mod q
t(s+1)为目标字符串的子字符串T[s+1,s+m+1]的哈希值，因为用到了上一次的结果t(s)，所以可以节省计算时间。</p>

<p>首先计算pattern字符串的hash值，然后在从目标字符串的开头，计算相同长度字符串的hash值。若hash值相同，则表示匹配，若不同，则向右移动一位，计算新的hash值。整个过程，与暴力的字符串匹配算法很相似，但由于计算hash值时，可以利用上一次的hash值，从而使新的hash值只需要加上新字母的计算，并减去上一次的第一个字母的计算，即可。</p>

<p>Rabin-Karp算法的预处理时间为O(m)，最坏情况下该算法的匹配时间为O((n-m+1)m)。但是平均运行时间还是比较好的。</p>

<p>用C语言实现如下：</p>

<pre><code class="c">#include &lt;stdio.h&gt;
#include &lt;math.h&gt;

int mod = 0x7fffffff;
const int d = 128;

int rabin_karp(char *T, char *P, int n, int m)
{
    if (n &lt; m) return -2;
    int h = pow(d, m-1);
    int p = 0;
    int t = 0;
    int i, j;
    for (i=0; i&lt;m; i++) {
        p = (d*p + P[i]) % mod;
        t = (d*t + T[i]) % mod;
    }
    for (j=0; j&lt;=n-m; j++) {
        if (p == t) {
            return j;
        }
        if (j &lt; n-m) {
            t = (d*(t - h*T[j]) + T[j+m]) % mod;
        }
    }
    return -1;
}

int main(int argc, char *argv[])
{
    char t[] = "BBC ABCDAB ABCDABCDABDE";
    char p[] = "ABCDABD";
    int len1 = sizeof(t) - 1;
    int len2 = sizeof(p) - 1;
    int index = rabin_karp(t, p, len1, len2);
    printf("index: %d\n", index);
    return 0;
    return 0;
}
</code></pre>

<p>现在结合上面的公式和代码再进行讲解一下。<br/>
d表示字母表的字母个数，上面的代码只接受ascii值为0~127的字符。如果采用小写英文字母来做字母表的话，那么d就是26。<br/>
h等于d<sup>m-1</sup> % q。其实模q运算应该是可有可无的，加入q应该是为了避免数据溢出。但是加入模q后，由ts == p mod q不能说明ts == p，不过ts != p mod q则可以肯定ts != p。所以q最好选择比较大的质数，并且选取的q要满足使dq的值在一个计算机字长内。如果使用的是动态的编程语言的话就不用担心数据溢出，因此就不用进行模q运算。</p>
]]></content>
  </entry>
  
</feed>
