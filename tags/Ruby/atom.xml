<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Tag: Ruby | 龍昌博客]]></title>
  <link href="http://www.xefan.com/tags/Ruby/atom.xml" rel="self"/>
  <link href="http://www.xefan.com/"/>
  <updated>2015-04-05T21:18:11+08:00</updated>
  <id>http://www.xefan.com/</id>
  <author>
    <name><![CDATA[龍昌]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[使用Unicorn部署rails应用]]></title>
    <link href="http://www.xefan.com/archives/84142.html"/>
    <updated>2015-04-05T20:47:15+08:00</updated>
    <id>http://www.xefan.com/archives/84142-使用Unicorn部署rails应用</id>
    <content type="html"><![CDATA[<p>玩 rails 也有段时间了，最近研究下怎么部署一个 rails 应用。在几年前的话要部署 rails 应用是件很麻烦的事，
但是近几年出现了一些比较好的工具可以方便的进行 rails 部署。如： Unicorn、thin、Passenger等。</p>

<p>Unicorn 是一个 Rack 应用的HTTP服务器。之前玩 Python 的时候也有一个 Gunicorn ，使用它来部署 Python 的 Web 应用
也很方便，可以参考我之前的那篇文件 <a href="84138.html">《使用gunicorn部署Django》</a> 。</p>

<p>接下来简单分享下使用 Nginx + Unicorn 来部署 rails 的配置。</p>

<h2>安装</h2>

<p>首先安装 unicorn 包： <code>$ gem install unicorn</code></p>

<p>然后编译一下静态文件：</p>

<pre><code>$ RAILS_ENV=production rake assets:clean
$ RAILS_ENV=production rake assets:precompile
</code></pre>

<p>下载配置文件： <code>$ curl -o config/unicorn.rb https://raw.github.com/defunkt/unicorn/master/examples/unicorn.conf.rb</code></p>

<p>接着根据情况修改相关配置，如： working_directory、listen 等。
例如我的是需要同时监听网络端口和 sock 文件，那么我的 listen 设置如下：</p>

<pre><code>listen "#{root_path}/tmp/sockets/unicorn.sock", :backlog =&gt; 64
listen 8081, :tcp_nopush =&gt; true
</code></pre>

<h2>配置 Nginx</h2>

<p>然后配置 Nginx 的反向代理，以下是我的 Nginx 配置示例：</p>

<pre><code>upstream rails_server {
  server unix:/app_path/tmp/sockets/unicorn.sock fail_timeout=0;
}

server {
  listen 80;
    server_name webserver localhost;

    root /app_path/public;

  try_files $uri $uri @unicorn;

  location @unicorn {
    proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
    proxy_set_header Host $http_host;
    proxy_redirect off;
    proxy_pass http://rails_server;
  }

  location ~ /\.ht {
    deny  all;
  }
}
</code></pre>

<h2>启动服务</h2>

<p>配置完成之后，最后启动服务。</p>

<pre><code>$ bundle exec unicorn_rails -c config/unicorn.rb -D -E production
$ sudo service nginx start
</code></pre>

<p>然后再在浏览器中访问试试。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Vagrant使用笔记]]></title>
    <link href="http://www.xefan.com/archives/84141.html"/>
    <updated>2015-02-24T19:17:43+08:00</updated>
    <id>http://www.xefan.com/archives/84141-Vagrant使用笔记</id>
    <content type="html"><![CDATA[<p>Vgrant是一个基于 Ruby 使用 Virtualbox 进行创建和部署虚拟化环境的工具。
类似的工具之前有使用过 Docker。就我个人而言这两款工具之间，Docker是轻量级的VM，
因此性能应该会比较好，但是只能在64位的系统下使用。
而 Vgrant 是使用 Virtualbox 进行虚拟化，因此性能上不及 Docker，
不过它可以在32/64位的 Linux、Windows 等系统上运行。</p>

<p>我觉得 Vgrant 比较适合用于在开发环境中使用，而 Docker 比较适合用于生产环境。</p>

<h2>安装</h2>

<p>首先安装 virtualbox，然后再安装 Vgrant。</p>

<p>1.通过源代码安装</p>

<pre><code>git clone https://github.com/mitchellh/vagrant
cd vagrant
bundle install
rake install
</code></pre>

<p>2.通过安装包安装<br/>
根据情况选择下载对应的安装包： <a href="http://www.vagrantup.com/downloads.html">http://www.vagrantup.com/downloads.html</a></p>

<p>注意：如果是 Windows 系统，可能还需要将 Vgrant 的路径添加到环境变量中，以便使用 vgrant 命令。</p>

<h2>使用</h2>

<p>Vagrant 的使用方法也很简单，基本如下：</p>

<pre><code># 这里我先添加一个 ArchLinux 的镜像
vagrant box add archlinux http://vagrant.srijn.net/archlinux-x64-2014-01-07.box
# 进行初始化
vagrant init archlinux
# 运行虚拟机
vagrant up
# 如果需要进行ssh连接到虚拟机中进行一些操作，可以执行该命令
vagrant ssh
</code></pre>

<p>其他的一些命令：</p>

<pre><code># 关闭虚拟机
vagrant halt
# 删除创建的虚拟机
vagrant destroy
</code></pre>

<p>vagrant的一些镜像： <a href="http://www.vagrantbox.es/">http://www.vagrantbox.es/</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[使用ruby开发vim插件]]></title>
    <link href="http://www.xefan.com/archives/84117.html"/>
    <updated>2014-07-03T00:00:00+08:00</updated>
    <id>http://www.xefan.com/archives/84117-使用ruby开发vim插件</id>
    <content type="html"><![CDATA[<p>作为一个Vimmer和Pythoner，之前折腾过用python编写vim插件。现在作为半个Rubist，又开始继续折腾。</p>


<p>在开始编写插件之前，你需要确认 Vim 是否支持 Ruby，通过以下命令来判别：</p>


<pre><code>$ vim --version | grep +ruby
</code></pre>


<p>如果输出为空，则表示你当前的vim不支持Ruby，需要重新编译一下，并启用对Ruby的支持。</p>


<p>顺便说下我当前的环境是：</p>


<ul>
<li>vim 7.4  </li>
<li>ruby 2.1.0  </li>
</ul>


<p>环境检查没有问题那么就开始吧。<br>
在~/.vim/plugin目录下创建一个 demo.vim 文件。</p>


<p>在开头写上以下代码：</p>


<pre><code>if !has('ruby')
    echo "Error: Required vim compiled with +ruby"
    finish
endif
</code></pre>


<p>这段代码就是用 VimL 编写的，它将检查 Vim 是否支持 Ruby。</p>


<p>接下来再判断该插件是否已经加载过了，以免重复加载：</p>


<pre><code>if exists('g:loaded_ruby_demo_plugin')
    finish
endif
let g:loaded_ruby_demo_plugin = 1
</code></pre>


<p>所有的检查都没有问题，则开始插件的正文了。先定义一个函数。</p>


<pre><code>function! DemoFun1()
ruby&lt;&lt;EOF
buf = VIM::Buffer.current
puts "current buffer name: #{buf.name} number: #{buf.number} length: #{buf.length}"
EOF
endfunction
</code></pre>


<p>function与endfunction是vim中用于定义函数的，在”ruby&lt;&lt;EOF”和”EOF”之间部分的是Ruby代码。这个例子是输出当前缓冲区的名字、编号以及总行数。<br>
执行命令:call DemoFun1()，应该就可以看到输出结果了。</p>


<p>然后再举个例子说下函数的参数处理。</p>


<pre><code>function! DemoFun2(arg1)
ruby&lt;&lt; EOF
puts "you input: #{VIM.evaluate('a:arg1')}"
EOF
endfunction
</code></pre>


<p>这里定义了一个函数接收一个参数，然后将其输出。使用 VIM.evaluate 将vim的变量转化为Ruby的变量。</p>


<p>为了方便我们再定义两个命令，以简化对这两个函数的调用。</p>


<pre><code>command! -nargs=0 DemoFun1 call DemoFun1()  
command! -nargs=1 -rang DemoFun2 call DemoFun2(&lt;f-args&gt;)
</code></pre>


<p>要获取完整的代码可以访问： https://gist.github.com/wusuopu/c1182efefa85d4f6839b</p>


<p>接下来再简单说下vim中Ruby的使用。</p>


<p>vim为Ruby提供了一个VIM模块，通过它可以在Ruby中访问vim的接口。同时还提供了两个全局变量：$curwin、$curbuf，它们分别代表了当前窗口对象以及当前缓冲区对象。</p>


<p>VIM模块中有 Buffer 和 Window 两个对象，分别是用来对缓冲区和窗口进行操作的。同时VIM模块还提供了message、set_option、command和evaluate四个函数。</p>


<p>想要查看更多的帮忙信息，可以在vim中执行如下命令：</p>


<pre><code>:help ruby
</code></pre>


<p>好了，先写这么多吧，其余的自己去尝试吧。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[使用rvm进行ruby多版本管理]]></title>
    <link href="http://www.xefan.com/archives/84105.html"/>
    <updated>2014-06-16T00:00:00+08:00</updated>
    <id>http://www.xefan.com/archives/84105-使用rvm进行ruby多版本管理</id>
    <content type="html"><![CDATA[<p>rvm与Python的virtualenv和Node的nvm类似。使用它可以很方便的在你的系统中安装多个Ruby环境。类似的工具还有rbenv、ry、rbfu等。  </p>


<h3>安装rvm</h3>


<p>以下的命令都是在当前用户权限下执行的，最好不要使用sudo。<br>
下载安装rvm:</p>


<pre><code>$ curl -sSL https://get.rvm.io | bash -s stable
</code></pre>


<p>安装完成之后再加载配置：</p>


<pre><code>$ source ~/.profile
</code></pre>


<p>为了下次能直接使用，建议将该命令添加到 ~/.bash_profile 或者 ~/.zshrc 中。  </p>


<p>使用rvm安装Ruby时会默认从官方网站上进行下载，为了提高下载速度这里建议将安装源修改为淘宝的镜像。</p>


<pre><code>$ sed -i -e 's/ftp\.ruby-lang\.org\/pub\/ruby/ruby\.taobao\.org\/mirrors\/ruby/g' ~/.rvm/config/db
</code></pre>


<h3>使用</h3>


<p>安装完成之后就可以使用了，以下介绍几条常用的命令。<br>
列出已知的ruby版本:  </p>


<pre><code>$ rvm list known
</code></pre>


<p>列出已经安装的ruby：  </p>


<pre><code>$ rvm list
</code></pre>


<p>安装一个ruby版本：  </p>


<pre><code>$ rvm install 2.1.0
</code></pre>


<p>这里安装最新的2.1.0版本的Ruby。</p>


<p>如果安装了多个版本，想使用其中一个版本：  </p>


<pre><code>$ rvm use 2.1.0
</code></pre>


<p>设置为默认版本：  </p>


<pre><code>$ rvm use 2.1.0 --default
</code></pre>


<p>use了某个版本之后，可以使用 which ruby 命令查看当前的ruby命令信息。  </p>


<p>删除一个已安装的版本：  </p>


<pre><code>$ rvm remove 2.1.0
</code></pre>


<p>更多内容请参考官方文档： https://rvm.io/#docindex</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Rack开发简介]]></title>
    <link href="http://www.xefan.com/archives/84103.html"/>
    <updated>2014-05-02T00:00:00+08:00</updated>
    <id>http://www.xefan.com/archives/84103-Rack开发简介</id>
    <content type="html"><![CDATA[<p>Rack是Ruby应用与web服务器之间的一个接口，它在服务器与应用程序之间作为中间件，可以对用户的请求和程序的返回数据进行处理。现在几乎所有主流的Ruby web框架都是支持Rack接口的。</p>


<p>Rack与Python的wsgi很相似，在它的规格书（http://rack.rubyforge.org/doc/SPEC.html）中也说道它采用了WSGI的一些内容。</p>


<h2>开始</h2>


<p>首先安装Rack:</p>


<pre><code>[sudo] gem install rack
</code></pre>


<p>然后通过一个简单的例子来讲解。</p>


<pre><code>require "rack"
rack_app = lambda{|env| [200, {}, ["Hello World!"]]}
Rack::Handler::WEBrick.run rack_app, :Port =&gt; 3000
</code></pre>


<p>执行上述代码，然后访问 http://127.0.0.1:3000 会看到 &#8220;Hello World!&#8221;。</p>


<p>上面代码中的rack_app即是一个Rack应用。Rack应用除了lambda之外也还可以使用其他对象，只要满足以下条件即可：<br>
  * 可响应call方法的对象；<br>
  * 接收一个参数rack环境 environment 。它是一个散列表，包含了CGI的信息和rack的一些变量；<br>
  * 返回一个有三个值的数组，第一个值为返回状态 status；第二个值为返回头 headers，也是一个散列表；第三个值为返回正文 body，它必须是一个可响应each方法并生成字符串的对象，例如字符串数组。</p>


<p>WEBrick是Handler的一种。Handler用于将web服务器与Rack连接。使用 Rack::Handler.constants 可以查看Rack包含的所有Handler。</p>


<h2>请求/Request</h2>


<p>在Rack应用中可以直接操作env参数来访问请求信息，但是这种方法不太方便。对于这种操作Rack::Request对象提供了方便的接口。</p>


<pre><code>request = Rack::Request.new env
</code></pre>


<p>创建request对象时传入env参数。</p>


<h2>响应/Response</h2>


<p>Rack应用的返回值是一个有三个值的数组，包含了返回状态、返回头和返回正文。对于简单的程序手动构建数组还行，如果是复杂的程序则要考虑自动构建了。<br>
同样的可以使用Rack::Request对象来创建返回数据。</p>


<pre><code>response = Rack::Response.new
response.finish
</code></pre>


<p>内容填充完之后调用response对象的finish方法生成符合Rack规范的数组对象。</p>

]]></content>
  </entry>
  
</feed>
