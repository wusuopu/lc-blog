<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Tag: Ruby | 龍昌博客]]></title>
  <link href="http://www.xefan.com/tags/Ruby/atom.xml" rel="self"/>
  <link href="http://www.xefan.com/"/>
  <updated>2015-05-13T23:10:33+08:00</updated>
  <id>http://www.xefan.com/</id>
  <author>
    <name><![CDATA[龍昌]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Ruby 3.0的未来]]></title>
    <link href="http://www.xefan.com/archives/84144.html"/>
    <updated>2015-05-13T21:33:08+08:00</updated>
    <id>http://www.xefan.com/archives/84144-Ruby 3.0的未来</id>
    <content type="html"><![CDATA[<p>原文地址：<a href="http://hrnabi.com/2015/05/12/7035/  ">http://hrnabi.com/2015/05/12/7035/  </a>
谁日语好的为大家做下贡献，把原文翻译一下吧。</p>

<p>反正我不会日语，根据文中的一些汉字连蒙带猜的，大致看了一遍，现在简单总结一下。
如果有总结得不对的，本人不负责哦。</p>

<p>看来要玩好Ruby不仅需要学英语，也还得学日语啊。</p>

<hr />

<p>在2014年9月举行的 RubyKaigi 2014 大会上，Matz在演讲过程中首次提到了 Ruby 3.0。<br/>
文中说的Ruby 3.0的三个工作方向：</p>

<ul>
<li>Concurrency (并行性)</li>
<li>JIT (即时编译)</li>
<li>Static typing (静态类型)</li>
</ul>


<p>Ruby要引入静态类型检查？<br/>
Matz说，在20世纪出生的语言大多是脚本语言，如：Ruby、PHP和Perl、JavaScript，这些都不是静态类型的。
另一方面，最近推出的如Scala和Dart、Go是属于静态类型的。
在Ruby中可以考虑引入Python这种通过注释来进行检查的方法。</p>

<p>Ruby要引入并行计算？<br/>
Matz详细讨论了静态类型，但没有提到并行计算。详细的内容是由笹田氏来说的。<br/>
（这部分内容我没看懂，只是大概知道这位笹田氏的博士论文与这个相关。）<br/>
关于并行计算，Matz提到了Erlang和Scala的actor模型。</p>

<p>最后期待下一个Ruby开发者大会。</p>

<hr />

<p>好了，我只看懂了这么多。其余的各位感兴趣的自己去看原文吧。
(怎么感觉好坑啊，这总结得跟没总结一样啊。没办法了我的日语水平有限。)</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Ruby中一些重要的钩子方法]]></title>
    <link href="http://www.xefan.com/archives/84143.html"/>
    <updated>2015-04-30T22:35:42+08:00</updated>
    <id>http://www.xefan.com/archives/84143-Ruby中一些重要的钩子方法</id>
    <content type="html"><![CDATA[<p>Ruby的哲学理念是基于一个基本的要素，那就是让程序员快乐。Ruby非常注重程序员的快乐，并且也提供了许多不同的方法来实现它。
它的元编程能力能够让程序员编写在运行时动态生成的代码。它的线程功能使得程序员有一种优雅的的方式编写多线程代码。
它的钩子方法能让程序员在程序运行时扩展它的行为。</p>

<p>上述的这些特性，以及一些其他很酷的语言方面，使得Ruby成为编写代码的优先选择之一。
本文将探讨Ruby中的一些重要的钩子方法。我们将从不同方面讨论钩子方法，如它们是什么，它们用于什么，以及我们如何使用它们来解决不同的问题。
我们同时也了解一下一些流行的Ruby框架/Gem包/库是如何使用它们来提供非常酷的特性的。</p>

<p>我们开始吧。</p>

<h1>什么是钩子方法？</h1>

<p>钩子方法提供了一种方式用于在程序运行时扩展程序的行为。
假设有这样的功能，可以在无论何时一个子类继承了一些特定的父类时收到通知，
或者是比较优雅地处理一个对象上的不可调用的方法而不是让编译器抛出异常。
这些情况就是使用钩子方法，但是它们的用法并不仅限于此。
不同的框架/库使用了不同的钩子方法来实现它们的功能。</p>

<p>在本文中我们将会讨论如下几个钩子方法：</p>

<ul>
<li>included</li>
<li>extended</li>
<li>prepended</li>
<li>inherited</li>
<li>method_missing</li>
</ul>


<h2>included</h2>

<p>Ruby给我们提供了一种方式使用 <code>模块(modules)</code> （在其他语言中被称作 <code>混入类(mixins)</code>）来编写模块化的代码供其他的 <code>模块</code>/<code>类</code> 使用。
<code>模块</code> 的概念很简单，它就是一个可以在其他地方使用的独立代码块。</p>

<p>例如，如果我们想要编写一些代码在任何时候调用特定的方法都会返回一个静态字符串。
我们姑且将这个方法称作 <code>name</code>。你可能在其他地方也会想使用同一块代码。
这样最好是新建一个模块。让我们来创建一个：</p>

<pre><code class="ruby">module Person
  def name
    puts "My name is Person"
  end
end
</code></pre>

<p>这是一个非常简单的模块，仅有一个 <code>name</code> 方法用于返回一个静态字符串。在我们的程序中使用这个模块：</p>

<pre><code class="ruby">class User
  include Person
end
</code></pre>

<p>Ruby提供了一些不同的方法来使用<code>模块</code>。<code>include</code> 是其中之一。<code>include</code> 所做的就是将在 <code>module</code> 内定义的方法在一个 <code>class</code> 的实例变量上可用。
在我们的例子中，是将 <code>Person</code> 模块中定义的方法变为一个 <code>User</code> 类实例对象的方法。
这就相当于我们是将 <code>name</code> 方法写在 <code>User</code> 类里一样，但是定义在 <code>module</code> 里的好处是可复用。
要调用 <code>name</code> 方法我们需要创建一个 <code>User</code> 的实例对象，然后再在这个对象上调用 <code>name</code> 方法。例如：</p>

<pre><code class="ruby">User.new.name
=&gt; My name is Person
</code></pre>

<p>让我们看看基于 <code>include</code> 的钩子方法。<code>included</code> 是Ruby提供的一个钩子方法，当你在一些 <code>module</code> 或者 <code>class</code> 中 <code>include</code> 了一个 <code>module</code> 时它会被调用。
更新 <code>Person</code> 模块：</p>

<pre><code class="ruby">module Person
  def self.included(base)
    puts "#{base} included #{self}"
  end

  def name
    "My name is Person"
  end
end
</code></pre>

<p>你可以看到一个新的方法 <code>included</code> 被定义为 <code>Person</code> 模块的类方法。当你在其他的模块或者类中执行 <code>include Person</code> 时，这个 <code>included</code> 方法会被调用。
该方法接收的一个参数是对包含该模块的类的引用。试试运行 <code>User.new.name</code>，你会看到如下的输出：</p>

<pre><code class="ruby">User included Person
My name is Person
</code></pre>

<p>正如你所见，<code>base</code> 返回的是包含该模块的类名。现在我们有了一个包含 <code>Person</code> 模块的类的引用，我们可以通过元编程来实现我们想要的功能。
让我们来看看 <strong>Devise</strong>是如何使用 <code>included</code> 钩子的。</p>

<h3>Devise中的 <code>included</code></h3>

<p>Devise是Ruby中使用最广泛的身份验证gem包之一。它主要是由我喜欢的程序员 <a href="https://twitter.com/josevalim">José Valim</a> 开发的，现在是由一些了不起的贡献者在维护。
Devise为我们提供了从注册到登录，从忘记密码到找回密码等等完善的功能。它可以让我们在用户模型中使用简单的语法来配置各种模块：</p>

<pre><code class="ruby">devise :database_authenticatable, :registerable, :validatable
</code></pre>

<p>在我们模型中使用的 <code>devise</code> 方法在<a href="https://github.com/plataformatec/devise/blob/v3.4.1/lib/devise/models.rb#L77">这里</a>定义。
为了方便我将这段代码粘贴在下面：</p>

<pre><code class="ruby">def devise(*modules)
  options = modules.extract_options!.dup

  selected_modules = modules.map(&amp;:to_sym).uniq.sort_by do |s|
    Devise::ALL.index(s) || -1  # follow Devise::ALL order
  end

  devise_modules_hook! do
    include Devise::Models::Authenticatable

    selected_modules.each do |m|
      mod = Devise::Models.const_get(m.to_s.classify)

      if mod.const_defined?("ClassMethods")
        class_mod = mod.const_get("ClassMethods")
        extend class_mod

        if class_mod.respond_to?(:available_configs)
          available_configs = class_mod.available_configs
          available_configs.each do |config|
            next unless options.key?(config)
            send(:"#{config}=", options.delete(config))
          end
        end
      end

      include mod
    end

    self.devise_modules |= selected_modules
    options.each { |key, value| send(:"#{key}=", value) }
  end
end
</code></pre>

<p>在我们的模型中传给 <code>devise</code> 方法的模块名将会作为一个数组保存在 <code>*modules</code> 中。
对于传入的模块调用 <code>extract_options!</code> 方法提取可能传入的选项。
在11行中调用 <code>each</code> 方法，并且每个模块在代码块中用 <code>m</code> 表示。
在12行中 <code>m</code> 将会转化为一个常量（类名），因此使用 <code>m.to.classify</code> 一个例如 <code>:validatable</code> 这样的符号会变为 <code>Validatable</code> 。
随便说一下 <code>classify</code> 是ActiveSupport的方法。<br/>
<code>Devise::Models.const_get(m.to_classify)</code> 会获取该模块的引用，并赋值给 <code>mod</code>。
在27行使用 <code>include mod</code> 包含该模块。
例子中的 <code>Validatable</code> 模块是定义在<a href="https://github.com/plataformatec/devise/blob/v3.4.1/lib/devise/models/validatable.rb">这是</a>。
<code>Validatable</code> 的 <code>included</code> 钩子方法定义如下：</p>

<pre><code class="ruby">def self.included(base)
  base.extend ClassMethods
  assert_validations_api!(base)

  base.class_eval do
    validates_presence_of   :email, if: :email_required?
    validates_uniqueness_of :email, allow_blank: true, if: :email_changed?
    validates_format_of     :email, with: email_regexp, allow_blank: true, if: :email_changed?

    validates_presence_of     :password, if: :password_required?
    validates_confirmation_of :password, if: :password_required?
    validates_length_of       :password, within: password_length, allow_blank: true
  end
end
</code></pre>

<p>此时模型是 <code>base</code>。在第5行的 <code>class_eval</code> 代码块会以该类作为上下文进行求值运算。
通过 <code>class_eval</code> 编写的代码与直接打开该类的文件将代码粘贴进去效果是一样的。
Devise是通过 <code>class_eval</code> 将验证包含到我们的用户模型中的。</p>

<p>当我们试着使用Devise注册或者登录时，我们会看到这些验证，但是我们并没有编写这些验证代码。
Devise是利用了 <code>included</code> 钩子来实现这些的。非常的优雅吧。</p>

<h2>extended</h2>

<p>Ruby也允许开发者 <code>扩展(extend)</code> 一个模块，这与 <code>包含(include)</code> 有点不同。
<code>extend</code> 是将定义在 <code>模块(module)</code> 内的方法应用为类的方法，而不是实例的方法。
让我们来看一个简单的例子：</p>

<pre><code class="ruby">module Person
  def name
    "My name is Person"
  end
end

class User
  extend Person
end

puts User.name # =&gt; My name is Person
</code></pre>

<p>正如你所看到的，我们将 <code>Person</code> 模块内定义的 <code>name</code> 方法作为了 <code>User</code> 的类方法调用。
<code>extend</code> 将 <code>Person</code> 模块内的方法添加到了 <code>User</code> 类中。<code>extend</code> 同样也可以用于将模块内的方法作为单例方法(singleton methods)。
让我们再来看另外一个例子：</p>

<pre><code class="ruby"># We are using same Person module and User class from previous example.     

u1 = User.new
u2 = User.new

u1.extend Person

puts u1.name # =&gt; My name is Person
puts u2.name # =&gt; undefined method `name' for #&lt;User:0x007fb8aaa2ab38&gt; (NoMethodError)
</code></pre>

<p>我们创建了两个 <code>User</code> 的实例对象，并将 <code>Person</code> 作为参数在 <code>u1</code> 上调用 <code>extend</code> 方法。
使用这种调用方式，<code>Person</code> 的 <code>name</code> 方法仅对 <code>u1</code> 有效，对于其他实例是无效的。</p>

<p>正如 <code>included</code> 一样，与 <code>extend</code> 相对应的钩子方法是 <code>extended</code>。
当一个模块被其他模块或者类执行了 <code>extend</code> 操作时，该方法将会被调用。
让我们来看一个例子：</p>

<pre><code class="ruby"># Modified version of Person module

module Person
  def self.extended(base)
    puts "#{base} extended #{self}"
  end

  def name
    "My name is Person"
  end
end

class User
  extend Person
end
</code></pre>

<p>该代码的运行结果是输出 <code>User extended Person</code>。</p>

<p>关于 <code>extended</code> 的介绍已经完了，让我们来看看 <code>ActiveRecord</code> 是如何使用它的。</p>

<h3>ActiveRecord中的 <code>extended</code></h3>

<p><code>ActiveRecord</code> 是在 Ruby 以及 Rails 中广泛使用的ORM框架。它具有许多酷的特性，
因此使用它在很多情况下成为了ORM的首选。让我们进入 <code>ActiveRecord</code> 内部看看 <code>ActiveRecord</code> 是如何使用回调的。
(我们使用的是 Rails v3.2.21)</p>

<p><code>ActiveRecord</code> 在<a href="https://github.com/rails/rails/blob/v3.2.21/activerecord/lib/active_record/callbacks.rb#L246">这里</a> <code>extend</code> 了 <code>ActiveRecord::Models</code> 模块。</p>

<pre><code class="ruby">extend ActiveModel::Callbacks
</code></pre>

<p><code>ActiveModel</code> 提供了一套在模型类中使用的接口。它们允许 ActionPack 与不是 ActiveRecord 的模型进行交互。
在<a href="https://github.com/rails/rails/blob/v3.2.21/activemodel/lib/active_model/callbacks.rb#L49-L53">这里</a>， <code>ActiveModel::Callbacks</code> 内部你将会看到如下代码：</p>

<pre><code class="ruby">def self.extended(base)
  base.class_eval do
    include ActiveSupport::Callbacks
  end
end
</code></pre>

<p><code>ActiveModel::Callbacks</code> 对 <code>base</code> 即就是 <code>ActiveRecord::Callbacks</code> 调用了 <code>class_eval</code> 方法，
并包含了 <code>ActiveSupport::Callbacks</code> 模块。我们前面已经提到过了，对一个类调用 <code>class_eval</code> 与手动地将代码写在这个类里是一样的。
<code>ActiveSupport::Callbacks</code> 为 <code>ActiveRecord::Callbacks</code> 提供了 Rails 中的回调方法。</p>

<p>这里我们讨论了 <code>extend</code> 方法，以及与之对应的钩子 <code>extended</code>。并且也了解了 <code>ActiveRecord</code> / <code>ActiveModel</code>
是如何使用上述方法为我们提供可用功能的。</p>

<h2>prepended</h2>

<p>另一个使用定义在模块内部方法的方式称为 <code>prepend</code>。<code>prepend</code> 是在Ruby 2.0中引入的，并且与 <code>include</code> 和 <code>extend</code> 很不一样。
使用 <code>include</code> 和 <code>extend</code> 引入的方法可以被目标模块/类重新定义覆盖。
例如，如果我们在某个模块中定义了一个名为 <code>name</code> 的方法，并且在目标模块/类中也定义同名的方法。
那么这个在我们类在定义的 <code>name</code> 方法将会覆盖模块中的。而 <code>prepend</code> 是不一样的，它会将 <code>prepend</code> 引入的模块
中的方法覆盖掉我们模块/类中定义的方法。让我们来看一个简单的例子：</p>

<pre><code class="ruby">module Person
  def name
    "My name belongs to Person"
  end
end

class User
  include Person
  def name
    "My name belongs to User"
  end
end

puts User.new.name 
=&gt; My name belongs to User
</code></pre>

<p>现在再来看看 <code>prepend</code> 的情况：</p>

<pre><code class="ruby">module Person
  def name
    "My name belongs to Person"
  end
end

class User
  prepend Person
  def name
    "My name belongs to User"
  end
end

puts User.new.name 
=&gt; My name belongs to Person
</code></pre>

<p>使用 <code>prepend Person</code> 会将 <code>User</code> 中的同名方法给覆盖掉，因此在终端输出的结果为 <code>My name belongs to Person</code>。
<code>prepend</code> 实际上是将方法添加到方法链的前端。在调用 <code>User</code> 类内定义的 <code>name</code> 方法时，会调用 <code>super</code> 从而调用 <code>Person</code> 模块的 <code>name</code>。</p>

<p>与 <code>prepend</code> 对应的回调名为（你应该猜到了） <code>prepended</code>。当一个模块被预置到另一个模块/类中时它会被调用。
我们来看下效果。更新 <code>Person</code> 模块的定义：</p>

<pre><code class="ruby">module Person
  def self.prepended(base)
    puts "#{self} prepended to #{base}"
  end

  def name
    "My name belongs to Person"
  end
end
</code></pre>

<p>你再运行这段代码应该会看到如下结果：</p>

<pre><code>Person prepended to User
My name belongs to Person
</code></pre>

<p><code>prepend</code> 的引入是为了去除 <code>alias_method_chain</code> hack的丑陋，它曾被Rails以及其他库广泛地使用以达到与 <code>prepend</code> 相同的功能。
因为 <code>prepend</code> 只有在 Ruby >= 2.0 的版本中才能使用，因此如果你打算使用 <code>prepend</code> 的话，那么你就应该升级你的Ruby版本。</p>

<h2>inherited</h2>

<p>继承是面向对象中一个最重要的概念。Ruby是一门面向对象的编程语言，并且提供了从基/父类继承一个子类的功能。
我们来看一个简单的例子：</p>

<pre><code class="ruby">class Person
  def name
     "My name is Person"
  end
end

class User &lt; Person
end

puts User.new.name # =&gt; My name is Person
</code></pre>

<p>我们创建了一个 <code>Person</code> 类和一个子类 <code>User</code>。在 <code>Person</code> 中定义的方法也成为了 <code>User</code> 的一部分。
这是非常简单的继承。你可能会好奇，是否有什么方法可以在一个类被其他类继承时收到通知呢？
是的，Ruby有一个名为 <code>inherited</code> 的钩子可以实现。我们再看看这个例子：</p>

<pre><code class="ruby">class Person
  def self.inherited(child_class)
    puts "#{child_class} inherits #{self}"
  end

  def name
    "My name is Person"
  end
end

class User &lt; Person
end

puts User.new.name
</code></pre>

<p>正如你所见，当 <code>Person</code> 类被其他子类继承时 <code>inherited</code> 类方法将会被调用。
运行以上代码结果如下：</p>

<pre><code>User inherits Person
My name is Person
</code></pre>

<p>让我们看看 <code>Rails</code> 在它的代码中是如何使用 <code>inherited</code> 的。</p>

<h3>Rails中的 <code>inherited</code></h3>

<p>Rails应用中有一个重要的类名为 <code>Application</code> ，定义中 <strong>config/application.rb</strong> 文件内。
这个类执行了许多不同的任务，如运行所有的Railties，引擎以及插件的初始化。
关于 <code>Application</code> 类的一个有趣的事件是，在同一个进程中不能运行两个实例。
如果我们尝试修改这个行为，Rails将会抛出一个异常。让我们来看看Rails是如何实现这个特性的。</p>

<p><code>Application</code> 类继承自 <code>Rails::Application</code>，它是在<a href="https://github.com/rails/rails/blob/v3.2.21/railties/lib/rails/application.rb">这里</a>定义的。
在62行定义了 <code>inherited</code> 钩子，它会在我们的Rails应用 <code>Application</code> 类继承 <code>Rails::Application</code> 时被调用。
<code>inherited</code> 钩子的代码如下：</p>

<pre><code class="ruby">class &lt;&lt; self
  def inherited(base)
    raise "You cannot have more than one Rails::Application" if Rails.application
    super
    Rails.application = base.instance
    Rails.application.add_lib_to_load_path!
    ActiveSupport.run_load_hooks(:before_configuration, base.instance)
  end
end
</code></pre>

<p><code>class &lt;&lt; self</code> 是Ruby中的另一个定义类方法的方式。在 <code>inherited</code> 中的第1行是检查 <code>Rails.application</code> 是否已存在。
如果存在则抛出异常。第一次运行这段代码时 <code>Rails.application</code> 会返回false然后调用 <code>super</code>。
在这里 <code>super</code> 即是 <code>Rails::Engine</code> 的 <code>inherited</code> 钩子，因为 <code>Rails::Application</code> 继承自 <code>Rails::Engine</code>。</p>

<p>在下一行，你会看到 <code>Rails.application</code> 被赋值为 <code>base.instance</code> 。其余就是设置Rails应用了。</p>

<p>这就是Rails如何巧妙地使用 <code>inherited</code> 钩子来实现我们的Rails <code>Application</code> 类的单实例。</p>

<h2>method_missing</h2>

<p><code>method_missing</code> 可能是Ruby中使用最广的钩子。在许多流行的Ruby框架/gem包/库中都有使用它。
当我们试图访问一个对象上不存在的方法时则会调用这个钩子方法。
让我们来看一个简单的例子：</p>

<pre><code class="ruby">class Person
  def name
    "My name is Person"
  end
end

p = Person.new

puts p.name     # =&gt; My name is Person 
puts p.address  # =&gt; undefined method `address' for #&lt;Person:0x007fb730a2b450&gt; (NoMethodError)
</code></pre>

<p>我们定义了一个简单的 <code>Person</code> 类， 它只有一个 <code>name</code> 方法。然后创建一个 <code>Person</code> 的实例对象，
并分别调用 <code>name</code> 和 <code>address</code>　两个方法。因为 <code>Person</code> 中定义了 <code>name</code>，因此这个运行没问题。
然而 <code>Person</code> 并没有定义 <code>address</code>，这将会抛出一个异常。
<code>method_missing</code> 钩子可以优雅地捕捉到这些未定义的方法，避免此类异常。
让我们修改一下 <code>Person</code> 类：</p>

<pre><code class="ruby">class Person
  def method_missing(sym, *args)
     "#{sym} not defined on #{self}"
  end

  def name
    "My name is Person"
  end
end

p = Person.new

puts p.name     # =&gt; My name is Person
puts p.address  # =&gt; address not defined on #&lt;Person:0x007fb2bb022fe0&gt;
</code></pre>

<p><code>method_missing</code> 接收两个参数：被调用的方法名和传递给该方法的参数。
首先Ruby会寻找我们试图调用的方法，如果方法没找到则会寻找 <code>method_missing</code> 方法。
现在我们重载了 <code>Person</code> 中的 <code>method_missing</code>，因此Ruby将会调用它而不是抛出异常。</p>

<p>让我们来看看 <code>Rake</code> 是如何使用 <code>method_missing</code> 的。</p>

<h3>Rake中的 <code>method_missing</code></h3>

<p><code>Rake</code> 是Ruby中使用最广泛的gem包之一。<code>Rake</code> 使用 <code>method_missing</code> 来提供访问传递给Rake任务的参数。
首先创建一个简单的rake任务：</p>

<pre><code class="ruby">task :hello do
  puts "Hello"
end
</code></pre>

<p>如果你通过调用 <code>rake hello</code> 来执行这个任务，你会看到输出 <code>Hello</code>。
让我们扩展这个rake任务，以便接收一个参数（一个人名）并向他打招呼：</p>

<pre><code class="ruby">task :hello, :name do |t, args|
  puts "Hello #{args.name}"
end
</code></pre>

<p><code>t</code> 是任务名，<code>args</code> 保存了传递过来的参数。正如你所见，我们调用 <code>args.name</code> 来获取传递给 <code>hello</code> 任务的 <code>name</code> 参数。
运行该任务，并传递一个参数：</p>

<pre><code class="ruby">rake hello["Imran Latif"]
=&gt; Hello Imran Latif
</code></pre>

<p>让我们来看看 <code>Rake</code> 是如何使用 <code>method_missing</code> 为我们提供了传递给任务的参数的。</p>

<p>在上面任务中的 <code>args</code> 对象是一个 <code>Rake::TaskArguments</code> 实例，它是在<a href="https://github.com/ruby/rake/blob/v10.4.2/lib/rake/task_arguments.rb">这里</a>所定义。
这个类负责管理传递给Rake任务的参数。查看 <code>Rake::TaskArguments</code> 的代码，你会发现并没有定义相关的方法将参数传给任务。
那么 <code>Rake</code> 是如何将参数提供给任务的呢？答案是 <code>Rake</code> 是使用了 <code>method_missing</code> 巧妙地实现了这个功能。
看看第64行 <code>method_missing</code> 的定义：</p>

<pre><code class="ruby">def method_missing(sym, *args)
  lookup(sym.to_sym)
end
</code></pre>

<p>在这个类中定义 <code>method_missing</code> 是为了保证能够访问到那些未定义的方法，而不是由Ruby抛出异常。
在 <code>method_missing</code> 中它调用了 <code>lookup</code> 方法：</p>

<pre><code class="ruby">def lookup(name)
  if @hash.has_key?(name)
   @hash[name]
  elsif @parent
    @parent.lookup(name)
  end
end
</code></pre>

<p><code>method_missing</code> 调用 <code>lookup</code>，并将方法名以 <code>Symbol(符号)</code> 的形式传递给它。
<code>lookup</code> 方法将会在 <code>@hash</code> 中进行查找，它是在 <code>Rake::TaskArguments</code> 的构造函数中创建的。
如果 <code>@hash</code> 中包含该参数则返回，如果在 <code>@hash</code> 中没有则 <code>Rake</code> 会尝试调用 <code>@parent</code> 的 <code>lookup</code>。
如果该参数没有找到，则什么都不返回。</p>

<p>这就是 <code>Rake</code> 如何巧妙地使用 <code>method_missing</code> 提供了访问传递给Rake任务的参数的。
感谢<a href="https://twitter.com/jimweirich">Jim Weirich</a>编写了Rake。</p>

<h1>结束语</h1>

<p>我们讨论了5个重要的Ruby钩子方法，探索了它们是如何工作的，以及一些流行的框架/gem包是如何使用它们来提供一些优雅的功能。
我希望你能喜欢这篇文章。请在评论中告诉我们你所喜欢的Ruby钩子，以及你使用它们所解决的问题。</p>

<p>原文地址： <a href="http://www.sitepoint.com/rubys-important-hook-methods/">http://www.sitepoint.com/rubys-important-hook-methods/</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[使用Unicorn部署rails应用]]></title>
    <link href="http://www.xefan.com/archives/84142.html"/>
    <updated>2015-04-05T20:47:15+08:00</updated>
    <id>http://www.xefan.com/archives/84142-使用Unicorn部署rails应用</id>
    <content type="html"><![CDATA[<p>玩 rails 也有段时间了，最近研究下怎么部署一个 rails 应用。在几年前的话要部署 rails 应用是件很麻烦的事，
但是近几年出现了一些比较好的工具可以方便的进行 rails 部署。如： Unicorn、thin、Passenger等。</p>

<p>Unicorn 是一个 Rack 应用的HTTP服务器。之前玩 Python 的时候也有一个 Gunicorn ，使用它来部署 Python 的 Web 应用
也很方便，可以参考我之前的那篇文件 <a href="84138.html">《使用gunicorn部署Django》</a> 。</p>

<p>接下来简单分享下使用 Nginx + Unicorn 来部署 rails 的配置。</p>

<h2>安装</h2>

<p>首先安装 unicorn 包： <code>$ gem install unicorn</code></p>

<p>然后编译一下静态文件：</p>

<pre><code>$ RAILS_ENV=production rake assets:clean
$ RAILS_ENV=production rake assets:precompile
</code></pre>

<p>下载配置文件： <code>$ curl -o config/unicorn.rb https://raw.github.com/defunkt/unicorn/master/examples/unicorn.conf.rb</code></p>

<p>接着根据情况修改相关配置，如： working_directory、listen 等。
例如我的是需要同时监听网络端口和 sock 文件，那么我的 listen 设置如下：</p>

<pre><code>listen "#{root_path}/tmp/sockets/unicorn.sock", :backlog =&gt; 64
listen 8081, :tcp_nopush =&gt; true
</code></pre>

<h2>配置 Nginx</h2>

<p>然后配置 Nginx 的反向代理，以下是我的 Nginx 配置示例：</p>

<pre><code>upstream rails_server {
  server unix:/app_path/tmp/sockets/unicorn.sock fail_timeout=0;
}

server {
  listen 80;
    server_name webserver localhost;

    root /app_path/public;

  try_files $uri $uri @unicorn;

  location @unicorn {
    proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
    proxy_set_header Host $http_host;
    proxy_redirect off;
    proxy_pass http://rails_server;
  }

  location ~ /\.ht {
    deny  all;
  }
}
</code></pre>

<h2>启动服务</h2>

<p>配置完成之后，最后启动服务。</p>

<pre><code>$ bundle exec unicorn_rails -c config/unicorn.rb -D -E production
$ sudo service nginx start
</code></pre>

<p>然后再在浏览器中访问试试。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Vagrant使用笔记]]></title>
    <link href="http://www.xefan.com/archives/84141.html"/>
    <updated>2015-02-24T19:17:43+08:00</updated>
    <id>http://www.xefan.com/archives/84141-Vagrant使用笔记</id>
    <content type="html"><![CDATA[<p>Vgrant是一个基于 Ruby 使用 Virtualbox 进行创建和部署虚拟化环境的工具。
类似的工具之前有使用过 Docker。就我个人而言这两款工具之间，Docker是轻量级的VM，
因此性能应该会比较好，但是只能在64位的系统下使用。
而 Vgrant 是使用 Virtualbox 进行虚拟化，因此性能上不及 Docker，
不过它可以在32/64位的 Linux、Windows 等系统上运行。</p>

<p>我觉得 Vgrant 比较适合用于在开发环境中使用，而 Docker 比较适合用于生产环境。</p>

<h2>安装</h2>

<p>首先安装 virtualbox，然后再安装 Vgrant。</p>

<p>1.通过源代码安装</p>

<pre><code>git clone https://github.com/mitchellh/vagrant
cd vagrant
bundle install
rake install
</code></pre>

<p>2.通过安装包安装<br/>
根据情况选择下载对应的安装包： <a href="http://www.vagrantup.com/downloads.html">http://www.vagrantup.com/downloads.html</a></p>

<p>注意：如果是 Windows 系统，可能还需要将 Vgrant 的路径添加到环境变量中，以便使用 vgrant 命令。</p>

<h2>使用</h2>

<p>Vagrant 的使用方法也很简单，基本如下：</p>

<pre><code># 这里我先添加一个 ArchLinux 的镜像
vagrant box add archlinux http://vagrant.srijn.net/archlinux-x64-2014-01-07.box
# 进行初始化
vagrant init archlinux
# 运行虚拟机
vagrant up
# 如果需要进行ssh连接到虚拟机中进行一些操作，可以执行该命令
vagrant ssh
</code></pre>

<p>其他的一些命令：</p>

<pre><code># 关闭虚拟机
vagrant halt
# 删除创建的虚拟机
vagrant destroy
</code></pre>

<p>vagrant的一些镜像： <a href="http://www.vagrantbox.es/">http://www.vagrantbox.es/</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[使用ruby开发vim插件]]></title>
    <link href="http://www.xefan.com/archives/84117.html"/>
    <updated>2014-07-03T00:00:00+08:00</updated>
    <id>http://www.xefan.com/archives/84117-使用ruby开发vim插件</id>
    <content type="html"><![CDATA[<p>作为一个Vimmer和Pythoner，之前折腾过用python编写vim插件。现在作为半个Rubist，又开始继续折腾。</p>


<p>在开始编写插件之前，你需要确认 Vim 是否支持 Ruby，通过以下命令来判别：</p>


<pre><code>$ vim --version | grep +ruby
</code></pre>


<p>如果输出为空，则表示你当前的vim不支持Ruby，需要重新编译一下，并启用对Ruby的支持。</p>


<p>顺便说下我当前的环境是：</p>


<ul>
<li>vim 7.4  </li>
<li>ruby 2.1.0  </li>
</ul>


<p>环境检查没有问题那么就开始吧。<br>
在~/.vim/plugin目录下创建一个 demo.vim 文件。</p>


<p>在开头写上以下代码：</p>


<pre><code>if !has('ruby')
    echo "Error: Required vim compiled with +ruby"
    finish
endif
</code></pre>


<p>这段代码就是用 VimL 编写的，它将检查 Vim 是否支持 Ruby。</p>


<p>接下来再判断该插件是否已经加载过了，以免重复加载：</p>


<pre><code>if exists('g:loaded_ruby_demo_plugin')
    finish
endif
let g:loaded_ruby_demo_plugin = 1
</code></pre>


<p>所有的检查都没有问题，则开始插件的正文了。先定义一个函数。</p>


<pre><code>function! DemoFun1()
ruby&lt;&lt;EOF
buf = VIM::Buffer.current
puts "current buffer name: #{buf.name} number: #{buf.number} length: #{buf.length}"
EOF
endfunction
</code></pre>


<p>function与endfunction是vim中用于定义函数的，在”ruby&lt;&lt;EOF”和”EOF”之间部分的是Ruby代码。这个例子是输出当前缓冲区的名字、编号以及总行数。<br>
执行命令:call DemoFun1()，应该就可以看到输出结果了。</p>


<p>然后再举个例子说下函数的参数处理。</p>


<pre><code>function! DemoFun2(arg1)
ruby&lt;&lt; EOF
puts "you input: #{VIM.evaluate('a:arg1')}"
EOF
endfunction
</code></pre>


<p>这里定义了一个函数接收一个参数，然后将其输出。使用 VIM.evaluate 将vim的变量转化为Ruby的变量。</p>


<p>为了方便我们再定义两个命令，以简化对这两个函数的调用。</p>


<pre><code>command! -nargs=0 DemoFun1 call DemoFun1()  
command! -nargs=1 -rang DemoFun2 call DemoFun2(&lt;f-args&gt;)
</code></pre>


<p>要获取完整的代码可以访问： https://gist.github.com/wusuopu/c1182efefa85d4f6839b</p>


<p>接下来再简单说下vim中Ruby的使用。</p>


<p>vim为Ruby提供了一个VIM模块，通过它可以在Ruby中访问vim的接口。同时还提供了两个全局变量：$curwin、$curbuf，它们分别代表了当前窗口对象以及当前缓冲区对象。</p>


<p>VIM模块中有 Buffer 和 Window 两个对象，分别是用来对缓冲区和窗口进行操作的。同时VIM模块还提供了message、set_option、command和evaluate四个函数。</p>


<p>想要查看更多的帮忙信息，可以在vim中执行如下命令：</p>


<pre><code>:help ruby
</code></pre>


<p>好了，先写这么多吧，其余的自己去尝试吧。</p>

]]></content>
  </entry>
  
</feed>
