<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Tag: React | 龍昌博客]]></title>
  <link href="http://www.xefan.com/tags/react/atom.xml" rel="self"/>
  <link href="http://www.xefan.com/"/>
  <updated>2016-07-31T13:42:03+08:00</updated>
  <id>http://www.xefan.com/</id>
  <author>
    <name><![CDATA[龍昌]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[ReactNative获取设备屏幕尺寸]]></title>
    <link href="http://www.xefan.com/archives/84164.html"/>
    <updated>2016-07-31T16:25:17+08:00</updated>
    <id>http://www.xefan.com/archives/84164-ReactNative获取设备屏幕尺寸</id>
    <content type="html"><![CDATA[<p>在做移动开发过程中，有时我们需要适配不同尺寸大小的屏幕。这里我们就需要到获取设备屏幕的大小。
由于我们是使用的 ReactNative 来开发手机 app，这里就介绍一下在 ReactNative 中如何获取到设备屏幕的分辨率的。
也算是对之前踩坑的总结吧。</p>

<p>在此之前需要先了解 ReactNative 中的尺寸计算单位，它并不是使用的px。<a href="http://facebook.github.io/react-native/releases/next/docs/pixelratio.html">http://facebook.github.io/react-native/releases/next/docs/pixelratio.html</a></p>

<h2>使用 Dimensions 模块</h2>

<p>在 ReactNative 中有一个 Dimensions 模块，通过它可以获取当前设备的屏幕分辨率。
参考： <a href="http://facebook.github.io/react-native/releases/next/docs/dimensions.html">http://facebook.github.io/react-native/releases/next/docs/dimensions.html</a></p>

<pre><code>var {height, width} = Dimensions.get('window');
</code></pre>

<p>刚开始时我也是使用这种方法来得到整个屏幕的分辨率的，感觉轻松搞定。然而这里面却有一个坑。</p>

<p>首先来看看 ios 和 android 中的界面结构：</p>

<p><img src="/wp-content/uploads/2016/07/31/ios-screen-struct.png" alt="ios-screen-struct" />
<img src="/wp-content/uploads/2016/07/31/android-screen-struct.png" alt="android-screen-struct" /></p>

<p>如图所示，屏幕的宽度计算比较简单，就是从左边到右边的距离即可。
然后就是屏幕的高度了，这里其实我们是需要获取到可用区域的高度。
如图所示，对于 ios 系统来说可用区域高度就是整个屏幕的高度减去 Status Bar 的高度；
对于 android 系统来说就是屏幕的高度减去 Status Bar 和 Soft Menu Bar 的高度。</p>

<h2>获取 iOS 设备的屏幕分辨率</h2>

<p>正如上面所说的，在 ios 下的计算方法为：</p>

<pre><code>var WIDTH = Dimensions.get('window').width;
var HEIGHT = Dimensions.get('window').height - STATUS_BAR_HEIGHT;
</code></pre>

<p>在 ios 系统状态栏高度(STATUS_BAR_HEIGHT)通常为 20。
不过如果你设置了隐藏状态栏的话，那么 <code>STATUS_BAR_HEIGHT</code> 则为0。</p>

<p>以上是手机竖屏的情况，在横屏状态下则交换两个值：</p>

<pre><code>var LANDSCAPE_WIDTH = HEIGHT + STATUS_BAR_HEIGHT;
var LANDSCAPE_HEIGHT = WIDTH - STATUS_BAR_HEIGHT;
</code></pre>

<p>到了这里虽然麻烦了一点，但是总体来说也还好。问题都解决了。
感觉生活是如此美好啊，然而这个世界上却还有一个系统名为 android。
它有着数不清种类屏幕大小的设备，然后瞬间感觉整个人都不好了。</p>

<h2>获取 Android 设备的屏幕分辨率</h2>

<p>如果按照 ios 下的方法来做，获取到 <code>WIDTH</code> 是没有问题，
但是 <code>HEIGHT</code> 的话还需要减去 Status Bar 和 Soft Menu Bar 的高度。
因此我们还需要获取到状态栏的高度(STATUS_BAR_HEIGHT)和虚拟按钮的高度(SOFT_MENU_BAR_HEIGHT)。</p>

<p>这里我们使用<a href="https://github.com/jaysoo/react-native-extra-dimensions-android">react-native-extra-dimensions-android</a>这个库。</p>

<pre><code>const ExtraDimensions = require('react-native-extra-dimensions-android');

const STATUS_BAR_HEIGHT = ExtraDimensions.get('STATUS_BAR_HEIGHT');
const SOFT_MENU_BAR_HEIGHT = ExtraDimensions.get('SOFT_MENU_BAR_HEIGHT');
const WIDTH = ExtraDimensions.get('REAL_WINDOW_WIDTH');
const HEIGHT = ExtraDimensions.get('REAL_WINDOW_HEIGHT') - STATUS_BAR_HEIGHT - SOFT_MENU_BAR_HEIGHT;
</code></pre>

<p>以上是设备竖屏的结果，在横屏下你以为是不是只需要交换两个值就搞定了呢。</p>

<pre><code>var LANDSCAPE_WIDTH = HEIGHT + STATUS_BAR_HEIGHT;
var LANDSCAPE_HEIGHT = WIDTH - STATUS_BAR_HEIGHT;
</code></pre>

<p>Naive!!如果这么轻松就搞定了的话，android就不叫做android了。</p>

<p>先来看看下面两张图片吧，分别是一个android平板设备在横屏和竖屏状态下的截图：</p>

<p><img src="/wp-content/uploads/2016/07/31/android-pad-landscape.png" alt="android-pad-landscape" />
<img src="/wp-content/uploads/2016/07/31/android-pad-portrait.png" alt="android-pad-portrait" /></p>

<p>你把你手中的 android 手机分别进入横屏和竖屏状态下，再对照上面两张图片你会发现什么。
没错的，在平板设备上屏幕旋转之后 Soft Menu Bar 也跟着旋转了，
而在手机设备上 Soft Menu Bar 是始终固定在手机底部的。</p>

<p>尼玛，太坑爹了。看到这里瞬间呕血三升，要适配手机跟平板实现是太麻烦了。
以下是我的解决办法，先检查当前设备是否为平板，然后再分别处理。
至于平板的判断方法就自己想办法了，我的方法也不一定准。</p>

<pre><code>if (isPad) {
  LANDSCAPE_WIDTH = HEIGHT + STATUS_BAR_HEIGHT + SOFT_MENU_BAR_HEIGHT;
  LANDSCAPE_HEIGHT = WIDTH - STATUS_BAR_HEIGHT - SOFT_MENU_BAR_HEIGHT;
} else {
  LANDSCAPE_WIDTH = HEIGHT + STATUS_BAR_HEIGHT;
  LANDSCAPE_HEIGHT = WIDTH - STATUS_BAR_HEIGHT;
}
</code></pre>

<p>以上是在 android 下遇到的第一个大坑。</p>

<p>到了这里我以为一切都该结束了吧，然而没想到还有一种手机叫做魅族。如下图：</p>

<p><img src="/wp-content/uploads/2016/07/31/Mezu-smart-bar.png" alt="Mezu-smart-bar" /></p>

<p>在屏幕右下角其实是有一个按钮的，然而左图所示的，该按钮被魅族手机的 Smart Bar 遮住了。
进入系统设置将 Smart Bar 隐藏后效果如右图所示。</p>

<p>看到这里又吐了两口老血，此为第二个大坑。</p>

<pre><code>const SMART_BAR_HEIGHT = ExtraDimensions.get('SMART_BAR_HEIGHT');

if (SMART_BAR_HEIGHT) {
  HEIGHT -= SMART_BAR_HEIGHT;
}

....
// 在上面 LANDSCAPE 的计算结果上再作如下处理

if (SMART_BAR_HEIGHT) {
  LANDSCAPE_WIDTH += SMART_BAR_HEIGHT;
  LANDSCAPE_HEIGHT -= SMART_BAR_HEIGHT;
}
</code></pre>

<p>在魅族的手机上计算屏幕高度时还需要再减去 Smart Bar 的高度，
同时还需要注意的是， Smart Bar 跟平板上的Soft Menu Bar 一样会随着屏幕旋转而转动的。</p>

<p>最后还有一点需要注意的是，在安装 <code>react-native-extra-dimensions-android</code> 库时不能直接使用 <code>npm install --save react-native-extra-dimensions-android</code> 进行安装，
而是需要直接通过 git 仓库来安装： <code>npm install --save git+https://github.com/jaysoo/react-native-extra-dimensions-android.git</code>。</p>

<p>因为在 npm 上 <code>react-native-extra-dimensions-android</code> 的最新版为 0.17.0，
而 <code>SMART_BAR_HEIGHT</code> 的功能是在此之后才添加进来的。</p>

<p>在库的版本上面又被坑了一下。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[ReactNative Jsbundle管理]]></title>
    <link href="http://www.xefan.com/archives/84163.html"/>
    <updated>2016-06-26T12:02:30+08:00</updated>
    <id>http://www.xefan.com/archives/84163-ReactNative jsbundle管理</id>
    <content type="html"><![CDATA[<p>在<a href="http://www.xefan.com/archives/84162.html">上一篇文章</a>中介绍了 RN(ReactNative) 自动设置 development server IP 的方法。
这在开发过程中方便了不少，然而我在想能否更加方便一些呢。首先我们知道在开发 RN 应用时，jsbundle 有两种加载方式。
第一种是指定 url 通过网络进行加载；第二种是 pre-bundled 将 jsbundle 文件打包进 app 安装包中。
编译生成的安装包有 Debug 和 Release 两种模式，在 Debug 模式下默认是使用第一种方式加载 jsbundle，在 Release 模式下默认是使用第二种方式。</p>

<p>现在我的需求是编译生成三种模式的安装包：Debug、Release 和 Stage。前两种跟之前一样，
而 Stage 模式下是使用第二种方式加载 jsbundle， 但是生成的 jsbundle 是 DEV 状态下的。
这样在开发过程中给他人安装app进行测试时就不需要反复的修改配置了。</p>

<h2>修改 Android 的配置</h2>

<p>对于的 android 的配置比较简单。只需修改 <code>android/app/build.gradle</code> 文件，新添加一个 <code>buildTypes</code> 即可。</p>

<p>在 <code>apply from: "react.gradle"</code> 之前添加如下内容：</p>

<pre><code>project.ext.react = [
  bundleInStage: true
]
</code></pre>

<p>然后再修改配置如下：</p>

<pre><code>android {
    buildTypes {
        debug {
            applicationIdSuffix ".debug"
            resValue 'string', 'app_name', '"XXXX(Debug)"'
            ......
        }
        release {
            minifyEnabled enableProguardInReleaseBuilds
            proguardFiles getDefaultProguardFile("proguard-android.txt"), "proguard-rules.pro"
            resValue 'string', 'app_name', '"XXXX"'
            ......
        }
        stage {
            initWith(buildTypes.debug)
            applicationIdSuffix ".stage"
            resValue 'string', 'app_name', '"XXXX(Stage)"'
        }
    }
}
</code></pre>

<p>这里添加了一个 <code>stage</code> buildTypes 继承至 <code>debug</code>。并且为了能够同时安装不同模式下的app，这里设置了不同模式 bundleID 的后缀。
同时还设置了不同模式下app的名称，以便区分。</p>

<p>然后进行 <code>android</code> 目录下执行 <code>./gradlew assemble</code> 命令，即可在 <code>android/app/build/outputs/apk</code> 目录生成 app-debug.apk、app-release.apk 和 app-stage.apk 三个 apk 包。</p>

<h2>修改 iOS 的配置</h2>

<p>首先将 Debug Configuration 复制为 Stage
<img src="/wp-content/uploads/2016/06/26/Xcode-configuration.png" alt="Xcode-configuration" /></p>

<p>然后进入 <code>Build Settings</code> 修改 <code>Preprocessor Macros</code>，对 <code>Stage</code> 添加一项配置： <code>STAGE=1</code>
<img src="/wp-content/uploads/2016/06/26/Xcode-buildSettings.png" alt="Xcode-buildSettings" /></p>

<p>然后再编辑 <code>AppDelegate.m</code> 文件，修改 <code>jsCodeLocation</code> 相关配置。</p>

<pre><code>#if STAGE
#warning "STAGE"
  jsCodeLocation = [[NSBundle mainBundle] URLForResource:@"main" withExtension:@"jsbundle"];
#elif DEBUG
#if TARGET_OS_SIMULATOR
#warning "DEBUG SIMULATOR"
  jsCodeLocation = [NSURL URLWithString:@"http://localhost:8081/index.ios.bundle?platform=ios&amp;dev=true"];
#else
#warning "DEBUG DEVICE"
  NSString *serverIP = [[NSBundle mainBundle] objectForInfoDictionaryKey:@"SERVER_IP"];
  NSString *jsCodeUrlString = [NSString stringWithFormat:@"http://%@:8081/index.ios.bundle?platform=ios&amp;dev=true", serverIP];
  NSString *jsBundleUrlString = [jsCodeUrlString stringByAddingPercentEscapesUsingEncoding:NSUTF8StringEncoding];
  jsCodeLocation = [NSURL URLWithString:jsBundleUrlString];
#endif
#else
#warning "PRODUCTION DEVICE"
  jsCodeLocation = [[NSBundle mainBundle] URLForResource:@"main" withExtension:@"jsbundle"];
#endif
</code></pre>

<p>为了能够同时安装多个应用，还需要设置各个模式下的 Bundle Identifier。进入 <code>Build Settings</code> -> <code>Packaging</code> -> <code>Product Bundle Identifier</code>
<img src="/wp-content/uploads/2016/06/26/Xcode-bundleID.png" alt="Xcode-bundleID" /></p>

<p>为了便于区分，最好给各个模式下的应用设置不同的AppName。进入 <code>Build Settings</code> -> <code>User-Defined</code>，添加一项设置
<img src="/wp-content/uploads/2016/06/26/Xcode-User-Defined.png" alt="Xcode-User-Defined" /></p>

<p>然后再进入 <code>Info</code>，设置 <code>CFBundleDisplayName</code> 的值为 <code>$(BUNDLE_DISPLAY_NAME)</code></p>

<p>至此，配置已经修改完成。如果之前有使用 cocoapods 安装过第三方库的话，那么可能还需要再重新安装一遍。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[ReactNative自动设置开发服务器IP]]></title>
    <link href="http://www.xefan.com/archives/84162.html"/>
    <updated>2016-06-18T21:40:01+08:00</updated>
    <id>http://www.xefan.com/archives/84162-ReactNative自动设置开发服务器IP</id>
    <content type="html"><![CDATA[<p>在开发 ReactNative 应用时，jsbundle 有两种加载方式。第一种是指定 url 通过网络进行加载；第二种是 pre-bundled 将 jsbundle 文件打包进 app 安装包中。</p>

<p>以下就是创建项目之后 ios 的默认配置。</p>

<pre><code>  /**
   * Loading JavaScript code - uncomment the one you want.
   *
   * OPTION 1
   * Load from development server. Start the server from the repository root:
   *
   * $ npm start
   *
   * To run on device, change `localhost` to the IP address of your computer
   * (you can get this by typing `ifconfig` into the terminal and selecting the
   * `inet` value under `en0:`) and make sure your computer and iOS device are
   * on the same Wi-Fi network.
   */

  jsCodeLocation = [NSURL URLWithString:@"http://localhost:8081/index.ios.bundle?platform=ios&amp;dev=true"];

  /**
   * OPTION 2
   * Load from pre-bundled file on disk. The static bundle is automatically
   * generated by the "Bundle React Native code and images" build step when
   * running the project on an actual device or running the project on the
   * simulator in the "Release" build configuration.
   */

//   jsCodeLocation = [[NSBundle mainBundle] URLForResource:@"main" withExtension:@"jsbundle"];
</code></pre>

<p>这里有个麻烦的地方就是，当我在真机设备上调试时。每次都需要执行 <code>ifconfig</code> 命令，然后将 <code>localhost</code> 修改为我的 ip 地址。并且在使用 git 进行代码管理时，一不小心将修改后的文件提交上去了，其他同事在 pull 时又会与自己的冲突。
最终实在忍受不了了，在想能不能编译时自动获取到本机的 ip 呢，这样就不用每次都手动修改了。于是找到了这篇文章： <a href="http://moduscreate.com/automated-ip-configuration-for-react-native-development/">http://moduscreate.com/automated-ip-configuration-for-react-native-development/</a>
我这里参考了他的方案并做了一点小调整。</p>

<p>按照他的步骤，首先添加 Run Script。
在 Xcode 中选择“Build Phases”，然后点击左上角的&#8221;+&ldquo;选择“New Run Script Phase”。
在列表最后出现了“Run Script”，将其展开，然后编辑代码块的内容：</p>

<pre><code>INFOPLIST="${TARGET_BUILD_DIR}/${INFOPLIST_PATH}"
echo "writing to $INFOPLIST"
PLISTCMD="Add :SERVER_IP string $(ifconfig | grep inet\ | tail -1 | cut -d " " -f 2)"
echo -n "$INFOPLIST" | xargs -0 /usr/libexec/PlistBuddy -c "$PLISTCMD" || true
PLISTCMD="Set :SERVER_IP $(hostname)"
echo -n "$INFOPLIST" | xargs -0 /usr/libexec/PlistBuddy -c "$PLISTCMD" || true
</code></pre>

<p>第二步编辑 <code>AppDelegate.m</code> 文件。
将项目默认生成的 <code>jsCodeLocation</code> 配置删除掉，并添加代码：</p>

<pre><code>#if DEBUG
#if TARGET_OS_SIMULATOR
#warning "DEBUG SIMULATOR"
  jsCodeLocation = [NSURL URLWithString:@"http://localhost:8081/index.ios.bundle?platform=ios&amp;dev=true"];
#else
#warning "DEBUG DEVICE"
  NSString *serverIP = [[NSBundle mainBundle] objectForInfoDictionaryKey:@"SERVER_IP"];
  NSString *jsCodeUrlString = [NSString stringWithFormat:@"http://%@:8081/index.ios.bundle?platform=ios&amp;dev=true", serverIP];
  NSString *jsBundleUrlString = [jsCodeUrlString stringByAddingPercentEscapesUsingEncoding:NSUTF8StringEncoding];
  jsCodeLocation = [NSURL URLWithString:jsBundleUrlString];
#endif
#else
#warning "PRODUCTION DEVICE"
  jsCodeLocation = [[NSBundle mainBundle] URLForResource:@"main" withExtension:@"jsbundle"];
#endif
</code></pre>

<p>这里如果在模拟器中进行调试，那么 development server 则为 localhost；如果在真机设备中调试,那么 development server 则为电脑的 ip 地址。
到此已经可以实现自动设置 ip 地址了，如果还想要在 Chrome 中对设备进行调试，那么还需要修改一下 WebSocket 的配置。</p>

<p>第三步编辑 <code>RCTWebSocketExecutor.m</code> 文件。
在 Xcode 中打开 <YourProject> -> Libraries -> RCTWebSocket.xcodeproj -> RCTWebSocketExecutor.m 文件，大概在文件 53 行左右的位置，将 <code>NSString *URLString = [NSString stringWithFormat:@"http://localhost:%zd/debugger-proxy?role=client", port];</code> 修改为：</p>

<pre><code>#if TARGET_OS_SIMULATOR
    NSString *serverIP = @"localhost";
#else
    NSString *serverIP = [[NSBundle mainBundle] objectForInfoDictionaryKey:@"SERVER_IP"];
#endif
    NSString *URLString = [NSString stringWithFormat:@"http://%@:%zd/debugger-proxy?role=client", serverIP, port];
</code></pre>

<p>现在配置已经完成了，接下来就试试看是否有效吧。</p>

<p>经过修改之后相对于之前已经方便了不少，只是我还遇到一个问题。那就是我的 MacBook 在办公室时的 ip 跟在家里的 ip 是不同的。
这样的话每次切换环境都需要重新编译一下应用，还是有点麻烦。于是乎我自己将第一步的脚本作了下修改，新的内容如下：</p>

<pre><code>INFOPLIST="${TARGET_BUILD_DIR}/${INFOPLIST_PATH}"
echo "writing to $INFOPLIST"
PLISTCMD="Add :SERVER_IP string $(hostname)"
echo -n "$INFOPLIST" | xargs -0 /usr/libexec/PlistBuddy -c "$PLISTCMD" || true
PLISTCMD="Set :SERVER_IP $(hostname)"
echo -n "$INFOPLIST" | xargs -0 /usr/libexec/PlistBuddy -c "$PLISTCMD" || true
</code></pre>

<p>这里我使用 hostname 来作为 development server 的地址，而不是 ip。这样的话即便是网络环境发生了变化，只要手机设备跟电脑处于同一个局域网内就不需要再重新编译应用了。</p>
]]></content>
  </entry>
  
</feed>
