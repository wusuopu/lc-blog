<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Tag: Mongodb | 龍昌博客]]></title>
  <link href="http://www.xefan.com/tags/mongodb/atom.xml" rel="self"/>
  <link href="http://www.xefan.com/"/>
  <updated>2015-04-05T21:18:11+08:00</updated>
  <id>http://www.xefan.com/</id>
  <author>
    <name><![CDATA[龍昌]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Mongodb分片配置实例]]></title>
    <link href="http://www.xefan.com/archives/84139.html"/>
    <updated>2014-12-29T16:52:37+08:00</updated>
    <id>http://www.xefan.com/archives/84139-Mongodb分片配置实例</id>
    <content type="html"><![CDATA[<p>数据分片即是从一个集合中选择一个片键(shard key)作为数据拆分的依据，原理与索引类似，然后将集合的数据拆分并保存到不同的服务器上。
以下通过一个例子来介绍一下Mongodb的分片配置。</p>

<p>有四台主机：</p>

<ul>
<li>172.17.0.6    (配置服务器)</li>
<li>172.17.0.7    (mongos)</li>
<li>172.17.0.8    (片服务器)</li>
<li>172.17.0.9    (片服务器)</li>
</ul>


<p>1.在 172.17.0.6 上启动 mongod 服务作为配置服务器；<br/>
修改配置，使其作为一个配置服务器，默认监听 27019 端口。</p>

<pre><code>configsvr = true
</code></pre>

<p>启动服务 <code>$ service mongodb start</code></p>

<p>2.在 172.17.0.7 上启动 mongos 服务作为路由服务;<br/>
建立mongos进程。(可以有多台配置服务器)，用法如下：</p>

<pre><code>$ mongos --configdb &lt;config server hostnames&gt;[,&lt;config server hostnames&gt;]
</code></pre>

<p>例如： <code>$ mongos --configdb 172.17.0.6:27019</code></p>

<p>注意：在同一个分片集群中的每个 mongos 必须使用相同的 configDB 配置。</p>

<p>3.添加分片<br/>
一个片服务既可以是单个 mongod 实例，也可以是一个副本集。<br/>
1).先分别在 172.17.0.8 和 172.17.0.9 上启动片服务器，即就是一个普通的 mongod 服务。</p>

<pre><code>$ service mongodb start
</code></pre>

<p>2).使用 mongo 客户端连接到 mongos 服务</p>

<pre><code>$ mongo --host &lt;hostname of machine running mongos&gt; --port &lt;port mongos listens on&gt;
</code></pre>

<p>如： <code>$ mongo --host 172.17.0.7 --port 27017</code></p>

<p>3).在 mongo 客户端上执行命令添加分片：</p>

<pre><code>&gt; use admin
&gt; db.auth(&lt;user&gt;, &lt;pswd&gt;)
&gt; sh.addShard("172.17.0.8:27017")
&gt; sh.addShard("172.17.0.9:27017")
</code></pre>

<p>4.切片数据<br/>
1).首先对数据库进行切片<br/>
使用 mongo 客户端连接到 mongos ，执行命令打开数据库的分片功能，用法如下：</p>

<pre><code>&gt; sh.enableSharding("&lt;database&gt;")
</code></pre>

<p>例如要打开 mydb 数据库的分片功能： <code>&gt; sh.enableSharding("mydb")</code></p>

<p>2).然后对数据集合进行切片<br/>
命令用法如下：</p>

<pre><code>&gt; sh.shardCollection("&lt;database&gt;.&lt;collection&gt;", shard-key-pattern)
</code></pre>

<p><code>shard-key-pattern</code> 与索引的用法一样，例如，要对 mydb 数据库的 test 集合按照 <code>_id</code> 字段进行分片： <code>&gt; sh.shardCollection("mydb.test", {"_id": "hashed"})</code></p>

<p>接下来通过一个程序来测试一下，向数据库中添加10000条数据：</p>

<pre><code class="ruby">#!/usr/bin/env ruby
#-*- coding:utf-8 -*-

require "mongo"

begin
  conn = Mongo::Connection.new '172.17.0.7'
  db = conn['mydb']
rescue Exception=&gt;e
  p e
  exit 1
end

i = 0
while i &lt; 10000
  d = {'no' =&gt; i}
  d = db['test'].insert(d)
  i += 1
  puts d
end
</code></pre>

<p>然后分别查看 172.17.0.8 和 172.17.0.9 的状态：</p>

<pre><code>172.17.0.8:
&gt; db.test.count()
4952

172.17.0.9:
&gt; db.test.count()
5048
</code></pre>

<p>数据基本上是平均的分布在两台服务器上。</p>

<p>参考： <a href="http://docs.mongodb.org/manual/tutorial/deploy-shard-cluster/">http://docs.mongodb.org/manual/tutorial/deploy-shard-cluster/</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Mongodb集群配置实例]]></title>
    <link href="http://www.xefan.com/archives/84137.html"/>
    <updated>2014-12-10T20:33:02+08:00</updated>
    <id>http://www.xefan.com/archives/84137-Mongodb集群配置实例</id>
    <content type="html"><![CDATA[<p>Mongodb的集群有两种，一个是主从复制，另一种是副本集。</p>

<h2>主从复制</h2>

<p>根据 Mongodb 的官方文档说明，在生产环境中建议使用副本集代替主从复制。 <a href="http://docs.mongodb.org/manual/core/master-slave/">http://docs.mongodb.org/manual/core/master-slave/</a></p>

<p>不过对于主从复制还是可以了解一下。假设有如下三台主机：</p>

<ul>
<li>172.17.0.4    (主)</li>
<li>172.17.0.5    (从)</li>
<li>172.17.0.6    (从)</li>
</ul>


<p>要进行主从复制的配置，首先修改主服务器的配置信息：</p>

<pre><code>master = true         # 以主服务器模式启动
bind_ip = 0.0.0.0
</code></pre>

<p>然后修改另两台从服务器配置信息：</p>

<pre><code>slave = true
source = 172.17.0.4
bind_ip = 0.0.0.0
</code></pre>

<p>最后启动三台主机上的 Mongodb 服务，再通过一个简单的程序来测试一下。</p>

<pre><code class="ruby">#!/usr/bin/env ruby
#-*- coding:utf-8 -*-

require "mongo"

begin
  conn = Mongo::Connection.new '172.17.0.4'
  db = conn['test']
rescue Exception=&gt;e
  p e
  exit 1
end

i = 0
while i &lt; 100
  d = {'no' =&gt; i}
  d = db['data'].insert(d)
  i += 1
  puts d
end
</code></pre>

<p>执行该脚本，向 <code>172.17.0.4</code> 主机的 Mongodb 中插入一些数据。然后发现数据被同步到了另外两台主机上。</p>

<p>主从之间安全认证：<br/>
如果启动了 <code>auth</code> 项，那么主从之间的认证需要使用 <code>keyFile</code> 选项。</p>

<p>执行如下命令生成 key 文件，并设置为只有 mongodb 的进程用户可读写：</p>

<pre><code>$ openssl rand -base64 741 &gt; /path/mongodb_keyFile
$ chmow 600 /path/mongodb_keyFile
$ chown mongodb:mongodb /path/mongodb_keyFile
</code></pre>

<p>将该文件复制到这三台主机中，然后分别修改主从的配置信息：</p>

<pre><code>keyFile = /path/mongodb_keyFile
</code></pre>

<h2>副本集</h2>

<p>同样的对于这三台主机，我们重新修改配置设置为副本集的形式。</p>

<ul>
<li>172.17.0.4</li>
<li>172.17.0.5</li>
<li>172.17.0.6</li>
</ul>


<p>首先修改配置文件，设置副本集的名字。<br/>
注意：副本集中所有主机设置的名字需要一样。这里我们设为 <code>myrepl0</code>。<br/>
注意：设置副本集之前各个 mongodb 的数据目录必须都为空。</p>

<pre><code>replSet = myrepl0
</code></pre>

<p>接着启动所有 mongodb 服务，然后对副本集进行初始化。<br/>
连接任意一台 mongodb 服务，执行如下操作：</p>

<pre><code>&gt; rs.initiate({'_id': 'myrepl0', 'members': [
    {'_id': 1, 'host': '172.17.0.4:27017'},
    {'_id': 2, 'host': '172.17.0.7:27017'},
    {'_id': 3, 'host': '172.17.0.8:27017'}
]})
</code></pre>

<p>现在副本集的初始化已完成，可以通过如下命令查看状态：</p>

<pre><code>&gt; rs.status()
</code></pre>

<p>在运行过程中可以随时添加或移除一个节点，如：</p>

<pre><code>rs.add("172.17.0.8:27017")
rs.remove("172.17.0.8:27017")
</code></pre>

<p>可以再通过上面的程序添加一些数据。然后再连接到任意一台主机进行查询，看看数据是否已同步。</p>

<p>详细内容可参考文档： <a href="http://docs.mongodb.org/manual/core/replication/">http://docs.mongodb.org/manual/core/replication/</a></p>

<p>安全认证：</p>

<p>1.禁用 auth 选项和 replSet 选项再运行 mongodb</p>

<p>2.连接到该 mongodb 服务并创建用户</p>

<pre><code>&gt; use admin
switched to db admin
&gt; db.addUser('root','root')
{
        "user" : "root",
        "readOnly" : false,
        "pwd" : "2a8025f0885adad5a8ce0044070032b3",
        "_id" : ObjectId("54745351f79804bd44b596fb")
}
&gt; 
</code></pre>

<p>3.重新以 auth、keyFile 和 replSet 模式启动 mongodb</p>

<p>4.连接到刚刚创建用户的 mongodb 服务</p>

<p>5.跟之前的步骤一样，配置副本集</p>

<pre><code>&gt; rs.initiate({'_id': 'myrepl0', 'members': [
    {'_id': 1, 'host': '172.17.0.4:27017'},
    {'_id': 2, 'host': '172.17.0.7:27017'},
    {'_id': 3, 'host': '172.17.0.8:27017'}
]})
</code></pre>

<p>参考： <a href="http://docs.mongodb.org/manual/tutorial/deploy-replica-set-with-auth/">http://docs.mongodb.org/manual/tutorial/deploy-replica-set-with-auth/</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Mongoengine教程(5)——信号]]></title>
    <link href="http://www.xefan.com/archives/84076.html"/>
    <updated>2014-04-06T00:00:00+08:00</updated>
    <id>http://www.xefan.com/archives/84076-mongoengine教程(5)——信号</id>
    <content type="html"><![CDATA[<p>MongoEngine在进行数据操作时会发出一些信号，我们可以连接这些信号进行一些额外的操作。注意：要在MongoEngine中使用信号，需要安装 <em>blinker</em> 这个库。  </p>


<pre><code>$ pip install blinker
</code></pre>


<p>MongoEngine提供的信号如下：  </p>


<ul>
<li>pre_init: 在创建一个新的 Document 或者 EmbeddedDocument 实例对象之后，并且对象初始化之前调用。  </li>
<li>post_init:在 Document 或者 EmbeddedDocument 实例对象初始化完成之后调用。  </li>
<li>pre_save:在 save 方法执行之前调用。  </li>
<li>pre_save_post_validation:在数据检验完成之后，数据保存之前调用。  </li>
<li>post_save:在数据保存完成之后调用。  </li>
<li>pre_delete:在 delete 方法执行之前调用。  </li>
<li>post_delete:在记录成功删除之后调用。  </li>
<li>pre_bulk_insert:在数据检验之后，数据插入之前调用。  </li>
<li>post_bulk_insert:在数据成功插入之后调用。</li>
</ul>


<h2>事件连接</h2>


<p>使用 signals 将信号与回调函数进行连接。</p>


<pre><code>from mongoengine import *
from mongoengine import signals

class Author(Document):
    name = StringField()

    @classmethod
    def pre_save(cls, sender, document, **kwargs):
        print("Pre Save: %s" % document.name)

    @classmethod
    def post_save(cls, sender, document, **kwargs):
        print("Post Save: %s" % document.name)
        if 'created' in kwargs:
            if kwargs['created']:
                print("Created")
            else:
                print("Updated")

signals.pre_save.connect(Author.pre_save, sender=Author)
signals.post_save.connect(Author.post_save, sender=Author)
</code></pre>


<p>注意：对于 RefereneField 的<em>reverse_delete_rules</em>参数不会触发信号。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Mongoengine教程(4)——文件存储]]></title>
    <link href="http://www.xefan.com/archives/84072.html"/>
    <updated>2014-04-05T00:00:00+08:00</updated>
    <id>http://www.xefan.com/archives/84072-mongoengine教程(4)——文件存储</id>
    <content type="html"><![CDATA[<p>MongoDB的GridFS支持直接在数据库中存储文件。要在MongoEngine中使用GridFS，只要使用 FileField 对象即可。以下是一个例子：</p>


<pre><code>class Animal(Document):
    genus = StringField()
    family = StringField()
    photo = FileField()

marmot = Animal(genus='Marmota', family='Sciuridae')

marmot_photo = open('gtk.png', 'rb')
marmot.photo.put(marmot_photo, content_type = 'image/png')
marmot.save()
</code></pre>


<p>这个例子将 gtk.png 这个图片存入了数据库中。<br>
文件的读取也很简单：</p>


<pre><code>marmot = Animal.objects(genus='Marmota').first()
photo = marmot.photo.read()
content_type = marmot.photo.content_type
</code></pre>


<p>FileField不仅可以存储文件，还可以用来存储数据流。只是操作上略微不同。</p>


<p>要存储数据流，首先先创建一个新的文件，然后再往里面写入数据。</p>


<pre><code>marmot.photo.new_file()
marmot.photo.write('some_image_data')
marmot.photo.write('some_more_image_data')
marmot.photo.close()
marmot.save()
</code></pre>


<p>如果要删除存储在数据库中的文件，只需要调用该文件对象的 delete 方法：</p>


<pre><code>marmot.photo.delete()
</code></pre>


<p>注意：一条文档记录中的FileField字段只保存了对GridFS集合中该文件的ID引用。这意味着如果该文档被删除了，对用的文件不会被删除。因此在删除这类文档时需要小心，以免出现孤立文件。</p>


<p>对于已存储的文件可以进行替换修改：</p>


<pre><code>another_marmot = open('python.png', 'rb')
marmot.photo.replace(another_marmot, content_type='image/png')
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Mongoengine教程(3)——数据查询]]></title>
    <link href="http://www.xefan.com/archives/84069.html"/>
    <updated>2014-04-05T00:00:00+08:00</updated>
    <id>http://www.xefan.com/archives/84069-mongoengine教程(3)——数据查询</id>
    <content type="html"><![CDATA[<p>与Django一样，Document类都有一个 objects 属性。它用于将类与数据库关联起来。objects属性是一个QuerySetManager类型的对象，它的操作会返回一个QuerySet类型的对象。可以通过对QuerySet对象的迭代获取数据库中的数据。</p>


<pre><code>class User(Document):
    name = StringField()
    country = StringField()

class Paper(Document):
    content = StringField()
    author = ReferenceField(User)
</code></pre>


<h2>查询过滤</h2>


<p>可以在查询是指定过滤条件以获取想要的结果。例如想要查询英国的用户：</p>


<pre><code>uk_users = User.objects(country='uk')
</code></pre>


<p>与Django类似，要查询引用的对象只需要使用双下划线即可。例如想要查询英国用户的论文：</p>


<pre><code>uk_papers = Paper.objects(author__country='uk')
</code></pre>


<h2>查询操作</h2>


<p>与Django类似，MongoEngine同样也提供了一些条件语句。</p>


<ul>
<li>ne - 不相等</li>
<li>lt - 小于</li>
<li>lte - 小于等于</li>
<li>gt - 大于</li>
<li>gte - 大于等于</li>
<li>not - 取反</li>
<li>in - 值在列表中</li>
<li>nin - 值不在列表中</li>
<li>mod - 取模</li>
<li>all - 与列表的值相同</li>
<li>size - 数组的大小</li>
<li>exists - 字段的值存在</li>
</ul>


<p>例如查询年龄小于等于18岁的用户：</p>


<pre><code>young_users = Users.objects(age__lte=18)
</code></pre>


<p>对于不同类型的数据提供了不同的条件语句。</p>


<h3>查询结果个数限制</h3>


<p>跟传统的ORM一样，MongoEngine也可以限制查询结果的个数。一种方法是在QuerySet对象上调用limit和skip方法；另一种方法是使用数组的分片的语法。例如：</p>


<pre><code>users = User.objects[10:15]
users = User.objects.skip(10).limit(5)
</code></pre>


<h2>聚合操作</h2>


<p>MongoEngine提供了一些数据库的聚合操作。</p>


<p>统计结果个数即可以使用QuerySet的count方法，也可以使用Python风格的方法：</p>


<pre><code>num_users = len(User.objects)
num_users = User.objects.count()
</code></pre>


<p>其他的一些聚合操作。<br>
求和：</p>


<pre><code>yearly_expense = Employee.objects.sum('salary')
</code></pre>


<p>求平均数：</p>


<pre><code>mean_age = User.objects.average('age')
</code></pre>


<h2>高级查询</h2>


<p>有时需要将多个条件进行组合，前面提到的方法就不能满足需求了。这时可以使用MongoEngine的Q类。它可以将多个查询条件进行 &amp;(与) 和 |(或) 操作。</p>


<p>例如下面的语句是查询所有年龄大于等于18岁的英国用户，或者所有年龄大于等于20岁的用户。</p>


<pre><code>User.objects((Q(country='uk') &amp; Q(age__gte=18)) | Q(age__gte=20))
</code></pre>


<h2>在服务器端执行javascript代码</h2>


<p>通过MongoEngine QuerySet对象的 exec_js 方法可以将javascript代码作为字符串发送给服务器端执行，然后返回执行的结果。</p>


<p>例如查询该数据库都有那些集合：</p>


<pre><code>User.objects.exec_js("db.getCollectionNames()")
</code></pre>

]]></content>
  </entry>
  
</feed>
