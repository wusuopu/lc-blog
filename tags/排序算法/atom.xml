<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Tag: 排序算法 | 龍昌博客]]></title>
  <link href="http://www.xefan.com/tags/排序算法/atom.xml" rel="self"/>
  <link href="http://www.xefan.com/"/>
  <updated>2014-12-29T17:06:40+08:00</updated>
  <id>http://www.xefan.com/</id>
  <author>
    <name><![CDATA[龍昌]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Python中的排序算法——Timsort]]></title>
    <link href="http://www.xefan.com/archives/83857.html"/>
    <updated>2013-07-13T00:00:00+08:00</updated>
    <id>http://www.xefan.com/archives/83857-Python中的排序算法——Timsort</id>
    <content type="html"><![CDATA[<p>突然对Python中list对象的sort函数比较好奇，想知道它用的是什么算法。正好最近我也在复习算法，于是就随便把Python的sort也研究一下吧。刚开始我猜想可能用是快速排序之类的，最后看了 Python的源代码之后发现其实用的是一个适应性强的、稳定的、自然的归并算法，名为timsort。</p>

<p>Timsort是一种混合的算法，它派生自归并排序和插入排序。它是2002年由Tim Peters为Python语言发明的。<br/>
Timsort的时间复杂度最好情况为O(n)，平均情况为O(nlogn)，最差情况为O(nlogn)；空间复杂度为O(n)。<br/>
更多关于Timsort的信息： <a href="http://en.wikipedia.org/wiki/Timsort">http://en.wikipedia.org/wiki/Timsort</a></p>

<p>在<a target="_blank" href="http://www.amazon.cn/gp/product/B003LPO4KS/ref=as_li_ss_tl?ie=UTF8&camp=536&creative=3132&creativeASIN=B003LPO4KS&linkCode=as2&tag=wosuopu-23">《Python Cookbook(第2版)中文版》</a>这本书的第5章中由Tim Peters介绍了Python排序算法发展简史。其中说到Timsort算法的实现包括了大约1200行C程序，而且大概有一半是在实现一个技术上的技巧。可见该算法还是很复杂的。</p>

<p>在Python源代码目录下有Objects/listsort.txt这个文件，这是Tim Peters写的一个详细的文档。</p>

<p>有个项目致力于用纯C来实现Timsort算法，如Tim所言代码量超过了1200行。<a href="http://code.google.com/p/timsort/">http://code.google.com/p/timsort/</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[常用的排序算法（八）——桶排序]]></title>
    <link href="http://www.xefan.com/archives/83849.html"/>
    <updated>2013-07-10T00:00:00+08:00</updated>
    <id>http://www.xefan.com/archives/83849-常用的排序算法（八）——桶排序</id>
    <content type="html"><![CDATA[<p>桶排序算法对待排数列有一定的要求。数据长度必须一样，并且符合均匀分布。</p>

<p>桶排序的基本思想就是先创建一个含n个元素的数组，即就是创建n个桶。然后将待排的数进行哈希算法并链接到这个数组的各个元素中去，即就是将这些数分布到各个桶中去。为得到结果先对各个桶中的数据进行排序，然后按次序把各个桶的元素取出来即可。</p>

<p>代码如下：</p>

<pre><code class="c">#include &lt;stdio.h&gt;
#include &lt;time.h&gt;
#include &lt;stdlib.h&gt;
const int N = 20;
const int M = 10;

struct chain
{
    int key;
    struct chain *next;
};

void init_bucket(struct chain a[], int n)
{
    int i = 0;
    for(; i &lt; n; i++)
    {
        a[i].key = i * 10;
        a[i].next = NULL;
    }
}

int * generate(int a[], int n)
{
    int i;
    for(i = 0; i &lt; n; i++)
    {
        a[i] = 0;
    }
    time_t t;
    srand((unsigned)time(&amp;t));

    for(i = 0; i &lt; n; i++)
    {
        a[i] = rand() % 100;
    }
    return a;
}


void print_array(int *a, int n)
{
    int i = 0;
    while(i &lt; n)
    {
        printf("%4d", a[i]);
        i++;
    }
    printf("\n");
}

void print_bucket(struct chain a[], int n)
{
    int i = 0;
    for(; i &lt; n; i++)
    {
        printf("%4d", a[i].key);
    }
    printf("\n");
}


void insertChain(struct chain node, struct chain *newNode)
{
    if(node.next == NULL)
    {
        node.next = newNode;
    }
    else
    {
        struct chain *p = node.next;
        struct chain *q = p;
        while(p-&gt;key &lt; newNode-&gt;key)
        {

            q = p;
            p = p-&gt;next;
        }
        newNode-&gt;next = q-&gt;next;
        q-&gt;next = newNode;

    }
}

void print_keys(struct chain a[], int n)
{
    int i = 0;
    for(; i &lt; n; i++)
    {
        if(a[i].next != NULL)
        {
            struct chain *p = a[i].next;
            while(p-&gt;next != NULL)
            {
                printf("%4d", p-&gt;key);
                p = p-&gt;next;
            }
            printf("%4d", p-&gt;key);
        }
    }
}

void insert_bucket(struct chain a[], int *keys, int n)
{
    int i = 0;
    for(; i &lt; n; i++)
    {
        struct chain *newNode = (struct chain *)malloc(sizeof(struct chain));
        newNode-&gt;key = keys[i];
        newNode-&gt;next = NULL;

        struct chain *node = &amp;a[keys[i] / 10];

        if(node-&gt;next == NULL)
        {
            node-&gt;next = newNode;
        }
        else
        {
            struct chain *p = node-&gt;next;
            struct chain *q = p;
            while((p-&gt;key &lt;= newNode-&gt;key) &amp;&amp; (p-&gt;next != NULL))
            {

                q = p;
                p = p-&gt;next;
            }
            newNode-&gt;next = q-&gt;next;
            q-&gt;next = newNode;
        }
    }
}

int main()
{
    struct chain heads[M];
    init_bucket(heads, M);
    printf("bucket: ");
    print_bucket(heads, M);

    int keys[N];
    generate(keys,N);
    printf("numbers:");
    print_array(keys, N);

    insert_bucket(heads, keys, N);
    printf("ordered:");
    print_keys(heads, M);
    printf("\n");
    return 0;
}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[常用的排序算法（七）——希尔排序]]></title>
    <link href="http://www.xefan.com/archives/83847.html"/>
    <updated>2013-07-10T00:00:00+08:00</updated>
    <id>http://www.xefan.com/archives/83847-常用的排序算法（七）——希尔排序</id>
    <content type="html"><![CDATA[<p>希尔排序又称缩小增量排序。它是插入排序的一种改进版。</p>

<p>它的基本思想是：先将整个待排序列分割成若干子序列分别进行直接插入排序，待整个序列基本有序时再进行一次直接插入排序。</p>

<p>例如对于数列A={49, 38, 65, 97, 76, 13, 27, 49, 55, 04}，首先将数列分成五个子序列{A0, A5}, {A1, A6}, {A2,A7}, {A3,A8}, {A4,A9}，分别对它们进行直接插入排序。于是第1趟希尔排序之后数列为：{ 13 27 49 55 4 49 38 65 97 76 }。然后再将该数列分成两个子数列{A0,A2,A4,A6,A8}， {A1,A3,A5,A7,A9}，于是第3趟希尔排序之后数列为：{ 4 27 13 49 38 55 49 65 97 76 }。最后再进行一次插入排序即可。</p>

<p>用C语言实现如下：</p>

<pre><code class="c">#include &lt;stdio.h&gt;

void print_list(int *ar, int n)
{
    int i;
    printf("[ ");
    for (i=0; i&lt;n; i++) {
        printf("%d ", ar[i]);
    }
    printf("]\n");

}

void shell_sort(int *ar, int n)
{
    int d, i, j, tmp;
    d = n / 2;
    while (d &gt;= 1) {
        for (i=d; i&lt;n; i++) {
            tmp = ar[i];
            j = i - d;
            while (j &gt;= 0 &amp;&amp; tmp &lt; ar[j]) {
                ar[j+d] = ar[j];
                j -= d;
            }
            ar[j+d] = tmp;
        }
        d = d / 2;
        print_list(ar, n);
    }
}

int main(int argc, char *argv[])
{
    int a[] = {49, 38, 65, 97, 76, 13, 27, 49, 55, 04};
    int len=sizeof(a)/sizeof(int);
    printf("begin: ");
    print_list(a, len);
    shell_sort(a, len);
    printf("end ");
    print_list(a, len);
    return 0;
}
</code></pre>

<p>希尔排序演示图片：
<img src="http://www.linuxeden.com/upimg/allimg/130504/1021141026-5.gif"></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[常用的排序算法（六）——快速排序]]></title>
    <link href="http://www.xefan.com/archives/83845.html"/>
    <updated>2013-07-10T00:00:00+08:00</updated>
    <id>http://www.xefan.com/archives/83845-常用的排序算法（六）——快速排序</id>
    <content type="html"><![CDATA[<p>快速排序也是分治算法的一种应用。它的基本操作是根据某种方法（可以是随机的，也可以是最左边，或者是中间的）选择一个元素作为中枢值。这个元素将数组分为两个子数组，小于或等于中枢值的元素都移到左边，大于或等于中枢值的元素都移到右边。然后每个子数组再递归地排序。</p>

<p>快速排序的平均时间复杂度为O(nlogn)，最好时为O(nlogn)，最坏时为O(n*n)。</p>

<p>用C语言实现如下：</p>

<pre><code class="c">#include &lt;stdio.h&gt;

void print_list(int *ar, int n)
{
    int i;
    printf("[ ");
    for (i=0; i&lt;n; i++) {
        printf("%d ", ar[i]);
    }
    printf("]\n");

}

int partition(int *ar, int left, int right)
{
    int x, i, j;
    int tmp;

    x = ar[right];
    i = left;
    for (j=left; j&lt;right; j++) {
        if (ar[j] &lt;= x) {
            tmp = ar[j];
            ar[j] = ar[i];
            ar[i] = tmp;
            i++;
        }
    }
    tmp = ar[i];
    ar[i] = ar[right];
    ar[right] = tmp;
    return i;
}

void quick_sort(int *ar, int left, int right)
{
    int index;
    if (left &lt; right) {
        index = partition(ar, left, right);
        quick_sort(ar, left, index-1);
        quick_sort(ar, index, right);
    }
}

int main(int argc, char *argv[])
{
    int a[] = {15, 9, 8, 1, 4, 11, 7, 12, 13, 16, 5, 3, 16, 2, 10, 14};
    int len=sizeof(a)/sizeof(int);
    printf("begin: ");
    print_list(a, len);
    quick_sort(a, 0, len-1);
    printf("end ");
    print_list(a, len);
    return 0;
}
</code></pre>

<p>这个例子是选择最右边的元素作为中枢值。</p>

<p>快速排序演示图片：
<img src="http://www.linuxeden.com/upimg/allimg/130504/102114LX-0.gif"></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[常用的排序算法（五）——堆排序]]></title>
    <link href="http://www.xefan.com/archives/83841.html"/>
    <updated>2013-07-10T00:00:00+08:00</updated>
    <id>http://www.xefan.com/archives/83841-常用的排序算法（五）——堆排序</id>
    <content type="html"><![CDATA[<p>堆排序的时间复杂度为O(nlogn)。</p>

<p>首先简单介绍一下堆，一个堆其实就是一个近似的完全二叉树，它具有以下两个性质：<br/>
外形性质：如果深度k-1存在2**(k-1)个节点，那么深度k(k>0)上存在叶子节点。另外，在一个部分填充的深度级上，节点是“ 从左到右”添加的。</p>

<p>堆的性质：树中每一个节点的值都大于或者等于任意一个子节点的值。</p>

<p>堆只是一个抽象的数据结构，在内存可以使用数组来表示的。第0个值为根节点。对于第i个节点，其左子节点为2<em>i+1，右子节点为2</em>i+2。</p>

<p>例如，对于数列[ 5 3 16 2 10 14 ]，将其构造一个堆则为：</p>

<pre><code>        16
       /   \
      10    14
     / \    /
    2   3  5
</code></pre>

<p>然后这个堆对应的数组为[ 16 10 14 2 3 5 ]，最后就是对这个堆进行排序。</p>

<p>代码如下：</p>

<pre><code class="c">#include &lt;stdio.h&gt;

void print_list(int *ar, int n)
{
    int i;
    printf("[ ");
    for (i=0; i&lt;n; i++) {
        printf("%d ", ar[i]);
    }
    printf("]\n");

}
static void heapify(int *ar, int idx, int max)
{
    int left = 2*idx + 1;
    int right = 2*idx +2;
    int largest;

    // 计算A[idx], A[left], A[right]中最大的一个
    if (left &lt; max &amp;&amp; ar[left] &gt; ar[idx]) {
        largest = left;
    } else {
        largest = idx;
    }

    if (right &lt; max &amp;&amp; ar[right] &gt; ar[largest]) {
        largest = right;
    }

    // 如果最大的不是父节点，那么交换并递归执行
    if (largest != idx) {
        int tmp;
        tmp = ar[idx];
        ar[idx] = ar[largest];
        ar[largest] = tmp;

        heapify(ar, largest, max);
    }
}

static void buildHeap(int *ar, int n)
{
    int i;
    for (i=n/2-1; i&gt;=0; i--) {
        heapify(ar, i, n);
    }
}

void heap_sort(int *ar, int n)
{
    int i;
    int tmp;
    buildHeap(ar, n);
    printf("build:");
    for (i=n-1; i&gt;=1; i--) {
        tmp = ar[0];
        ar[0] = ar[i];
        ar[i] = tmp;

        heapify(ar, 0, i);
    }
}

int main(int argc, char *argv[])
{
    int a[] = {5, 3, 16, 2, 10, 14};
    int len=sizeof(a)/sizeof(int);
    printf("begin: ");
    print_list(a, len);
    heap_sort(a, len);
    printf("end ");
    print_list(a, len);
    return 0;
}
</code></pre>

<p>堆排序演示图片：
<img src="http://www.linuxeden.com/upimg/allimg/130504/1021144023-2.gif"></p>
]]></content>
  </entry>
  
</feed>
