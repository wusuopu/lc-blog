
<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js" lang="en"><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <title>龍昌博客</title>
  <meta name="author" content="龍昌">

  
  <meta name="description" content="贪吃蛇 在这部分的Ruby GTK编程教程中我们将创建一个贪吃蛇游戏。 贪吃蛇是一个比较老的经典电子游戏。它第一次创建是在70年代后期。之后被移植到PC上。在这个游戏中玩家控制蛇，目标是尽可能多的吃掉苹果。蛇每吃掉一个苹果，身体就会变长。必须避免蛇撞到墙或者自己的身体。 开发 &hellip;">
  

  <!-- http://t.co/dKP3o1e -->
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  
  <link rel="canonical" href="http://www.xefan.com/page/6/index.html">
  <link href="/favicon.png" rel="icon">
  <link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
  <link href="/atom.xml" rel="alternate" title="龍昌博客" type="application/atom+xml">
  <script src="/javascripts/modernizr-2.0.js"></script>
  <script src="//ajax.useso.com/ajax/libs/jquery/1.9.1/jquery.min.js"></script>
  <script>!window.jQuery && document.write(unescape('%3Cscript src="./javascripts/libs/jquery.min.js"%3E%3C/script%3E'))</script>
  <script src="/javascripts/octopress.js" type="text/javascript"></script>
  <!--Fonts from Google"s Web font directory at http://google.com/webfonts -->
<link href="//fonts.useso.com/css?family=PT+Serif:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">
<link href="//fonts.useso.com/css?family=PT+Sans:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">

  

</head>

<body   >
  <header role="banner"><hgroup>
  <h1><a href="/">龍昌博客</a></h1>
  
    <h2>从Pythoner转向Rubist</h2>
  
</hgroup>

</header>
  <nav role="navigation"><ul class="subscription" data-subscription="rss">
  <li><a href="/atom.xml" rel="subscribe-rss" title="subscribe via RSS">RSS</a></li>
  
</ul>
  
<form action="https://www.google.com/search" method="get">
  <fieldset role="search">
    <input type="hidden" name="q" value="site:www.xefan.com" />
    <input class="search" type="text" name="q" results="0" placeholder="Search"/>
  </fieldset>
</form>
  
<ul class="main-navigation">
  <li><a href="/">Home</a></li>
  <li><a href="/blog/archives">Archives</a></li>
 <li><a href="/about/">About</a></li>  <li><a href="/gbook/">留言板</a></li> 
</ul>

</nav>
  <div id="main">
    <div id="content">
      <div class="blog-index">
  
  
  
    <article>
      
  <header>
    
    <h1 class="entry-title"><a href="http://www.xefan.com/archives/83975.html">[翻译]Ruby GTK教程8——贪吃蛇</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2013-11-25T00:00:00+08:00'><span class='date'><span class='date-month'>Nov</span> <span class='date-day'>25</span><span class='date-suffix'>th</span>, <span class='date-year'>2013</span></span> <span class='time'>12:00 am</span></time>
        
           | <a href="http://www.xefan.com/archives/83975.html#disqus_thread"
             data-disqus-identifier="http://www.xefan.com/archives/83975.html">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><h1>贪吃蛇</h1>


<p>在这部分的Ruby GTK编程教程中我们将创建一个贪吃蛇游戏。</p>


<p>贪吃蛇是一个比较老的经典电子游戏。它第一次创建是在70年代后期。之后被移植到PC上。在这个游戏中玩家控制蛇，目标是尽可能多的吃掉苹果。蛇每吃掉一个苹果，身体就会变长。必须避免蛇撞到墙或者自己的身体。</p>


<h2>开发</h2>


<p>蛇的每块关节的大小为10像素。使用方向键控制蛇。初始，蛇有三块关节。游戏立即开始。当游戏结束后在窗口中央显示&#8221;Game Over&#8221;。</p>


<p><em>board.rb</em></p>


<pre><code>WIDTH = 300
HEIGHT = 270
DOT_SIZE = 10
ALL_DOTS = WIDTH * HEIGHT / (DOT_SIZE * DOT_SIZE)
RAND_POS = 26

$x = [0] * ALL_DOTS
$y = [0] * ALL_DOTS

class Board &lt; Gtk::DrawingArea

    def initialize
        super

        modify_bg Gtk::STATE_NORMAL, Gdk::Color.new(0, 0, 0)

        signal_connect "expose-event" do  
            on_expose
        end

        init_game
    end

    def on_timer

        if @inGame
            check_apple
            check_collision
            move
            queue_draw
            return true
        else
            return false
        end
    end

    def init_game

        @left = false
        @right = true
        @up = false
        @down = false
        @inGame = true
        @dots = 3

        for i in (0..@dots)
            $x[i] = 50 - i * 10
            $y[i] = 50
        end

        begin
            @dot = Cairo::ImageSurface.from_png "dot.png"
            @head = Cairo::ImageSurface.from_png "head.png"
            @apple = Cairo::ImageSurface.from_png "apple.png"
        rescue Exception =&gt; e
            puts "cannot load images"
            exit
        end

        locate_apple
        GLib::Timeout.add(100) { on_timer }

     end


    def on_expose

        cr = window.create_cairo_context

        if @inGame
            draw_objects cr
        else
            game_over cr
        end      
    end

    def draw_objects cr

        cr.set_source_rgb 0, 0, 0
        cr.paint

        cr.set_source @apple, @apple_x, @apple_y
        cr.paint

        for z in (0..@dots)
            if z == 0 
                cr.set_source @head, $x[z], $y[z]
                cr.paint
            else
                cr.set_source @dot, $x[z], $y[z]
                cr.paint
            end    
        end
    end

    def game_over cr

        w = allocation.width / 2
        h = allocation.height / 2

        cr.set_font_size 15
        te = cr.text_extents "Game Over"

        cr.set_source_rgb 65535, 65535, 65535

        cr.move_to w - te.width/2, h
        cr.show_text "Game Over"

    end


    def check_apple

        if $x[0] == @apple_x and $y[0] == @apple_y 
            @dots = @dots + 1
            locate_apple
        end
    end

    def move

        z = @dots

        while z &gt; 0
            $x[z] = $x[(z - 1)]
            $y[z] = $y[(z - 1)]
            z = z - 1
        end

        if @left
            $x[0] -= DOT_SIZE
        end

        if @right 
            $x[0] += DOT_SIZE
        end

        if @up
            $y[0] -= DOT_SIZE
        end

        if @down
            $y[0] += DOT_SIZE
        end

     end

    def check_collision

        z = @dots

        while z &gt; 0
            if z &gt; 4 and $x[0] == $x[z] and $y[0] == $y[z]
                @inGame = false
            end
            z = z - 1
        end

        if $y[0] &gt; HEIGHT - DOT_SIZE
            @inGame = false
        end

        if $y[0] &lt; 0
            @inGame = false
        end

        if $x[0] &gt; WIDTH - DOT_SIZE
            @inGame = false
        end

        if $x[0] &lt; 0
            @inGame = false
        end

    end

    def locate_apple

        r = rand(RAND_POS)
        @apple_x = r * DOT_SIZE
        r = rand(RAND_POS)
        @apple_y = r * DOT_SIZE
    end

    def on_key_down event

        key = event.keyval

        if key == Gdk::Keyval::GDK_Left and not @right
            @left = true
            @up = false
            @down = false
        end

        if key == Gdk::Keyval::GDK_Right and not @left
            @right = true
            @up = false
            @down = false
        end

        if key == Gdk::Keyval::GDK_Up and not @down
            @up = true
            @right = false
            @left = false
        end

        if key == Gdk::Keyval::GDK_Down and not @up
            @down = true
            @right = false
            @left = false
        end
    end   
end
</code></pre>


<p>首先我们定义一些全局变量。</p>


<p>WIDTH和HEIGHT常量决定了甲板的大小。DOT_SIZE是苹果和蛇的每个点的大小。ALL_DOTS常量定义了甲板可能包含的最大的点数量。RAND_POS常量用于计算苹果的随机位置。DELAY常量决定游戏速度。</p>


<pre><code>$x = [0] * ALL_DOTS
$y = [0] * ALL_DOTS
</code></pre>


<p>这两个数组存储了蛇所有关节的x、y坐标。</p>


<p><em>init_game</em>方法初始化变量、加载图片和启动timeout函数。</p>


<pre><code>if @inGame
    draw_objects cr
else
    game_over cr
end
</code></pre>


<p>在<em>on_expose_method</em>方法里我们检查<em>@inGame</em>变量。如果为true，绘制苹果和蛇。否则显示&#8221;Game over&#8221;文字。</p>


<pre><code>def draw_objects cr

    cr.set_source_rgb 0, 0, 0
    cr.paint

    cr.set_source @apple, @apple_x, @apple_y
    cr.paint

    for z in (0..@dots)
        if z == 0 
            cr.set_source @head, $x[z], $y[z]
            cr.paint
        else
            cr.set_source @dot, $x[z], $y[z]
            cr.paint
        end    
    end
end
</code></pre>


<p><em>draw_objects</em>方法绘制苹果和蛇。蛇的头部用红色的圆表示。</p>


<pre><code>def check_apple

    if $x[0] == @apple_x and $y[0] == @apple_y 
        @dots = @dots + 1
        locate_apple
    end
end
</code></pre>


<p><em>check_apple</em>方法查检蛇是否碰到苹果，如果是则增加蛇的关节并调用<em>locate_apple</em>方法随机放置一个新的苹果。</p>


<p><em>move</em>方法是游戏的关键算法。为了理解它，先看一下蛇是如何移动的。控制蛇头，可以使用方向键改变它的方向。其余的关节朝该方向前进。第二个关节移到到第一关节的位置，第三个关节到第二个等等。</p>


<pre><code>while z &gt; 0
    $x[z] = $x[(z - 1)]
    $y[z] = $y[(z - 1)]
    z = z - 1
end
</code></pre>


<p>这些代码将关节按照链状前进。</p>


<pre><code>if @left
    $x[0] -= DOT_SIZE
end
</code></pre>


<p>头部向左移动。</p>


<p><em>check_collision</em>方法中，我们检查蛇是否撞到了自己或者墙。</p>


<pre><code>while z &gt; 0
    if z &gt; 4 and $x[0] == $x[z] and $y[0] == $y[z]
        @inGame = false
    end
    z = z - 1
end
</code></pre>


<p>如果蛇撞到了自己，游戏结束。</p>


<pre><code>if $y[0] &gt; HEIGHT - DOT_SIZE
    @inGame = false
end
</code></pre>


<p>如果蛇撞到底部，游戏结束。</p>


<p><em>localte_apple</em>方法在甲板上随机定位一个苹果。</p>


<pre><code>r = rand(RAND_POS)
</code></pre>


<p>获取0到RAND_POS-1的一个随机数。</p>


<pre><code>@apple_x = r * DOT_SIZE
...
@apple_y = r * DOT_SIZE
</code></pre>


<p>这几行设置了苹果的x、y坐标。</p>


<pre><code>if @inGame
    check_apple
    check_collision
    move
    queue_draw
    return true
else
    return false
end
</code></pre>


<p>第140ms调用一次<em>on_timer</em>方法。如果游戏运行则调用三个组成游戏逻辑的方法。否则返回false，停止定时事件。</p>


<p>在Board类的<em>on_key_down</em>方法中我们判断按下的键。</p>


<pre><code>if key == Gdk::Keyval::GDK_Left and not @right
    @left = true
    @up = false
    @down = false
end
</code></pre>


<p>如果我们按的是左方向键，我们设置<em>left</em>变量为true。这个变量用于<em>move</em>方法改变蛇的坐标。同样注意，当蛇是朝右时，我们不能立即朝左。</p>


<p><em>nibbles.rb</em></p>


<pre><code>#!/usr/bin/ruby

# ZetCode Ruby GTK tutorial
#
# This is a simple nibbles game
# clone
#
# author: jan bodnar
# website: www.zetcode.com
# last modified: June 2009

require 'gtk2'
require 'board'

class RubyApp &gt; Gtk::Window
    def initialize
        super

        set_title "Nibbles"
        signal_connect "destroy" do 
            Gtk.main_quit 
        end

        @board = Board.new
        signal_connect "key-press-event" do |w, e|
            on_key_down(w, e)
        end

        add @board

        set_default_size 300, 270
        set_window_position Gtk::Window::POS_CENTER
        show_all
    end

    def on_key_down widget, event

        key = event.keyval
        @board.on_key_down event
    end
end

Gtk.init
    window = RubyApp.new
Gtk.main
</code></pre>


<p>在这个类我们启动了贪吃游戏。</p>


<pre><code>def on_key_down widget, event

    key = event.keyval
    @board.on_key_down event
end
</code></pre>


<p>在这个类的捕获按键事件然后委托Board类的<em>on_key_down method</em>方法进行处理。</p>


<p><img alt="image" src="http://zetcode.com/img/gui/rubygtk/nibbles.png"><br>
<em>图片：贪吃蛇</em></p>


<p>这是使用Ruby语言和GTK库编写的贪吃蛇计算机游戏。</p>


<hr>


<p>原文地址： <a href="http://zetcode.com/gui/rubygtk/nibbles/">http://zetcode.com/gui/rubygtk/nibbles/</a><br>
翻译：龙昌  admin@longchangjin.cn </p>

</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
    <h1 class="entry-title"><a href="http://www.xefan.com/archives/83972.html">[翻译]Ruby GTK教程7——自定义控件</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2013-11-24T00:00:00+08:00'><span class='date'><span class='date-month'>Nov</span> <span class='date-day'>24</span><span class='date-suffix'>th</span>, <span class='date-year'>2013</span></span> <span class='time'>12:00 am</span></time>
        
           | <a href="http://www.xefan.com/archives/83972.html#disqus_thread"
             data-disqus-identifier="http://www.xefan.com/archives/83972.html">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><h1>自定义控件</h1>


<p>大多数套件通常只提供了最常用的控件，如按钮、文本控件、滑动条等。没有套件可以提供所有可能的控件。程序员必须自己创建这些。这是通过套件提供的绘制工具完成。这有两种可能。程序员可以修改或增强已存在的控件，或者从头开始创建一个自定义控件。</p>


<h2>Burning控件</h2>


<p>这个例子我们从头开始创建一个控件。这个控件可以在各种媒体烧定应用中看到，如Nero Burning ROM。</p>


<p><em>custom.rb</em></p>


<pre><code>#!/usr/bin/ruby

# ZetCode Ruby GTK tutorial 
#
# This example creates a burning
# custom widget
#
# author: jan bodnar
# website: zetcode.com 
# last edited: June 2009


require 'gtk2'

class Burning &lt; Gtk::DrawingArea

    def initialize(parent)
        @parent = parent

        super()

        @num = [ "75", "150", "225", "300", 
            "375", "450", "525", "600", "675" ]

        set_size_request 1, 30
        signal_connect "expose-event" do
            expose
        end
    end


    def expose

        cr = window.create_cairo_context
        draw_widget cr

    end

    def draw_widget cr

         cr.set_line_width 0.8

        cr.select_font_face("Courier", 
            Cairo::FONT_SLANT_NORMAL, Cairo::FONT_WEIGHT_NORMAL)
        cr.set_font_size 11

        width = allocation.width

        @cur_width = @parent.get_cur_value

        step = (width / 10.0).round

        till = (width / 750.0) * @cur_width
        full = (width / 750.0) * 700

        if @cur_width &gt;= 700

            cr.set_source_rgb(1.0, 1.0, 0.72)
            cr.rectangle(0, 0, full, 30)
            cr.clip
            cr.paint
            cr.reset_clip

            cr.set_source_rgb(1.0, 0.68, 0.68)
            cr.rectangle(full, 0, till-full, 30)
            cr.clip
            cr.paint
            cr.reset_clip

        else
            cr.set_source_rgb 1.0, 1.0, 0.72
            cr.rectangle 0, 0, till, 30
            cr.clip
            cr.paint
            cr.reset_clip
        end


        cr.set_source_rgb(0.35, 0.31, 0.24)

        for i in (1..@num.length)
            cr.move_to i*step, 0
            cr.line_to i*step, 5
            cr.stroke

            te = cr.text_extents @num[i-1]
            cr.move_to i*step-te.width/2, 15
            cr.text_path @num[i-1]
            cr.stroke
        end         
    end
end


class RubyApp &lt; Gtk::Window
    def initialize
        super

        set_title "Burning"
        signal_connect "destroy" do 
            Gtk.main_quit 
        end

        set_size_request 350, 200        
        set_window_position Gtk::Window::POS_CENTER

        @cur_value = 0

        vbox = Gtk::VBox.new false, 2

        scale = Gtk::HScale.new
        scale.set_range 0, 750
        scale.set_digits 0
        scale.set_size_request 160, 35
        scale.set_value @cur_value

        scale.signal_connect "value-changed" do |w|
            on_changed(w)
        end

        fix = Gtk::Fixed.new
        fix.put scale, 50, 50

        vbox.pack_start fix

        @burning = Burning.new(self)
        vbox.pack_start @burning, false, false, 0

        add vbox
        show_all
    end

    def on_changed widget

        @cur_value = widget.value
        @burning.queue_draw
    end

    def get_cur_value
        return @cur_value
    end
end

Gtk.init
    window = RubyApp.new
Gtk.main
</code></pre>


<p>我们将DrawingArea放在窗口的底部，并且手动绘制控件的条目。所有的重要代码放在draw_widget里，通过Burning类的expose方法调用。这个控件生动的显示了媒介的容量和剩余空间。这个控件通过刻度控件来控制。我们自定义控件的最小值为0,最大值为750。如果达到700，我们开始绘制红色。这通常表明超标了。</p>


<pre><code>@num = [ "75", "150", "225", "300", 
    "375", "450", "525", "600", "675" ]
</code></pre>


<p>这些数字显示在控件上。他们显示了媒介的容量。</p>


<pre><code>@cur_width = @parent.get_cur_value
</code></pre>


<p>通过父控件我们获得刻度控件的值。</p>


<pre><code>till = (width / 750.0) * @cur_width
full = (width / 750.0) * 700
</code></pre>


<p>我们使用width变量进行刻度值和自定义控件尺寸的转换。注意我们使用了浮点数，得到较大精度的绘制。<em>till</em>参数决定了绘制的总大小，它的值来自刻度控件。它是整个区域的比例。<em>full</em>参数决定了从什么位置开始绘制红色。</p>


<pre><code>cr.set_source_rgb(1.0, 1.0, 0.72)
cr.rectangle(0, 0, full, 30)
cr.clip
cr.paint
cr.reset_clip
</code></pre>


<p>绘制黄色矩形直到<em>full</em>点。</p>


<pre><code>te = cr.text_extents @num[i-1]
cr.move_to i*step-te.width/2, 15
cr.text_path @num[i-1]
cr.stroke
</code></pre>


<p>这些代码绘制了burning控件的数字。我们计算了文本恰当的位置。</p>


<pre><code>def on_changed widget

    @cur_value = widget.value
    @burning.queue_draw
end
</code></pre>


<p>我们获取刻度控件的值保存在<em>cur_value</em>变量中，稍后使用。重绘burning控件。</p>


<p><img alt="image" src="http://zetcode.com/img/gui/rubygtk/burning.png"><br>
<em>图片：Burning widget</em></p>


<p>在这一章中，我们创建了一个自定义控件。</p>


<hr>


<p>原文地址： <a href="http://zetcode.com/gui/rubygtk/customwidget/">http://zetcode.com/gui/rubygtk/customwidget/</a><br>
翻译：龙昌  admin@longchangjin.cn </p>

</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
    <h1 class="entry-title"><a href="http://www.xefan.com/archives/83969.html">[翻译]Ruby GTK教程6——Cairo</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2013-11-24T00:00:00+08:00'><span class='date'><span class='date-month'>Nov</span> <span class='date-day'>24</span><span class='date-suffix'>th</span>, <span class='date-year'>2013</span></span> <span class='time'>12:00 am</span></time>
        
           | <a href="http://www.xefan.com/archives/83969.html#disqus_thread"
             data-disqus-identifier="http://www.xefan.com/archives/83969.html">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><h1>使用Cairo绘制</h1>


<p>这部分的Ruby GTK教程，我们将使用Cairo库进行一些绘制。</p>


<p>Cairo是一个用于创建2D矢量图像的库。我们可以用它来绘制自己的控件、图表或者各种效果或动画。</p>


<h2>颜色</h2>


<p>在第一个会例子，我们将介绍颜色。颜色是一个代表了红、绿和蓝（RGB）强度值的对象。Cairo的RGB有效值范围为0到1。</p>


<pre><code>#!/usr/bin/ruby

# ZetCode Ruby GTK tutorial
#
# This program shows how to work
# with colors in Cairo
#
# author: jan bodnar
# website: www.zetcode.com
# last modified: June 2009

require 'gtk2'


class RubyApp &lt; Gtk::Window

    def initialize
        super

        set_title "Colors"
        signal_connect "destroy" do 
            Gtk.main_quit 
        end

        init_ui

        set_default_size 360, 100
        set_window_position Gtk::Window::POS_CENTER

        show_all
    end

    def init_ui

        @darea = Gtk::DrawingArea.new

        @darea.signal_connect "expose-event" do  
            on_expose
        end

        add(@darea)

    end

    def on_expose

        cr = @darea.window.create_cairo_context  
        draw_colors cr

    end

    def draw_colors cr

        cr.set_source_rgb 0.2, 0.23, 0.9
        cr.rectangle 10, 15, 90, 60
        cr.fill

        cr.set_source_rgb 0.9, 0.1, 0.1
        cr.rectangle 130, 15, 90, 60
        cr.fill

        cr.set_source_rgb 0.4, 0.9, 0.4
        cr.rectangle 250, 15, 90, 60
        cr.fill
    end
end

Gtk.init
    window = RubyApp.new
Gtk.main
</code></pre>


<p>这个例子中我们绘制了三个矩形并且用三种不同的颜色填充。</p>


<pre><code>@darea = Gtk::DrawingArea.new
</code></pre>


<p>我们将在DrawingArea控件是进行绘制操作。</p>


<pre><code>@darea.signal_connect "expose-event" do  
    on_expose
end
</code></pre>


<p>当窗口需要重绘时<em>expose-event</em>事件将触发。对这个事件的响应中我们调用了<em>on_expose</em>方法。</p>


<pre><code>cr = @darea.window.create_cairo_context
</code></pre>


<p>从GdkWindow创建cairo上下文对象。这个上下文是我们将要进行所有绘制的对象。</p>


<pre><code>draw_colors cr
</code></pre>


<p>实际的绘制委托给<em>draw_colors</em>方法。</p>


<pre><code>cr.set_source_rgb 0.2, 0.23, 0.9
</code></pre>


<p><em>set_source_rgb</em>方法是设置cairo上下文的颜色。这个方法的三个参数是颜色的强度值。</p>


<pre><code>cr.rectangle 10, 15, 90, 60
</code></pre>


<p>绘制一个矩形。前两个参数是矩形左上角的x、y坐标。后两个参数是矩形的宽和高。</p>


<pre><code>cr.fill
</code></pre>


<p>使用当前的颜色填充矩形。</p>


<p><img alt="image1" src="http://zetcode.com/img/gui/rubygtk/colors.png"><br>
<em>图片：颜色</em></p>


<h2>基本形状</h2>


<p>下一个例子在窗口上绘制一些基本形状。</p>


<pre><code>#!/usr/bin/ruby

# ZetCode Ruby GTK tutorial
#
# This code example draws basic shapes
# with the Cairo library
#
# author: jan bodnar
# website: www.zetcode.com
# last modified: June 2009

require 'gtk2'


class RubyApp &lt; Gtk::Window

    def initialize
        super

        set_title "Basic shapes"
        signal_connect "destroy" do 
            Gtk.main_quit 
        end

        init_ui

        set_default_size 390, 240
        set_window_position Gtk::Window::POS_CENTER

        show_all
    end

    def init_ui

        @darea = Gtk::DrawingArea.new

        @darea.signal_connect "expose-event" do  
            on_expose
        end

        add(@darea)
    end

    def on_expose

        cr = @darea.window.create_cairo_context  
        draw_shapes cr
    end

    def draw_shapes cr

        cr.set_source_rgb 0.6, 0.6, 0.6

        cr.rectangle 20, 20, 120, 80
        cr.rectangle 180, 20, 80, 80
        cr.fill

        cr.arc 330, 60, 40, 0, 2*Math::PI
        cr.fill

        cr.arc 90, 160, 40, Math::PI/4, Math::PI
        cr.fill

        cr.translate 220, 180
        cr.scale 1, 0.7
        cr.arc 0, 0, 50, 0, 2*Math::PI
        cr.fill
    end
end

Gtk.init
    window = RubyApp.new
Gtk.main
</code></pre>


<p>这个例子我们将创建一个矩形、方形、圆形、弧形和椭圆形。我们将轮廓绘为蓝色，内部为白色。</p>


<pre><code>cr.rectangle 20, 20, 120, 80
cr.rectangle 180, 20, 80, 80
cr.fill
</code></pre>


<p>这几行绘制了一个矩形和一个方形。</p>


<pre><code>cr.arc 330, 60, 40, 0, 2*Math::PI
cr.fill
</code></pre>


<p><em>arc</em>方法绘制一个全圆。</p>


<pre><code>cr.translate 220, 180
cr.scale 1, 0.7
cr.arc 0, 0, 50, 0, 2*Math::PI
cr.fill
</code></pre>


<p><em>translate</em>方法将对象移动到指定的点。如果我们想要绘制椭圆，我们需要进行一些缩放。这里<em>scale</em>方法将y轴收缩。</p>


<p><img alt="image2" src="http://zetcode.com/img/gui/rubygtk/shapes.png"><br>
<em>图片：基本形状</em></p>


<h2>透明矩形</h2>


<p>透明度是透过实体的可见度。最简单的理解可以把它想象成玻璃或者水。光线可以透过玻璃，这样我们就可以看到玻璃后的物体。</p>


<p>在计算机图像中，我们可以使用透明混合实现透明度。透明混合处理图片和背景的组合，显示部透明。作品处理使用了阿尔法通道。</p>


<pre><code>#!/usr/bin/ruby

# ZetCode Ruby GTK tutorial
#
# This program shows transparent
# rectangles using Cairo
#
# author: jan bodnar
# website: www.zetcode.com
# last modified: June 2009

require 'gtk2'


class RubyApp &lt; Gtk::Window

    def initialize
        super

        set_title "Transparent rectangles"
        signal_connect "destroy" do 
            Gtk.main_quit 
        end

        init_ui

        set_default_size 590, 90
        set_window_position Gtk::Window::POS_CENTER

        show_all
    end

    def init_ui

        @darea = Gtk::DrawingArea.new

        @darea.signal_connect "expose-event" do  
            on_expose
        end

        add(@darea)

    end

    def on_expose

        cr = @darea.window.create_cairo_context

        for i in (1..10)
            cr.set_source_rgba 0, 0, 1, i*0.1
            cr.rectangle 50*i, 20, 40, 40
            cr.fill
        end
    end
end

Gtk.init
    window = RubyApp.new
Gtk.main
</code></pre>


<p>这个例子我们使用不同等级透明度绘制了10个矩形。</p>


<pre><code>cr.set_source_rgba 0, 0, 1, i*0.1
</code></pre>


<p><em>set_source_rgba</em>方法是最后一个参数是alpha透明度。</p>


<p><img alt="image3" src="http://zetcode.com/img/gui/rubygtk/transparency.png"> <br>
<em>图片：透明矩形</em></p>


<h2>甜甜圈</h2>


<p>接下来的例子我们通过旋转一堆椭圆来创建一个复杂的形状。</p>


<pre><code>#!/usr/bin/ruby

# ZetCode Ruby GTK tutorial
#
# This program creates a donut
# with Cairo library
#
# author: jan bodnar
# website: www.zetcode.com
# last modified: June 2009

require 'gtk2'


class RubyApp &lt; Gtk::Window

    def initialize
        super

        set_title "Donut"
        signal_connect "destroy" do 
            Gtk.main_quit 
        end

        init_ui

        set_default_size 350, 250
        set_window_position Gtk::Window::POS_CENTER

        show_all
    end

    def init_ui

        @darea = Gtk::DrawingArea.new

        @darea.signal_connect "expose-event" do  
            on_expose
        end

        add(@darea)

    end

    def on_expose

        cr = @darea.window.create_cairo_context  
        cr.set_line_width 0.5

        w = allocation.width
        h = allocation.height

        cr.translate w/2, h/2
        cr.arc 0, 0, 120, 0, 2*Math::PI
        cr.stroke

        for i in (1..36)
            cr.save
            cr.rotate i*Math::PI/36
            cr.scale 0.3, 1
            cr.arc 0, 0, 120, 0, 2*Math::PI
            cr.restore
            cr.stroke
        end
    end
end

Gtk.init
    window = RubyApp.new
Gtk.main
</code></pre>


<p>这个例子我们创建了一个甜甜圈。它的形状与饼干相似，因此取名为甜甜圈（donut）。</p>


<pre><code>cr.translate w/2, h/2
cr.arc 0, 0, 120, 0, 2*Math::PI
cr.stroke
</code></pre>


<p>在开始只是一个椭圆。</p>


<pre><code>for i in (1..36)
    cr.save
    cr.rotate i*Math::PI/36
    cr.scale 0.3, 1
    cr.arc 0, 0, 120, 0, 2*Math::PI
    cr.restore
    cr.stroke
end
</code></pre>


<p>经过一些旋转后变成了甜甜圈。</p>


<p><img alt="image4" src="http://zetcode.com/img/gui/rubygtk/donut.jpg"><br>
<em>图片：Donut</em></p>


<h2>绘制文本</h2>


<p>下一个例子我们在窗口上绘制一些文本。</p>


<pre><code>#!/usr/bin/ruby

# ZetCode Ruby GTK tutorial
#
# This program draws text
# using Cairo
#
# author: jan bodnar
# website: www.zetcode.com
# last modified: June 2009

require 'gtk2'


class RubyApp &lt; Gtk::Window

    def initialize
        super

        set_title "Soulmate"
        signal_connect "destroy" do 
            Gtk.main_quit 
        end

        init_ui

        set_default_size 370, 240
        set_window_position Gtk::Window::POS_CENTER

        show_all
    end

    def init_ui

        @darea = Gtk::DrawingArea.new

        @darea.signal_connect "expose-event" do  
            on_expose
        end

        add(@darea)

    end

    def on_expose

        cr = @darea.window.create_cairo_context

        cr.set_source_rgb 0.1, 0.1, 0.1

        cr.select_font_face "Purisa", Cairo::FONT_SLANT_NORMAL, 
            Cairo::FONT_WEIGHT_NORMAL
        cr.set_font_size 13

        cr.move_to 20, 30
        cr.show_text "Most relationships seem so transitory"
        cr.move_to 20, 60
        cr.show_text "They're all good but not the permanent one"
        cr.move_to 20, 120
        cr.show_text "Who doesn't long for someone to hold"
        cr.move_to 20, 150
        cr.show_text "Who knows how to love without being told"
        cr.move_to 20, 180
        cr.show_text "Somebody tell me why I'm on my own"
        cr.move_to 20, 210
        cr.show_text "If there's a soulmate for everyone"
    end
end

Gtk.init
    window = RubyApp.new
Gtk.main
</code></pre>


<p>我们显示了Natasha Bedingfields Soulmate歌的部分歌词。</p>


<pre><code>cr.select_font_face "Purisa", Cairo::FONT_SLANT_NORMAL, 
    Cairo::FONT_WEIGHT_NORMAL
</code></pre>


<p>这里我们指定我们使用的字体。</p>


<pre><code>cr.set_font_size 13
</code></pre>


<p>我们指定字体的大小。</p>


<pre><code>cr.move_to 20, 30
</code></pre>


<p>移动到开始绘制文本的坐标。</p>


<pre><code>cr.show_text "Most relationships seem so transitory"
</code></pre>


<p><em>show_text</em>方法在窗口上绘制文本。</p>


<p><img alt="image5" src="http://zetcode.com/img/gui/rubygtk/soulmate.png"><br>
<em>图片: Soulmate</em></p>


<p>这章的Ruby GTK教程我们使用Cairo库进行绘制。</p>


<hr>


<p>原文地址： <a href="http://zetcode.com/gui/rubygtk/cairo/">http://zetcode.com/gui/rubygtk/cairo/</a><br>
翻译：龙昌  admin@longchangjin.cn </p>

</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
    <h1 class="entry-title"><a href="http://www.xefan.com/archives/83966.html">[翻译]Ruby GTK教程5——对话框</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2013-11-23T00:00:00+08:00'><span class='date'><span class='date-month'>Nov</span> <span class='date-day'>23</span><span class='date-suffix'>rd</span>, <span class='date-year'>2013</span></span> <span class='time'>12:00 am</span></time>
        
           | <a href="http://www.xefan.com/archives/83966.html#disqus_thread"
             data-disqus-identifier="http://www.xefan.com/archives/83966.html">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><h1>对话框</h1>


<p>在这部分的Ruby GTK教程我们将介绍对话框。</p>


<p>对话框是现代GUI应用程序不可缺的一部分。对话是两个或者更多人之间交谈。在计算机程序中对话是一个用于与应用程序交互的窗口。对话框用于输入数据、修改数据、修改设置等。对话框在用户与计算机程序之间的交流具有重要意义。</p>


<h2>消息盒子</h2>


<p>消息对话框是应用程序便于给用户提供消息的对话框。消息由文本和图片数据组成。</p>


<pre><code>#!/usr/bin/ruby

# ZetCode Ruby GTK tutorial
#
# This example shows message
# dialogs
#
# author: jan bodnar
# website: www.zetcode.com
# last modified: June 2009

require 'gtk2'


class RubyApp &lt; Gtk::Window

    def initialize
        super

        set_title "Messages"
        signal_connect "destroy" do 
            Gtk.main_quit 
        end

        init_ui

        set_default_size 250, 100
        set_window_position Gtk::Window::POS_CENTER

        show_all
    end

    def init_ui

        table = Gtk::Table.new 2, 2, true

        info = Gtk::Button.new "Information"
        warn = Gtk::Button.new "Warning"
        ques = Gtk::Button.new "Question"
        erro = Gtk::Button.new "Error"

        info.signal_connect "clicked" do
            on_info
        end

        warn.signal_connect "clicked" do
            on_warn
        end

        ques.signal_connect "clicked" do
            on_ques
        end

        erro.signal_connect "clicked" do
            on_erro
        end

        table.attach info, 0, 1, 0, 1
        table.attach warn, 1, 2, 0, 1
        table.attach ques, 0, 1, 1, 2
        table.attach erro, 1, 2, 1, 2

        add table

    end

    def on_info
        md = Gtk::MessageDialog.new(self,
            Gtk::Dialog::DESTROY_WITH_PARENT, Gtk::MessageDialog::INFO, 
            Gtk::MessageDialog::BUTTONS_CLOSE, "Download completed")
        md.run
        md.destroy
    end


    def on_erro
        md = Gtk::MessageDialog.new(self, Gtk::Dialog::MODAL |
            Gtk::Dialog::DESTROY_WITH_PARENT, Gtk::MessageDialog::ERROR, 
            Gtk::MessageDialog::BUTTONS_CLOSE, "Error loading file")
        md.run
        md.destroy
    end


    def on_ques
        md = Gtk::MessageDialog.new(self,
            Gtk::Dialog::DESTROY_WITH_PARENT, Gtk::MessageDialog::QUESTION, 
            Gtk::MessageDialog::BUTTONS_CLOSE, "Are you sure to quit?")
        md.run
        md.destroy
    end

    def on_warn
        md = Gtk::MessageDialog.new(self,
            Gtk::Dialog::DESTROY_WITH_PARENT, Gtk::MessageDialog::WARNING, 
            Gtk::MessageDialog::BUTTONS_CLOSE, "Unallowed operation")
        md.run
        md.destroy
    end
end

Gtk.init
    window = RubyApp.new
Gtk.main
</code></pre>


<p>我们的例子中显示了四种消息对话框。信息、警告、询问和错误消息对话框。</p>


<pre><code>info = Gtk::Button.new "Information"
warn = Gtk::Button.new "Warning"
ques = Gtk::Button.new "Question"
erro = Gtk::Button.new "Error"
</code></pre>


<p>创建四个按钮。每个按钮将显示不同种类的消息对话框。</p>


<pre><code>def on_info
    md = Gtk::MessageDialog.new(self,
        Gtk::Dialog::DESTROY_WITH_PARENT, Gtk::MessageDialog::INFO, 
        Gtk::MessageDialog::BUTTONS_CLOSE, "Download completed")
    md.run
    md.destroy
end
</code></pre>


<p>如果我们点击了<em>info</em>按钮，信息对话框将显示。<em>Gtk::MessageDialog::INFO</em>指定了对话框的类型。<em>Gtk::MessageDialog::BUTTONS_CLOSE</em>指定在对话框中显示的按钮。最后一个参数是要显示的消息。对话框使用<em>run</em>方法显示。程序员必须也要调用<em>destroy</em>或者<em>hide</em>方法。<br>
<img alt="image1" src="http://zetcode.com/img/gui/rubygtk/information.png">  <img alt="image2" src="http://zetcode.com/img/gui/rubygtk/warning.png">  <br>
<img alt="image3" src="http://zetcode.com/img/gui/rubygtk/question.png">  <img alt="image4" src="http://zetcode.com/img/gui/rubygtk/error.png">   </p>


<h2>关于对话框(AboutDialog)</h2>


<p><em>关于对话框</em>显示了应用程序的信息。<em>关于对话框</em>可以显示logo、应用程序名、版本号、版权、网站或者授权信息。它也可能给出作者、文档编写才、翻译者和设计师的信息。</p>


<pre><code>#!/usr/bin/ruby

# ZetCode Ruby GTK tutorial
#
# This example demonstrates the
# AboutDialog dialog
#
# author: jan bodnar
# website: www.zetcode.com
# last modified: June 2009

require 'gtk2'


class RubyApp &lt; Gtk::Window

    def initialize
        super

        set_title "About dialog"
        signal_connect "destroy" do 
            Gtk.main_quit 
        end

        init_ui

        set_default_size 300, 150
        set_window_position Gtk::Window::POS_CENTER

        show_all
    end

    def init_ui

        button = Gtk::Button.new "About"
        button.set_size_request 80, 30

        button.signal_connect "clicked" do
            on_clicked
        end

        fix = Gtk::Fixed.new
        fix.put button, 20, 20

        add fix

    end

    def on_clicked
        about = Gtk::AboutDialog.new
        about.set_program_name "Battery"
        about.set_version "0.1"
        about.set_copyright "(c) Jan Bodnar"
        about.set_comments "Battery is a simple tool for battery checking"
        about.set_website "http://www.zetcode.com"
        about.set_logo Gdk::Pixbuf.new "battery.png"
        about.run
        about.destroy
    end
end

Gtk.init
    window = RubyApp.new
Gtk.main
</code></pre>


<p>代码伅使用了<em>AboutDialog</em>的一些特性。</p>


<pre><code>about = Gtk::AboutDialog.new
</code></pre>


<p>创建一个AboutDialog。</p>


<pre><code>about.set_program_name "Battery"
about.set_version "0.1"
about.set_copyright "(c) Jan Bodnar"
</code></pre>


<p>这里我们指定名称、版本号和版权信息。</p>


<pre><code>about.set_logo Gdk::Pixbuf.new "battery.png"
</code></pre>


<p>这行创建一个logo。 <br>
<img alt="image5" src="http://zetcode.com/img/gui/rubygtk/about.png"> <br>
<em>图片：AboutDialog</em></p>


<h2>字体选择对话框</h2>


<p>FontSelectionDialog是一个用于选择字体的对话框。它典型的应用于文本编辑或者格式化的应用程序中。</p>


<pre><code>#!/usr/bin/ruby

# ZetCode Ruby GTK tutorial
#
# This example works with the
# FontSelectionDialog
#
# author: jan bodnar
# website: www.zetcode.com
# last modified: June 2009

require 'gtk2'


class RubyApp &lt; Gtk::Window

    def initialize
        super

        set_title "FontSelectionDialog"
        signal_connect "destroy" do 
            Gtk.main_quit 
        end

        init_ui

        set_default_size 300, 150
        set_window_position Gtk::Window::POS_CENTER

        show_all
    end

    def init_ui

        set_border_width 10
        @label = Gtk::Label.new "The only victory over love is flight."
        button = Gtk::Button.new "Select font"

        button.signal_connect "clicked" do
            on_clicked
        end

        fix = Gtk::Fixed.new
        fix.put button, 100, 30
        fix.put @label, 30, 90
        add fix

    end

    def on_clicked
        fdia = Gtk::FontSelectionDialog.new "Select font name"
        response = fdia.run

        if response == Gtk::Dialog::RESPONSE_OK
            font_desc = Pango::FontDescription.new fdia.font_name
            if font_desc
                @label.modify_font font_desc
            end
        end
        fdia.destroy
    end     
end

Gtk.init
    window = RubyApp.new
Gtk.main
</code></pre>


<p>这个代码例子我们创建了一个按钮和一个标签。点击按钮之后显示字体选择对话框。</p>


<pre><code>fdia = Gtk::FontSelectionDialog.new "Select font name"
</code></pre>


<p>创建<em>FontSelectionDialog</em>。</p>


<pre><code>if response == Gtk::Dialog::RESPONSE_OK
    font_desc = Pango::FontDescription.new fdia.font_name
    if font_desc
        @label.modify_font font_desc
    end
end
</code></pre>


<p>如果点击确定按钮，标签的字体会变为我们在对话框中选中的。<br>
<img alt="image6" src="http://zetcode.com/img/gui/rubygtk/fontdialog.png"><br>
<em>图片：FontSelectionDialog</em></p>


<h2>颜色选择对话框</h2>


<p>ColorSelectionDialog是用于选择颜色的对话框。</p>


<pre><code>#!/usr/bin/ruby

# ZetCode Ruby GTK tutorial
#
# This example works with the
# ColorSelectionDialog
#
# author: jan bodnar
# website: www.zetcode.com
# last modified: June 2009

require 'gtk2'


class RubyApp &lt; Gtk::Window

    def initialize
        super

        set_title "ColorSelectionDialog"
        signal_connect "destroy" do 
            Gtk.main_quit 
        end

        init_ui

        set_default_size 350, 150
        set_window_position Gtk::Window::POS_CENTER

        show_all
    end

    def init_ui

        set_border_width 10
        @label = Gtk::Label.new "The only victory over love is flight."
        button = Gtk::Button.new "Select color"

        button.signal_connect "clicked" do
            on_clicked
        end

        fix = Gtk::Fixed.new
        fix.put button, 100, 30
        fix.put @label, 30, 90
        add fix
    end

    def on_clicked
        cdia = Gtk::ColorSelectionDialog.new "Select color"
        response = cdia.run

        if response == Gtk::Dialog::RESPONSE_OK
            colorsel = cdia.colorsel
            color = colorsel.current_color
            @label.modify_fg Gtk::STATE_NORMAL, color
        end

        cdia.destroy
    end
end

Gtk.init
    window = RubyApp.new
Gtk.main
</code></pre>


<p>这个例子与前一个例子很相似。这次我们是改变标签的颜色。</p>


<pre><code>cdia = Gtk::ColorSelectionDialog.new "Select color"
</code></pre>


<p>创建ColorSelectionDialog。</p>


<pre><code>if response == Gtk::Dialog::RESPONSE_OK
    colorsel = cdia.colorsel
    color = colorsel.current_color
    @label.modify_fg Gtk::STATE_NORMAL, color
end
</code></pre>


<p>如果按下OK按钮，我们得到颜色值并修改标签的颜色。</p>


<p><img alt="image7" src="http://zetcode.com/img/gui/rubygtk/colordialog.png"><br>
<em>图片：ColorSelectionDialog</em></p>


<p>这部分的Ruby GTK教程我们展示了对话框。</p>


<hr>


<p>原文地址： <a href="http://zetcode.com/gui/rubygtk/dialogs/">http://zetcode.com/gui/rubygtk/dialogs/</a><br>
翻译：龙昌  admin@longchangjin.cn </p>

</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
    <h1 class="entry-title"><a href="http://www.xefan.com/archives/83963.html">[翻译]Ruby GTK教程4——菜单&工具条</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2013-11-23T00:00:00+08:00'><span class='date'><span class='date-month'>Nov</span> <span class='date-day'>23</span><span class='date-suffix'>rd</span>, <span class='date-year'>2013</span></span> <span class='time'>12:00 am</span></time>
        
           | <a href="http://www.xefan.com/archives/83963.html#disqus_thread"
             data-disqus-identifier="http://www.xefan.com/archives/83963.html">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><h1>菜单&amp;工具条</h1>


<p>这部分的Ruby GTK教程我们将使用菜单和工具条。</p>


<p>菜单栏是GUI应用中最常用的部分之一。它是位于各个菜单的一组命令。在命令行应用程序中我们需要记住这些所有神秘的命令，而现在我们将这些大部分的命令按照逻辑归合在一起。接受这些标准将进一步减少在学习新应用上花费的时间。</p>


<h2>简单的菜单</h2>


<p>我们的第一个例子将创建一个有文件菜单的菜单栏。这个菜单只有一个菜单项，选择这一项将退出应用。</p>


<pre><code>#!/usr/bin/ruby

# ZetCode Ruby GTK tutorial
#
# This example shows a simple menu
#
# author: jan bodnar
# website: www.zetcode.com
# last modified: June 2009

require 'gtk2'


class RubyApp &lt; Gtk::Window

    def initialize
        super

        set_title "Simple menu"
        signal_connect "destroy" do 
            Gtk.main_quit 
        end

        init_ui

        set_default_size 250, 200
        set_window_position Gtk::Window::POS_CENTER

        show_all
    end

    def init_ui

        modify_bg Gtk::STATE_NORMAL, Gdk::Color.new(6400, 6400, 6440)

        mb = Gtk::MenuBar.new

        filemenu = Gtk::Menu.new
        filem = Gtk::MenuItem.new "File"
        filem.set_submenu filemenu

        exit = Gtk::MenuItem.new "Exit"
        exit.signal_connect "activate" do
            Gtk.main_quit
        end

        filemenu.append exit

        mb.append filem

        vbox = Gtk::VBox.new false, 2
        vbox.pack_start mb, false, false, 0

        add vbox
    end
end

Gtk.init
    window = RubyApp.new
Gtk.main
</code></pre>


<p>这是一个最小功能的菜单栏的例子。</p>


<pre><code>mb = Gtk::MenuBar.new
</code></pre>


<p>创建<em>MenuBar</em>控件，这是菜单的容器。</p>


<pre><code>filemenu = Gtk::Menu.new
filem = Gtk::MenuItem.new "File"
filem.set_submenu filemenu
</code></pre>


<p>创建顶级菜单项。</p>


<pre><code>exit = Gtk::MenuItem.new "Exit"
exit.signal_connect "activate" do
    Gtk.main_quit
end

filemenu.append exit
</code></pre>


<p>创建退出菜单项并添加到文件菜单项中。</p>


<pre><code>mb.append filem
</code></pre>


<p>将顶级菜单项添加到菜单栏控件中。</p>


<pre><code>vbox = Gtk::VBox.new false, 2
vbox.pack_start mb, false, false, 0
</code></pre>


<p>与其他套件不同，我们必须要自己处理菜单栏的布局。我们将菜单栏放入竖直盒子中。</p>


<p><img alt="image1" src="http://zetcode.com/img/gui/rubygtk/simplemenu.png"> <br>
<em>图片：简单的菜单</em></p>


<h2>子菜单</h2>


<p>最后展示如何创建一个子菜单。</p>


<pre><code>#!/usr/bin/ruby

# ZetCode Ruby GTK tutorial
#
# This example shows a submenu
#
# author: jan bodnar
# website: www.zetcode.com
# last modified: June 2009

require 'gtk2'


class RubyApp &lt; Gtk::Window

    def initialize
        super

        set_title "Submenu"
        signal_connect "destroy" do 
            Gtk.main_quit 
        end

        init_ui

        set_default_size 250, 200
        set_window_position Gtk::Window::POS_CENTER

        show_all
    end

    def init_ui

        modify_bg Gtk::STATE_NORMAL, Gdk::Color.new(6400, 6400, 6440)

        mb = Gtk::MenuBar.new

        filemenu = Gtk::Menu.new
        filem = Gtk::MenuItem.new "File"
        filem.set_submenu filemenu

        mb.append filem

        imenu = Gtk::Menu.new

        importm = Gtk::MenuItem.new "Import"
        importm.set_submenu imenu

        inews = Gtk::MenuItem.new "Import news feed..."
        ibookmarks = Gtk::MenuItem.new "Import bookmarks..."
        imail = Gtk::MenuItem.new "Import mail..."

        imenu.append inews
        imenu.append ibookmarks
        imenu.append imail

        filemenu.append importm

        exit = Gtk::MenuItem.new "Exit"
        exit.signal_connect "activate" do
            Gtk.main_quit
        end

        filemenu.append exit

        vbox = Gtk::VBox.new false, 2
        vbox.pack_start mb, false, false, 0

        add vbox
    end
end

Gtk.init
    window = RubyApp.new
Gtk.main
</code></pre>


<p>创建子菜单。</p>


<pre><code>imenu = Gtk::Menu.new
</code></pre>


<p>子菜单也是Menu控件。</p>


<pre><code>importm = Gtk::MenuItem.new "Import"
importm.set_submenu imenu
</code></pre>


<p>这是属于文件顶级菜单的菜单项的子菜单。</p>


<pre><code>inews = Gtk::MenuItem.new "Import news feed..."
ibookmarks = Gtk::MenuItem.new "Import bookmarks..."
imail = Gtk::MenuItem.new "Import mail..."

imenu.append inews
imenu.append ibookmarks
imenu.append imail
</code></pre>


<p>子菜单有自己的菜单项。</p>


<p><img alt="image2" src="http://zetcode.com/img/gui/rubygtk/submenu.png"><br>
<em>图片：子菜单</em></p>


<h2>图片菜单</h2>


<p>接下来的例子我们将进一步探索菜单。我们将在菜单项上添加图片和快捷键（accelerators）。</p>


<pre><code>#!/usr/bin/ruby

# ZetCode Ruby GTK tutorial
#
# This example shows a menu with
# images, accelerators and a separator
#
# author: jan bodnar
# website: www.zetcode.com
# last modified: June 2009

require 'gtk2'


class RubyApp &lt; Gtk::Window

    def initialize
        super

        set_title "Image menu"
        signal_connect "destroy" do 
            Gtk.main_quit 
        end

        init_ui

        set_default_size 250, 200
        set_window_position Gtk::Window::POS_CENTER

        show_all
    end

    def init_ui

        modify_bg Gtk::STATE_NORMAL, Gdk::Color.new(6400, 6400, 6440)

        mb = Gtk::MenuBar.new

        filemenu = Gtk::Menu.new
        filem = Gtk::MenuItem.new "File"
        filem.set_submenu filemenu

        agr = Gtk::AccelGroup.new
        add_accel_group agr

        newi = Gtk::ImageMenuItem.new Gtk::Stock::NEW, agr
        key, mod = Gtk::Accelerator.parse "N"
        newi.add_accelerator("activate", agr, key, 
            mod, Gtk::ACCEL_VISIBLE)
        filemenu.append newi

        openm = Gtk::ImageMenuItem.new Gtk::Stock::OPEN, agr
        key, mod = Gtk::Accelerator.parse "O"
        openm.add_accelerator("activate", agr, key, 
            mod, Gtk::ACCEL_VISIBLE)
        filemenu.append openm

        sep = Gtk::SeparatorMenuItem.new
        filemenu.append sep

        exit = Gtk::ImageMenuItem.new Gtk::Stock::QUIT, agr
        key, mod = Gtk::Accelerator.parse "Q"
        exit.add_accelerator("activate", agr, key, 
            mod, Gtk::ACCEL_VISIBLE)

        exit.signal_connect "activate" do
            Gtk.main_quit
        end
        filemenu.append exit

        mb.append filem

        vbox = Gtk::VBox.new false, 2
        vbox.pack_start mb, false, false, 0

        add vbox
    end
end

Gtk.init
    window = RubyApp.new
Gtk.main
</code></pre>


<p>这个例子显示了一个有子菜单的顶级菜单，每个菜单项都有一个图像和一个快捷键。退出菜单的快捷键是激活的。</p>


<pre><code>agr = Gtk::AccelGroup.new
add_accel_group agr
</code></pre>


<p>为了使用快捷键，我们创建了一个全局的<em>AccelGroup</em>对象。它稍后被用到。</p>


<pre><code>newi = Gtk::ImageMenuItem.new Gtk::Stock::NEW, agr
key, mod = Gtk::Accelerator.parse "N"
newi.add_accelerator("activate", agr, key, 
    mod, Gtk::ACCEL_VISIBLE)
filemenu.append newi
</code></pre>


<p>创建图片菜单项。图片来自图片库中。我们也创建了<em>Ctrl+N</em>快捷键。</p>


<pre><code>sep = Gtk::SeparatorMenuItem.new
filemenu.append sep
</code></pre>


<p>这行创建一条分隔线。它用于将菜单项按照逻辑分组。</p>


<p><img alt="image3" src="http://zetcode.com/img/gui/rubygtk/imagemenu.png"><br>
<em>图片：图片菜单</em></p>


<p>菜单将我们使用的命令进行分组。工具条提供了一个快速访问最常用命令的方式。</p>


<h2>简单的工具条</h2>


<p>接下来我们创建一个简单的工具条。</p>


<pre><code>#!/usr/bin/ruby

# ZetCode Ruby GTK tutorial
#
# This example shows a toolbar
# widget
#
# author: jan bodnar
# website: www.zetcode.com
# last modified: June 2009

require 'gtk2'


class RubyApp &lt; Gtk::Window

    def initialize
        super

        set_title "Toolbar"
        signal_connect "destroy" do 
            Gtk.main_quit 
        end

        init_ui

        set_default_size 250, 200
        set_window_position Gtk::Window::POS_CENTER

        show_all
    end

    def init_ui

        toolbar = Gtk::Toolbar.new
        toolbar.set_toolbar_style Gtk::Toolbar::Style::ICONS

        newtb = Gtk::ToolButton.new Gtk::Stock::NEW
        opentb = Gtk::ToolButton.new Gtk::Stock::OPEN
        savetb = Gtk::ToolButton.new Gtk::Stock::SAVE
        sep = Gtk::SeparatorToolItem.new
        quittb = Gtk::ToolButton.new Gtk::Stock::QUIT

        toolbar.insert 0, newtb
        toolbar.insert 1, opentb
        toolbar.insert 2, savetb
        toolbar.insert 3, sep
        toolbar.insert 4, quittb

        quittb.signal_connect "clicked" do
            Gtk.main_quit
        end

        vbox = Gtk::VBox.new false, 2
        vbox.pack_start toolbar, false, false, 0

        add(vbox)
    end
end

Gtk.init
    window = RubyApp.new
Gtk.main
</code></pre>


<p>这个例子显示了有四个工具按钮的工具栏。</p>


<pre><code>toolbar = Gtk::Toolbar.new
</code></pre>


<p>创建<em>Toolbar</em>控件。</p>


<pre><code>toolbar.set_toolbar_style Gtk::Toolbar::Style::ICONS
</code></pre>


<p>工具栏上我们只显示图标，没有文字。</p>


<pre><code>newtb = Gtk::ToolButton.new Gtk::Stock::NEW
</code></pre>


<p>创建了一个包含图片的ToolButton控件。图片来自内建的图片库。</p>


<pre><code>sep = Gtk::SeparatorToolItem.new
</code></pre>


<p>这是一个分隔符，用于将按钮按照逻辑分组。</p>


<pre><code>toolbar.insert 0, newtb
toolbar.insert 1, opentb
...
</code></pre>


<p>将按钮添加到工具栏。</p>


<p><img alt="image4" src="http://zetcode.com/img/gui/rubygtk/toolbar.png"><br>
<em>图片：工具栏</em></p>


<h2>撤消重做</h2>


<p>接下来的例子展示了如何停用工具栏上的按钮。这是GUI编程中的常见练习。例如对于保存按钮，在大多数编辑器中如果我们将文档的修改保存到磁盘中了，那么保存按钮会被停用。这是应用程序给用户的提示，所有修改都已保存。</p>


<pre><code>#!/usr/bin/ruby

# ZetCode Ruby GTK tutorial
#
# This example shows how to 
# activate/deactivate a ToolButton
#
# author: jan bodnar
# website: www.zetcode.com
# last modified: June 2009

require 'gtk2'


class RubyApp &lt; Gtk::Window


    def initialize
        super

        set_title "Undo redo"
        signal_connect "destroy" do 
            Gtk.main_quit 
        end

        @count = 2

        init_ui

        set_default_size 250, 200
        set_window_position Gtk::Window::POS_CENTER

        show_all
    end

    def init_ui

        toolbar = Gtk::Toolbar.new
        toolbar.set_toolbar_style Gtk::Toolbar::Style::ICONS

        @undo = Gtk::ToolButton.new Gtk::Stock::UNDO
        @redo = Gtk::ToolButton.new Gtk::Stock::REDO
        sep = Gtk::SeparatorToolItem.new
        quit = Gtk::ToolButton.new Gtk::Stock::QUIT

        toolbar.insert 0, @undo
        toolbar.insert 1, @redo
        toolbar.insert 2, sep
        toolbar.insert 3, quit

        @undo.signal_connect "clicked" do
            on_undo
        end

        @redo.signal_connect "clicked" do
            on_redo
        end

        quit.signal_connect "clicked" do
            Gtk.main_quit
        end

        vbox = Gtk::VBox.new false, 2
        vbox.pack_start toolbar, false, false, 0

        self.add vbox

    end

    def on_undo

        @count = @count - 1

        if @count &lt;= 0
            @undo.set_sensitive false
            @redo.set_sensitive true
        end
    end


    def on_redo
        @count = @count + 1

        if @count &gt;= 5
            @redo.set_sensitive false
            @undo.set_sensitive true
        end
    end
end

Gtk.init
    window = RubyApp.new
Gtk.main
</code></pre>


<p>我们例子从GTK资源中创建了撤消和重做按钮。每个按钮点击多次后会被禁用，变为灰色。</p>


<pre><code>@count = 2
</code></pre>


<p><em>@count</em>变量用于描述按钮是禁用还是激活。</p>


<pre><code>@undo = Gtk::ToolButton.new Gtk::Stock::UNDO
@redo = Gtk::ToolButton.new Gtk::Stock::REDO
</code></pre>


<p>创建两个工具按钮，图片来自资源库。</p>


<pre><code>@undo.signal_connect "clicked" do
    on_undo
end
</code></pre>


<p>点击undo按钮触发<em>on_undo</em>方法。</p>


<pre><code>if @count &lt;= 0
    @undo.set_sensitive false
    @redo.set_sensitive true
end
</code></pre>


<p>我们使用<em>set_sensitive</em>方法激活或者禁用控件。</p>


<p><img alt="image5" src="http://zetcode.com/img/gui/rubygtk/undoredo.png"><br>
<em>图片：撤消重做</em></p>


<p>这章的Ruby GTK教程我们展示了如何使用菜单和工具栏。</p>


<hr>


<p>原文地址： <a href="http://zetcode.com/gui/rubygtk/menustoolbars/">http://zetcode.com/gui/rubygtk/menustoolbars/</a><br>
翻译：龙昌  admin@longchangjin.cn  </p>

</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
    <h1 class="entry-title"><a href="http://www.xefan.com/archives/83960.html">[翻译]Ruby GTK教程3——控件</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2013-11-23T00:00:00+08:00'><span class='date'><span class='date-month'>Nov</span> <span class='date-day'>23</span><span class='date-suffix'>rd</span>, <span class='date-year'>2013</span></span> <span class='time'>12:00 am</span></time>
        
           | <a href="http://www.xefan.com/archives/83960.html#disqus_thread"
             data-disqus-identifier="http://www.xefan.com/archives/83960.html">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><h1>控件</h1>


<p>在这部分的Ruby GTK编程教程中我们将提到一些控件。</p>


<p>控件是GUI应用程序的基本构成。这些年来一些控件成为了所有平台所有套件的标准。如按钮、复选框或者滚动条。GTK套件的理念是保持控件的数量为最小的数量级，一些特殊的控件需要创建为自定义GTK控件。</p>


<h2>复选按钮（CheckButton）</h2>


<p><em>CheckButton</em>是一个有两种状态的控件，开和关。开状态表示选中。它用于表示一些布尔属性。</p>


<pre><code>#!/usr/bin/ruby

# ZetCode Ruby GTK tutorial
#
# This program toggles the title of the
# window with the CheckButton widget
#
# author: jan bodnar
# website: www.zetcode.com
# last modified: April 2009

require 'gtk2'

class RubyApp &lt; Gtk::Window
    def initialize
        super

        set_title "CheckButton"
        signal_connect "destroy" do 
            Gtk.main_quit 
        end

        init_ui

        set_default_size 250, 200
        set_window_position Gtk::Window::POS_CENTER
        show_all
    end


    def init_ui

        fixed = Gtk::Fixed.new
        add fixed

        cb = Gtk::CheckButton.new "Show title"
        cb.set_active true
        cb.set_can_focus false
        cb.signal_connect("clicked") do |w|
            on_clicked(w)
        end

        fixed.put cb, 50, 50

    end

    def on_clicked sender

        if sender.active?
            self.set_title "Check Button"
        else
           self.set_title ""
        end
    end
end

Gtk.init
    window = RubyApp.new
Gtk.main
</code></pre>


<p>我们将根据复选按钮的状态在窗口的标题栏显示一个标题。</p>


<pre><code>cb = Gtk::CheckButton.new "Show title"
</code></pre>


<p>创建<em>CheckButton</em>控件。</p>


<pre><code>cb.set_active true
</code></pre>


<p>标题默认是可见的，因此我们将按钮默认选中。</p>


<pre><code>if sender.active?
    self.set_title "Check Button"
else
    self.set_title ""
end
</code></pre>


<p>如果按钮选中则显示标题。</p>


<p><img alt="image1" src="http://zetcode.com/img/gui/rubygtk/checkbutton.png"><br>
<em>图片：复选按钮</em></p>


<h2>标签（Label）</h2>


<p>Label控件用于显示文本。</p>


<pre><code>#!/usr/bin/ruby

# ZetCode Ruby GTK tutorial
#
# This example demonstrates the Label widget
#
# author: jan bodnar
# website: www.zetcode.com
# last modified: June 2009

require 'gtk2'

$lyrics = %{Meet you downstairs in the bar and heard
your rolled up sleeves and your skull t-shirt
You say why did you do it with him today?
and sniff me out like I was Tanqueray

cause you're my fella, my guy
hand me your stella and fly
by the time I'm out the door
you tear men down like Roger Moore

I cheated myself
like I knew I would
I told ya, I was trouble
you know that I'm no good}


class RubyApp &lt; Gtk::Window

    def initialize
        super

        set_title  "You know I'm no Good"
        signal_connect "destroy" do 
            Gtk.main_quit 
        end

        init_ui

        set_default_size 250, 200
        set_window_position Gtk::Window::POS_CENTER

        show_all
    end

    def init_ui

        set_border_width 10
        label = Gtk::Label.new $lyrics
        add label

    end
end

Gtk.init
    window = RubyApp.new
Gtk.main
</code></pre>


<p>例子在窗口上显示了一些歌词。</p>


<pre><code> $lyrics = %{Meet you downstairs in the bar and heard
 your rolled up sleeves and your skull t-shirt
 ...
</code></pre>


<p>创建一个多行文本。</p>


<pre><code>set_border_width 10
</code></pre>


<p>标签被一些空白空间包围着。</p>


<pre><code>label = Gtk::Label.new $lyrics
add label
</code></pre>


<p>创建标签并添加到窗口内。</p>


<p><img alt="image2" src="http://zetcode.com/img/gui/rubygtk/label.png"><br>
<em>图片：标签控件</em></p>


<h2>输入框（Entry）</h2>


<p>Entry是单行文本输入字段，用于文本数据的输入。</p>


<pre><code>#!/usr/bin/ruby

# ZetCode Ruby GTK tutorial
#
# This example demonstrates the Entry widget
#
# author: jan bodnar
# website: www.zetcode.com
# last modified: June 2009

require 'gtk2'


class RubyApp &lt; Gtk::Window

    def initialize
        super

        set_title "Entry"
        signal_connect "destroy" do 
            Gtk.main_quit 
        end

        init_ui

        set_default_size 250, 200
        set_window_position Gtk::Window::POS_CENTER

        show_all
    end

    def init_ui

        fixed = Gtk::Fixed.new

        label = Gtk::Label.new "..."
        fixed.put label, 60, 40

        entry = Gtk::Entry.new
        fixed.put entry, 60, 100

        entry.signal_connect "key-release-event" do |w, e|
            on_key_release(w, e, label)
        end

        add(fixed)
    end

    def on_key_release sender, event, label
        label.set_text sender.text
    end
end

Gtk.init
    window = RubyApp.new
Gtk.main
</code></pre>


<p>这个例子显示了一个输入控件和一个标签。我们在输入框输入的文本会立即在标签上显示。</p>


<pre><code>entry = Gtk::Entry.new
</code></pre>


<p>创建Entry控件。</p>


<pre><code>entry.signal_connect "key-release-event" do |w, e|
    on_key_release(w, e, label)
end
</code></pre>


<p>我们将<em>on_key_release</em>方法插到Entry控件的<em>key-release-event</em>事件中。</p>


<pre><code>def on_key_release sender, event, label
    label.set_text sender.text
end
</code></pre>


<p>从Entry控件获取文本并设置到标签中。</p>


<p><img alt="image3" src="http://zetcode.com/img/gui/rubygtk/entry.png"><br>
<em>图片：Entry控件</em></p>


<h2>图片（Image）</h2>


<p>Image控件用于显示图片。</p>


<pre><code>#!/usr/bin/ruby

# ZetCode Ruby GTK tutorial
#
# This example demonstrates the Image widget
#
# author: jan bodnar
# website: www.zetcode.com
# last modified: June 2009

require 'gtk2'


class RubyApp &lt; Gtk::Window

    def initialize
        super

        set_title "Red Rock"
        signal_connect "destroy" do 
            Gtk.main_quit 
        end

        init_ui

        set_default_size 250, 200
        set_window_position Gtk::Window::POS_CENTER

        show_all
    end

    def init_ui

        set_border_width 2

        begin
            image = Gtk::Image.new "redrock.png"
        rescue
            puts "cannot load image"
            exit
        end

        add image
    end

end

Gtk.init
    window = RubyApp.new
Gtk.main
</code></pre>


<p>我们例子在窗口上显示了一个图片。</p>


<pre><code>set_border_width 2
</code></pre>


<p>我们在图片周围添加一些空白边框。</p>


<pre><code>begin
    image = Gtk::Image.new "redrock.png"
rescue
    puts "cannot load image"
    exit
end
</code></pre>


<p>创建Image控件。IO操作容易出现错误，因此我们处理可能的异常。</p>


<pre><code>add image
</code></pre>


<p>将控件添加到容器中。</p>


<p><img alt="image4" src="http://zetcode.com/img/gui/rubygtk/image.jpg"><br>
<em>图片：Image控件</em></p>


<h2>下拉框（ComboBox）</h2>


<p>ComboBox控件允许用户从一个列表选项中进行选择。</p>


<pre><code>#!/usr/bin/ruby

# ZetCode Ruby GTK tutorial
#
# This example demonstrates the ComboBox widget
#
# author: jan bodnar
# website: www.zetcode.com
# last modified: June 2009

require 'gtk2'


class RubyApp &lt; Gtk::Window

    def initialize
        super

        set_title "ComboBox"
        signal_connect "destroy" do 
            Gtk.main_quit 
        end

        init_ui

        set_default_size 250, 200
        set_window_position Gtk::Window::POS_CENTER

        show_all
    end

    def init_ui

        fixed = Gtk::Fixed.new
        label = Gtk::Label.new '-'
        fixed.put label, 50, 140

        cb = Gtk::ComboBox.new
        cb.signal_connect "changed" do |w, e|
            on_changed(w, e, label)
        end

        cb.append_text 'Ubuntu'
        cb.append_text 'Mandriva'
        cb.append_text 'Redhat'
        cb.append_text 'Gento'
        cb.append_text 'Mint'

        fixed.put cb, 50, 30

        add fixed

    end

    def on_changed sender, event, label
        label.set_label sender.active_text
    end
end

Gtk.init
    window = RubyApp.new
Gtk.main
</code></pre>


<p>这个例子显示了一个下拉框和一个标签。下拉框列表有5个选项。它们是Linux发行版的名称。标签控件显示下拉列表选中的选项。</p>


<pre><code>cb = Gtk::ComboBox.new
</code></pre>


<p>创建下拉框。</p>


<pre><code>cb.append_text 'Ubuntu'
cb.append_text 'Mandriva'
cb.append_text 'Redhat'
cb.append_text 'Gento'
cb.append_text 'Mint'
</code></pre>


<p>填充数据。</p>


<pre><code>def on_changed sender, event, label
    label.set_label sender.active_text
end
</code></pre>


<p>在<em>on_changed</em>方法里，我们获取选中的文本并设置到标签中。</p>


<p><img alt="image5" src="http://zetcode.com/img/gui/rubygtk/combobox.png"><br>
<em>图片：下拉框</em></p>


<p>在这章的Ruby GTK教程中我们显示了一些基本的控件。</p>


<hr>


<p>原文地址： <a href="http://zetcode.com/gui/rubygtk/widgets/">http://zetcode.com/gui/rubygtk/widgets/</a><br>
翻译：龙昌  admin@longchangjin.cn  </p>

</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
    <h1 class="entry-title"><a href="http://www.xefan.com/archives/83957.html">[翻译]Ruby GTK教程2——布局管理</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2013-11-21T00:00:00+08:00'><span class='date'><span class='date-month'>Nov</span> <span class='date-day'>21</span><span class='date-suffix'>st</span>, <span class='date-year'>2013</span></span> <span class='time'>12:00 am</span></time>
        
           | <a href="http://www.xefan.com/archives/83957.html#disqus_thread"
             data-disqus-identifier="http://www.xefan.com/archives/83957.html">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><h1>布局管理</h1>


<p>这一章我们将展示如何布置窗口或者对话框中的控件。</p>


<p>当我设计应用程序的用户界面时，我们决定了将要使用哪些控件以及如何在应用程序中组织这些控件。为了组织我们的控件，我们使用了一些称为布局容器的特殊不可见控件。这一章我们将提到<em>Alignment</em>、<em>Fixed</em>、<em>VBox</em>和<em>Table</em>。</p>


<h2>Fixed</h2>


<p>Fixed窗口是将子控件放置在固定位置固定大小。这个容器不会执行自动布局管理。在大部分的应用程序中我们不使用这个容器。它用于一些特殊的地方，例如游戏、使用图表的特殊应用、可移动可变大小的组件（如电子表格中的图表）。以下是一些小例子。</p>


<pre><code>#!/usr/bin/ruby

# ZetCode Ruby GTK tutorial
#
# In this program, we lay out widgets
# using absolute positioning
#
# author: jan bodnar
# website: www.zetcode.com
# last modified: June 2009

require 'gtk2'


class RubyApp &lt; Gtk::Window

    def initialize
        super

        set_title "Fixed"
        signal_connect "destroy" do 
            Gtk.main_quit 
        end

        init_ui

        set_default_size 300, 280
        set_window_position Gtk::Window::POS_CENTER

        show_all
    end

    def init_ui

        modify_bg Gtk::STATE_NORMAL, Gdk::Color.new(6400, 6400, 6440)

        begin       
            bardejov = Gdk::Pixbuf.new "bardejov.jpg"
            rotunda = Gdk::Pixbuf.new "rotunda.jpg"
            mincol = Gdk::Pixbuf.new "mincol.jpg"
        rescue IOError =&gt; e
            puts e
            puts "cannot load images"
            exit
        end

        image1 = Gtk::Image.new bardejov
        image2 = Gtk::Image.new rotunda
        image3 = Gtk::Image.new mincol

        fixed = Gtk::Fixed.new

        fixed.put image1, 20, 20
        fixed.put image2, 40, 160
        fixed.put image3, 170, 50

        add fixed

    end
end

Gtk.init
    window = RubyApp.new
Gtk.main
</code></pre>


<p>在我们在例子中我们在窗口上显示了三张图片。我们明确的指定了这些图片的x、y坐标的位置。</p>


<pre><code>modify_bg Gtk::STATE_NORMAL, Gdk::Color.new(6400, 6400, 6440)
</code></pre>


<p>为了更好的显示体验，我们修改背景颜色为灰色。</p>


<pre><code>bardejov = Gdk::Pixbuf.new "bardejov.jpg"
</code></pre>


<p>从磁盘上加载图片为Pixbug对象。</p>


<pre><code>image1 = Gtk::Image.new bardejov
image2 = Gtk::Image.new rotunda
image3 = Gtk::Image.new mincol
</code></pre>


<p><em>Image</em>是用于显示图片的控件。在它的构造函数接收一个<em>Pixbuf</em>对象。</p>


<pre><code>fixed = Gtk::Fixed.new
</code></pre>


<p>创建一个Fixed容器。</p>


<pre><code>fixed.put image1, 20, 20
</code></pre>


<p>将第一张图片放在x=20，y=20的坐标位置上。</p>


<pre><code> add fixed
</code></pre>


<p>最后我们将Fixed窗口放入窗口中。</p>


<p><img alt="image1" src="http://zetcode.com/img/gui/rubygtk/fixed.png"><br>
<em>图片：Fixed</em></p>


<h2>按钮</h2>


<p>Alignment容器用于控件它的子控件的对齐和大小。</p>


<pre><code>#!/usr/bin/ruby

# ZetCode Ruby GTK tutorial
#
# In this program, we position two buttons
# in the bottom right corner of the window.
# We use horizontal and vertical boxes.
#
# author: jan bodnar
# website: www.zetcode.com
# last modified: June 2009

require 'gtk2'


class RubyApp &lt; Gtk::Window

    def initialize
        super

        set_title "Buttons"
        signal_connect "destroy" do 
            Gtk.main_quit 
        end

        init_ui

        set_default_size 260, 150
        set_window_position Gtk::Window::POS_CENTER

        show_all
    end

    def init_ui

        vbox = Gtk::VBox.new false, 5
        hbox = Gtk::HBox.new true, 3

        valign = Gtk::Alignment.new 0, 1, 0, 0
        vbox.pack_start valign

        ok = Gtk::Button.new "OK"
        ok.set_size_request 70, 30
        close = Gtk::Button.new "Close"

        hbox.add ok
        hbox.add close

        halign = Gtk::Alignment.new 1, 0, 0, 0
        halign.add hbox

        vbox.pack_start halign, false, false, 3

        add vbox
    end
end

Gtk.init
    window = RubyApp.new
Gtk.main
</code></pre>


<p>这个例子的代码中，我们将两个按钮放置在窗口的右下角。为了实现这个功能我们使用了两个垂直盒子和一个水平盒子和两个对齐容器。</p>


<pre><code>valign = Gtk::Alignment.new 0, 1, 0, 0
</code></pre>


<p>这会将子控件放置在底部。</p>


<pre><code>vbox.pack_start valign
</code></pre>


<p>这里我们将Alignment控件放置在竖直例子中。</p>


<pre><code>hbox = Gtk::HBox.new true, 3 
...
ok = Gtk::Button.new "OK"
ok.set_size_request 70, 30
close = Gtk::Button.new "Close"

hbox.add ok
hbox.add close
</code></pre>


<p>创建一个水平盒子并放入两个按钮。</p>


<pre><code>halign = Gtk::Alignment.new 1, 0, 0, 0
halign.add hbox

vbox.pack_start halign, false, false, 3
</code></pre>


<p>这将会创建一个对齐容器用于将其子控件放置在右边。我们将水平盒子放入对齐容器里并将对齐容器放入竖直盒子中。我们必须记住对齐容器只有一个子控件，这就是为什么我们要使用盒子容器。 <br>
<img alt="image2" src="http://zetcode.com/img/gui/rubygtk/buttons.png"><br>
<em>图片：按钮</em></p>


<h2>计算器框架</h2>


<p>Table控件将控件按行和列进行排序。</p>


<pre><code>#!/usr/bin/ruby

# ZetCode Ruby GTK tutorial
#
# In this program we create a skeleton of
# a calculator. We use the Table widget. 
#
# author: jan bodnar
# website: www.zetcode.com
# last modified: June 2009

require 'gtk2'


class RubyApp &lt; Gtk::Window

    def initialize
        super

        set_title "Calculator"
        signal_connect "destroy" do 
            Gtk.main_quit 
        end

        init_ui

        set_default_size 300, 250
        set_window_position Gtk::Window::POS_CENTER

        show_all
    end

    def init_ui

        vbox = Gtk::VBox.new false, 2

        mb = Gtk::MenuBar.new
        filemenu = Gtk::Menu.new
        file = Gtk::MenuItem.new "File"
        file.set_submenu filemenu
        mb.append file

        vbox.pack_start mb, false, false, 0

        table = Gtk::Table.new 5, 4, true

        table.attach Gtk::Button.new("Cls"), 0, 1, 0, 1
        table.attach Gtk::Button.new("Bck"), 1, 2, 0, 1
        table.attach Gtk::Label.new, 2, 3, 0, 1
        table.attach Gtk::Button.new("Close"), 3, 4, 0, 1

        table.attach Gtk::Button.new("7"), 0, 1, 1, 2
        table.attach Gtk::Button.new("8"), 1, 2, 1, 2
        table.attach Gtk::Button.new("9"), 2, 3, 1, 2
        table.attach Gtk::Button.new("/"), 3, 4, 1, 2

        table.attach Gtk::Button.new("4"), 0, 1, 2, 3
        table.attach Gtk::Button.new("5"), 1, 2, 2, 3
        table.attach Gtk::Button.new("6"), 2, 3, 2, 3
        table.attach Gtk::Button.new("*"), 3, 4, 2, 3

        table.attach Gtk::Button.new("1"), 0, 1, 3, 4
        table.attach Gtk::Button.new("2"), 1, 2, 3, 4
        table.attach Gtk::Button.new("3"), 2, 3, 3, 4
        table.attach Gtk::Button.new("-"), 3, 4, 3, 4

        table.attach Gtk::Button.new("0"), 0, 1, 4, 5
        table.attach Gtk::Button.new("."), 1, 2, 4, 5
        table.attach Gtk::Button.new("="), 2, 3, 4, 5
        table.attach Gtk::Button.new("+"), 3, 4, 4, 5

        vbox.pack_start Gtk::Entry.new, false, false, 0

        vbox.pack_end table, true, true, 0

        add vbox

    end
end

Gtk.init
    window = RubyApp.new
Gtk.main
</code></pre>


<p>我们使用Table控件来创建计算器的框架。</p>


<pre><code>table = Gtk::Table.new 5, 4, true
</code></pre>


<p>我们创建了一个有5行4列的表格控件。第三个参数是homogenous参数。如果设置为true那么表格中的所有控件都是一样大小的。控件的大小等于表格容器中最大的那个控件。</p>


<pre><code>table.attach Gtk::Button.new("Cls"), 0, 1, 0, 1
</code></pre>


<p>我们将一个按钮附加到表格容器的左上角。前两个参数是单元格的左右边界，后两个参数是单元格的上下边界。</p>


<pre><code>vbox.pack_end table, true, true, 0
</code></pre>


<p>将表格控件打包放入竖直盒子里。<br>
<img alt="image3" src="http://zetcode.com/img/gui/rubygtk/calculator.png">  <br>
<em>图片：计算器框架</em></p>


<h2>窗口</h2>


<p>接下来我们创建一个更高级的例子。我们展示一个JDeveloper IDE中的窗口。</p>


<pre><code>#!/usr/bin/ruby

# ZetCode Ruby GTK tutorial
#
# This is a more complicated layout example.
# We use Alignment and Table widgets. 
#
# author: jan bodnar
# website: www.zetcode.com
# last modified: June 2009

require 'gtk2'


class RubyApp &lt; Gtk::Window

    def initialize
        super

        set_title "Windows"
        signal_connect "destroy" do 
            Gtk.main_quit 
        end

        init_ui

        set_default_size 300, 250
        set_window_position Gtk::Window::POS_CENTER

        show_all
    end

    def init_ui

        set_border_width 15

        table = Gtk::Table.new 8, 4, false
        table.set_column_spacings 3

        title = Gtk::Label.new "Windows"

        halign = Gtk::Alignment.new 0, 0, 0, 0
        halign.add title

        table.attach(halign, 0, 1, 0, 1, Gtk::FILL,
            Gtk::FILL, 0, 0)

        frame = Gtk::Frame.new
        table.attach(frame, 0, 2, 1, 3, Gtk::FILL | Gtk::EXPAND,
            Gtk::FILL | Gtk::EXPAND, 1, 1)

        activate = Gtk::Button.new "Activate"
        activate.set_size_request 50, 30
        table.attach(activate, 3, 4, 1, 2, Gtk::FILL,
            Gtk::SHRINK, 1, 1)

        valign = Gtk::Alignment.new 0, 0, 0, 0
        close = Gtk::Button.new "Close"
        close.set_size_request 70, 30
        valign.add close
        table.set_row_spacing 1, 3
        table.attach(valign, 3, 4, 2, 3, Gtk::FILL,
            Gtk::FILL | Gtk::EXPAND, 1, 1)

        halign2 = Gtk::Alignment.new 0, 1, 0, 0
        help = Gtk::Button.new "Help"
        help.set_size_request 70, 30
        halign2.add help
        table.set_row_spacing 3, 6
        table.attach(halign2, 0, 1, 4, 5, Gtk::FILL,
            Gtk::FILL, 0, 0)

        ok = Gtk::Button.new "OK"
        ok.set_size_request 70, 30
        table.attach(ok, 3, 4, 4, 5, Gtk::FILL,
            Gtk::FILL, 0, 0)

        add table
    end
end

Gtk.init
    window = RubyApp.new
Gtk.main
</code></pre>


<p>这个例子展示了我们如何可以使用Ruby GTK创建一个类似的窗口。</p>


<pre><code>table = Gtk::Table.new 8, 4, false
table.set_column_spacings 3
</code></pre>


<p>这个例子是基于Table容器的。每个列之间有3像素的空隙。</p>


<pre><code>title = Gtk::Label.new "Windows"

halign = Gtk::Alignment.new 0, 0, 0, 0
halign.add title

table.attach(halign, 0, 1, 0, 1, Gtk::FILL,
    Gtk::FILL, 0, 0)
</code></pre>


<p>这个代码创建了一个左对齐的标签。这个标签放置在表格的第一行中。</p>


<pre><code>frame = Gtk::Frame.new
table.attach(frame, 0, 2, 1, 3, Gtk::FILL | Gtk::EXPAND,
    Gtk::FILL | Gtk::EXPAND, 1, 1)
</code></pre>


<p><em>frame</em>控件跨度为2行2列。</p>


<pre><code>valign = Gtk::Alignment.new 0, 0, 0, 0
close = Gtk::Button.new "Close"
close.set_size_request 70, 30
valign.add close
table.set_row_spacing 1, 3
table.attach(valign, 3, 4, 2, 3, Gtk::FILL,
    Gtk::FILL | Gtk::EXPAND, 1, 1)
</code></pre>


<p>我们将关闭按钮放置在<em>frame</em>控件的下一个位置，在表格的第4列（我们是从0算起）。我们将按钮放在对齐控件内，这样我们就可以顶对齐了。</p>


<p><img alt="image4" src="http://zetcode.com/img/gui/rubygtk/windows.png"><br>
<em>图片：窗口</em></p>


<p>这部分的Ruby GTK教程，我们提到了布局控件。</p>


<hr>


<p>原文地址： <a href="http://zetcode.com/gui/rubygtk/layoutmanagement/">http://zetcode.com/gui/rubygtk/layoutmanagement/</a><br>
翻译：龙昌  admin@longchangjin.cn  </p>

</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
    <h1 class="entry-title"><a href="http://www.xefan.com/archives/83954.html">[翻译]Ruby GTK教程1——介绍</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2013-11-20T00:00:00+08:00'><span class='date'><span class='date-month'>Nov</span> <span class='date-day'>20</span><span class='date-suffix'>th</span>, <span class='date-year'>2013</span></span> <span class='time'>12:00 am</span></time>
        
           | <a href="http://www.xefan.com/archives/83954.html#disqus_thread"
             data-disqus-identifier="http://www.xefan.com/archives/83954.html">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><h1>Ruby GTK介绍</h1>


<p>在这部分的Ruby GTK编程教程中，我偿将介绍GTK库并且使用Ruby语言编写我们的第一个程序。</p>


<p>这个教程的目标是让你入门GTK和Ruby。贪吃蛇游戏的图片可以从这里<a href="http://zetcode.com/img/gui/rubygtk/images.zip">下载</a>。</p>


<h2>关于</h2>


<p>GTK是一个领先的创建图形化用户界面的套件。Ruby是一个流行的脚本语言。</p>


<h2>简单的例子</h2>


<p>第一个例子我们创建一个简单的窗口。这个窗口位置屏幕中间。</p>


<pre><code>#!/usr/bin/ruby

# ZetCode Ruby GTK tutorial
#
# This program centers a window on 
# the screen
#
# author: jan bodnar
# website: www.zetcode.com
# last modified: April 2009

require 'gtk2'

class RubyApp &lt; Gtk::Window

    def initialize
        super

        set_title "Center"
        signal_connect "destroy" do 
            Gtk.main_quit 
        end

        set_default_size 250, 200
        set_window_position Gtk::Window::POS_CENTER

        show
    end
end

Gtk.init
    window = RubyApp.new
Gtk.main
</code></pre>


<p>这个例子在屏幕中间显示了一个250x200像素的窗口。</p>


<pre><code>require 'gtk2'
</code></pre>


<p><em>require</em>关键字导入了这个应用程序中将要使用的类。</p>


<pre><code>class RubyApp &lt; Gtk::Window
</code></pre>


<p>这个例子继承自<em>Window</em>。<em>Window</em>是一个顶级容器。</p>


<pre><code>set_title "Center"
</code></pre>


<p>设置窗口的标题。</p>


<pre><code>signal_connect "destroy" do 
    Gtk.main_quit 
end
</code></pre>


<p>当我们点击标题栏的关闭按钮或者按下Alt+F4时<em>destroy</em>事件被触发。<em>main_quit</em>正常退出应用程序。</p>


<pre><code>set_default_size 250, 200
</code></pre>


<p>设置应用程序窗口的默认大小。</p>


<pre><code>set_window_position Gtk::Window::POS_CENTER
</code></pre>


<p>将窗口放置在屏幕中间。</p>


<pre><code>show
</code></pre>


<p>一些就绪，我们在屏幕上显示该窗口。</p>


<pre><code>Gtk.init
    window = RubyApp.new
Gtk.main
</code></pre>


<p>这三行启动应用程序。</p>


<h2>创建提示框</h2>


<p>第二个例子我们将显示一个提示框。提示框(Tooltip)是一个小的矩形窗口用于显示一些简洁的提示信息。它是一个常用的GUI组件。它是应用程序帮助系统的一部分。</p>


<pre><code>#!/usr/bin/ruby

# ZetCode Ruby GTK tutorial
#
# This code shows a tooltip on 
# a window and a button
#
# author: jan bodnar
# website: www.zetcode.com
# last modified: June 2009

require 'gtk2'

class RubyApp &lt; Gtk::Window

    def initialize
        super

        set_title  "Tooltips"
        signal_connect "destroy" do 
            Gtk.main_quit 
        end

        fixed = Gtk::Fixed.new
        add fixed

        button = Gtk::Button.new "Button"
        button.set_size_request 80, 35      
        button.set_tooltip_text "Button widget"

        fixed.put button, 50, 50

        set_tooltip_text "Window widget"
        set_default_size 250, 200
        set_window_position Gtk::Window::POS_CENTER

        show_all

    end
end

Gtk.init
    window = RubyApp.new
Gtk.main
</code></pre>


<p>这个例子创建了一个窗口。如果我们将鼠标光标放在窗口的区域中，将会出现一个提示框。</p>


<pre><code>button.set_tooltip_text "Button widget"
</code></pre>


<p>我们使用<em>set_tooltip_text</em>方法设置一个提示框。</p>


<p><img alt="image1" src="http://zetcode.com/img/gui/rubygtk/tooltip.png"><br>
<em>图片：提示框</em></p>


<h2>退出按钮</h2>


<p>在这节的最后一个例子我们将创建一个退出按钮。当我们按下这个按钮时程序结束。</p>


<pre><code>#!/usr/bin/ruby

# ZetCode Ruby GTK tutorial
#
# This program creates a quit
# button. When we press the button,
# the application terminates. 
#
# author: jan bodnar
# website: www.zetcode.com
# last modified: June 2009

require 'gtk2'

class RubyApp &lt; Gtk::Window

    def initialize
        super

        set_title  "Quit button"
        signal_connect "destroy" do 
            Gtk.main_quit 
        end

        init_ui

        show_all
    end

    def init_ui

        fixed = Gtk::Fixed.new
        add fixed

        button = Gtk::Button.new "Quit"
        button.set_size_request 80, 35      
        button.signal_connect "clicked" do 
            Gtk.main_quit 
        end

        fixed.put button, 50, 50

        set_default_size 250, 200
        set_window_position Gtk::Window::POS_CENTER
    end
end

Gtk.init
    window = RubyApp.new
Gtk.main
</code></pre>


<p>我们使用一个按钮控件。这是一个非常平常的控件。它显示一个文本、图像或者两者都显示。</p>


<pre><code>init_ui
</code></pre>


<p>我们将用户接口的创建委派给<em>init_ui</em>方法。</p>


<pre><code>show_all
</code></pre>


<p>我们有两个选择。对每个控件都调用<em>show</em>，或者调用<em>show_all</em>显示容器的所有了子控件。</p>


<pre><code>button = Gtk::Button.new "Quit"
</code></pre>


<p>这里创建一个按钮控件。</p>


<pre><code>button.set_size_request 80, 35
</code></pre>


<p>设置按钮的大小。</p>


<pre><code>button.signal_connect "clicked" do 
    Gtk.main_quit 
end
</code></pre>


<p>我们将<em>main_quit</em>方法插入到按钮的点击事件中。</p>


<pre><code>fixed.put button, 50, 50
</code></pre>


<p>将退出按钮放在<em>fixed</em>容器的x=50，y=50的位置。
<img alt="image2" src="http://zetcode.com/img/gui/rubygtk/quitbutton.png"><br>
<em>图片：退出按钮</em></p>


<p>这一节我们介绍Ruby语言的GTK库。</p>


<hr>


<p>原文地址： <a href="http://zetcode.com/gui/rubygtk/introduction/">http://zetcode.com/gui/rubygtk/introduction/</a><br>
翻译：龙昌  admin@longchangjin.cn  </p>

</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
    <h1 class="entry-title"><a href="http://www.xefan.com/archives/83949.html">[翻译]Ruby教程15——输入&输出</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2013-11-18T00:00:00+08:00'><span class='date'><span class='date-month'>Nov</span> <span class='date-day'>18</span><span class='date-suffix'>th</span>, <span class='date-year'>2013</span></span> <span class='time'>12:00 am</span></time>
        
           | <a href="http://www.xefan.com/archives/83949.html#disqus_thread"
             data-disqus-identifier="http://www.xefan.com/archives/83949.html">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><h1>Ruby的输入&amp;输出</h1>


<p>这部分的教程我们讨论Ruby的输入和输出操作。输入是程序从键盘、文件或者其他程序读取数据。输出是程序产生数据。可以输出到屏幕、文件或者其他程序。</p>


<p>输入&amp;输出是一个大的话题。稍后我们通过一些例子来大概介绍一下这个主题。Ruby中的一些类有些方法会执行输入&amp;输出操作。例如Kernel、IO、Dir或者File。</p>


<h2>输出到终端</h2>


<p>Ruby有一些在终端上打印输出的方法。这些方法是Kernel模块的一部分。Kernel模块的方法对于所有的Ruby对象都是有效的。</p>


<pre><code>#!/usr/bin/ruby

print "Apple "
print "Apple\n"

puts "Orange"
puts "Orange"
</code></pre>


<p><em>print</em>和<em>puts</em>方法会将文本输出到终端。它们的不同是会在最后加上一个换行符。</p>


<pre><code>print "Apple "
print "Apple\n"
</code></pre>


<p><em>print</em>在终端上打印两个连续的&#8221;Apple&#8221;字符串。如果我们想换一行，我们就必须显示的包含一个换行符。换行符是&#8217;\n&#8217;。<em>print</em>方法实际上是调用了对象的<em>to_s</em>方法。</p>


<pre><code>puts "Orange"
puts "Orange"
</code></pre>


<p><em>puts</em>方法在终端上打印两个字符串。每一个都各在一行。这个方法会自己添加换行符。</p>


<p>$ ./printing.rb 
Apple Apple<br>
Orange<br>
Orange  </p>


<p><em>printing.rb</em>脚本的输出结果。</p>


<p>根据Ruby的文档，<em>print</em>方法与<em>$stdout.print</em>是等效的。<em>$stdout</em>是全局变量，保存的标准输出流。</p>


<pre><code>#!/usr/bin/ruby

$stdout.print "Ruby language\n"
$stdout.puts "Python language"
</code></pre>


<p>我们使用$stdout变量打印两行内容。</p>


<p>Ruby有另外三种输出方法。</p>


<pre><code>#!/usr/bin/ruby

p "Lemon"
p "Lemon"

printf "There are %d apples\n", 3

putc 'K'
putc 0xA
</code></pre>


<p>这个例子中，我们展示了p、printf和putc方法。</p>


<pre><code>p "Lemon"
</code></pre>


<p><em>p</em>会调用对象的<em>inspect</em>方法。这个方法对于调试很有用。</p>


<pre><code>printf "There are %d apples\n", 3
</code></pre>


<p><em>printf</em>方法因C语言而出名。它能够将字符串格式化。</p>


<pre><code>putc 'K'
putc 0xA
</code></pre>


<p><em>putc</em>方法在终端上打印一个字符。第二行是打印一个换行符。0xA是换行符的十六进制代码。</p>


<p>$ ./printing3.rb <br>
&#8220;Lemon&#8221;<br>
&#8220;Lemon&#8221;<br>
There are 3 apples<br>
K  </p>


<p>printing3.rb的输出。</p>


<p>使用Kernel的方法在终端上打印数据是简短方便的方式。接下来的例子展示了更多在终端上打印数据的正式方法。</p>


<pre><code>ios = IO.new STDOUT.fileno
ios.write "ZetCode\n"
ios.close
</code></pre>


<p>这个例子我们打开标准输出流并往其中写入字符串。</p>


<pre><code>ios = IO.new STDOUT.fileno
</code></pre>


<p><em>new</em>方法返回一个可写的数据流。这个方法传入一个文件描述符数字。<em>STDOUT.fileno</em>返回了标准输出流的文件描述符。我们也可以直接写2。</p>


<pre><code>ios.write "ZetCode\n"
</code></pre>


<p>我们往打开的数据流写入字符串。</p>


<pre><code>ios.close
</code></pre>


<p>关闭输出流。</p>


<p>在Unix系统中标准的终端输出是连接到一个特殊的文件/dev/tty。将其打开并写入数据，既是写到终端上。</p>


<pre><code>#!/usr/bin/ruby

fd = IO.sysopen "/dev/tty", "w"
ios = IO.new(fd, "w")
ios.puts "ZetCode"
ios.close
</code></pre>


<p>写入到/dev/tty文件的一个例子。这仅能够在Unix上运行。</p>


<pre><code>fd = IO.sysopen "/dev/tty", "w"
</code></pre>


<p><em>sysopen</em>方法打开指定目录的文件，返回最后的文件描述符。</p>


<pre><code>ios = IO.new(fd, "w")
</code></pre>


<p>文件描述符数字用于打开一个数据流。</p>


<pre><code>ios.puts "ZetCode"
ios.close
</code></pre>


<p>往数据流中写入字符串然后关闭它。</p>


<h2>从终端输入</h2>


<p>这一节我们将创建一些处理输入的代码例子。</p>


<p>$stdin是一个全局变量保存了标准输入流。它可以用于从终端输入数据。</p>


<pre><code>#!/usr/bin/ruby

inp = $stdin.read
puts inp
</code></pre>


<p>上面的代码，我们使用<em>read</em>方法从终端读取输入。</p>


<pre><code>inp = $stdin.read
</code></pre>


<p><em>read</em>方法从标准输入读取数据直到文件结尾。EOF在Unix中是使用Ctrl + D产生，在Windows中是Ctrl + Z。</p>


<p>$ ./reading.rb<br>
Ruby language<br>
Ruby language  </p>


<p>我们启动了程序，这个脚本会读取数据直到我们按下Ctrl + D 或者 Ctrl + Z。</p>


<p>$ echo &#8220;ZetCode&#8221; | ./reading.rb<br>
ZetCode  </p>


<p>$ ./input.rb &lt; stones <br>
Garnet<br>
Topaz<br>
Opal<br>
Amethyst<br>
Ruby<br>
Jasper<br>
Pyrite<br>
Malachite<br>
Quartz  </p>


<p>如果我们使用重定向，脚本可以从其他程序或者文件中读取数据。</p>


<p>通常从终端读取数据是使用<em>gets</em>方法。</p>


<pre><code>#!/usr/bin/ruby

print "Enter your name: "
name = gets
puts "Hello #{name}"
</code></pre>


<p>使用<em>gets</em>方法读取用户输入的一行数据。</p>


<pre><code>name = gets
</code></pre>


<p><em>gets</em>方法从标准输入读取数据并分配给<em>name</em>变量。</p>


<pre><code>puts "Hello #{name}"
</code></pre>


<p>打印输入的数据。</p>


<p>$ ./readline.rb<br>
Enter your name: Jan<br>
Hello Jan  </p>


<p>输出结果。</p>


<p>接下来的两个脚本我们讨论<em>chomp</em>方法。它是字符串方法，用于移除字符串结尾的空白。当我们执行输入操作时它很有用。这个方法名和用法来自Perl语言。</p>


<pre><code>#!/usr/bin/ruby

print "Enter a string: "
inp = gets

puts "The string has #{inp.size} characters"
</code></pre>


<p>读取一个用户输入的字符串，并计算它的长度。</p>


<p>$ ./nochomp.rb <br>
Enter a string: Ruby<br>
The string has 5 characters  </p>


<p>这个提示表示了这个字符串有5个字符，因为它统计的换行符。</p>


<p>为了得到正确的结果，我们需要移除换行符。这正是<em>chomp</em>方法的作用。</p>


<pre><code>#!/usr/bin/ruby

print "Enter a string: "
inp = gets.chomp

puts "The string has #{inp.size} characters"
</code></pre>


<p>这次我们使用<em>chomp</em>方法截掉了换行符。</p>


<p>$ ./chomp.rb <br>
Enter a string: Ruby<br>
The string has 4 characters  </p>


<p><em>Ruby</em>字符串有4个字符。</p>


<h2>文件</h2>


<p>从Ruby官方文档我们知道<em>IO</em>类是所有输入输出的基类。<em>File</em>类只是<em>IO</em>类的一个子类。这两个类是紧密相关的。</p>


<pre><code>#!/usr/bin/ruby

f = File.open('output.txt', 'w')
f.puts "The Ruby tutorial"
f.close
</code></pre>


<p>第一个例子我们打开一个文件并往里面写入一些数据。</p>


<pre><code>f = File.open('output.txt', 'w')
</code></pre>


<p>以写模式打开&#8217;output.txt&#8217;文件。<em>open</em>方法返回数据流。</p>


<pre><code>f.puts "The Ruby tutorial"
</code></pre>


<p>往上面打开的数据流写入数据。<em>puts</em>方法也可用于往文件写入数据。</p>


<pre><code>f.close
</code></pre>


<p>最后关闭数据流。</p>


<p>$ ./simplewrite.rb<br>
$ cat output.txt <br>
The Ruby tutorial  </p>


<p>执行脚本并显示output.txt文件的内容。</p>


<p>以下是一个类似的例子显示了额外的方法。</p>


<pre><code>#!/usr/bin/ruby

File.open('langs', 'w') do |f|

    f.puts "Ruby"
    f.write "Java\n"
    f &lt;&lt; "Python\n"

end
</code></pre>


<p>如果<em>open</em>方法之后是一个代码块，Ruby会将打开的数据流传递给这个代码块。最后这个文件会自动关闭。</p>


<pre><code>f.puts "Ruby"
f.write "Java\n"
f &lt;&lt; "Python\n"
</code></pre>


<p>我们使用了三个方法写文件。</p>


<p>$ ./simplewrite2.rb<br>
$ cat langs <br>
Ruby<br>
Java<br>
Python  </p>


<p>执行这个脚本并查看里面的内容。</p>


<p>第二个例子我们显示一些<em>File</em>类的方法。</p>


<pre><code>#!/usr/bin/ruby

puts File.exists? 'tempfile'

f = File.new 'tempfile', 'w'
puts File.mtime 'tempfile'
puts f.size

File.rename 'tempfile', 'tempfile2'

f.close
</code></pre>


<p>这个例子创建了一个新文件&#8217;tempfile&#8217;并调用了一些方法。</p>


<pre><code>puts File.exists? 'tempfile'
</code></pre>


<p><em>exists?</em>方法检查给定的文件是否存在。这行返回false，因为我们还没有创建这个文件。</p>


<pre><code>f = File.new 'tempfile', 'w'
</code></pre>


<p>创建文件。</p>


<pre><code>puts File.mtime 'tempfile'
</code></pre>


<p><em>mtime</em>方法返回这个文件的最后修改时间。</p>


<pre><code>puts f.size
</code></pre>


<p>查看文件的大小。这里返回0,因为我们还没有往文件写入数据。</p>


<pre><code>File.rename 'tempfile', 'tempfile2'
</code></pre>


<p>最后我们使用<em>rename</em>将文件重命名。</p>


<p>$ ./testfile.rb<br>
false<br>
2011-11-05 16:19:36 +0100<br>
0  </p>


<p>输出结果。</p>


<p>接下来我们从磁盘文件读取内容。</p>


<pre><code>#!/usr/bin/ruby

f = File.open("stones")

while line = f.gets do
    puts line
end

f.close
</code></pre>


<p>这是一个简单的脚本，打开<em>stones</em>文件并在终端上打印它的内容。</p>


<pre><code>f = File.open("stones")
</code></pre>


<p>打开&#8217;stones&#8217;文件，默认是只读模式。</p>


<pre><code>while line = f.gets do
    puts line
end
</code></pre>


<p><em>gets</em>方法从I/O数据流读取一行数据。当读到文件结尾时while代码块退出。</p>


<p>$ ./readlines2.rb<br>
Garnet<br>
Topaz<br>
Opal<br>
Amethyst<br>
Ruby<br>
Jasper<br>
Pyrite<br>
Malachite<br>
Quartz  </p>


<p>例子输出结果。</p>


<p>下一个例子将从文件读取数据。</p>


<pre><code>#!/usr/bin/ruby

fname = 'alllines.rb'

File.readlines(fname).each do |line|
    puts line
end
</code></pre>


<p>这个脚本显示了另一个读取文件内容的方式。这个例子将它自己的代码打印在终端上。</p>


<pre><code>File.readlines(fname).each do |line|
    puts line
end
</code></pre>


<p><em>readlines</em>读取指定文件的每一行内容，并作为数据返回。我们使用<em>each</em>方法遍历数组，并将其在终端上打印。</p>


<pre><code>$ ./alllines.rb
#!/usr/bin/ruby

fname = 'alllines.rb'

File.readlines(fname).each do |line|
    puts line
end
</code></pre>


<p>输出结果。</p>


<h2>目录</h2>


<p>在这一节我们使用目录。Ruby中有一个Dir类可以操作目录。</p>


<pre><code>#!/usr/bin/ruby

Dir.mkdir "tmp"
puts Dir.exists? "tmp"

puts Dir.pwd
Dir.chdir "tmp"
puts Dir.pwd

Dir.chdir '..'
puts Dir.pwd
Dir.rmdir "tmp"
puts Dir.exists? "tmp"
</code></pre>


<p>这个脚本我们使用了Dir类的四个方法。</p>


<pre><code>Dir.mkdir "tmp"
</code></pre>


<p><em>mkdir</em>方法创建一个新目录&#8217;tmp&#8217;。</p>


<pre><code>puts Dir.exists? "tmp"
</code></pre>


<p>使用<em>exists?</em>方法检查一个目录是否存在。</p>


<pre><code>puts Dir.pwd
</code></pre>


<p><em>pwd</em>方法打印当前的工作目录。这是我们启动脚本的目录。</p>


<pre><code>Dir.chdir '..'
</code></pre>


<p><em>chdir</em>方法切换目录。&#8217;..&#8217;目录是当前工作目录的父目录。</p>


<pre><code>Dir.rmdir "tmp"
puts Dir.exists? "tmp"
</code></pre>


<p>最后我们使用<em>rmdir</em>方法移除目录。这时<em>exists?</em>方法返回false。</p>


<p>$ ./dirs.rb<br>
true<br>
/home/vronskij/programming/ruby/io<br>
/home/vronskij/programming/ruby/io/tmp<br>
/home/vronskij/programming/ruby/io<br>
false  </p>


<p>例子的输出结果。
第二个例子我们检索目录所有的条目，包括文件和子目录。</p>


<pre><code>#!/usr/bin/ruby

fls = Dir.entries '.'
puts fls.inspect
</code></pre>


<p><em>entries</em> 方法返回指定目录的所有条目。</p>


<pre><code>fls = Dir.entries '.'
puts fls.inspect
</code></pre>


<p>我们得到了当前目录下的文件和目录数组。&#8217;.&#8217;代表当前工作目录。<em>inspect</em>方法使得数组更加可读。</p>


<p>$ ./allfiles.rb<br>
[&#8220;putc.rb&#8221;, &#8220;simplewrite.rb&#8221;, &#8220;readlines2.rb&#8221;, &#8220;fileexists.rb~&#8221; &#8230;  </p>


<p>输出结果。</p>


<p>第三个例子使用了home目录。每个计算机用户都有一个分配给他的唯一的目录，称为home目录。它是用于存放用户自己的文件。</p>


<pre><code>#!/usr/bin/ruby

puts Dir.home
puts Dir.home 'root'
</code></pre>


<p>这个脚本打印两个home目录。</p>


<pre><code>puts Dir.home
</code></pre>


<p>如果没有指定用户名则返回当前用户的home目录。当前用户是指定启动这个脚本文件的用户。</p>


<pre><code>puts Dir.home 'root'
</code></pre>


<p>这里我们指定了一个用户。</p>


<p>$ ./homedir.rb<br>
/home/vronskij<br>
/root  </p>


<p>输出结果。</p>


<h2>执行外部程序</h2>


<p>Ruby有一些方式可以执行外部程序。我们的例子中我们使用了Linux中有名的命令。Windows或者Mac读取可以使用他们自己系统的命令。</p>


<pre><code>#!/usr/bin/ruby

data = system 'ls'
puts data
</code></pre>


<p>调用<em>ls</em>命令列出目录内容。</p>


<pre><code>data = system 'ls'
</code></pre>


<p><em>system</em>命令在一个子shell中执行外部程序。这个方法是属于Kernel Ruby 模块的。</p>


<p>$ ./system.rb<br>
allfiles.rb   characters.rb  fileexists.rb   homedir.rb~ &#8230;  </p>


<p>输出结果。</p>


<p>我们展示另外两个执行外部程序的方式。</p>


<pre><code>#!/usr/bin/ruby

out = `pwd`
puts out

out = %x[uptime]
puts out

out = %x[ls | grep 'readline']
puts out
</code></pre>


<p>执行外部程序我们可以使用反引号&#8220;和%x[]字符。</p>


<pre><code>out = `pwd`
</code></pre>


<p>这里我们使用反引号执行<em>pwd</em>命令。这个命令返回当前的工作目录。</p>


<pre><code>out = %x[uptime]
</code></pre>


<p>这里我得到<em>uptime</em>命令的输出，它显示系统运行了多久。</p>


<pre><code>out = %x[ls | grep 'readline']
</code></pre>


<p>我们也可以使用复合命令。</p>


<p>$ ./system2.rb<br>
/home/vronskij/programming/ruby/io<br>
 22:50:50 up  5:32,  1 user,  load average: 0.46, 0.44, 0.45<br>
readline.rb<br>
readline.rb~<br>
readlines2.rb<br>
readlines2.rb~  </p>


<p>输出结果。</p>


<p>我们可以使用<em>open</em>方法执行命令。这个方法是属于Kernel模块的。它创建一个IO对象连接到指定的数据流、文件或者子进程。如果我们想要连接到子进程，我们将打开路径以管道符(|)开头。</p>


<pre><code>#!/usr/bin/ruby

f = open("|ls -l |head -3")
out = f.read
puts out
f.close

puts $?.success?
</code></pre>


<p>这个例子我们打印了<em>ls -l | head -3</em>命令的结果。我们也还检查了子进程的状态。</p>


<pre><code>f = open("|ls -l |head -3")
</code></pre>


<p>连接到子进程。</p>


<pre><code>out = f.read
puts out
</code></pre>


<p>读取并打印子进程的数据。</p>


<pre><code>f.close
</code></pre>


<p>关闭文件句柄。</p>


<pre><code>puts $?.success?
</code></pre>


<p><em>$?</em>是一个特殊的变量，设置为上次执行过的子进程。如果子进程成功退出<em>success?</em>方法返回true。</p>


<p>$ ./system3.rb<br>
total 148<br>
-rwxr-xr-x 1 vronskij vronskij   57 2011-10-30 23:33 allfiles.rb<br>
-rwxr-xr-x 1 vronskij vronskij   58 2011-10-30 23:33 allfiles.rb~<br>
true  </p>


<p>输出结果。</p>


<h2>重定向标准输出</h2>


<p>Ruby对标准输入、标准输出和标准错误输出都有预定义的全局变量。<em>$stdout</em> 是标准输出的变量名。</p>


<pre><code>#!/usr/bin/ruby

$stdout = File.open "output.log", "a"

puts "Ruby"
puts "Java"

$stdout.close
$stdout = STDOUT

puts "Python"
</code></pre>


<p>上面的例子我们将输出重定向到output.log文件。</p>


<pre><code>$stdout = File.open "output.log", "a"
</code></pre>


<p>这行创建一个新的标准输出。现在标准输出流向ouput.log文件。这个文件以追加方式打开，如果文件不存在则创建，否则打开并将数据追加到文件尾部。</p>


<pre><code>puts "Ruby"
puts "Java"
</code></pre>


<p>打印两个字符串。这些字符串不会像平常一样在终端上显示了。而是追加到output.log文件中。</p>


<pre><code>$stdout.close
</code></pre>


<p>关闭文件句柄。</p>


<pre><code>$stdout = STDOUT

puts "Python"
</code></pre>


<p>使用预定义的常量<em>STDOUT</em>重新创建正常的标准输出。&#8221;Python&#8221;字符串在终端上打印。</p>


<p>这部分的教程我们使用了输入和输出操作。</p>


<hr>


<p>原文地址： <a href="http://zetcode.com/lang/rubytutorial/io/">http://zetcode.com/lang/rubytutorial/io/</a><br>
翻译：龙昌  admin@longchangjin.cn<br>
完整教程：<a href="https://github.com/wusuopu/Ruby-tutorial">https://github.com/wusuopu/Ruby-tutorial</a> </p>

</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
    <h1 class="entry-title"><a href="http://www.xefan.com/archives/83945.html">[翻译]Ruby教程14——正则表达式</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2013-11-17T00:00:00+08:00'><span class='date'><span class='date-month'>Nov</span> <span class='date-day'>17</span><span class='date-suffix'>th</span>, <span class='date-year'>2013</span></span> <span class='time'>12:00 am</span></time>
        
           | <a href="http://www.xefan.com/archives/83945.html#disqus_thread"
             data-disqus-identifier="http://www.xefan.com/archives/83945.html">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><h1>Ruby的正则表达式</h1>


<p>在这部分和教程中我们将讨论正则表达式。</p>


<p>正则表达式用于文本搜索和更高级的文本操作。内建正则表达式的工具如grep、sed；文本编辑器如vi、emacs；编程语言如Tcl、Perl、Python。Ruby也内建支持正则表达式。</p>


<p>从另一方面来看正则表达式语法构成了一个文本匹配的领域专用语言。</p>


<p><em>pattern</em>（模式）是一个正则表达式，它定义了我们要搜索或者操作的文本。它由文本字面和元字符构成。模式位于两个分隔符内。在Ruby中是<em>//</em>字符。它们通知正则表达式函数的开始和结束。</p>


<p>这里是元字符的部分列表。</p>


<table>
    <tr>
        <td>.</td>
        <td>匹配任意一个字符</td>
    </tr>
    <tr>
        <td>*</td>
        <td>匹配前一个元素0次或多次</td>
    </tr>
    <tr>
        <td>[]</td>
        <td>括号表达式。匹配括号内的一个字符</td>
    </tr>
    <tr>
        <td>[^]</td>
        <td>匹配不在括号内的一个字符</td>
    </tr>
    <tr>
        <td>^</td>
        <td>匹配字符串的开始位置</td>
    </tr>
    <tr>
        <td>$</td>
        <td>匹配字符串的结束位置</td>
    </tr>
    <tr>
        <td>|</td>
        <td>交替操作</td>
    </tr>
</table>




<p>=~操作符对字符串匹配正则表达式，如果匹配则返回匹配字符串的偏移量否则为nil。 <em>RegExp</em>类是用来开发正则表达式。还有两个速记的方式来创建正则表达式。下面的例子将显示它们。</p>


<pre><code>#!/usr/bin/ruby

re = Regexp.new 'Jane'
p "Jane is hot".match re

p "Jane is hot" =~ /Jane/
p "Jane is hot".match %r{Jane}
</code></pre>


<p>第一个例子我们显示了对字符串应用正则表达式的三种方式。</p>


<pre><code>re = Regexp.new 'Jane'
p "Jane is hot".match re
</code></pre>


<p>上面两行我们创建了一个简单的包含正则表达式文本的<em>Regexp</em>对象。使用<em>match</em>方法我们对<em>&#8220;Jane is hot&#8221;</em>句子应用这个正则表达式。检查&#8217;Jance&#8217;是否在这个句子中。</p>


<pre><code>p "Jane is hot" =~ /Jane/
p "Jane is hot".match %r{Jane}
</code></pre>


<p>这两行完成相同的工作。两个斜杠//和%R{}字符是第一种方式的简写。在这个教程中，我们将使用斜杠。这是在许多语言中是事实上的标准。</p>


<pre><code>$ ./regex.rb
#&lt;MatchData "Jane"&gt;
0
#&lt;MatchData "Jane"&gt;
</code></pre>


<p>这三种情况都匹配的。<em>match</em>方法返回匹配的数据，如果没有则返回nil。=~操作符返回第一个匹配的字符的位置，或者nil。</p>


<h2>点字符</h2>


<p>点字符是一个可以匹配任意单字符的正则表达式字符。注意必须要有些字符，它不能被忽略。</p>


<pre><code>#!/usr/bin/ruby

p "Seven".match /.even/
p "even".match /.even/
p "eleven".match /.even/
p "proven".match /.even/
</code></pre>


<p>第一个例子，我们对字符串使用<em>match</em>方法应用正则表达式。<em>match</em>方法成功则返回匹配到的数据，否则返回nil。</p>


<pre><code>p "Seven".match /.even/
</code></pre>


<p>&#8220;Seven&#8221;是一个字符串，可以调用<em>match</em>方法。这个方法的参数是一个模式。/.even/正则表达式模式是查找以任意字符开头接着是<em>&#8216;even&#8217;</em>的字符串。</p>


<pre><code>$ ./dot.rb
#&lt;MatchData "Seven"&gt;
nil
#&lt;MatchData "leven"&gt;
nil
</code></pre>


<p>从输出结果中我们看到哪些是匹配的哪些是没有匹配的。</p>


<hr>


<p>正如前面所说的，如果有点字符，那么就必须要有一个任意的字符。它不能被忽略。如果我们想到查找一个文本，其中有字符能被忽略的。换言之，我们想要一个模式可以同时匹配&#8217;seven&#8217;和&#8217;even&#8217;。对于这个我们可以使用一个<em>?</em>重复字符。<em>?</em>重复字符表示前一个字符可能出现0或者1次。</p>


<pre><code>#!/usr/bin/ruby

p "seven".match /.even/
p "even".match /.even/
p "even".match /.?even/
</code></pre>


<p>这个脚本使用<em>?</em>重复字符。</p>


<pre><code>p "even".match /.even/
</code></pre>


<p>这行打印nil，因为正则表达式在&#8217;even&#8217;之前要接受一个字符。</p>


<pre><code>p "even".match /.?even/
</code></pre>


<p>我们稍微修改一下正则表达式。<em>&#8217;.?&#8217;</em>代表没有字符或者有一个字符。这次匹配成功。</p>


<pre><code>$ ./dot2.rb
#&lt;MatchData "seven"&gt;
nil
#&lt;MatchData "even"&gt;
</code></pre>


<p>输出结果。</p>


<h2>正则表达式方法</h2>


<p>前面的两个例子我们对正则表达式使用了<em>match</em>方法。除了<em>match</em>之外还有其他的方法也接受正则表达式参数。</p>


<pre><code>#!/usr/bin/ruby

puts "motherboard" =~ /board/
puts "12, 911, 12, 111"[/\d{3}/]

puts "motherboard".gsub /board/, "land"

p "meet big deep nil need".scan /.[e][e]./
p "This is Sparta!".split(/\s/)
</code></pre>


<p>这个例子显示了正则表达式的一些方法。</p>


<pre><code>puts "motherboard" =~ /board/
</code></pre>


<p>=~操作符将正则表达式放在右边，字符串放在左边。</p>


<pre><code>puts "12, 911, 12, 111"[/\d{3}/]
</code></pre>


<p>正则表达式可以位于字符串后面的中括号内。这行打印第一个3个数字。</p>


<pre><code>puts "motherboard".gsub /board/, "land"
</code></pre>


<p>使用<em>gsub</em>方法我们将&#8217;board&#8217;字符串替换成&#8217;land&#8217;。</p>


<pre><code>p "meet big deep nil need".scan /.[e][e]./
</code></pre>


<p><em>scan</em>方法查找字符串匹配。它会查找所有出现的匹配，而不仅是第一个。这行打印所有与模式匹配的字符串。</p>


<pre><code>p "This is Sparta!".split(/\s/)
</code></pre>


<p><em>split</em>方法使用给定的正则式来分隔字符串。<em>\s</em>字符代表了任何空白字符。</p>


<pre><code>$ ./apply.rb
6
911
motherland
["meet", "deep", "need"]
["This", "is", "Sparta!"]
</code></pre>


<p>apply.rb脚本的输出结果。</p>


<h2>特殊变量</h2>


<p>一些使用正则式的方法会激活一些特殊的变量。包括上次匹配的字符串、上次匹配结果的前面部分和上次匹配结果的后面部分。这些变量方便了程序员。</p>


<pre><code>#!/usr/bin/ruby

puts "Her name is Jane" =~ /name/

p $`
p $&amp;
p $'
</code></pre>


<p>这个例子显示了三个特殊的变量。</p>


<pre><code>puts "Her name is Jane" =~ /name/
</code></pre>


<p>这行代码是一个简单的正则式匹配。我们在&#8217;Her name is Jane&#8217;句子中查找&#8217;name&#8217;。我们使用=~操作符。这个操作符也会设置三个特殊的变量。这行返回数字4。</p>


<pre><code>p $`
</code></pre>


<p><em>$`</em>特殊变量包含了上次匹配结果之前的文本。</p>


<pre><code>p $&amp;
</code></pre>


<p><em>$&amp;</em>为匹配的文本。</p>


<pre><code>p $'
</code></pre>


<p><em>$&#8217;</em>变量包含上次匹配结果之后的文本。</p>


<p>$ ./svars.rb<br>
4<br>
&#8220;Her &#8221;<br>
&#8220;name&#8221;<br>
&#8221; is Jane&#8221;  </p>


<p>例子的输出结果。</p>


<h2>锚点</h2>


<p>锚点是在文本中匹配位置的字符。我们展示三个锚点字符。^字符匹配了行的开头；$字符匹配了行的结尾；\b字符匹配词的边界。</p>


<pre><code>#!/usr/bin/ruby

sen1 = "Everywhere I look I see Jane"
sen2 = "Jane is the best thing that happened to me"

p sen1.match /^Jane/ 
p sen2.match /^Jane/

p sen1.match /Jane$/ 
p sen2.match /Jane$/
</code></pre>


<p>第一个例子我们使用了^和$。</p>


<pre><code>sen1 = "Everywhere I look I see Jane"
sen2 = "Jane is the best thing that happened to me"
</code></pre>


<p>有两个句子。&#8217;Jane&#8217;位于第一个的结尾第二个的开头。</p>


<pre><code>p sen1.match /^Jane/ 
p sen2.match /^Jane/
</code></pre>


<p>这里我们查找这两个句子是否以&#8217;Jane&#8217;开头。</p>


<pre><code>p sen1.match /Jane$/ 
p sen2.match /Jane$/
</code></pre>


<p>这里我们在句子结尾查找匹配。</p>


<pre><code>$ ./anchors.rb
nil
#&lt;MatchData "Jane"&gt;
#&lt;MatchData "Jane"&gt;
nil
</code></pre>


<p>运行结果。</p>


<hr>


<p>通常一个请求仅包含一个匹配全部的词。我们会默认计算所有匹配，包括更大的或者复合词。让我们通过一个例子来阐述。</p>


<pre><code>#!/usr/bin/ruby

text = "The cat also known as the domestic cat is a small, 
usually furry, domesticated, carnivorous mammal."

p text.scan /cat/

p $`
p $&amp;
p $'
</code></pre>


<p>有一个句子。我们使用<em>scan</em>在这个句子中查找所有的&#8217;cat&#8217;字符串。</p>


<pre><code>text = "The cat also known as the domestic cat is a small, 
usually furry, domesticated, carnivorous mammal."
</code></pre>


<p>问题是这个文本中有三个&#8217;cat&#8217;字符串。要匹配的&#8217;cat&#8217;表示一个哺乳动物,/cat/却匹配了&#8217;domesticated&#8217;词的8-10的字母。这不是我们想要的。</p>


<pre><code>$ ./boudaries.rb
["cat", "cat", "cat"]
"The cat also known as the domestic cat is a small, \nusually furry, domesti"
"cat"
"ed, carnivorous mammal."
</code></pre>


<p>最后一次匹配的&#8217;domesticated&#8217;在下一个例子中将被使用\b锚点字符排除。</p>


<hr>


<p>\b字符用于设置要查找的词的边界。</p>


<pre><code>#!/usr/bin/ruby

text = "The cat also known as the domestic cat is a small, 
usually furry, domesticated, carnivorous mammal."

p text.scan /\bcat\b/

p $`
p $&amp;
p $'
</code></pre>


<p>这个例子使用\b元字符进行了改善。</p>


<pre><code>p text.scan /\bcat\b/
</code></pre>


<p>使用上面的正则式我们将查找&#8217;cat&#8217;整个词，不计算子词。</p>


<h2>字符类</h2>


<p>我们可以结合方括号将字符转换成字符类。字符类可以匹配在方括号内的任意字符。/[ab]/模式意味a或者b，相反的/ab/意味着a接着b。</p>


<pre><code>#!/usr/bin/ruby

words = %w/ sit MIT fit fat lot pad /

pattern = /[fs]it/

words.each do |word|
   if word.match pattern
       puts "#{word} matches the pattern" 
   else
       puts "#{word} does not match the pattern" 
   end
end
</code></pre>


<p>有一系列的6个3字母的单词。我们对数组的每个字符串采用特定字符集的正则式。</p>


<pre><code>pattern = /[fs]it/
</code></pre>


<p>这个式模式在这个数组中查找到了&#8217;fit&#8217;、&#8217;sit&#8217;。我们从字符集使用&#8217;f&#8217;或者&#8217;s&#8217;。</p>


<p>$ ./classes.rb<br>
sit matches the pattern<br>
MIT does not match the pattern<br>
fit matches the pattern<br>
fat does not match the pattern<br>
lot does not match the pattern<br>
pad does not match the pattern  </p>


<p>有两个匹配的。</p>


<hr>


<p>一个例子我们将进一步探讨字符类。</p>


<pre><code>#!/usr/bin/ruby

p "car".match %r{[abc][a][rs]}
p "car".match /[a-r]+/
p "23af 433a 4ga".scan /\b[a-f0-9]+\b/
</code></pre>


<p>例子中有三个字符类正则式。</p>


<pre><code>p "car".match %r{[abc][a][rs]}
</code></pre>


<p>这行的正则式由三个字符类构成。每个都对应一个字符。[abc]是a、b或者c。[a]就是a。第三个[rs]是r或者s。这里匹配&#8217;car&#8217;字符串。</p>


<pre><code>p "car".match /[a-r]+/
</code></pre>


<p>我们在字符类中使用了一个连接符<em>-</em>。连接符是一个元字符表示一个范围：这里是a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, 或r。由于字符类仅对应一个字符。我们也可以使用+重复字符。这表示前一个字符集的字符可以重复一次或者多次。&#8217;car&#8217;字符串被匹配了。</p>


<pre><code>p "23af 433a 4ga".scan /\b[a-f0-9]+\b/
</code></pre>


<p>这行有一个由三个子字符串构成的字符串。使用<em>scan</em>方法检查十六进制整数。我们有两个范围。第一个[a-f]代表a到f的字符。第二个[0-9]代表字数0到9。+表示这些字符可以重复多次。最后\b创建一个边界，表示仅接受由这些字符构成的字符串。</p>


<pre><code>$ ./classes2.rb
#&lt;MatchData "car"&gt;
#&lt;MatchData "car"&gt;
["23af", "433a"]
</code></pre>


<p>输出结果。 </p>


<hr>


<p>如果字符类的第一个字符是脱字符（^），则对该类反转。它会匹配除了这些之外的任何字符。</p>


<pre><code>#!/usr/bin/ruby

p "ABC".match /[^a-z]{3}/
p "abc".match /[^a-z]{3}/
</code></pre>


<p>这个例子我们在字符类中使用脱字符。</p>


<pre><code>p "ABC".match /[^a-z]{3}/
</code></pre>


<p>我们查找一个有3个字母的字符串。这些字母不能在a到z之间。&#8221;ABC&#8221;字符串匹配这个正则式，因为所有的三个字符都是大写字母。</p>


<pre><code>p "abc".match /[^a-z]{3}/
</code></pre>


<p>&#8220;abc&#8221;字符串没有匹配。</p>


<pre><code>$ ./caret.rb
#&lt;MatchData "ABC"&gt;
nil
</code></pre>


<p>输出结果。</p>


<h2>量词</h2>


<p>标记或者组后面的量词表示前面的元素允许出现多少次。</p>


<pre><code> ?     - 0 or 1 match
 *     - 0 or more
 +     - 1 or more
 {n}   - exactly n
 {n,}  - n or more
 {,n}  - n or less (??)
 {n,m} - range n to m
</code></pre>


<p>上面是通常的量词列表。</p>


<pre><code>#!/usr/bin/ruby

p "seven dig moon car lot fire".scan /\w{3}/
p "seven dig moon car lot fire".scan /\b\w{3}\b/
</code></pre>


<p>例子中我们想要选择这些有3个字符的单词。\w字符是一个词字符。\w{3}意味着前面的词字符出现3次。</p>


<pre><code>p "seven dig moon car lot fire".scan /\w{3}/
</code></pre>


<p>第一只是对每个字符串截取前三个字符。这不是我们想要的。</p>


<pre><code>p "seven dig moon car lot fire".scan /\b\w{3}\b/
</code></pre>


<p>这是改进的搜索。我们将之前的模式放在边界符\b之间。现在仅查找有三个字符的单词。</p>


<pre><code>$ ./nchars.rb
["sev", "dig", "moo", "car", "lot", "fir"]
["dig", "car", "lot"]
</code></pre>


<p>输出结果。</p>


<hr>


<p>{n,m}是一个重复结构对于有n到m个字符的字符串。</p>


<pre><code>#!/usr/bin/ruby

p "I dig moon lottery it fire".scan /\b\w{2,4}\b/
</code></pre>


<p>上面的例子我们选择有2、3、4个字符的单词。我们再次使用了边界符\b。</p>


<pre><code>$ ./rchars.rb
["dig", "moon", "it", "fire"]
</code></pre>


<p>这个例子打印了一个有2-4个字符的单词数组。</p>


<hr>


<p>下一个例子我们展示<em>?</em>元字符。接着<em>?</em>的字符是可选的。<em>?</em>之前的字符可以出现一次或者0次。</p>


<pre><code>#!/usr/bin/ruby

p "color colour colors colours".scan /colou?rs/
p "color colour colors colours".scan /colou?rs?/

p "color colour colors colours".scan /\bcolor\b|\bcolors\b|\bcolour\b|\bcolours\b/
</code></pre>


<p>我们想要在一个文本中查找<em>colour</em>单词。这个单词有两种拼写方式，美式的&#8217;colour&#8217;和英式的&#8217;color&#8217;。我们想要两种都查找，此外我们还想查找复数形式。</p>


<pre><code>p "color colour colors colours".scan /colou?rs/
</code></pre>


<p>colou?rs模式查找&#8217;colours&#8217;和&#8217;colors&#8217;。u字符在?字符之前表示是可选的。</p>


<pre><code>p "color colour colors colours".scan /colou?rs?/
</code></pre>


<p>colou?rs?模式使u和s字符是可选的。因此我们会查找到这四个组合。</p>


<pre><code>p "color colour colors colours".scan /\bcolor\b|\bcolors\b|\bcolour\b|\bcolours\b/
</code></pre>


<p>相同的请求可以间隔的写。</p>


<pre><code>$ ./qmark.rb
["colors", "colours"]
["color", "colour", "colors", "colours"]
["color", "colour", "colors", "colours"]
</code></pre>


<p>输出结果。</p>


<hr>


<p>这节的最后一个例子我们展示+字符。它允许前面的字符重复1次或多次。</p>


<pre><code>#!/usr/bin/ruby

nums = %w/ 234 1 23 53434 234532453464 23455636
    324f 34532452343452 343 2324 24221 34$34232/

nums.each do |num|
    m = num.match /[0-9]+/

    if m.to_s.eql? num
        puts num
    end              
end
</code></pre>


<p>这个例子我们有一个数字数组。数字可以有一个或者多个数字字符。</p>


<pre><code>nums = %w/ 234 1 23 53434 234532453464 23455636
    324f 34532452343452 343 2324 24221 34$34232/
</code></pre>


<p>这是一个字符串数组。其中有两个不是数字，因为它们包含了非数字字符。</p>


<pre><code>nums.each do |num|
    m = num.match /[0-9]+/

    if m.to_s.eql? num
        puts num
    end              
end
</code></pre>


<p>我们遍历数组并对每个字符串应用正则式。表达式[0-9]+代表了0到9的任意字符重复0次或者多次。默认的这个表达式也会查找子字符串。
在34$34232中引擎认为34是一个数字。\b边界符在这里是无效的，因为我们没有具体的字符，引擎不知道该在哪里停止查找。这就是为什么我们在代码块中包含一个if条件式。仅当匹配结果等于原字符串才认为它是一个数字。</p>


<p>$ ./numbers.rb<br>
234<br>
1<br>
23<br>
53434<br>
234532453464<br>
23455636<br>
34532452343452<br>
343<br>
2324<br>
24221  </p>


<p>这些的值是数字。</p>


<h2>忽略大小写搜索</h2>


<p>我们可以执行忽略大小写的搜索。正则表达式可以接一个选项。它是一个单一的字符，以某种方式修改模式。这里不区分大小写的搜索我们使用i选项。</p>


<pre><code>#!/usr/bin/ruby

p "Jane".match /Jane/
p "Jane".match /jane/
p "Jane".match /JANE/

p "Jane".match /jane/i
p "Jane".match /Jane/i
p "Jane".match /JANE/i
</code></pre>


<p>这个例子显示了区分大小写和不区分大小写的搜索。</p>


<pre><code>p "Jane".match /Jane/
p "Jane".match /jane/
p "Jane".match /JANE/
</code></pre>


<p>这三行的字符必须完全匹配模式。仅有第一行是匹配的。</p>


<pre><code>p "Jane".match /jane/i
p "Jane".match /Jane/i
p "Jane".match /JANE/i
</code></pre>


<p>这里我们使用i选项，接在第二个/字符后面。我们进行不区分大小写的搜索。这三行者匹配了。</p>


<pre><code>$ ./icase.rb
#&lt;MatchData "Jane"&gt;
nil
nil
#&lt;MatchData "Jane"&gt;
#&lt;MatchData "Jane"&gt;
#&lt;MatchData "Jane"&gt;
</code></pre>


<p>例子的输出结果。</p>


<h2>交替</h2>


<p>一个例子解释交替操作符（|）。这个操作符可以创建一个有多个选择的正则式。</p>


<pre><code>#!/usr/bin/ruby

names = %w/Jane Thomas Robert Lucy Beky
    John Peter Andy/

pattern = /Jane|Beky|Robert/

names.each do |name|

    if name =~ pattern
        puts "#{name} is my friend"
    else
        puts "#{name} is not my friend"
    end
end
</code></pre>


<p><em>names</em>数组中有8个名字。我们将在数组中查找多虑字符串的组合。</p>


<pre><code>pattern = /Jane|Beky|Robert/
</code></pre>


<p>这是搜索模式。它表示Jane, Beky和Robert是我的朋友。如果你查找他们就会找到我的朋友。</p>


<p>$ ./alternation.rb<br>
Jane is my friend<br>
Thomas is not my friend<br>
Robert is my friend<br>
Lucy is not my friend<br>
Beky is my friend<br>
John is not my friend<br>
Peter is not my friend<br>
Andy is not my friend  </p>


<p>这是脚本的输出结果。</p>


<h2>子模式</h2>


<p>我们可以使用括号()创建子模式。</p>


<pre><code>#!/usr/bin/ruby

p "bookworm" =~ /book(worm)?$/
p "book" =~ /book(worm)?$/
p "worm" =~ /book(worm)?$/
p "bookstore" =~ /book(worm)?$/
</code></pre>


<p>我们有如下正则式模式：book(worm)?$。(worm)是一个子模式。仅有两个字符串可以匹配：&#8217;book&#8217;或者&#8217;bookworm&#8217;。接在子模式后面的?字符意味着这个子模式出现0或者1次。这里$字符确切的匹配字符串的结尾。没有它单词bookstore和bookmania也会被匹配。</p>


<pre><code>#!/usr/bin/ruby

p "book" =~ /book(shelf|worm)?$/
p "bookshelf" =~ /book(shelf|worm)?$/
p "bookworm" =~ /book(shelf|worm)?$/
p "bookstore" =~ /book(shelf|worm)?$/
</code></pre>


<p>子模式经常是多个单词组合交替结合的。例如，book(shelf|worm)匹配&#8217;bookshelf&#8217;和&#8217;bookworm&#8217;，book(shelf|worm)?匹配&#8217;bookshelf&#8217;，&#8217;bookworm&#8217;和&#8217;book&#8217;。</p>


<p>$ ./subpatterns2.rb<br>
0<br>
0<br>
0<br>
nil  </p>


<p>最后一个子模式没有匹配。记住0不意味着没有匹配。对于=~操作符，它是第一个匹配到的字符的索引。</p>


<h2>邮箱例子</h2>


<p>最后一个例子，我们创建一个正则式模式检查邮箱地址。</p>


<pre><code>#!/usr/bin/ruby

emails = %w/ luke@gmail.com andy@yahoo.com 23214sdj^as
    f3444@gmail.com /

pattern = /^[a-zA-Z0-9._-]+@[a-zA-Z0-9-]+\.[a-zA-Z.]{2,5}$/

emails.each do |email|

    if email.match pattern
        puts "#{email} matches"
    else
        puts "#{email} does not match"
    end

end
</code></pre>


<p>注意这个例子提供了仅一种解决方案。它不需要是最好的。</p>


<pre><code>emails = %w/ luke@gmail.com andy@yahoocom 23214sdj^as
    f3444@gmail.com /
</code></pre>


<p>这是一个邮箱数组，仅有两个是有效的。</p>


<pre><code>pattern = /^[a-zA-Z0-9._-]+@[a-zA-Z0-9-]+\.[a-zA-Z.]{2,5}$/
</code></pre>


<p>这是一个模式，第一个^和最后一个$是获取完整匹配。在模式之前和之后都不允许有字符。邮箱分为5部分。第一部分是本地部分，它通常是公司、个体或者昵称的名字。[a-zA-Z0-9._-]+列出了所有可能用于本地部分的字符，它们可以使用一次或者多次。第二部分是字面符@，第三部分是域名部分。它通常是邮箱的提供商，如 yahoo或者gmail。字符集[a-zA-Z0-9-]+指明了所有的可以用于域名的字符。+量词将这些字符使用一次或者多次。第四部分是点字符。它的前面接一个转义符。(&#46;)因为点字符是一个元字符具有特殊意义。转义之后得到一个字面上的点。最后一部分是顶级域名。这个模式是[a-zA-Z.]{2,5}。顶级域名有2到5个字符，如sk, net, info, travel。这同样也有点字符，这是因此一些顶级域名有两部分如co.uk。</p>


<p>$ ./email.rb<br>
luke@gmail.com matches<br>
andy@yahoocom does not match<br>
23214sdj^as does not match<br>
f3444@gmail.com matches  </p>


<p>这个正则式标记了两个有效的邮箱地址。</p>


<p>在这章，我们学习了Ruby的正则表达式。</p>


<hr>


<p>原文地址： <a href="http://zetcode.com/lang/rubytutorial/regex/">http://zetcode.com/lang/rubytutorial/regex/</a><br>
翻译：龙昌  admin@longchangjin.cn<br>
完整教程：<a href="https://github.com/wusuopu/Ruby-tutorial">https://github.com/wusuopu/Ruby-tutorial</a> </p>

</div>
  
  


    </article>
  
  <div class="pagination">
    
      <a class="prev" href="/page/7">&larr; Older</a>
    
    <a href="/blog/archives">Blog Archives</a>
    
    <a class="next" href="/page/5">Newer &rarr;</a>
    
  </div>
</div>
<aside class="sidebar">
  
    <section>
  <h1>Subscription</h1>
  <!--以下是QQ邮件列表订阅嵌入代码--><script >var nId = "e7ee5da6d322dc7157c25cfd8a7700bb23a056dd1fb18cb4",nWidth="auto",sColor="light",sText="请输入邮件地址：" ;</script><script src="http://list.qq.com/zh_CN/htmledition/js/qf/page/qfcode.js" charset="gb18030"></script>
</section>
<section>
  <h1>Recent Posts</h1>
  <ul id="recent_posts">
    
      <li class="post">
        <a href="http://www.xefan.com/archives/84138.html">使用gunicorn部署Django</a>
      </li>
    
      <li class="post">
        <a href="http://www.xefan.com/archives/84137.html">Mongodb集群配置实例</a>
      </li>
    
      <li class="post">
        <a href="http://www.xefan.com/archives/84136.html">使用VIM进行PHP远程调试</a>
      </li>
    
      <li class="post">
        <a href="http://www.xefan.com/archives/84135.html">Nginx + Uwsgi + Django环境配置</a>
      </li>
    
      <li class="post">
        <a href="http://www.xefan.com/archives/84134.html">配置rails的vim环境</a>
      </li>
    
  </ul>
</section>
<section>
  <h1>Categories</h1>
    <ul id="category-list"><li><a href='/categories/linux栏目/index.html'>linux栏目 (47)</a></li><li><a href='/categories/python栏目/index.html'>python栏目 (34)</a></li><li><a href='/categories/ruby栏目/index.html'>ruby栏目 (26)</a></li><li><a href='/categories/web开发/index.html'>web开发 (18)</a></li><li><a href='/categories/嵌入式栏目/index.html'>嵌入式栏目 (11)</a></li><li><a href='/categories/开源软件/index.html'>开源软件 (20)</a></li><li><a href='/categories/教程/index.html'>教程 (15)</a></li><li><a href='/categories/数据库/index.html'>数据库 (8)</a></li><li><a href='/categories/数据结构和算法/index.html'>数据结构和算法 (16)</a></li><li><a href='/categories/编程开发/index.html'>编程开发 (38)</a></li><li><a href='/categories/网络日志/index.html'>网络日志 (11)</a></li><li><a href='/categories/资源分享/index.html'>资源分享 (23)</a></li></ul>
</section>
<section>
  <h1>Tag Cloud</h1>
    <span id="tag-cloud"><a href='/tags/access/index.html' style='font-size: 105.45454545454545%'>access(6)</a> <a href='/tags/adobe/index.html' style='font-size: 100.9090909090909%'>adobe(1)</a> <a href='/tags/ajax/index.html' style='font-size: 101.81818181818181%'>ajax(2)</a> <a href='/tags/apache/index.html' style='font-size: 100.9090909090909%'>apache(1)</a> <a href='/tags/arch/index.html' style='font-size: 106.36363636363636%'>Arch(7)</a> <a href='/tags/arm/index.html' style='font-size: 107.27272727272727%'>ARM(8)</a> <a href='/tags/asp/index.html' style='font-size: 106.36363636363636%'>asp(7)</a> <a href='/tags/c/index.html' style='font-size: 111.81818181818181%'>C(13)</a> <a href='/tags/css/index.html' style='font-size: 101.81818181818181%'>css(2)</a> <a href='/tags/django/index.html' style='font-size: 102.72727272727273%'>Django(3)</a> <a href='/tags/dreamweaver/index.html' style='font-size: 100.9090909090909%'>Dreamweaver(1)</a> <a href='/tags/fedora/index.html' style='font-size: 101.81818181818181%'>Fedora(2)</a> <a href='/tags/firefox/index.html' style='font-size: 102.72727272727273%'>firefox(3)</a> <a href='/tags/flash/index.html' style='font-size: 100.9090909090909%'>Flash(1)</a> <a href='/tags/ftp/index.html' style='font-size: 100.9090909090909%'>ftp(1)</a> <a href='/tags/gcc/index.html' style='font-size: 105.45454545454545%'>gcc(6)</a> <a href='/tags/gentoo/index.html' style='font-size: 101.81818181818181%'>Gentoo(2)</a> <a href='/tags/git/index.html' style='font-size: 103.63636363636364%'>git(4)</a> <a href='/tags/gobject/index.html' style='font-size: 105.45454545454545%'>GObject(6)</a> <a href='/tags/grub/index.html' style='font-size: 100.9090909090909%'>grub(1)</a> <a href='/tags/gtk/index.html' style='font-size: 115.45454545454545%'>gtk(17)</a> <a href='/tags/hash/index.html' style='font-size: 100.9090909090909%'>Hash(1)</a> <a href='/tags/ibus/index.html' style='font-size: 100.9090909090909%'>ibus(1)</a> <a href='/tags/js/index.html' style='font-size: 100.9090909090909%'>js(1)</a> <a href='/tags/linux/index.html' style='font-size: 160.0%'>Linux(66)</a> <a href='/tags/mongodb/index.html' style='font-size: 110.0%'>mongodb(11)</a> <a href='/tags/mysql/index.html' style='font-size: 103.63636363636364%'>mysql(4)</a> <a href='/tags/nginx/index.html' style='font-size: 100.9090909090909%'>nginx(1)</a> <a href='/tags/node/index.html' style='font-size: 100.9090909090909%'>node(1)</a> <a href='/tags/php/index.html' style='font-size: 109.0909090909091%'>php(10)</a> <a href='/tags/ps/index.html' style='font-size: 105.45454545454545%'>PS(6)</a> <a href='/tags/pygame/index.html' style='font-size: 110.9090909090909%'>pygame(12)</a> <a href='/tags/python/index.html' style='font-size: 146.36363636363637%'>python(51)</a> <a href='/tags/qt/index.html' style='font-size: 101.81818181818181%'>Qt(2)</a> <a href='/tags/redis/index.html' style='font-size: 100.9090909090909%'>Redis(1)</a> <a href='/tags/ruby/index.html' style='font-size: 123.63636363636364%'>Ruby(26)</a> <a href='/tags/scrapy/index.html' style='font-size: 102.72727272727273%'>Scrapy(3)</a> <a href='/tags/shell/index.html' style='font-size: 100.9090909090909%'>shell(1)</a> <a href='/tags/tq2440/index.html' style='font-size: 104.54545454545455%'>TQ2440(5)</a> <a href='/tags/ubuntu/index.html' style='font-size: 106.36363636363636%'>ubuntu(7)</a> <a href='/tags/usb/index.html' style='font-size: 102.72727272727273%'>USB(3)</a> <a href='/tags/vim/index.html' style='font-size: 123.63636363636364%'>vim(26)</a> <a href='/tags/virtualbox/index.html' style='font-size: 102.72727272727273%'>VirtualBox(3)</a> <a href='/tags/vmware/index.html' style='font-size: 100.9090909090909%'>vmware(1)</a> <a href='/tags/w3m/index.html' style='font-size: 100.9090909090909%'>w3m(1)</a> <a href='/tags/web开发/index.html' style='font-size: 112.72727272727272%'>Web开发(14)</a> <a href='/tags/windows/index.html' style='font-size: 106.36363636363636%'>windows(7)</a> <a href='/tags/wordpress/index.html' style='font-size: 100.9090909090909%'>WordPress(1)</a> <a href='/tags/xml/index.html' style='font-size: 100.9090909090909%'>xml(1)</a> <a href='/tags/免费/index.html' style='font-size: 100.9090909090909%'>免费(1)</a> <a href='/tags/内核/index.html' style='font-size: 100.9090909090909%'>内核(1)</a> <a href='/tags/匹配算法/index.html' style='font-size: 105.45454545454545%'>匹配算法(6)</a> <a href='/tags/单片机/index.html' style='font-size: 101.81818181818181%'>单片机(2)</a> <a href='/tags/嵌入式/index.html' style='font-size: 100.9090909090909%'>嵌入式(1)</a> <a href='/tags/开源软件/index.html' style='font-size: 108.18181818181819%'>开源软件(9)</a> <a href='/tags/排序算法/index.html' style='font-size: 108.18181818181819%'>排序算法(9)</a> <a href='/tags/文件空间/index.html' style='font-size: 100.9090909090909%'>文件空间(1)</a> <a href='/tags/无线网/index.html' style='font-size: 100.9090909090909%'>无线网(1)</a> <a href='/tags/正则式/index.html' style='font-size: 100.9090909090909%'>正则式(1)</a> <a href='/tags/注册机/index.html' style='font-size: 101.81818181818181%'>注册机(2)</a> <a href='/tags/游戏/index.html' style='font-size: 109.0909090909091%'>游戏(10)</a> <a href='/tags/电脑技巧/index.html' style='font-size: 108.18181818181819%'>电脑技巧(9)</a> <a href='/tags/空间/index.html' style='font-size: 100.9090909090909%'>空间(1)</a> <a href='/tags/算法/index.html' style='font-size: 114.54545454545455%'>算法(16)</a> <a href='/tags/红旗/index.html' style='font-size: 100.9090909090909%'>红旗(1)</a> <a href='/tags/经典语录/index.html' style='font-size: 100.9090909090909%'>经典语录(1)</a> <a href='/tags/网络日志/index.html' style='font-size: 105.45454545454545%'>网络日志(6)</a> <a href='/tags/翻译/index.html' style='font-size: 120.9090909090909%'>翻译(23)</a> <a href='/tags/视频教程/index.html' style='font-size: 109.0909090909091%'>视频教程(10)</a> <a href='/tags/资源分享/index.html' style='font-size: 110.9090909090909%'>资源分享(12)</a> <a href='/tags/转载/index.html' style='font-size: 101.81818181818181%'>转载(2)</a> <a href='/tags/随笔/index.html' style='font-size: 100.9090909090909%'>随笔(1)</a> </span>
</section>
<section>
  <h1>Link</h1>
    <ul id="category-list">
      <li><a target="_blank" title="我的Github" href="https://github.com/wusuopu">@Github</a></li>
      <li><a target="_blank" title="我的微博" href="http://www.weibo.com/u/1768691343">@Weibo</a></li>
      <li><a target="_blank" title="我的Twitter" href="https://twitter.com/longchangjin">@Twitter</a></li>
      <li><a target="_blank" title="我的豆瓣" href="http://www.douban.com/people/lchj/">@Douban</a></li>

      <li><a target="_blank" title="" href="http://www.vimer.cn/">Vimer的程序世界</a></li>
      <li><a target="_blank" title="" href="http://pythoner.net/">python开发者社区</a></li>
      <li><a target="_blank" title="" href="http://simple-is-better.com/">python.cn(news, jobs)</a></li>
      <li><a target="_blank" title="" href="http://gtk.awaysoft.com/">GTK+ 中文社区</a></li>
    </ul>
</section>

  
</aside>

    </div>
  </div>
  <footer role="contentinfo"><p>
  Copyright &copy; 2014 - 龍昌 -
  <span class="credit">Powered by <a href="http://octopress.org">Octopress</a></span>
</p>
<div style="display:none;"><script src="http://s94.cnzz.com/stat.php?id=1259846&web_id=1259846&show=pic" language="JavaScript"></script></div>

</footer>
  

<script type="text/javascript">
      var disqus_shortname = 'longchang';
      
        
        var disqus_script = 'count.js';
      
    (function () {
      var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
      dsq.src = '//' + disqus_shortname + '.disqus.com/' + disqus_script;
      (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    }());
</script>











</body>
</html>
