
<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js" lang="en"><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <title>龍昌博客</title>
  <meta name="author" content="龍昌">

  
  <meta name="description" content="cgi模块中有一个FieldStorage类可用于表单处理。 单一字段名 有一个HTML表单如下： 1
2
3
4
5
6
&lt;html&gt;&lt;body&gt;
&lt;form method=&quot;get&quot; action=&quot;/cgi-bin/form1.py &hellip;">
  

  <!-- http://t.co/dKP3o1e -->
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  
  <link rel="canonical" href="http://www.xefan.com/page/6/index.html">
  <link href="/favicon.png" rel="icon">
  <link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
  <link href="/atom.xml" rel="alternate" title="龍昌博客" type="application/atom+xml">
  <script src="/javascripts/modernizr-2.0.js"></script>
  <script src="//ajax.useso.com/ajax/libs/jquery/1.9.1/jquery.min.js"></script>
  <script>!window.jQuery && document.write(unescape('%3Cscript src="./javascripts/libs/jquery.min.js"%3E%3C/script%3E'))</script>
  <script src="/javascripts/octopress.js" type="text/javascript"></script>
  <!--Fonts from Google"s Web font directory at http://google.com/webfonts -->
<link href="//fonts.useso.com/css?family=PT+Serif:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">
<link href="//fonts.useso.com/css?family=PT+Sans:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">

  

</head>

<body   >
  <header role="banner"><hgroup>
  <h1><a href="/">龍昌博客</a></h1>
  
    <h2>从Pythoner转向Rubist</h2>
  
</hgroup>

</header>
  <nav role="navigation"><ul class="subscription" data-subscription="rss">
  <li><a href="/atom.xml" rel="subscribe-rss" title="subscribe via RSS">RSS</a></li>
  
</ul>
  
<form action="https://www.google.com/search" method="get">
  <fieldset role="search">
    <input type="hidden" name="q" value="site:www.xefan.com" />
    <input class="search" type="text" name="q" results="0" placeholder="Search"/>
  </fieldset>
</form>
  
<ul class="main-navigation">
  <li><a href="/">Home</a></li>
  <li><a href="/blog/archives">Archives</a></li>
 <li><a href="/about/">About</a></li>  <li><a href="/gbook/">留言板</a></li> 
</ul>

</nav>
  <div id="main">
    <div id="content">
      <div class="blog-index">
  
  
  
    <article>
      
  <header>
    
    <h1 class="entry-title"><a href="http://www.xefan.com/archives/83990.html">Python Cgi教程3——表单</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2013-12-07T00:00:00+08:00'><span class='date'><span class='date-month'>Dec</span> <span class='date-day'>7</span><span class='date-suffix'>th</span>, <span class='date-year'>2013</span></span> <span class='time'>12:00 am</span></time>
        
           | <a href="http://www.xefan.com/archives/83990.html#disqus_thread"
             data-disqus-identifier="http://www.xefan.com/archives/83990.html">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><p>cgi模块中有一个FieldStorage类可用于表单处理。</p>


<h2>单一字段名</h2>


<p>有一个HTML表单如下：</p>




<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='html'><span class='line'><span class="nt">&lt;html&gt;&lt;body&gt;</span>
</span><span class='line'><span class="nt">&lt;form</span> <span class="na">method=</span><span class="s">&quot;get&quot;</span> <span class="na">action=</span><span class="s">&quot;/cgi-bin/form1.py&quot;</span><span class="nt">&gt;</span>
</span><span class='line'>Name: <span class="nt">&lt;input</span> <span class="na">type=</span><span class="s">&quot;text&quot;</span> <span class="na">name=</span><span class="s">&quot;name&quot;</span><span class="nt">&gt;</span>
</span><span class='line'><span class="nt">&lt;input</span> <span class="na">type=</span><span class="s">&quot;submit&quot;</span> <span class="na">value=</span><span class="s">&quot;Submit&quot;</span><span class="nt">&gt;</span>
</span><span class='line'><span class="nt">&lt;/form&gt;</span>
</span><span class='line'><span class="nt">&lt;/body&gt;&lt;/html&gt;</span>
</span></code></pre></td></tr></table></div></figure>




<p>form1.py内容为：</p>


<pre><code>#!/usr/bin/env python
import cgi
form = cgi.FieldStorage() # instantiate only once!
name = form.getfirst('name', 'empty')

# Avoid script injection escaping the user input
name = cgi.escape(name)

print """\
Content-Type: text/html\n
&lt;html&gt;&lt;body&gt;
&lt;p&gt;The submitted name was "%s"&lt;/p&gt;
&lt;/body&gt;&lt;/html&gt;
""" % name
</code></pre>

<p><em>getfirst</em>方法获取指定字段的第一个值，如果该字段不存在则为空。将表单的方法改为post它同样适用。</p>


<p>为了避免用户提交危险的内容，可以使用<em>cgi.escape()</em>方法对内容进行转换。</p>


<h2>多字段名</h2>


<p>对于多个字段具有相同名字的可以使用<em>getlist()</em>方法，它返回一个列表包含了这些值。</p>


<pre><code>&lt;html&gt;&lt;body&gt;
&lt;form method="post" action="/cgi-bin/form2.py"&gt;
Red&lt;input type="checkbox" name="color" value="red"&gt;
Green&lt;input type="checkbox" name="color" value="green"&gt;
&lt;input type="submit" value="Submit"&gt;
&lt;/form&gt;
&lt;/body&gt;&lt;/html&gt;
</code></pre>

<p>form2.py内容如下：</p>


<pre><code>#!/usr/bin/env python
import cgi
form = cgi.FieldStorage()

# getlist() returns a list containing the
# values of the fields with the given name
colors = form.getlist('color')

print "Content-Type: text/html\n"
print '&lt;html&gt;&lt;body&gt;'
print 'The colors list:', colors
for color in colors:
   print '&lt;p&gt;', cgi.escape(color), '&lt;/p&gt;'
print '&lt;/body&gt;&lt;/html&gt;'
</code></pre>

<h2>文件上传</h2>


<pre><code>&lt;html&gt;&lt;body&gt;
&lt;form enctype="multipart/form-data" action="/cgi-bin/form3.py" method="post"&gt;
&lt;p&gt;File: &lt;input type="file" name="file"&gt;&lt;/p&gt;
&lt;p&gt;&lt;input type="submit" value="Upload"&gt;&lt;/p&gt;
&lt;/form&gt;
&lt;/body&gt;&lt;/html&gt;
</code></pre>

<p><em>getfirst()</em>和<em>getlist()</em>都只能获取文件的内容。想获取文件名需要使用<em>FieldStorage</em>。</p>


<p>form3.py内容如下：</p>


<pre><code>#!/usr/bin/env python
import cgi, os
import cgitb; cgitb.enable()

try: # Windows needs stdio set for binary mode.
    import msvcrt
    msvcrt.setmode (0, os.O_BINARY) # stdin  = 0
    msvcrt.setmode (1, os.O_BINARY) # stdout = 1
except ImportError:
    pass

form = cgi.FieldStorage()

# A nested FieldStorage instance holds the file
fileitem = form['file']

# Test if the file was uploaded
if fileitem.filename:

   # strip leading path from file name to avoid directory traversal attacks
   fn = os.path.basename(fileitem.filename)
   open('files/' + fn, 'wb').write(fileitem.file.read())
   message = 'The file "' + fn + '" was uploaded successfully'

else:
   message = 'No file was uploaded'

print """\
Content-Type: text/html\n
&lt;html&gt;&lt;body&gt;
&lt;p&gt;%s&lt;/p&gt;
&lt;/body&gt;&lt;/html&gt;
""" % (message,)
</code></pre>

<h2>大文件上传</h2>


<p>在处理大文件时如果内存不足，可以使用生成器将文件分成小片。<br>
可将之前的脚本改写如下：</p>


<pre><code>#!/usr/bin/env python
import cgi, os
import cgitb; cgitb.enable()

try: # Windows needs stdio set for binary mode.
    import msvcrt
    msvcrt.setmode (0, os.O_BINARY) # stdin  = 0
    msvcrt.setmode (1, os.O_BINARY) # stdout = 1
except ImportError:
    pass

form = cgi.FieldStorage()

# Generator to buffer file chunks
def fbuffer(f, chunk_size=10000):
   while True:
      chunk = f.read(chunk_size)
      if not chunk: break
      yield chunk

# A nested FieldStorage instance holds the file
fileitem = form['file']

# Test if the file was uploaded
if fileitem.filename:

   # strip leading path from file name to avoid directory traversal attacks
   fn = os.path.basename(fileitem.filename)
   f = open('files/' + fn, 'wb', 10000)

   # Read the file in chunks
   for chunk in fbuffer(fileitem.file):
      f.write(chunk)
   f.close()
   message = 'The file "' + fn + '" was uploaded successfully'

else:
   message = 'No file was uploaded'

print """\
Content-Type: text/html\n
&lt;html&gt;&lt;body&gt;
&lt;p&gt;%s&lt;/p&gt;
&lt;/body&gt;&lt;/html&gt;
""" % (message,)
</code></pre>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
    <h1 class="entry-title"><a href="http://www.xefan.com/archives/83984.html">Python Cgi教程2——调试</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2013-12-06T00:00:00+08:00'><span class='date'><span class='date-month'>Dec</span> <span class='date-day'>6</span><span class='date-suffix'>th</span>, <span class='date-year'>2013</span></span> <span class='time'>12:00 am</span></time>
        
           | <a href="http://www.xefan.com/archives/83984.html#disqus_thread"
             data-disqus-identifier="http://www.xefan.com/archives/83984.html">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><p>有时数据头出错是很难定位的，除非有权限访问服务器日志。</p>


<p>好在Python有cgitb模块，可以将异常的堆栈信息放在正文中，作为HTML输出。</p>


<p>以下是一个简单的例子：</p>




<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='python'><span class='line'><span class="c">#!/usr/bin/env python</span>
</span><span class='line'><span class="k">print</span> <span class="s">&quot;Content-Type: text/html</span><span class="se">\n</span><span class="s">&quot;</span>
</span><span class='line'><span class="kn">import</span> <span class="nn">cgitb</span><span class="p">;</span> <span class="n">cgitb</span><span class="o">.</span><span class="n">enable</span><span class="p">()</span>
</span><span class='line'><span class="k">print</span> <span class="mi">1</span><span class="o">/</span><span class="mi">0</span>
</span></code></pre></td></tr></table></div></figure>




<p>也可以使用handler()方法进行捕获异常处理。</p>




<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='python'><span class='line'><span class="c">#!/usr/bin/env python</span>
</span><span class='line'><span class="k">print</span> <span class="s">&quot;Content-Type: text/html&quot;</span>
</span><span class='line'><span class="k">print</span>
</span><span class='line'><span class="kn">import</span> <span class="nn">cgitb</span>
</span><span class='line'><span class="k">try</span><span class="p">:</span>
</span><span class='line'>   <span class="n">f</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="s">&#39;non-existent-file.txt&#39;</span><span class="p">,</span> <span class="s">&#39;r&#39;</span><span class="p">)</span>
</span><span class='line'><span class="k">except</span><span class="p">:</span>
</span><span class='line'>   <span class="n">cgitb</span><span class="o">.</span><span class="n">handler</span><span class="p">()</span>
</span></code></pre></td></tr></table></div></figure>




<p>还有一种更直接的方法，将数据头设为&#8221;text/plain&#8221;并把标准错误输出设置到标准输出。</p>




<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='python'><span class='line'><span class="k">print</span> <span class="s">&quot;Content-Type: text/plain&quot;</span>
</span><span class='line'><span class="k">print</span>
</span><span class='line'><span class="kn">import</span> <span class="nn">sys</span>
</span><span class='line'><span class="n">sys</span><span class="o">.</span><span class="n">stderr</span> <span class="o">=</span> <span class="n">sys</span><span class="o">.</span><span class="n">stdout</span>
</span><span class='line'><span class="n">f</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="s">&#39;non-existent-file.txt&#39;</span><span class="p">,</span> <span class="s">&#39;r&#39;</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>




<p>注意：这些只是用于在开发阶段，在生产环境中要把它禁用。以免异常信息被攻击者利用。</p>

</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
    <h1 class="entry-title"><a href="http://www.xefan.com/archives/83979.html">Python cgi教程1——Hello World</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2013-12-06T00:00:00+08:00'><span class='date'><span class='date-month'>Dec</span> <span class='date-day'>6</span><span class='date-suffix'>th</span>, <span class='date-year'>2013</span></span> <span class='time'>12:00 am</span></time>
        
           | <a href="http://www.xefan.com/archives/83979.html#disqus_thread"
             data-disqus-identifier="http://www.xefan.com/archives/83979.html">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><h2>简介</h2>


<p>CGI(Common Gateway Interface)，通用网关接口的简称。它是客户端和服务器程序进行数据传输的一种标准。</p>


<p>一个CGI程序可以使用任何语言编写，通常它是放在Web服务器（如Apache）目录下的cgi-bin目录里。</p>


<h2>实例</h2>


<p>接下来看一个简单的例子。</p>




<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class='python'><span class='line'><span class="c">#!/usr/bin/env python</span>
</span><span class='line'><span class="k">print</span> <span class="s">&quot;Content-Type: text/html&quot;</span>
</span><span class='line'><span class="k">print</span>
</span><span class='line'><span class="k">print</span> <span class="s">&quot;&quot;&quot;</span><span class="se">\</span>
</span><span class='line'><span class="s">&lt;html&gt;</span>
</span><span class='line'><span class="s">&lt;body&gt;</span>
</span><span class='line'><span class="s">&lt;h2&gt;Hello World!&lt;/h2&gt;</span>
</span><span class='line'><span class="s">&lt;/body&gt;</span>
</span><span class='line'><span class="s">&lt;/html&gt;</span>
</span><span class='line'><span class="s">&quot;&quot;&quot;</span>
</span></code></pre></td></tr></table></div></figure>




<p>脚本程序的第一行指定了python解释器的路径。在你系统中它也可能为：</p>




<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='python'><span class='line'><span class="c">#!/usr/bin/python</span>
</span><span class='line'><span class="c">#!/usr/bin/python2</span>
</span><span class='line'><span class="c">#!c:\Python26\python.exe</span>
</span><span class='line'><span class="c">#!c:\Python27\python.exe</span>
</span></code></pre></td></tr></table></div></figure>




<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='python'><span class='line'><span class="k">print</span> <span class="s">&quot;Content-Type: text/html&quot;</span>
</span><span class='line'><span class="k">print</span>
</span></code></pre></td></tr></table></div></figure>




<p>脚本必须输出一个HTTP的头，它由一条或者多条消息构成，然后再一个空行。空行是必需的，它意味着头的结束。<br>
这里我们想要把输出作为HTML解释，因此指定Content-Type为 text/html。</p>


<p>这里也可以写成：</p>




<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='python'><span class='line'><span class="k">print</span> <span class="s">&quot;Content-Type: text/html</span><span class="se">\n</span><span class="s">&quot;</span>
</span></code></pre></td></tr></table></div></figure>




<p>保存以上脚本，并添加执行权限。然后在浏览器中访问执行该脚本，应该可以看到&#8221;Hello World&#8221;这几个字。</p>

</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
    <h1 class="entry-title"><a href="http://www.xefan.com/archives/83975.html">[翻译]Ruby GTK教程8——贪吃蛇</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2013-11-25T00:00:00+08:00'><span class='date'><span class='date-month'>Nov</span> <span class='date-day'>25</span><span class='date-suffix'>th</span>, <span class='date-year'>2013</span></span> <span class='time'>12:00 am</span></time>
        
           | <a href="http://www.xefan.com/archives/83975.html#disqus_thread"
             data-disqus-identifier="http://www.xefan.com/archives/83975.html">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><h1>贪吃蛇</h1>


<p>在这部分的Ruby GTK编程教程中我们将创建一个贪吃蛇游戏。</p>


<p>贪吃蛇是一个比较老的经典电子游戏。它第一次创建是在70年代后期。之后被移植到PC上。在这个游戏中玩家控制蛇，目标是尽可能多的吃掉苹果。蛇每吃掉一个苹果，身体就会变长。必须避免蛇撞到墙或者自己的身体。</p>


<h2>开发</h2>


<p>蛇的每块关节的大小为10像素。使用方向键控制蛇。初始，蛇有三块关节。游戏立即开始。当游戏结束后在窗口中央显示&#8221;Game Over&#8221;。</p>


<p><em>board.rb</em></p>


<pre><code>WIDTH = 300
HEIGHT = 270
DOT_SIZE = 10
ALL_DOTS = WIDTH * HEIGHT / (DOT_SIZE * DOT_SIZE)
RAND_POS = 26

$x = [0] * ALL_DOTS
$y = [0] * ALL_DOTS

class Board &lt; Gtk::DrawingArea

    def initialize
        super

        modify_bg Gtk::STATE_NORMAL, Gdk::Color.new(0, 0, 0)

        signal_connect "expose-event" do  
            on_expose
        end

        init_game
    end

    def on_timer

        if @inGame
            check_apple
            check_collision
            move
            queue_draw
            return true
        else
            return false
        end
    end

    def init_game

        @left = false
        @right = true
        @up = false
        @down = false
        @inGame = true
        @dots = 3

        for i in (0..@dots)
            $x[i] = 50 - i * 10
            $y[i] = 50
        end

        begin
            @dot = Cairo::ImageSurface.from_png "dot.png"
            @head = Cairo::ImageSurface.from_png "head.png"
            @apple = Cairo::ImageSurface.from_png "apple.png"
        rescue Exception =&gt; e
            puts "cannot load images"
            exit
        end

        locate_apple
        GLib::Timeout.add(100) { on_timer }

     end


    def on_expose

        cr = window.create_cairo_context

        if @inGame
            draw_objects cr
        else
            game_over cr
        end      
    end

    def draw_objects cr

        cr.set_source_rgb 0, 0, 0
        cr.paint

        cr.set_source @apple, @apple_x, @apple_y
        cr.paint

        for z in (0..@dots)
            if z == 0 
                cr.set_source @head, $x[z], $y[z]
                cr.paint
            else
                cr.set_source @dot, $x[z], $y[z]
                cr.paint
            end    
        end
    end

    def game_over cr

        w = allocation.width / 2
        h = allocation.height / 2

        cr.set_font_size 15
        te = cr.text_extents "Game Over"

        cr.set_source_rgb 65535, 65535, 65535

        cr.move_to w - te.width/2, h
        cr.show_text "Game Over"

    end


    def check_apple

        if $x[0] == @apple_x and $y[0] == @apple_y 
            @dots = @dots + 1
            locate_apple
        end
    end

    def move

        z = @dots

        while z &gt; 0
            $x[z] = $x[(z - 1)]
            $y[z] = $y[(z - 1)]
            z = z - 1
        end

        if @left
            $x[0] -= DOT_SIZE
        end

        if @right 
            $x[0] += DOT_SIZE
        end

        if @up
            $y[0] -= DOT_SIZE
        end

        if @down
            $y[0] += DOT_SIZE
        end

     end

    def check_collision

        z = @dots

        while z &gt; 0
            if z &gt; 4 and $x[0] == $x[z] and $y[0] == $y[z]
                @inGame = false
            end
            z = z - 1
        end

        if $y[0] &gt; HEIGHT - DOT_SIZE
            @inGame = false
        end

        if $y[0] &lt; 0
            @inGame = false
        end

        if $x[0] &gt; WIDTH - DOT_SIZE
            @inGame = false
        end

        if $x[0] &lt; 0
            @inGame = false
        end

    end

    def locate_apple

        r = rand(RAND_POS)
        @apple_x = r * DOT_SIZE
        r = rand(RAND_POS)
        @apple_y = r * DOT_SIZE
    end

    def on_key_down event

        key = event.keyval

        if key == Gdk::Keyval::GDK_Left and not @right
            @left = true
            @up = false
            @down = false
        end

        if key == Gdk::Keyval::GDK_Right and not @left
            @right = true
            @up = false
            @down = false
        end

        if key == Gdk::Keyval::GDK_Up and not @down
            @up = true
            @right = false
            @left = false
        end

        if key == Gdk::Keyval::GDK_Down and not @up
            @down = true
            @right = false
            @left = false
        end
    end   
end
</code></pre>


<p>首先我们定义一些全局变量。</p>


<p>WIDTH和HEIGHT常量决定了甲板的大小。DOT_SIZE是苹果和蛇的每个点的大小。ALL_DOTS常量定义了甲板可能包含的最大的点数量。RAND_POS常量用于计算苹果的随机位置。DELAY常量决定游戏速度。</p>


<pre><code>$x = [0] * ALL_DOTS
$y = [0] * ALL_DOTS
</code></pre>


<p>这两个数组存储了蛇所有关节的x、y坐标。</p>


<p><em>init_game</em>方法初始化变量、加载图片和启动timeout函数。</p>


<pre><code>if @inGame
    draw_objects cr
else
    game_over cr
end
</code></pre>


<p>在<em>on_expose_method</em>方法里我们检查<em>@inGame</em>变量。如果为true，绘制苹果和蛇。否则显示&#8221;Game over&#8221;文字。</p>


<pre><code>def draw_objects cr

    cr.set_source_rgb 0, 0, 0
    cr.paint

    cr.set_source @apple, @apple_x, @apple_y
    cr.paint

    for z in (0..@dots)
        if z == 0 
            cr.set_source @head, $x[z], $y[z]
            cr.paint
        else
            cr.set_source @dot, $x[z], $y[z]
            cr.paint
        end    
    end
end
</code></pre>


<p><em>draw_objects</em>方法绘制苹果和蛇。蛇的头部用红色的圆表示。</p>


<pre><code>def check_apple

    if $x[0] == @apple_x and $y[0] == @apple_y 
        @dots = @dots + 1
        locate_apple
    end
end
</code></pre>


<p><em>check_apple</em>方法查检蛇是否碰到苹果，如果是则增加蛇的关节并调用<em>locate_apple</em>方法随机放置一个新的苹果。</p>


<p><em>move</em>方法是游戏的关键算法。为了理解它，先看一下蛇是如何移动的。控制蛇头，可以使用方向键改变它的方向。其余的关节朝该方向前进。第二个关节移到到第一关节的位置，第三个关节到第二个等等。</p>


<pre><code>while z &gt; 0
    $x[z] = $x[(z - 1)]
    $y[z] = $y[(z - 1)]
    z = z - 1
end
</code></pre>


<p>这些代码将关节按照链状前进。</p>


<pre><code>if @left
    $x[0] -= DOT_SIZE
end
</code></pre>


<p>头部向左移动。</p>


<p><em>check_collision</em>方法中，我们检查蛇是否撞到了自己或者墙。</p>


<pre><code>while z &gt; 0
    if z &gt; 4 and $x[0] == $x[z] and $y[0] == $y[z]
        @inGame = false
    end
    z = z - 1
end
</code></pre>


<p>如果蛇撞到了自己，游戏结束。</p>


<pre><code>if $y[0] &gt; HEIGHT - DOT_SIZE
    @inGame = false
end
</code></pre>


<p>如果蛇撞到底部，游戏结束。</p>


<p><em>localte_apple</em>方法在甲板上随机定位一个苹果。</p>


<pre><code>r = rand(RAND_POS)
</code></pre>


<p>获取0到RAND_POS-1的一个随机数。</p>


<pre><code>@apple_x = r * DOT_SIZE
...
@apple_y = r * DOT_SIZE
</code></pre>


<p>这几行设置了苹果的x、y坐标。</p>


<pre><code>if @inGame
    check_apple
    check_collision
    move
    queue_draw
    return true
else
    return false
end
</code></pre>


<p>第140ms调用一次<em>on_timer</em>方法。如果游戏运行则调用三个组成游戏逻辑的方法。否则返回false，停止定时事件。</p>


<p>在Board类的<em>on_key_down</em>方法中我们判断按下的键。</p>


<pre><code>if key == Gdk::Keyval::GDK_Left and not @right
    @left = true
    @up = false
    @down = false
end
</code></pre>


<p>如果我们按的是左方向键，我们设置<em>left</em>变量为true。这个变量用于<em>move</em>方法改变蛇的坐标。同样注意，当蛇是朝右时，我们不能立即朝左。</p>


<p><em>nibbles.rb</em></p>


<pre><code>#!/usr/bin/ruby

# ZetCode Ruby GTK tutorial
#
# This is a simple nibbles game
# clone
#
# author: jan bodnar
# website: www.zetcode.com
# last modified: June 2009

require 'gtk2'
require 'board'

class RubyApp &gt; Gtk::Window
    def initialize
        super

        set_title "Nibbles"
        signal_connect "destroy" do 
            Gtk.main_quit 
        end

        @board = Board.new
        signal_connect "key-press-event" do |w, e|
            on_key_down(w, e)
        end

        add @board

        set_default_size 300, 270
        set_window_position Gtk::Window::POS_CENTER
        show_all
    end

    def on_key_down widget, event

        key = event.keyval
        @board.on_key_down event
    end
end

Gtk.init
    window = RubyApp.new
Gtk.main
</code></pre>


<p>在这个类我们启动了贪吃游戏。</p>


<pre><code>def on_key_down widget, event

    key = event.keyval
    @board.on_key_down event
end
</code></pre>


<p>在这个类的捕获按键事件然后委托Board类的<em>on_key_down method</em>方法进行处理。</p>


<p><img alt="image" src="http://zetcode.com/img/gui/rubygtk/nibbles.png"><br>
<em>图片：贪吃蛇</em></p>


<p>这是使用Ruby语言和GTK库编写的贪吃蛇计算机游戏。</p>


<hr>


<p>原文地址： <a href="http://zetcode.com/gui/rubygtk/nibbles/">http://zetcode.com/gui/rubygtk/nibbles/</a><br>
翻译：龙昌  admin@longchangjin.cn </p>

</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
    <h1 class="entry-title"><a href="http://www.xefan.com/archives/83972.html">[翻译]Ruby GTK教程7——自定义控件</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2013-11-24T00:00:00+08:00'><span class='date'><span class='date-month'>Nov</span> <span class='date-day'>24</span><span class='date-suffix'>th</span>, <span class='date-year'>2013</span></span> <span class='time'>12:00 am</span></time>
        
           | <a href="http://www.xefan.com/archives/83972.html#disqus_thread"
             data-disqus-identifier="http://www.xefan.com/archives/83972.html">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><h1>自定义控件</h1>


<p>大多数套件通常只提供了最常用的控件，如按钮、文本控件、滑动条等。没有套件可以提供所有可能的控件。程序员必须自己创建这些。这是通过套件提供的绘制工具完成。这有两种可能。程序员可以修改或增强已存在的控件，或者从头开始创建一个自定义控件。</p>


<h2>Burning控件</h2>


<p>这个例子我们从头开始创建一个控件。这个控件可以在各种媒体烧定应用中看到，如Nero Burning ROM。</p>


<p><em>custom.rb</em></p>


<pre><code>#!/usr/bin/ruby

# ZetCode Ruby GTK tutorial 
#
# This example creates a burning
# custom widget
#
# author: jan bodnar
# website: zetcode.com 
# last edited: June 2009


require 'gtk2'

class Burning &lt; Gtk::DrawingArea

    def initialize(parent)
        @parent = parent

        super()

        @num = [ "75", "150", "225", "300", 
            "375", "450", "525", "600", "675" ]

        set_size_request 1, 30
        signal_connect "expose-event" do
            expose
        end
    end


    def expose

        cr = window.create_cairo_context
        draw_widget cr

    end

    def draw_widget cr

         cr.set_line_width 0.8

        cr.select_font_face("Courier", 
            Cairo::FONT_SLANT_NORMAL, Cairo::FONT_WEIGHT_NORMAL)
        cr.set_font_size 11

        width = allocation.width

        @cur_width = @parent.get_cur_value

        step = (width / 10.0).round

        till = (width / 750.0) * @cur_width
        full = (width / 750.0) * 700

        if @cur_width &gt;= 700

            cr.set_source_rgb(1.0, 1.0, 0.72)
            cr.rectangle(0, 0, full, 30)
            cr.clip
            cr.paint
            cr.reset_clip

            cr.set_source_rgb(1.0, 0.68, 0.68)
            cr.rectangle(full, 0, till-full, 30)
            cr.clip
            cr.paint
            cr.reset_clip

        else
            cr.set_source_rgb 1.0, 1.0, 0.72
            cr.rectangle 0, 0, till, 30
            cr.clip
            cr.paint
            cr.reset_clip
        end


        cr.set_source_rgb(0.35, 0.31, 0.24)

        for i in (1..@num.length)
            cr.move_to i*step, 0
            cr.line_to i*step, 5
            cr.stroke

            te = cr.text_extents @num[i-1]
            cr.move_to i*step-te.width/2, 15
            cr.text_path @num[i-1]
            cr.stroke
        end         
    end
end


class RubyApp &lt; Gtk::Window
    def initialize
        super

        set_title "Burning"
        signal_connect "destroy" do 
            Gtk.main_quit 
        end

        set_size_request 350, 200        
        set_window_position Gtk::Window::POS_CENTER

        @cur_value = 0

        vbox = Gtk::VBox.new false, 2

        scale = Gtk::HScale.new
        scale.set_range 0, 750
        scale.set_digits 0
        scale.set_size_request 160, 35
        scale.set_value @cur_value

        scale.signal_connect "value-changed" do |w|
            on_changed(w)
        end

        fix = Gtk::Fixed.new
        fix.put scale, 50, 50

        vbox.pack_start fix

        @burning = Burning.new(self)
        vbox.pack_start @burning, false, false, 0

        add vbox
        show_all
    end

    def on_changed widget

        @cur_value = widget.value
        @burning.queue_draw
    end

    def get_cur_value
        return @cur_value
    end
end

Gtk.init
    window = RubyApp.new
Gtk.main
</code></pre>


<p>我们将DrawingArea放在窗口的底部，并且手动绘制控件的条目。所有的重要代码放在draw_widget里，通过Burning类的expose方法调用。这个控件生动的显示了媒介的容量和剩余空间。这个控件通过刻度控件来控制。我们自定义控件的最小值为0,最大值为750。如果达到700，我们开始绘制红色。这通常表明超标了。</p>


<pre><code>@num = [ "75", "150", "225", "300", 
    "375", "450", "525", "600", "675" ]
</code></pre>


<p>这些数字显示在控件上。他们显示了媒介的容量。</p>


<pre><code>@cur_width = @parent.get_cur_value
</code></pre>


<p>通过父控件我们获得刻度控件的值。</p>


<pre><code>till = (width / 750.0) * @cur_width
full = (width / 750.0) * 700
</code></pre>


<p>我们使用width变量进行刻度值和自定义控件尺寸的转换。注意我们使用了浮点数，得到较大精度的绘制。<em>till</em>参数决定了绘制的总大小，它的值来自刻度控件。它是整个区域的比例。<em>full</em>参数决定了从什么位置开始绘制红色。</p>


<pre><code>cr.set_source_rgb(1.0, 1.0, 0.72)
cr.rectangle(0, 0, full, 30)
cr.clip
cr.paint
cr.reset_clip
</code></pre>


<p>绘制黄色矩形直到<em>full</em>点。</p>


<pre><code>te = cr.text_extents @num[i-1]
cr.move_to i*step-te.width/2, 15
cr.text_path @num[i-1]
cr.stroke
</code></pre>


<p>这些代码绘制了burning控件的数字。我们计算了文本恰当的位置。</p>


<pre><code>def on_changed widget

    @cur_value = widget.value
    @burning.queue_draw
end
</code></pre>


<p>我们获取刻度控件的值保存在<em>cur_value</em>变量中，稍后使用。重绘burning控件。</p>


<p><img alt="image" src="http://zetcode.com/img/gui/rubygtk/burning.png"><br>
<em>图片：Burning widget</em></p>


<p>在这一章中，我们创建了一个自定义控件。</p>


<hr>


<p>原文地址： <a href="http://zetcode.com/gui/rubygtk/customwidget/">http://zetcode.com/gui/rubygtk/customwidget/</a><br>
翻译：龙昌  admin@longchangjin.cn </p>

</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
    <h1 class="entry-title"><a href="http://www.xefan.com/archives/83969.html">[翻译]Ruby GTK教程6——Cairo</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2013-11-24T00:00:00+08:00'><span class='date'><span class='date-month'>Nov</span> <span class='date-day'>24</span><span class='date-suffix'>th</span>, <span class='date-year'>2013</span></span> <span class='time'>12:00 am</span></time>
        
           | <a href="http://www.xefan.com/archives/83969.html#disqus_thread"
             data-disqus-identifier="http://www.xefan.com/archives/83969.html">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><h1>使用Cairo绘制</h1>


<p>这部分的Ruby GTK教程，我们将使用Cairo库进行一些绘制。</p>


<p>Cairo是一个用于创建2D矢量图像的库。我们可以用它来绘制自己的控件、图表或者各种效果或动画。</p>


<h2>颜色</h2>


<p>在第一个会例子，我们将介绍颜色。颜色是一个代表了红、绿和蓝（RGB）强度值的对象。Cairo的RGB有效值范围为0到1。</p>


<pre><code>#!/usr/bin/ruby

# ZetCode Ruby GTK tutorial
#
# This program shows how to work
# with colors in Cairo
#
# author: jan bodnar
# website: www.zetcode.com
# last modified: June 2009

require 'gtk2'


class RubyApp &lt; Gtk::Window

    def initialize
        super

        set_title "Colors"
        signal_connect "destroy" do 
            Gtk.main_quit 
        end

        init_ui

        set_default_size 360, 100
        set_window_position Gtk::Window::POS_CENTER

        show_all
    end

    def init_ui

        @darea = Gtk::DrawingArea.new

        @darea.signal_connect "expose-event" do  
            on_expose
        end

        add(@darea)

    end

    def on_expose

        cr = @darea.window.create_cairo_context  
        draw_colors cr

    end

    def draw_colors cr

        cr.set_source_rgb 0.2, 0.23, 0.9
        cr.rectangle 10, 15, 90, 60
        cr.fill

        cr.set_source_rgb 0.9, 0.1, 0.1
        cr.rectangle 130, 15, 90, 60
        cr.fill

        cr.set_source_rgb 0.4, 0.9, 0.4
        cr.rectangle 250, 15, 90, 60
        cr.fill
    end
end

Gtk.init
    window = RubyApp.new
Gtk.main
</code></pre>


<p>这个例子中我们绘制了三个矩形并且用三种不同的颜色填充。</p>


<pre><code>@darea = Gtk::DrawingArea.new
</code></pre>


<p>我们将在DrawingArea控件是进行绘制操作。</p>


<pre><code>@darea.signal_connect "expose-event" do  
    on_expose
end
</code></pre>


<p>当窗口需要重绘时<em>expose-event</em>事件将触发。对这个事件的响应中我们调用了<em>on_expose</em>方法。</p>


<pre><code>cr = @darea.window.create_cairo_context
</code></pre>


<p>从GdkWindow创建cairo上下文对象。这个上下文是我们将要进行所有绘制的对象。</p>


<pre><code>draw_colors cr
</code></pre>


<p>实际的绘制委托给<em>draw_colors</em>方法。</p>


<pre><code>cr.set_source_rgb 0.2, 0.23, 0.9
</code></pre>


<p><em>set_source_rgb</em>方法是设置cairo上下文的颜色。这个方法的三个参数是颜色的强度值。</p>


<pre><code>cr.rectangle 10, 15, 90, 60
</code></pre>


<p>绘制一个矩形。前两个参数是矩形左上角的x、y坐标。后两个参数是矩形的宽和高。</p>


<pre><code>cr.fill
</code></pre>


<p>使用当前的颜色填充矩形。</p>


<p><img alt="image1" src="http://zetcode.com/img/gui/rubygtk/colors.png"><br>
<em>图片：颜色</em></p>


<h2>基本形状</h2>


<p>下一个例子在窗口上绘制一些基本形状。</p>


<pre><code>#!/usr/bin/ruby

# ZetCode Ruby GTK tutorial
#
# This code example draws basic shapes
# with the Cairo library
#
# author: jan bodnar
# website: www.zetcode.com
# last modified: June 2009

require 'gtk2'


class RubyApp &lt; Gtk::Window

    def initialize
        super

        set_title "Basic shapes"
        signal_connect "destroy" do 
            Gtk.main_quit 
        end

        init_ui

        set_default_size 390, 240
        set_window_position Gtk::Window::POS_CENTER

        show_all
    end

    def init_ui

        @darea = Gtk::DrawingArea.new

        @darea.signal_connect "expose-event" do  
            on_expose
        end

        add(@darea)
    end

    def on_expose

        cr = @darea.window.create_cairo_context  
        draw_shapes cr
    end

    def draw_shapes cr

        cr.set_source_rgb 0.6, 0.6, 0.6

        cr.rectangle 20, 20, 120, 80
        cr.rectangle 180, 20, 80, 80
        cr.fill

        cr.arc 330, 60, 40, 0, 2*Math::PI
        cr.fill

        cr.arc 90, 160, 40, Math::PI/4, Math::PI
        cr.fill

        cr.translate 220, 180
        cr.scale 1, 0.7
        cr.arc 0, 0, 50, 0, 2*Math::PI
        cr.fill
    end
end

Gtk.init
    window = RubyApp.new
Gtk.main
</code></pre>


<p>这个例子我们将创建一个矩形、方形、圆形、弧形和椭圆形。我们将轮廓绘为蓝色，内部为白色。</p>


<pre><code>cr.rectangle 20, 20, 120, 80
cr.rectangle 180, 20, 80, 80
cr.fill
</code></pre>


<p>这几行绘制了一个矩形和一个方形。</p>


<pre><code>cr.arc 330, 60, 40, 0, 2*Math::PI
cr.fill
</code></pre>


<p><em>arc</em>方法绘制一个全圆。</p>


<pre><code>cr.translate 220, 180
cr.scale 1, 0.7
cr.arc 0, 0, 50, 0, 2*Math::PI
cr.fill
</code></pre>


<p><em>translate</em>方法将对象移动到指定的点。如果我们想要绘制椭圆，我们需要进行一些缩放。这里<em>scale</em>方法将y轴收缩。</p>


<p><img alt="image2" src="http://zetcode.com/img/gui/rubygtk/shapes.png"><br>
<em>图片：基本形状</em></p>


<h2>透明矩形</h2>


<p>透明度是透过实体的可见度。最简单的理解可以把它想象成玻璃或者水。光线可以透过玻璃，这样我们就可以看到玻璃后的物体。</p>


<p>在计算机图像中，我们可以使用透明混合实现透明度。透明混合处理图片和背景的组合，显示部透明。作品处理使用了阿尔法通道。</p>


<pre><code>#!/usr/bin/ruby

# ZetCode Ruby GTK tutorial
#
# This program shows transparent
# rectangles using Cairo
#
# author: jan bodnar
# website: www.zetcode.com
# last modified: June 2009

require 'gtk2'


class RubyApp &lt; Gtk::Window

    def initialize
        super

        set_title "Transparent rectangles"
        signal_connect "destroy" do 
            Gtk.main_quit 
        end

        init_ui

        set_default_size 590, 90
        set_window_position Gtk::Window::POS_CENTER

        show_all
    end

    def init_ui

        @darea = Gtk::DrawingArea.new

        @darea.signal_connect "expose-event" do  
            on_expose
        end

        add(@darea)

    end

    def on_expose

        cr = @darea.window.create_cairo_context

        for i in (1..10)
            cr.set_source_rgba 0, 0, 1, i*0.1
            cr.rectangle 50*i, 20, 40, 40
            cr.fill
        end
    end
end

Gtk.init
    window = RubyApp.new
Gtk.main
</code></pre>


<p>这个例子我们使用不同等级透明度绘制了10个矩形。</p>


<pre><code>cr.set_source_rgba 0, 0, 1, i*0.1
</code></pre>


<p><em>set_source_rgba</em>方法是最后一个参数是alpha透明度。</p>


<p><img alt="image3" src="http://zetcode.com/img/gui/rubygtk/transparency.png"> <br>
<em>图片：透明矩形</em></p>


<h2>甜甜圈</h2>


<p>接下来的例子我们通过旋转一堆椭圆来创建一个复杂的形状。</p>


<pre><code>#!/usr/bin/ruby

# ZetCode Ruby GTK tutorial
#
# This program creates a donut
# with Cairo library
#
# author: jan bodnar
# website: www.zetcode.com
# last modified: June 2009

require 'gtk2'


class RubyApp &lt; Gtk::Window

    def initialize
        super

        set_title "Donut"
        signal_connect "destroy" do 
            Gtk.main_quit 
        end

        init_ui

        set_default_size 350, 250
        set_window_position Gtk::Window::POS_CENTER

        show_all
    end

    def init_ui

        @darea = Gtk::DrawingArea.new

        @darea.signal_connect "expose-event" do  
            on_expose
        end

        add(@darea)

    end

    def on_expose

        cr = @darea.window.create_cairo_context  
        cr.set_line_width 0.5

        w = allocation.width
        h = allocation.height

        cr.translate w/2, h/2
        cr.arc 0, 0, 120, 0, 2*Math::PI
        cr.stroke

        for i in (1..36)
            cr.save
            cr.rotate i*Math::PI/36
            cr.scale 0.3, 1
            cr.arc 0, 0, 120, 0, 2*Math::PI
            cr.restore
            cr.stroke
        end
    end
end

Gtk.init
    window = RubyApp.new
Gtk.main
</code></pre>


<p>这个例子我们创建了一个甜甜圈。它的形状与饼干相似，因此取名为甜甜圈（donut）。</p>


<pre><code>cr.translate w/2, h/2
cr.arc 0, 0, 120, 0, 2*Math::PI
cr.stroke
</code></pre>


<p>在开始只是一个椭圆。</p>


<pre><code>for i in (1..36)
    cr.save
    cr.rotate i*Math::PI/36
    cr.scale 0.3, 1
    cr.arc 0, 0, 120, 0, 2*Math::PI
    cr.restore
    cr.stroke
end
</code></pre>


<p>经过一些旋转后变成了甜甜圈。</p>


<p><img alt="image4" src="http://zetcode.com/img/gui/rubygtk/donut.jpg"><br>
<em>图片：Donut</em></p>


<h2>绘制文本</h2>


<p>下一个例子我们在窗口上绘制一些文本。</p>


<pre><code>#!/usr/bin/ruby

# ZetCode Ruby GTK tutorial
#
# This program draws text
# using Cairo
#
# author: jan bodnar
# website: www.zetcode.com
# last modified: June 2009

require 'gtk2'


class RubyApp &lt; Gtk::Window

    def initialize
        super

        set_title "Soulmate"
        signal_connect "destroy" do 
            Gtk.main_quit 
        end

        init_ui

        set_default_size 370, 240
        set_window_position Gtk::Window::POS_CENTER

        show_all
    end

    def init_ui

        @darea = Gtk::DrawingArea.new

        @darea.signal_connect "expose-event" do  
            on_expose
        end

        add(@darea)

    end

    def on_expose

        cr = @darea.window.create_cairo_context

        cr.set_source_rgb 0.1, 0.1, 0.1

        cr.select_font_face "Purisa", Cairo::FONT_SLANT_NORMAL, 
            Cairo::FONT_WEIGHT_NORMAL
        cr.set_font_size 13

        cr.move_to 20, 30
        cr.show_text "Most relationships seem so transitory"
        cr.move_to 20, 60
        cr.show_text "They're all good but not the permanent one"
        cr.move_to 20, 120
        cr.show_text "Who doesn't long for someone to hold"
        cr.move_to 20, 150
        cr.show_text "Who knows how to love without being told"
        cr.move_to 20, 180
        cr.show_text "Somebody tell me why I'm on my own"
        cr.move_to 20, 210
        cr.show_text "If there's a soulmate for everyone"
    end
end

Gtk.init
    window = RubyApp.new
Gtk.main
</code></pre>


<p>我们显示了Natasha Bedingfields Soulmate歌的部分歌词。</p>


<pre><code>cr.select_font_face "Purisa", Cairo::FONT_SLANT_NORMAL, 
    Cairo::FONT_WEIGHT_NORMAL
</code></pre>


<p>这里我们指定我们使用的字体。</p>


<pre><code>cr.set_font_size 13
</code></pre>


<p>我们指定字体的大小。</p>


<pre><code>cr.move_to 20, 30
</code></pre>


<p>移动到开始绘制文本的坐标。</p>


<pre><code>cr.show_text "Most relationships seem so transitory"
</code></pre>


<p><em>show_text</em>方法在窗口上绘制文本。</p>


<p><img alt="image5" src="http://zetcode.com/img/gui/rubygtk/soulmate.png"><br>
<em>图片: Soulmate</em></p>


<p>这章的Ruby GTK教程我们使用Cairo库进行绘制。</p>


<hr>


<p>原文地址： <a href="http://zetcode.com/gui/rubygtk/cairo/">http://zetcode.com/gui/rubygtk/cairo/</a><br>
翻译：龙昌  admin@longchangjin.cn </p>

</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
    <h1 class="entry-title"><a href="http://www.xefan.com/archives/83966.html">[翻译]Ruby GTK教程5——对话框</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2013-11-23T00:00:00+08:00'><span class='date'><span class='date-month'>Nov</span> <span class='date-day'>23</span><span class='date-suffix'>rd</span>, <span class='date-year'>2013</span></span> <span class='time'>12:00 am</span></time>
        
           | <a href="http://www.xefan.com/archives/83966.html#disqus_thread"
             data-disqus-identifier="http://www.xefan.com/archives/83966.html">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><h1>对话框</h1>


<p>在这部分的Ruby GTK教程我们将介绍对话框。</p>


<p>对话框是现代GUI应用程序不可缺的一部分。对话是两个或者更多人之间交谈。在计算机程序中对话是一个用于与应用程序交互的窗口。对话框用于输入数据、修改数据、修改设置等。对话框在用户与计算机程序之间的交流具有重要意义。</p>


<h2>消息盒子</h2>


<p>消息对话框是应用程序便于给用户提供消息的对话框。消息由文本和图片数据组成。</p>


<pre><code>#!/usr/bin/ruby

# ZetCode Ruby GTK tutorial
#
# This example shows message
# dialogs
#
# author: jan bodnar
# website: www.zetcode.com
# last modified: June 2009

require 'gtk2'


class RubyApp &lt; Gtk::Window

    def initialize
        super

        set_title "Messages"
        signal_connect "destroy" do 
            Gtk.main_quit 
        end

        init_ui

        set_default_size 250, 100
        set_window_position Gtk::Window::POS_CENTER

        show_all
    end

    def init_ui

        table = Gtk::Table.new 2, 2, true

        info = Gtk::Button.new "Information"
        warn = Gtk::Button.new "Warning"
        ques = Gtk::Button.new "Question"
        erro = Gtk::Button.new "Error"

        info.signal_connect "clicked" do
            on_info
        end

        warn.signal_connect "clicked" do
            on_warn
        end

        ques.signal_connect "clicked" do
            on_ques
        end

        erro.signal_connect "clicked" do
            on_erro
        end

        table.attach info, 0, 1, 0, 1
        table.attach warn, 1, 2, 0, 1
        table.attach ques, 0, 1, 1, 2
        table.attach erro, 1, 2, 1, 2

        add table

    end

    def on_info
        md = Gtk::MessageDialog.new(self,
            Gtk::Dialog::DESTROY_WITH_PARENT, Gtk::MessageDialog::INFO, 
            Gtk::MessageDialog::BUTTONS_CLOSE, "Download completed")
        md.run
        md.destroy
    end


    def on_erro
        md = Gtk::MessageDialog.new(self, Gtk::Dialog::MODAL |
            Gtk::Dialog::DESTROY_WITH_PARENT, Gtk::MessageDialog::ERROR, 
            Gtk::MessageDialog::BUTTONS_CLOSE, "Error loading file")
        md.run
        md.destroy
    end


    def on_ques
        md = Gtk::MessageDialog.new(self,
            Gtk::Dialog::DESTROY_WITH_PARENT, Gtk::MessageDialog::QUESTION, 
            Gtk::MessageDialog::BUTTONS_CLOSE, "Are you sure to quit?")
        md.run
        md.destroy
    end

    def on_warn
        md = Gtk::MessageDialog.new(self,
            Gtk::Dialog::DESTROY_WITH_PARENT, Gtk::MessageDialog::WARNING, 
            Gtk::MessageDialog::BUTTONS_CLOSE, "Unallowed operation")
        md.run
        md.destroy
    end
end

Gtk.init
    window = RubyApp.new
Gtk.main
</code></pre>


<p>我们的例子中显示了四种消息对话框。信息、警告、询问和错误消息对话框。</p>


<pre><code>info = Gtk::Button.new "Information"
warn = Gtk::Button.new "Warning"
ques = Gtk::Button.new "Question"
erro = Gtk::Button.new "Error"
</code></pre>


<p>创建四个按钮。每个按钮将显示不同种类的消息对话框。</p>


<pre><code>def on_info
    md = Gtk::MessageDialog.new(self,
        Gtk::Dialog::DESTROY_WITH_PARENT, Gtk::MessageDialog::INFO, 
        Gtk::MessageDialog::BUTTONS_CLOSE, "Download completed")
    md.run
    md.destroy
end
</code></pre>


<p>如果我们点击了<em>info</em>按钮，信息对话框将显示。<em>Gtk::MessageDialog::INFO</em>指定了对话框的类型。<em>Gtk::MessageDialog::BUTTONS_CLOSE</em>指定在对话框中显示的按钮。最后一个参数是要显示的消息。对话框使用<em>run</em>方法显示。程序员必须也要调用<em>destroy</em>或者<em>hide</em>方法。<br>
<img alt="image1" src="http://zetcode.com/img/gui/rubygtk/information.png">  <img alt="image2" src="http://zetcode.com/img/gui/rubygtk/warning.png">  <br>
<img alt="image3" src="http://zetcode.com/img/gui/rubygtk/question.png">  <img alt="image4" src="http://zetcode.com/img/gui/rubygtk/error.png">   </p>


<h2>关于对话框(AboutDialog)</h2>


<p><em>关于对话框</em>显示了应用程序的信息。<em>关于对话框</em>可以显示logo、应用程序名、版本号、版权、网站或者授权信息。它也可能给出作者、文档编写才、翻译者和设计师的信息。</p>


<pre><code>#!/usr/bin/ruby

# ZetCode Ruby GTK tutorial
#
# This example demonstrates the
# AboutDialog dialog
#
# author: jan bodnar
# website: www.zetcode.com
# last modified: June 2009

require 'gtk2'


class RubyApp &lt; Gtk::Window

    def initialize
        super

        set_title "About dialog"
        signal_connect "destroy" do 
            Gtk.main_quit 
        end

        init_ui

        set_default_size 300, 150
        set_window_position Gtk::Window::POS_CENTER

        show_all
    end

    def init_ui

        button = Gtk::Button.new "About"
        button.set_size_request 80, 30

        button.signal_connect "clicked" do
            on_clicked
        end

        fix = Gtk::Fixed.new
        fix.put button, 20, 20

        add fix

    end

    def on_clicked
        about = Gtk::AboutDialog.new
        about.set_program_name "Battery"
        about.set_version "0.1"
        about.set_copyright "(c) Jan Bodnar"
        about.set_comments "Battery is a simple tool for battery checking"
        about.set_website "http://www.zetcode.com"
        about.set_logo Gdk::Pixbuf.new "battery.png"
        about.run
        about.destroy
    end
end

Gtk.init
    window = RubyApp.new
Gtk.main
</code></pre>


<p>代码伅使用了<em>AboutDialog</em>的一些特性。</p>


<pre><code>about = Gtk::AboutDialog.new
</code></pre>


<p>创建一个AboutDialog。</p>


<pre><code>about.set_program_name "Battery"
about.set_version "0.1"
about.set_copyright "(c) Jan Bodnar"
</code></pre>


<p>这里我们指定名称、版本号和版权信息。</p>


<pre><code>about.set_logo Gdk::Pixbuf.new "battery.png"
</code></pre>


<p>这行创建一个logo。 <br>
<img alt="image5" src="http://zetcode.com/img/gui/rubygtk/about.png"> <br>
<em>图片：AboutDialog</em></p>


<h2>字体选择对话框</h2>


<p>FontSelectionDialog是一个用于选择字体的对话框。它典型的应用于文本编辑或者格式化的应用程序中。</p>


<pre><code>#!/usr/bin/ruby

# ZetCode Ruby GTK tutorial
#
# This example works with the
# FontSelectionDialog
#
# author: jan bodnar
# website: www.zetcode.com
# last modified: June 2009

require 'gtk2'


class RubyApp &lt; Gtk::Window

    def initialize
        super

        set_title "FontSelectionDialog"
        signal_connect "destroy" do 
            Gtk.main_quit 
        end

        init_ui

        set_default_size 300, 150
        set_window_position Gtk::Window::POS_CENTER

        show_all
    end

    def init_ui

        set_border_width 10
        @label = Gtk::Label.new "The only victory over love is flight."
        button = Gtk::Button.new "Select font"

        button.signal_connect "clicked" do
            on_clicked
        end

        fix = Gtk::Fixed.new
        fix.put button, 100, 30
        fix.put @label, 30, 90
        add fix

    end

    def on_clicked
        fdia = Gtk::FontSelectionDialog.new "Select font name"
        response = fdia.run

        if response == Gtk::Dialog::RESPONSE_OK
            font_desc = Pango::FontDescription.new fdia.font_name
            if font_desc
                @label.modify_font font_desc
            end
        end
        fdia.destroy
    end     
end

Gtk.init
    window = RubyApp.new
Gtk.main
</code></pre>


<p>这个代码例子我们创建了一个按钮和一个标签。点击按钮之后显示字体选择对话框。</p>


<pre><code>fdia = Gtk::FontSelectionDialog.new "Select font name"
</code></pre>


<p>创建<em>FontSelectionDialog</em>。</p>


<pre><code>if response == Gtk::Dialog::RESPONSE_OK
    font_desc = Pango::FontDescription.new fdia.font_name
    if font_desc
        @label.modify_font font_desc
    end
end
</code></pre>


<p>如果点击确定按钮，标签的字体会变为我们在对话框中选中的。<br>
<img alt="image6" src="http://zetcode.com/img/gui/rubygtk/fontdialog.png"><br>
<em>图片：FontSelectionDialog</em></p>


<h2>颜色选择对话框</h2>


<p>ColorSelectionDialog是用于选择颜色的对话框。</p>


<pre><code>#!/usr/bin/ruby

# ZetCode Ruby GTK tutorial
#
# This example works with the
# ColorSelectionDialog
#
# author: jan bodnar
# website: www.zetcode.com
# last modified: June 2009

require 'gtk2'


class RubyApp &lt; Gtk::Window

    def initialize
        super

        set_title "ColorSelectionDialog"
        signal_connect "destroy" do 
            Gtk.main_quit 
        end

        init_ui

        set_default_size 350, 150
        set_window_position Gtk::Window::POS_CENTER

        show_all
    end

    def init_ui

        set_border_width 10
        @label = Gtk::Label.new "The only victory over love is flight."
        button = Gtk::Button.new "Select color"

        button.signal_connect "clicked" do
            on_clicked
        end

        fix = Gtk::Fixed.new
        fix.put button, 100, 30
        fix.put @label, 30, 90
        add fix
    end

    def on_clicked
        cdia = Gtk::ColorSelectionDialog.new "Select color"
        response = cdia.run

        if response == Gtk::Dialog::RESPONSE_OK
            colorsel = cdia.colorsel
            color = colorsel.current_color
            @label.modify_fg Gtk::STATE_NORMAL, color
        end

        cdia.destroy
    end
end

Gtk.init
    window = RubyApp.new
Gtk.main
</code></pre>


<p>这个例子与前一个例子很相似。这次我们是改变标签的颜色。</p>


<pre><code>cdia = Gtk::ColorSelectionDialog.new "Select color"
</code></pre>


<p>创建ColorSelectionDialog。</p>


<pre><code>if response == Gtk::Dialog::RESPONSE_OK
    colorsel = cdia.colorsel
    color = colorsel.current_color
    @label.modify_fg Gtk::STATE_NORMAL, color
end
</code></pre>


<p>如果按下OK按钮，我们得到颜色值并修改标签的颜色。</p>


<p><img alt="image7" src="http://zetcode.com/img/gui/rubygtk/colordialog.png"><br>
<em>图片：ColorSelectionDialog</em></p>


<p>这部分的Ruby GTK教程我们展示了对话框。</p>


<hr>


<p>原文地址： <a href="http://zetcode.com/gui/rubygtk/dialogs/">http://zetcode.com/gui/rubygtk/dialogs/</a><br>
翻译：龙昌  admin@longchangjin.cn </p>

</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
    <h1 class="entry-title"><a href="http://www.xefan.com/archives/83963.html">[翻译]Ruby GTK教程4——菜单&工具条</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2013-11-23T00:00:00+08:00'><span class='date'><span class='date-month'>Nov</span> <span class='date-day'>23</span><span class='date-suffix'>rd</span>, <span class='date-year'>2013</span></span> <span class='time'>12:00 am</span></time>
        
           | <a href="http://www.xefan.com/archives/83963.html#disqus_thread"
             data-disqus-identifier="http://www.xefan.com/archives/83963.html">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><h1>菜单&amp;工具条</h1>


<p>这部分的Ruby GTK教程我们将使用菜单和工具条。</p>


<p>菜单栏是GUI应用中最常用的部分之一。它是位于各个菜单的一组命令。在命令行应用程序中我们需要记住这些所有神秘的命令，而现在我们将这些大部分的命令按照逻辑归合在一起。接受这些标准将进一步减少在学习新应用上花费的时间。</p>


<h2>简单的菜单</h2>


<p>我们的第一个例子将创建一个有文件菜单的菜单栏。这个菜单只有一个菜单项，选择这一项将退出应用。</p>


<pre><code>#!/usr/bin/ruby

# ZetCode Ruby GTK tutorial
#
# This example shows a simple menu
#
# author: jan bodnar
# website: www.zetcode.com
# last modified: June 2009

require 'gtk2'


class RubyApp &lt; Gtk::Window

    def initialize
        super

        set_title "Simple menu"
        signal_connect "destroy" do 
            Gtk.main_quit 
        end

        init_ui

        set_default_size 250, 200
        set_window_position Gtk::Window::POS_CENTER

        show_all
    end

    def init_ui

        modify_bg Gtk::STATE_NORMAL, Gdk::Color.new(6400, 6400, 6440)

        mb = Gtk::MenuBar.new

        filemenu = Gtk::Menu.new
        filem = Gtk::MenuItem.new "File"
        filem.set_submenu filemenu

        exit = Gtk::MenuItem.new "Exit"
        exit.signal_connect "activate" do
            Gtk.main_quit
        end

        filemenu.append exit

        mb.append filem

        vbox = Gtk::VBox.new false, 2
        vbox.pack_start mb, false, false, 0

        add vbox
    end
end

Gtk.init
    window = RubyApp.new
Gtk.main
</code></pre>


<p>这是一个最小功能的菜单栏的例子。</p>


<pre><code>mb = Gtk::MenuBar.new
</code></pre>


<p>创建<em>MenuBar</em>控件，这是菜单的容器。</p>


<pre><code>filemenu = Gtk::Menu.new
filem = Gtk::MenuItem.new "File"
filem.set_submenu filemenu
</code></pre>


<p>创建顶级菜单项。</p>


<pre><code>exit = Gtk::MenuItem.new "Exit"
exit.signal_connect "activate" do
    Gtk.main_quit
end

filemenu.append exit
</code></pre>


<p>创建退出菜单项并添加到文件菜单项中。</p>


<pre><code>mb.append filem
</code></pre>


<p>将顶级菜单项添加到菜单栏控件中。</p>


<pre><code>vbox = Gtk::VBox.new false, 2
vbox.pack_start mb, false, false, 0
</code></pre>


<p>与其他套件不同，我们必须要自己处理菜单栏的布局。我们将菜单栏放入竖直盒子中。</p>


<p><img alt="image1" src="http://zetcode.com/img/gui/rubygtk/simplemenu.png"> <br>
<em>图片：简单的菜单</em></p>


<h2>子菜单</h2>


<p>最后展示如何创建一个子菜单。</p>


<pre><code>#!/usr/bin/ruby

# ZetCode Ruby GTK tutorial
#
# This example shows a submenu
#
# author: jan bodnar
# website: www.zetcode.com
# last modified: June 2009

require 'gtk2'


class RubyApp &lt; Gtk::Window

    def initialize
        super

        set_title "Submenu"
        signal_connect "destroy" do 
            Gtk.main_quit 
        end

        init_ui

        set_default_size 250, 200
        set_window_position Gtk::Window::POS_CENTER

        show_all
    end

    def init_ui

        modify_bg Gtk::STATE_NORMAL, Gdk::Color.new(6400, 6400, 6440)

        mb = Gtk::MenuBar.new

        filemenu = Gtk::Menu.new
        filem = Gtk::MenuItem.new "File"
        filem.set_submenu filemenu

        mb.append filem

        imenu = Gtk::Menu.new

        importm = Gtk::MenuItem.new "Import"
        importm.set_submenu imenu

        inews = Gtk::MenuItem.new "Import news feed..."
        ibookmarks = Gtk::MenuItem.new "Import bookmarks..."
        imail = Gtk::MenuItem.new "Import mail..."

        imenu.append inews
        imenu.append ibookmarks
        imenu.append imail

        filemenu.append importm

        exit = Gtk::MenuItem.new "Exit"
        exit.signal_connect "activate" do
            Gtk.main_quit
        end

        filemenu.append exit

        vbox = Gtk::VBox.new false, 2
        vbox.pack_start mb, false, false, 0

        add vbox
    end
end

Gtk.init
    window = RubyApp.new
Gtk.main
</code></pre>


<p>创建子菜单。</p>


<pre><code>imenu = Gtk::Menu.new
</code></pre>


<p>子菜单也是Menu控件。</p>


<pre><code>importm = Gtk::MenuItem.new "Import"
importm.set_submenu imenu
</code></pre>


<p>这是属于文件顶级菜单的菜单项的子菜单。</p>


<pre><code>inews = Gtk::MenuItem.new "Import news feed..."
ibookmarks = Gtk::MenuItem.new "Import bookmarks..."
imail = Gtk::MenuItem.new "Import mail..."

imenu.append inews
imenu.append ibookmarks
imenu.append imail
</code></pre>


<p>子菜单有自己的菜单项。</p>


<p><img alt="image2" src="http://zetcode.com/img/gui/rubygtk/submenu.png"><br>
<em>图片：子菜单</em></p>


<h2>图片菜单</h2>


<p>接下来的例子我们将进一步探索菜单。我们将在菜单项上添加图片和快捷键（accelerators）。</p>


<pre><code>#!/usr/bin/ruby

# ZetCode Ruby GTK tutorial
#
# This example shows a menu with
# images, accelerators and a separator
#
# author: jan bodnar
# website: www.zetcode.com
# last modified: June 2009

require 'gtk2'


class RubyApp &lt; Gtk::Window

    def initialize
        super

        set_title "Image menu"
        signal_connect "destroy" do 
            Gtk.main_quit 
        end

        init_ui

        set_default_size 250, 200
        set_window_position Gtk::Window::POS_CENTER

        show_all
    end

    def init_ui

        modify_bg Gtk::STATE_NORMAL, Gdk::Color.new(6400, 6400, 6440)

        mb = Gtk::MenuBar.new

        filemenu = Gtk::Menu.new
        filem = Gtk::MenuItem.new "File"
        filem.set_submenu filemenu

        agr = Gtk::AccelGroup.new
        add_accel_group agr

        newi = Gtk::ImageMenuItem.new Gtk::Stock::NEW, agr
        key, mod = Gtk::Accelerator.parse "N"
        newi.add_accelerator("activate", agr, key, 
            mod, Gtk::ACCEL_VISIBLE)
        filemenu.append newi

        openm = Gtk::ImageMenuItem.new Gtk::Stock::OPEN, agr
        key, mod = Gtk::Accelerator.parse "O"
        openm.add_accelerator("activate", agr, key, 
            mod, Gtk::ACCEL_VISIBLE)
        filemenu.append openm

        sep = Gtk::SeparatorMenuItem.new
        filemenu.append sep

        exit = Gtk::ImageMenuItem.new Gtk::Stock::QUIT, agr
        key, mod = Gtk::Accelerator.parse "Q"
        exit.add_accelerator("activate", agr, key, 
            mod, Gtk::ACCEL_VISIBLE)

        exit.signal_connect "activate" do
            Gtk.main_quit
        end
        filemenu.append exit

        mb.append filem

        vbox = Gtk::VBox.new false, 2
        vbox.pack_start mb, false, false, 0

        add vbox
    end
end

Gtk.init
    window = RubyApp.new
Gtk.main
</code></pre>


<p>这个例子显示了一个有子菜单的顶级菜单，每个菜单项都有一个图像和一个快捷键。退出菜单的快捷键是激活的。</p>


<pre><code>agr = Gtk::AccelGroup.new
add_accel_group agr
</code></pre>


<p>为了使用快捷键，我们创建了一个全局的<em>AccelGroup</em>对象。它稍后被用到。</p>


<pre><code>newi = Gtk::ImageMenuItem.new Gtk::Stock::NEW, agr
key, mod = Gtk::Accelerator.parse "N"
newi.add_accelerator("activate", agr, key, 
    mod, Gtk::ACCEL_VISIBLE)
filemenu.append newi
</code></pre>


<p>创建图片菜单项。图片来自图片库中。我们也创建了<em>Ctrl+N</em>快捷键。</p>


<pre><code>sep = Gtk::SeparatorMenuItem.new
filemenu.append sep
</code></pre>


<p>这行创建一条分隔线。它用于将菜单项按照逻辑分组。</p>


<p><img alt="image3" src="http://zetcode.com/img/gui/rubygtk/imagemenu.png"><br>
<em>图片：图片菜单</em></p>


<p>菜单将我们使用的命令进行分组。工具条提供了一个快速访问最常用命令的方式。</p>


<h2>简单的工具条</h2>


<p>接下来我们创建一个简单的工具条。</p>


<pre><code>#!/usr/bin/ruby

# ZetCode Ruby GTK tutorial
#
# This example shows a toolbar
# widget
#
# author: jan bodnar
# website: www.zetcode.com
# last modified: June 2009

require 'gtk2'


class RubyApp &lt; Gtk::Window

    def initialize
        super

        set_title "Toolbar"
        signal_connect "destroy" do 
            Gtk.main_quit 
        end

        init_ui

        set_default_size 250, 200
        set_window_position Gtk::Window::POS_CENTER

        show_all
    end

    def init_ui

        toolbar = Gtk::Toolbar.new
        toolbar.set_toolbar_style Gtk::Toolbar::Style::ICONS

        newtb = Gtk::ToolButton.new Gtk::Stock::NEW
        opentb = Gtk::ToolButton.new Gtk::Stock::OPEN
        savetb = Gtk::ToolButton.new Gtk::Stock::SAVE
        sep = Gtk::SeparatorToolItem.new
        quittb = Gtk::ToolButton.new Gtk::Stock::QUIT

        toolbar.insert 0, newtb
        toolbar.insert 1, opentb
        toolbar.insert 2, savetb
        toolbar.insert 3, sep
        toolbar.insert 4, quittb

        quittb.signal_connect "clicked" do
            Gtk.main_quit
        end

        vbox = Gtk::VBox.new false, 2
        vbox.pack_start toolbar, false, false, 0

        add(vbox)
    end
end

Gtk.init
    window = RubyApp.new
Gtk.main
</code></pre>


<p>这个例子显示了有四个工具按钮的工具栏。</p>


<pre><code>toolbar = Gtk::Toolbar.new
</code></pre>


<p>创建<em>Toolbar</em>控件。</p>


<pre><code>toolbar.set_toolbar_style Gtk::Toolbar::Style::ICONS
</code></pre>


<p>工具栏上我们只显示图标，没有文字。</p>


<pre><code>newtb = Gtk::ToolButton.new Gtk::Stock::NEW
</code></pre>


<p>创建了一个包含图片的ToolButton控件。图片来自内建的图片库。</p>


<pre><code>sep = Gtk::SeparatorToolItem.new
</code></pre>


<p>这是一个分隔符，用于将按钮按照逻辑分组。</p>


<pre><code>toolbar.insert 0, newtb
toolbar.insert 1, opentb
...
</code></pre>


<p>将按钮添加到工具栏。</p>


<p><img alt="image4" src="http://zetcode.com/img/gui/rubygtk/toolbar.png"><br>
<em>图片：工具栏</em></p>


<h2>撤消重做</h2>


<p>接下来的例子展示了如何停用工具栏上的按钮。这是GUI编程中的常见练习。例如对于保存按钮，在大多数编辑器中如果我们将文档的修改保存到磁盘中了，那么保存按钮会被停用。这是应用程序给用户的提示，所有修改都已保存。</p>


<pre><code>#!/usr/bin/ruby

# ZetCode Ruby GTK tutorial
#
# This example shows how to 
# activate/deactivate a ToolButton
#
# author: jan bodnar
# website: www.zetcode.com
# last modified: June 2009

require 'gtk2'


class RubyApp &lt; Gtk::Window


    def initialize
        super

        set_title "Undo redo"
        signal_connect "destroy" do 
            Gtk.main_quit 
        end

        @count = 2

        init_ui

        set_default_size 250, 200
        set_window_position Gtk::Window::POS_CENTER

        show_all
    end

    def init_ui

        toolbar = Gtk::Toolbar.new
        toolbar.set_toolbar_style Gtk::Toolbar::Style::ICONS

        @undo = Gtk::ToolButton.new Gtk::Stock::UNDO
        @redo = Gtk::ToolButton.new Gtk::Stock::REDO
        sep = Gtk::SeparatorToolItem.new
        quit = Gtk::ToolButton.new Gtk::Stock::QUIT

        toolbar.insert 0, @undo
        toolbar.insert 1, @redo
        toolbar.insert 2, sep
        toolbar.insert 3, quit

        @undo.signal_connect "clicked" do
            on_undo
        end

        @redo.signal_connect "clicked" do
            on_redo
        end

        quit.signal_connect "clicked" do
            Gtk.main_quit
        end

        vbox = Gtk::VBox.new false, 2
        vbox.pack_start toolbar, false, false, 0

        self.add vbox

    end

    def on_undo

        @count = @count - 1

        if @count &lt;= 0
            @undo.set_sensitive false
            @redo.set_sensitive true
        end
    end


    def on_redo
        @count = @count + 1

        if @count &gt;= 5
            @redo.set_sensitive false
            @undo.set_sensitive true
        end
    end
end

Gtk.init
    window = RubyApp.new
Gtk.main
</code></pre>


<p>我们例子从GTK资源中创建了撤消和重做按钮。每个按钮点击多次后会被禁用，变为灰色。</p>


<pre><code>@count = 2
</code></pre>


<p><em>@count</em>变量用于描述按钮是禁用还是激活。</p>


<pre><code>@undo = Gtk::ToolButton.new Gtk::Stock::UNDO
@redo = Gtk::ToolButton.new Gtk::Stock::REDO
</code></pre>


<p>创建两个工具按钮，图片来自资源库。</p>


<pre><code>@undo.signal_connect "clicked" do
    on_undo
end
</code></pre>


<p>点击undo按钮触发<em>on_undo</em>方法。</p>


<pre><code>if @count &lt;= 0
    @undo.set_sensitive false
    @redo.set_sensitive true
end
</code></pre>


<p>我们使用<em>set_sensitive</em>方法激活或者禁用控件。</p>


<p><img alt="image5" src="http://zetcode.com/img/gui/rubygtk/undoredo.png"><br>
<em>图片：撤消重做</em></p>


<p>这章的Ruby GTK教程我们展示了如何使用菜单和工具栏。</p>


<hr>


<p>原文地址： <a href="http://zetcode.com/gui/rubygtk/menustoolbars/">http://zetcode.com/gui/rubygtk/menustoolbars/</a><br>
翻译：龙昌  admin@longchangjin.cn  </p>

</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
    <h1 class="entry-title"><a href="http://www.xefan.com/archives/83960.html">[翻译]Ruby GTK教程3——控件</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2013-11-23T00:00:00+08:00'><span class='date'><span class='date-month'>Nov</span> <span class='date-day'>23</span><span class='date-suffix'>rd</span>, <span class='date-year'>2013</span></span> <span class='time'>12:00 am</span></time>
        
           | <a href="http://www.xefan.com/archives/83960.html#disqus_thread"
             data-disqus-identifier="http://www.xefan.com/archives/83960.html">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><h1>控件</h1>


<p>在这部分的Ruby GTK编程教程中我们将提到一些控件。</p>


<p>控件是GUI应用程序的基本构成。这些年来一些控件成为了所有平台所有套件的标准。如按钮、复选框或者滚动条。GTK套件的理念是保持控件的数量为最小的数量级，一些特殊的控件需要创建为自定义GTK控件。</p>


<h2>复选按钮（CheckButton）</h2>


<p><em>CheckButton</em>是一个有两种状态的控件，开和关。开状态表示选中。它用于表示一些布尔属性。</p>


<pre><code>#!/usr/bin/ruby

# ZetCode Ruby GTK tutorial
#
# This program toggles the title of the
# window with the CheckButton widget
#
# author: jan bodnar
# website: www.zetcode.com
# last modified: April 2009

require 'gtk2'

class RubyApp &lt; Gtk::Window
    def initialize
        super

        set_title "CheckButton"
        signal_connect "destroy" do 
            Gtk.main_quit 
        end

        init_ui

        set_default_size 250, 200
        set_window_position Gtk::Window::POS_CENTER
        show_all
    end


    def init_ui

        fixed = Gtk::Fixed.new
        add fixed

        cb = Gtk::CheckButton.new "Show title"
        cb.set_active true
        cb.set_can_focus false
        cb.signal_connect("clicked") do |w|
            on_clicked(w)
        end

        fixed.put cb, 50, 50

    end

    def on_clicked sender

        if sender.active?
            self.set_title "Check Button"
        else
           self.set_title ""
        end
    end
end

Gtk.init
    window = RubyApp.new
Gtk.main
</code></pre>


<p>我们将根据复选按钮的状态在窗口的标题栏显示一个标题。</p>


<pre><code>cb = Gtk::CheckButton.new "Show title"
</code></pre>


<p>创建<em>CheckButton</em>控件。</p>


<pre><code>cb.set_active true
</code></pre>


<p>标题默认是可见的，因此我们将按钮默认选中。</p>


<pre><code>if sender.active?
    self.set_title "Check Button"
else
    self.set_title ""
end
</code></pre>


<p>如果按钮选中则显示标题。</p>


<p><img alt="image1" src="http://zetcode.com/img/gui/rubygtk/checkbutton.png"><br>
<em>图片：复选按钮</em></p>


<h2>标签（Label）</h2>


<p>Label控件用于显示文本。</p>


<pre><code>#!/usr/bin/ruby

# ZetCode Ruby GTK tutorial
#
# This example demonstrates the Label widget
#
# author: jan bodnar
# website: www.zetcode.com
# last modified: June 2009

require 'gtk2'

$lyrics = %{Meet you downstairs in the bar and heard
your rolled up sleeves and your skull t-shirt
You say why did you do it with him today?
and sniff me out like I was Tanqueray

cause you're my fella, my guy
hand me your stella and fly
by the time I'm out the door
you tear men down like Roger Moore

I cheated myself
like I knew I would
I told ya, I was trouble
you know that I'm no good}


class RubyApp &lt; Gtk::Window

    def initialize
        super

        set_title  "You know I'm no Good"
        signal_connect "destroy" do 
            Gtk.main_quit 
        end

        init_ui

        set_default_size 250, 200
        set_window_position Gtk::Window::POS_CENTER

        show_all
    end

    def init_ui

        set_border_width 10
        label = Gtk::Label.new $lyrics
        add label

    end
end

Gtk.init
    window = RubyApp.new
Gtk.main
</code></pre>


<p>例子在窗口上显示了一些歌词。</p>


<pre><code> $lyrics = %{Meet you downstairs in the bar and heard
 your rolled up sleeves and your skull t-shirt
 ...
</code></pre>


<p>创建一个多行文本。</p>


<pre><code>set_border_width 10
</code></pre>


<p>标签被一些空白空间包围着。</p>


<pre><code>label = Gtk::Label.new $lyrics
add label
</code></pre>


<p>创建标签并添加到窗口内。</p>


<p><img alt="image2" src="http://zetcode.com/img/gui/rubygtk/label.png"><br>
<em>图片：标签控件</em></p>


<h2>输入框（Entry）</h2>


<p>Entry是单行文本输入字段，用于文本数据的输入。</p>


<pre><code>#!/usr/bin/ruby

# ZetCode Ruby GTK tutorial
#
# This example demonstrates the Entry widget
#
# author: jan bodnar
# website: www.zetcode.com
# last modified: June 2009

require 'gtk2'


class RubyApp &lt; Gtk::Window

    def initialize
        super

        set_title "Entry"
        signal_connect "destroy" do 
            Gtk.main_quit 
        end

        init_ui

        set_default_size 250, 200
        set_window_position Gtk::Window::POS_CENTER

        show_all
    end

    def init_ui

        fixed = Gtk::Fixed.new

        label = Gtk::Label.new "..."
        fixed.put label, 60, 40

        entry = Gtk::Entry.new
        fixed.put entry, 60, 100

        entry.signal_connect "key-release-event" do |w, e|
            on_key_release(w, e, label)
        end

        add(fixed)
    end

    def on_key_release sender, event, label
        label.set_text sender.text
    end
end

Gtk.init
    window = RubyApp.new
Gtk.main
</code></pre>


<p>这个例子显示了一个输入控件和一个标签。我们在输入框输入的文本会立即在标签上显示。</p>


<pre><code>entry = Gtk::Entry.new
</code></pre>


<p>创建Entry控件。</p>


<pre><code>entry.signal_connect "key-release-event" do |w, e|
    on_key_release(w, e, label)
end
</code></pre>


<p>我们将<em>on_key_release</em>方法插到Entry控件的<em>key-release-event</em>事件中。</p>


<pre><code>def on_key_release sender, event, label
    label.set_text sender.text
end
</code></pre>


<p>从Entry控件获取文本并设置到标签中。</p>


<p><img alt="image3" src="http://zetcode.com/img/gui/rubygtk/entry.png"><br>
<em>图片：Entry控件</em></p>


<h2>图片（Image）</h2>


<p>Image控件用于显示图片。</p>


<pre><code>#!/usr/bin/ruby

# ZetCode Ruby GTK tutorial
#
# This example demonstrates the Image widget
#
# author: jan bodnar
# website: www.zetcode.com
# last modified: June 2009

require 'gtk2'


class RubyApp &lt; Gtk::Window

    def initialize
        super

        set_title "Red Rock"
        signal_connect "destroy" do 
            Gtk.main_quit 
        end

        init_ui

        set_default_size 250, 200
        set_window_position Gtk::Window::POS_CENTER

        show_all
    end

    def init_ui

        set_border_width 2

        begin
            image = Gtk::Image.new "redrock.png"
        rescue
            puts "cannot load image"
            exit
        end

        add image
    end

end

Gtk.init
    window = RubyApp.new
Gtk.main
</code></pre>


<p>我们例子在窗口上显示了一个图片。</p>


<pre><code>set_border_width 2
</code></pre>


<p>我们在图片周围添加一些空白边框。</p>


<pre><code>begin
    image = Gtk::Image.new "redrock.png"
rescue
    puts "cannot load image"
    exit
end
</code></pre>


<p>创建Image控件。IO操作容易出现错误，因此我们处理可能的异常。</p>


<pre><code>add image
</code></pre>


<p>将控件添加到容器中。</p>


<p><img alt="image4" src="http://zetcode.com/img/gui/rubygtk/image.jpg"><br>
<em>图片：Image控件</em></p>


<h2>下拉框（ComboBox）</h2>


<p>ComboBox控件允许用户从一个列表选项中进行选择。</p>


<pre><code>#!/usr/bin/ruby

# ZetCode Ruby GTK tutorial
#
# This example demonstrates the ComboBox widget
#
# author: jan bodnar
# website: www.zetcode.com
# last modified: June 2009

require 'gtk2'


class RubyApp &lt; Gtk::Window

    def initialize
        super

        set_title "ComboBox"
        signal_connect "destroy" do 
            Gtk.main_quit 
        end

        init_ui

        set_default_size 250, 200
        set_window_position Gtk::Window::POS_CENTER

        show_all
    end

    def init_ui

        fixed = Gtk::Fixed.new
        label = Gtk::Label.new '-'
        fixed.put label, 50, 140

        cb = Gtk::ComboBox.new
        cb.signal_connect "changed" do |w, e|
            on_changed(w, e, label)
        end

        cb.append_text 'Ubuntu'
        cb.append_text 'Mandriva'
        cb.append_text 'Redhat'
        cb.append_text 'Gento'
        cb.append_text 'Mint'

        fixed.put cb, 50, 30

        add fixed

    end

    def on_changed sender, event, label
        label.set_label sender.active_text
    end
end

Gtk.init
    window = RubyApp.new
Gtk.main
</code></pre>


<p>这个例子显示了一个下拉框和一个标签。下拉框列表有5个选项。它们是Linux发行版的名称。标签控件显示下拉列表选中的选项。</p>


<pre><code>cb = Gtk::ComboBox.new
</code></pre>


<p>创建下拉框。</p>


<pre><code>cb.append_text 'Ubuntu'
cb.append_text 'Mandriva'
cb.append_text 'Redhat'
cb.append_text 'Gento'
cb.append_text 'Mint'
</code></pre>


<p>填充数据。</p>


<pre><code>def on_changed sender, event, label
    label.set_label sender.active_text
end
</code></pre>


<p>在<em>on_changed</em>方法里，我们获取选中的文本并设置到标签中。</p>


<p><img alt="image5" src="http://zetcode.com/img/gui/rubygtk/combobox.png"><br>
<em>图片：下拉框</em></p>


<p>在这章的Ruby GTK教程中我们显示了一些基本的控件。</p>


<hr>


<p>原文地址： <a href="http://zetcode.com/gui/rubygtk/widgets/">http://zetcode.com/gui/rubygtk/widgets/</a><br>
翻译：龙昌  admin@longchangjin.cn  </p>

</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
    <h1 class="entry-title"><a href="http://www.xefan.com/archives/83957.html">[翻译]Ruby GTK教程2——布局管理</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2013-11-21T00:00:00+08:00'><span class='date'><span class='date-month'>Nov</span> <span class='date-day'>21</span><span class='date-suffix'>st</span>, <span class='date-year'>2013</span></span> <span class='time'>12:00 am</span></time>
        
           | <a href="http://www.xefan.com/archives/83957.html#disqus_thread"
             data-disqus-identifier="http://www.xefan.com/archives/83957.html">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><h1>布局管理</h1>


<p>这一章我们将展示如何布置窗口或者对话框中的控件。</p>


<p>当我设计应用程序的用户界面时，我们决定了将要使用哪些控件以及如何在应用程序中组织这些控件。为了组织我们的控件，我们使用了一些称为布局容器的特殊不可见控件。这一章我们将提到<em>Alignment</em>、<em>Fixed</em>、<em>VBox</em>和<em>Table</em>。</p>


<h2>Fixed</h2>


<p>Fixed窗口是将子控件放置在固定位置固定大小。这个容器不会执行自动布局管理。在大部分的应用程序中我们不使用这个容器。它用于一些特殊的地方，例如游戏、使用图表的特殊应用、可移动可变大小的组件（如电子表格中的图表）。以下是一些小例子。</p>


<pre><code>#!/usr/bin/ruby

# ZetCode Ruby GTK tutorial
#
# In this program, we lay out widgets
# using absolute positioning
#
# author: jan bodnar
# website: www.zetcode.com
# last modified: June 2009

require 'gtk2'


class RubyApp &lt; Gtk::Window

    def initialize
        super

        set_title "Fixed"
        signal_connect "destroy" do 
            Gtk.main_quit 
        end

        init_ui

        set_default_size 300, 280
        set_window_position Gtk::Window::POS_CENTER

        show_all
    end

    def init_ui

        modify_bg Gtk::STATE_NORMAL, Gdk::Color.new(6400, 6400, 6440)

        begin       
            bardejov = Gdk::Pixbuf.new "bardejov.jpg"
            rotunda = Gdk::Pixbuf.new "rotunda.jpg"
            mincol = Gdk::Pixbuf.new "mincol.jpg"
        rescue IOError =&gt; e
            puts e
            puts "cannot load images"
            exit
        end

        image1 = Gtk::Image.new bardejov
        image2 = Gtk::Image.new rotunda
        image3 = Gtk::Image.new mincol

        fixed = Gtk::Fixed.new

        fixed.put image1, 20, 20
        fixed.put image2, 40, 160
        fixed.put image3, 170, 50

        add fixed

    end
end

Gtk.init
    window = RubyApp.new
Gtk.main
</code></pre>


<p>在我们在例子中我们在窗口上显示了三张图片。我们明确的指定了这些图片的x、y坐标的位置。</p>


<pre><code>modify_bg Gtk::STATE_NORMAL, Gdk::Color.new(6400, 6400, 6440)
</code></pre>


<p>为了更好的显示体验，我们修改背景颜色为灰色。</p>


<pre><code>bardejov = Gdk::Pixbuf.new "bardejov.jpg"
</code></pre>


<p>从磁盘上加载图片为Pixbug对象。</p>


<pre><code>image1 = Gtk::Image.new bardejov
image2 = Gtk::Image.new rotunda
image3 = Gtk::Image.new mincol
</code></pre>


<p><em>Image</em>是用于显示图片的控件。在它的构造函数接收一个<em>Pixbuf</em>对象。</p>


<pre><code>fixed = Gtk::Fixed.new
</code></pre>


<p>创建一个Fixed容器。</p>


<pre><code>fixed.put image1, 20, 20
</code></pre>


<p>将第一张图片放在x=20，y=20的坐标位置上。</p>


<pre><code> add fixed
</code></pre>


<p>最后我们将Fixed窗口放入窗口中。</p>


<p><img alt="image1" src="http://zetcode.com/img/gui/rubygtk/fixed.png"><br>
<em>图片：Fixed</em></p>


<h2>按钮</h2>


<p>Alignment容器用于控件它的子控件的对齐和大小。</p>


<pre><code>#!/usr/bin/ruby

# ZetCode Ruby GTK tutorial
#
# In this program, we position two buttons
# in the bottom right corner of the window.
# We use horizontal and vertical boxes.
#
# author: jan bodnar
# website: www.zetcode.com
# last modified: June 2009

require 'gtk2'


class RubyApp &lt; Gtk::Window

    def initialize
        super

        set_title "Buttons"
        signal_connect "destroy" do 
            Gtk.main_quit 
        end

        init_ui

        set_default_size 260, 150
        set_window_position Gtk::Window::POS_CENTER

        show_all
    end

    def init_ui

        vbox = Gtk::VBox.new false, 5
        hbox = Gtk::HBox.new true, 3

        valign = Gtk::Alignment.new 0, 1, 0, 0
        vbox.pack_start valign

        ok = Gtk::Button.new "OK"
        ok.set_size_request 70, 30
        close = Gtk::Button.new "Close"

        hbox.add ok
        hbox.add close

        halign = Gtk::Alignment.new 1, 0, 0, 0
        halign.add hbox

        vbox.pack_start halign, false, false, 3

        add vbox
    end
end

Gtk.init
    window = RubyApp.new
Gtk.main
</code></pre>


<p>这个例子的代码中，我们将两个按钮放置在窗口的右下角。为了实现这个功能我们使用了两个垂直盒子和一个水平盒子和两个对齐容器。</p>


<pre><code>valign = Gtk::Alignment.new 0, 1, 0, 0
</code></pre>


<p>这会将子控件放置在底部。</p>


<pre><code>vbox.pack_start valign
</code></pre>


<p>这里我们将Alignment控件放置在竖直例子中。</p>


<pre><code>hbox = Gtk::HBox.new true, 3 
...
ok = Gtk::Button.new "OK"
ok.set_size_request 70, 30
close = Gtk::Button.new "Close"

hbox.add ok
hbox.add close
</code></pre>


<p>创建一个水平盒子并放入两个按钮。</p>


<pre><code>halign = Gtk::Alignment.new 1, 0, 0, 0
halign.add hbox

vbox.pack_start halign, false, false, 3
</code></pre>


<p>这将会创建一个对齐容器用于将其子控件放置在右边。我们将水平盒子放入对齐容器里并将对齐容器放入竖直盒子中。我们必须记住对齐容器只有一个子控件，这就是为什么我们要使用盒子容器。 <br>
<img alt="image2" src="http://zetcode.com/img/gui/rubygtk/buttons.png"><br>
<em>图片：按钮</em></p>


<h2>计算器框架</h2>


<p>Table控件将控件按行和列进行排序。</p>


<pre><code>#!/usr/bin/ruby

# ZetCode Ruby GTK tutorial
#
# In this program we create a skeleton of
# a calculator. We use the Table widget. 
#
# author: jan bodnar
# website: www.zetcode.com
# last modified: June 2009

require 'gtk2'


class RubyApp &lt; Gtk::Window

    def initialize
        super

        set_title "Calculator"
        signal_connect "destroy" do 
            Gtk.main_quit 
        end

        init_ui

        set_default_size 300, 250
        set_window_position Gtk::Window::POS_CENTER

        show_all
    end

    def init_ui

        vbox = Gtk::VBox.new false, 2

        mb = Gtk::MenuBar.new
        filemenu = Gtk::Menu.new
        file = Gtk::MenuItem.new "File"
        file.set_submenu filemenu
        mb.append file

        vbox.pack_start mb, false, false, 0

        table = Gtk::Table.new 5, 4, true

        table.attach Gtk::Button.new("Cls"), 0, 1, 0, 1
        table.attach Gtk::Button.new("Bck"), 1, 2, 0, 1
        table.attach Gtk::Label.new, 2, 3, 0, 1
        table.attach Gtk::Button.new("Close"), 3, 4, 0, 1

        table.attach Gtk::Button.new("7"), 0, 1, 1, 2
        table.attach Gtk::Button.new("8"), 1, 2, 1, 2
        table.attach Gtk::Button.new("9"), 2, 3, 1, 2
        table.attach Gtk::Button.new("/"), 3, 4, 1, 2

        table.attach Gtk::Button.new("4"), 0, 1, 2, 3
        table.attach Gtk::Button.new("5"), 1, 2, 2, 3
        table.attach Gtk::Button.new("6"), 2, 3, 2, 3
        table.attach Gtk::Button.new("*"), 3, 4, 2, 3

        table.attach Gtk::Button.new("1"), 0, 1, 3, 4
        table.attach Gtk::Button.new("2"), 1, 2, 3, 4
        table.attach Gtk::Button.new("3"), 2, 3, 3, 4
        table.attach Gtk::Button.new("-"), 3, 4, 3, 4

        table.attach Gtk::Button.new("0"), 0, 1, 4, 5
        table.attach Gtk::Button.new("."), 1, 2, 4, 5
        table.attach Gtk::Button.new("="), 2, 3, 4, 5
        table.attach Gtk::Button.new("+"), 3, 4, 4, 5

        vbox.pack_start Gtk::Entry.new, false, false, 0

        vbox.pack_end table, true, true, 0

        add vbox

    end
end

Gtk.init
    window = RubyApp.new
Gtk.main
</code></pre>


<p>我们使用Table控件来创建计算器的框架。</p>


<pre><code>table = Gtk::Table.new 5, 4, true
</code></pre>


<p>我们创建了一个有5行4列的表格控件。第三个参数是homogenous参数。如果设置为true那么表格中的所有控件都是一样大小的。控件的大小等于表格容器中最大的那个控件。</p>


<pre><code>table.attach Gtk::Button.new("Cls"), 0, 1, 0, 1
</code></pre>


<p>我们将一个按钮附加到表格容器的左上角。前两个参数是单元格的左右边界，后两个参数是单元格的上下边界。</p>


<pre><code>vbox.pack_end table, true, true, 0
</code></pre>


<p>将表格控件打包放入竖直盒子里。<br>
<img alt="image3" src="http://zetcode.com/img/gui/rubygtk/calculator.png">  <br>
<em>图片：计算器框架</em></p>


<h2>窗口</h2>


<p>接下来我们创建一个更高级的例子。我们展示一个JDeveloper IDE中的窗口。</p>


<pre><code>#!/usr/bin/ruby

# ZetCode Ruby GTK tutorial
#
# This is a more complicated layout example.
# We use Alignment and Table widgets. 
#
# author: jan bodnar
# website: www.zetcode.com
# last modified: June 2009

require 'gtk2'


class RubyApp &lt; Gtk::Window

    def initialize
        super

        set_title "Windows"
        signal_connect "destroy" do 
            Gtk.main_quit 
        end

        init_ui

        set_default_size 300, 250
        set_window_position Gtk::Window::POS_CENTER

        show_all
    end

    def init_ui

        set_border_width 15

        table = Gtk::Table.new 8, 4, false
        table.set_column_spacings 3

        title = Gtk::Label.new "Windows"

        halign = Gtk::Alignment.new 0, 0, 0, 0
        halign.add title

        table.attach(halign, 0, 1, 0, 1, Gtk::FILL,
            Gtk::FILL, 0, 0)

        frame = Gtk::Frame.new
        table.attach(frame, 0, 2, 1, 3, Gtk::FILL | Gtk::EXPAND,
            Gtk::FILL | Gtk::EXPAND, 1, 1)

        activate = Gtk::Button.new "Activate"
        activate.set_size_request 50, 30
        table.attach(activate, 3, 4, 1, 2, Gtk::FILL,
            Gtk::SHRINK, 1, 1)

        valign = Gtk::Alignment.new 0, 0, 0, 0
        close = Gtk::Button.new "Close"
        close.set_size_request 70, 30
        valign.add close
        table.set_row_spacing 1, 3
        table.attach(valign, 3, 4, 2, 3, Gtk::FILL,
            Gtk::FILL | Gtk::EXPAND, 1, 1)

        halign2 = Gtk::Alignment.new 0, 1, 0, 0
        help = Gtk::Button.new "Help"
        help.set_size_request 70, 30
        halign2.add help
        table.set_row_spacing 3, 6
        table.attach(halign2, 0, 1, 4, 5, Gtk::FILL,
            Gtk::FILL, 0, 0)

        ok = Gtk::Button.new "OK"
        ok.set_size_request 70, 30
        table.attach(ok, 3, 4, 4, 5, Gtk::FILL,
            Gtk::FILL, 0, 0)

        add table
    end
end

Gtk.init
    window = RubyApp.new
Gtk.main
</code></pre>


<p>这个例子展示了我们如何可以使用Ruby GTK创建一个类似的窗口。</p>


<pre><code>table = Gtk::Table.new 8, 4, false
table.set_column_spacings 3
</code></pre>


<p>这个例子是基于Table容器的。每个列之间有3像素的空隙。</p>


<pre><code>title = Gtk::Label.new "Windows"

halign = Gtk::Alignment.new 0, 0, 0, 0
halign.add title

table.attach(halign, 0, 1, 0, 1, Gtk::FILL,
    Gtk::FILL, 0, 0)
</code></pre>


<p>这个代码创建了一个左对齐的标签。这个标签放置在表格的第一行中。</p>


<pre><code>frame = Gtk::Frame.new
table.attach(frame, 0, 2, 1, 3, Gtk::FILL | Gtk::EXPAND,
    Gtk::FILL | Gtk::EXPAND, 1, 1)
</code></pre>


<p><em>frame</em>控件跨度为2行2列。</p>


<pre><code>valign = Gtk::Alignment.new 0, 0, 0, 0
close = Gtk::Button.new "Close"
close.set_size_request 70, 30
valign.add close
table.set_row_spacing 1, 3
table.attach(valign, 3, 4, 2, 3, Gtk::FILL,
    Gtk::FILL | Gtk::EXPAND, 1, 1)
</code></pre>


<p>我们将关闭按钮放置在<em>frame</em>控件的下一个位置，在表格的第4列（我们是从0算起）。我们将按钮放在对齐控件内，这样我们就可以顶对齐了。</p>


<p><img alt="image4" src="http://zetcode.com/img/gui/rubygtk/windows.png"><br>
<em>图片：窗口</em></p>


<p>这部分的Ruby GTK教程，我们提到了布局控件。</p>


<hr>


<p>原文地址： <a href="http://zetcode.com/gui/rubygtk/layoutmanagement/">http://zetcode.com/gui/rubygtk/layoutmanagement/</a><br>
翻译：龙昌  admin@longchangjin.cn  </p>

</div>
  
  


    </article>
  
  <div class="pagination">
    
      <a class="prev" href="/page/7">&larr; Older</a>
    
    <a href="/blog/archives">Blog Archives</a>
    
    <a class="next" href="/page/5">Newer &rarr;</a>
    
  </div>
</div>
<aside class="sidebar">
  
    <section>
  <h1>Subscription</h1>
  <!--以下是QQ邮件列表订阅嵌入代码--><script >var nId = "e7ee5da6d322dc7157c25cfd8a7700bb23a056dd1fb18cb4",nWidth="auto",sColor="light",sText="请输入邮件地址：" ;</script><script src="http://list.qq.com/zh_CN/htmledition/js/qf/page/qfcode.js" charset="gb18030"></script>
</section>
<section>
  <h1>Recent Posts</h1>
  <ul id="recent_posts">
    
      <li class="post">
        <a href="http://www.xefan.com/archives/84141.html">Vagrant使用笔记</a>
      </li>
    
      <li class="post">
        <a href="http://www.xefan.com/archives/84140.html">Redis集群配置实例</a>
      </li>
    
      <li class="post">
        <a href="http://www.xefan.com/archives/84139.html">Mongodb分片配置实例</a>
      </li>
    
      <li class="post">
        <a href="http://www.xefan.com/archives/84138.html">使用gunicorn部署Django</a>
      </li>
    
      <li class="post">
        <a href="http://www.xefan.com/archives/84137.html">Mongodb集群配置实例</a>
      </li>
    
  </ul>
</section>
<section>
  <h1>Categories</h1>
    <ul id="category-list"><li><a href='/categories/linux栏目/index.html'>linux栏目 (48)</a></li><li><a href='/categories/python栏目/index.html'>python栏目 (34)</a></li><li><a href='/categories/ruby栏目/index.html'>ruby栏目 (26)</a></li><li><a href='/categories/web开发/index.html'>web开发 (18)</a></li><li><a href='/categories/嵌入式栏目/index.html'>嵌入式栏目 (11)</a></li><li><a href='/categories/开源软件/index.html'>开源软件 (20)</a></li><li><a href='/categories/教程/index.html'>教程 (15)</a></li><li><a href='/categories/数据库/index.html'>数据库 (10)</a></li><li><a href='/categories/数据结构和算法/index.html'>数据结构和算法 (16)</a></li><li><a href='/categories/编程开发/index.html'>编程开发 (38)</a></li><li><a href='/categories/网络日志/index.html'>网络日志 (11)</a></li><li><a href='/categories/资源分享/index.html'>资源分享 (23)</a></li></ul>
</section>
<section>
  <h1>Tag Cloud</h1>
    <span id="tag-cloud"><a href='/tags/access/index.html' style='font-size: 105.3731343283582%'>access(6)</a> <a href='/tags/adobe/index.html' style='font-size: 100.8955223880597%'>adobe(1)</a> <a href='/tags/ajax/index.html' style='font-size: 101.7910447761194%'>ajax(2)</a> <a href='/tags/apache/index.html' style='font-size: 100.8955223880597%'>apache(1)</a> <a href='/tags/arch/index.html' style='font-size: 106.26865671641791%'>Arch(7)</a> <a href='/tags/arm/index.html' style='font-size: 107.16417910447761%'>ARM(8)</a> <a href='/tags/asp/index.html' style='font-size: 106.26865671641791%'>asp(7)</a> <a href='/tags/c/index.html' style='font-size: 111.64179104477611%'>C(13)</a> <a href='/tags/css/index.html' style='font-size: 101.7910447761194%'>css(2)</a> <a href='/tags/django/index.html' style='font-size: 102.68656716417911%'>Django(3)</a> <a href='/tags/dreamweaver/index.html' style='font-size: 100.8955223880597%'>Dreamweaver(1)</a> <a href='/tags/fedora/index.html' style='font-size: 101.7910447761194%'>Fedora(2)</a> <a href='/tags/firefox/index.html' style='font-size: 102.68656716417911%'>firefox(3)</a> <a href='/tags/flash/index.html' style='font-size: 100.8955223880597%'>Flash(1)</a> <a href='/tags/ftp/index.html' style='font-size: 100.8955223880597%'>ftp(1)</a> <a href='/tags/gcc/index.html' style='font-size: 105.3731343283582%'>gcc(6)</a> <a href='/tags/gentoo/index.html' style='font-size: 101.7910447761194%'>Gentoo(2)</a> <a href='/tags/git/index.html' style='font-size: 103.58208955223881%'>git(4)</a> <a href='/tags/gobject/index.html' style='font-size: 105.3731343283582%'>GObject(6)</a> <a href='/tags/grub/index.html' style='font-size: 100.8955223880597%'>grub(1)</a> <a href='/tags/gtk/index.html' style='font-size: 115.22388059701493%'>gtk(17)</a> <a href='/tags/hash/index.html' style='font-size: 100.8955223880597%'>Hash(1)</a> <a href='/tags/ibus/index.html' style='font-size: 100.8955223880597%'>ibus(1)</a> <a href='/tags/js/index.html' style='font-size: 100.8955223880597%'>js(1)</a> <a href='/tags/linux/index.html' style='font-size: 160.0%'>Linux(67)</a> <a href='/tags/mongodb/index.html' style='font-size: 110.74626865671642%'>mongodb(12)</a> <a href='/tags/mysql/index.html' style='font-size: 103.58208955223881%'>mysql(4)</a> <a href='/tags/nginx/index.html' style='font-size: 100.8955223880597%'>nginx(1)</a> <a href='/tags/node/index.html' style='font-size: 100.8955223880597%'>node(1)</a> <a href='/tags/php/index.html' style='font-size: 108.95522388059702%'>php(10)</a> <a href='/tags/ps/index.html' style='font-size: 105.3731343283582%'>PS(6)</a> <a href='/tags/pygame/index.html' style='font-size: 110.74626865671642%'>pygame(12)</a> <a href='/tags/python/index.html' style='font-size: 145.67164179104478%'>python(51)</a> <a href='/tags/qt/index.html' style='font-size: 101.7910447761194%'>Qt(2)</a> <a href='/tags/redis/index.html' style='font-size: 100.8955223880597%'>Redis(1)</a> <a href='/tags/redis/index.html' style='font-size: 100.8955223880597%'>redis(1)</a> <a href='/tags/ruby/index.html' style='font-size: 124.17910447761194%'>Ruby(27)</a> <a href='/tags/scrapy/index.html' style='font-size: 102.68656716417911%'>Scrapy(3)</a> <a href='/tags/shell/index.html' style='font-size: 100.8955223880597%'>shell(1)</a> <a href='/tags/tq2440/index.html' style='font-size: 104.4776119402985%'>TQ2440(5)</a> <a href='/tags/ubuntu/index.html' style='font-size: 106.26865671641791%'>ubuntu(7)</a> <a href='/tags/usb/index.html' style='font-size: 102.68656716417911%'>USB(3)</a> <a href='/tags/vim/index.html' style='font-size: 123.28358208955224%'>vim(26)</a> <a href='/tags/virtualbox/index.html' style='font-size: 102.68656716417911%'>VirtualBox(3)</a> <a href='/tags/vmware/index.html' style='font-size: 100.8955223880597%'>vmware(1)</a> <a href='/tags/w3m/index.html' style='font-size: 100.8955223880597%'>w3m(1)</a> <a href='/tags/web开发/index.html' style='font-size: 112.53731343283582%'>Web开发(14)</a> <a href='/tags/windows/index.html' style='font-size: 106.26865671641791%'>windows(7)</a> <a href='/tags/wordpress/index.html' style='font-size: 100.8955223880597%'>WordPress(1)</a> <a href='/tags/xml/index.html' style='font-size: 100.8955223880597%'>xml(1)</a> <a href='/tags/免费/index.html' style='font-size: 100.8955223880597%'>免费(1)</a> <a href='/tags/内核/index.html' style='font-size: 100.8955223880597%'>内核(1)</a> <a href='/tags/匹配算法/index.html' style='font-size: 105.3731343283582%'>匹配算法(6)</a> <a href='/tags/单片机/index.html' style='font-size: 101.7910447761194%'>单片机(2)</a> <a href='/tags/嵌入式/index.html' style='font-size: 100.8955223880597%'>嵌入式(1)</a> <a href='/tags/开源软件/index.html' style='font-size: 108.05970149253731%'>开源软件(9)</a> <a href='/tags/排序算法/index.html' style='font-size: 108.05970149253731%'>排序算法(9)</a> <a href='/tags/文件空间/index.html' style='font-size: 100.8955223880597%'>文件空间(1)</a> <a href='/tags/无线网/index.html' style='font-size: 100.8955223880597%'>无线网(1)</a> <a href='/tags/正则式/index.html' style='font-size: 100.8955223880597%'>正则式(1)</a> <a href='/tags/注册机/index.html' style='font-size: 101.7910447761194%'>注册机(2)</a> <a href='/tags/游戏/index.html' style='font-size: 108.95522388059702%'>游戏(10)</a> <a href='/tags/电脑技巧/index.html' style='font-size: 108.05970149253731%'>电脑技巧(9)</a> <a href='/tags/空间/index.html' style='font-size: 100.8955223880597%'>空间(1)</a> <a href='/tags/算法/index.html' style='font-size: 114.32835820895522%'>算法(16)</a> <a href='/tags/红旗/index.html' style='font-size: 100.8955223880597%'>红旗(1)</a> <a href='/tags/经典语录/index.html' style='font-size: 100.8955223880597%'>经典语录(1)</a> <a href='/tags/网络日志/index.html' style='font-size: 105.3731343283582%'>网络日志(6)</a> <a href='/tags/翻译/index.html' style='font-size: 120.59701492537313%'>翻译(23)</a> <a href='/tags/视频教程/index.html' style='font-size: 108.95522388059702%'>视频教程(10)</a> <a href='/tags/资源分享/index.html' style='font-size: 110.74626865671642%'>资源分享(12)</a> <a href='/tags/转载/index.html' style='font-size: 101.7910447761194%'>转载(2)</a> <a href='/tags/随笔/index.html' style='font-size: 100.8955223880597%'>随笔(1)</a> </span>
</section>
<section>
  <h1>Link</h1>
    <ul id="category-list">
      <li><a target="_blank" title="我的Github" href="https://github.com/wusuopu">@Github</a></li>
      <li><a target="_blank" title="我的微博" href="http://www.weibo.com/u/1768691343">@Weibo</a></li>
      <li><a target="_blank" title="我的Twitter" href="https://twitter.com/longchangjin">@Twitter</a></li>
      <li><a target="_blank" title="我的豆瓣" href="http://www.douban.com/people/lchj/">@Douban</a></li>

      <li><a target="_blank" title="" href="http://www.vimer.cn/">Vimer的程序世界</a></li>
      <li><a target="_blank" title="" href="http://pythoner.net/">python开发者社区</a></li>
      <li><a target="_blank" title="" href="http://simple-is-better.com/">python.cn(news, jobs)</a></li>
      <li><a target="_blank" title="" href="http://gtk.awaysoft.com/">GTK+ 中文社区</a></li>
    </ul>
</section>

  
</aside>

    </div>
  </div>
  <footer role="contentinfo"><p>
  Copyright &copy; 2015 - 龍昌 -
  <span class="credit">Powered by <a href="http://octopress.org">Octopress</a></span>
</p>
<div style="display:none;"><script src="http://s94.cnzz.com/stat.php?id=1259846&web_id=1259846&show=pic" language="JavaScript"></script></div>

</footer>
  

<script type="text/javascript">
      var disqus_shortname = 'longchang';
      
        
        var disqus_script = 'count.js';
      
    (function () {
      var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
      dsq.src = '//' + disqus_shortname + '.disqus.com/' + disqus_script;
      (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    }());
</script>











</body>
</html>
