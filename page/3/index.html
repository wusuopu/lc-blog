
<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js" lang="en"><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <title>龍昌博客</title>
  <meta name="author" content="龍昌">

  
  <meta name="description" content="在Python代码中如果要创建一个自定义类使用class关键字即可，但是在C代码中就没那么方便了。
首先简单介绍下Python中的类型。在python中一切皆对象，python中有两种对象：
一种是类型对象（class对象）：表示Python定义的类型，例如int, str, object等； &hellip;">
  

  <!-- http://t.co/dKP3o1e -->
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  
  <link rel="canonical" href="http://www.xefan.com/page/3/index.html">
  <link href="/favicon.png" rel="icon">
  <link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
  <link href="/atom.xml" rel="alternate" title="龍昌博客" type="application/atom+xml">
  <script src="/javascripts/modernizr-2.0.js"></script>
  <script src="//ajax.useso.com/ajax/libs/jquery/1.9.1/jquery.min.js"></script>
  <script>!window.jQuery && document.write(unescape('%3Cscript src="./javascripts/libs/jquery.min.js"%3E%3C/script%3E'))</script>
  <script src="/javascripts/octopress.js" type="text/javascript"></script>
  <!--Fonts from Google"s Web font directory at http://google.com/webfonts -->
<link href="//fonts.useso.com/css?family=PT+Serif:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">
<link href="//fonts.useso.com/css?family=PT+Sans:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">

  

</head>

<body   >
  <header role="banner"><hgroup>
  <h1><a href="/">龍昌博客</a></h1>
  
    <h2>从Pythoner转向Rubist</h2>
  
</hgroup>

</header>
  <nav role="navigation"><ul class="subscription" data-subscription="rss">
  <li><a href="/atom.xml" rel="subscribe-rss" title="subscribe via RSS">RSS</a></li>
  
</ul>
  
<form action="https://www.google.com/search" method="get">
  <fieldset role="search">
    <input type="hidden" name="q" value="site:www.xefan.com" />
    <input class="search" type="text" name="q" results="0" placeholder="Search"/>
  </fieldset>
</form>
  
<ul class="main-navigation">
  <li><a href="/">Home</a></li>
  <li><a href="/blog/archives">Archives</a></li>
 <li><a href="/about/">About</a></li>  <li><a href="/gbook/">留言板</a></li> 
</ul>

</nav>
  <div id="main">
    <div id="content">
      <div class="blog-index">
  
  
  
    <article>
      
  <header>
    
    <h1 class="entry-title"><a href="http://www.xefan.com/archives/84091.html">使用C语言编写Python扩展3——创建自定义类型(1)</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2014-04-13T00:00:00+08:00'><span class='date'><span class='date-month'>Apr</span> <span class='date-day'>13</span><span class='date-suffix'>th</span>, <span class='date-year'>2014</span></span> <span class='time'>12:00 am</span></time>
        
           | <a href="http://www.xefan.com/archives/84091.html#disqus_thread"
             data-disqus-identifier="http://www.xefan.com/archives/84091.html">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><p>在Python代码中如果要创建一个自定义类使用class关键字即可，但是在C代码中就没那么方便了。<br>
首先简单介绍下Python中的类型。在python中一切皆对象，python中有两种对象：<br>
一种是类型对象（class对象）：表示Python定义的类型，例如int, str, object等；<br>
另一种是实例对象（instance对象）：表示由class对象创建的实例。 
Python中的所有对象都是直接或者间接继承object，然后object又是typy类型。可以运行下面的例子看看输出结果：  </p>


<pre><code>class A(object):
    pass

a = A()

print(type(a))
print(isinstance(a, A))
print(isinstance(a, object))
print(isinstance(a, type))

print(type(A))
print(A.__base__)
print(isinstance(A, object))
print(isinstance(A, type))

print(type(object))
print(isinstance(object, type))

print(type(type))
print(isinstance(type, object))
</code></pre>


<p>python是一门面向对象的编程语言，它是用C写的，而C又是面向过程的编程语言，那么python的类在C中是如何实现的呢？答案就是用结构体来模拟。  </p>


<p>在Python的<em>object.h</em>头文件中定义了一个重要的结构体 PyTypeObject 。创建新的类型就是靠的它，该结构体定义如下：  </p>


<pre><code>typedef struct _typeobject {
    PyObject_VAR_HEAD
    char *tp_name; /* For printing, in format "&lt;module&gt;.&lt;name&gt;" */
    int tp_basicsize, tp_itemsize; /* For allocation */

    /* Methods to implement standard operations */

    destructor tp_dealloc;
    printfunc tp_print;
    getattrfunc tp_getattr;
    setattrfunc tp_setattr;
    cmpfunc tp_compare;
    reprfunc tp_repr;

    /* Method suites for standard classes */

    PyNumberMethods *tp_as_number;
    PySequenceMethods *tp_as_sequence;
    PyMappingMethods *tp_as_mapping;

    /* More standard operations (here for binary compatibility) */

    hashfunc tp_hash;
    ternaryfunc tp_call;
    reprfunc tp_str;
    getattrofunc tp_getattro;
    setattrofunc tp_setattro;

    /* Functions to access object as input/output buffer */
    PyBufferProcs *tp_as_buffer;

    /* Flags to define presence of optional/expanded features */
    long tp_flags;

    char *tp_doc; /* Documentation string */

    /* Assigned meaning in release 2.0 */
    /* call function for all accessible objects */
    traverseproc tp_traverse;

    /* delete references to contained objects */
    inquiry tp_clear;

    /* Assigned meaning in release 2.1 */
    /* rich comparisons */
    richcmpfunc tp_richcompare;

    /* weak reference enabler */
    long tp_weaklistoffset;

    /* Added in release 2.2 */
    /* Iterators */
    getiterfunc tp_iter;
    iternextfunc tp_iternext;

    /* Attribute descriptor and subclassing stuff */
    struct PyMethodDef *tp_methods;
    struct PyMemberDef *tp_members;
    struct PyGetSetDef *tp_getset;
    struct _typeobject *tp_base;
    PyObject *tp_dict;
    descrgetfunc tp_descr_get;
    descrsetfunc tp_descr_set;
    long tp_dictoffset;
    initproc tp_init;
    allocfunc tp_alloc;
    newfunc tp_new;
    freefunc tp_free; /* Low-level free-memory routine */
    inquiry tp_is_gc; /* For PyObject_IS_GC */
    PyObject *tp_bases;
    PyObject *tp_mro; /* method resolution order */
    PyObject *tp_cache;
    PyObject *tp_subclasses;
    PyObject *tp_weaklist;
} PyTypeObject;
</code></pre>


<p>这个比较庞大，里面包含的数据比较多，大部分都是一些函数指针而且可以为空，至于每个字段是什么意思请查看Python文档。  </p>


<h2>创建自定义类型</h2>


<p>创建一个新的C代码文件 <em>noddy.c</em> ，然后我们编写一个名为 noddy 的扩展模块，该模块包含了一个名为 Noddy 的类。  </p>


<p>首先创建一个新的 PyTypeObject 类型的变量：</p>


<pre><code>typedef struct {
    PyObject_HEAD
    /* Type-specific fields go here. */
} noddy_NoddyObject;
static PyTypeObject noddy_NoddyType = {
    PyVarObject_HEAD_INIT(NULL, 0)
    "noddy.Noddy",             /*tp_name*/
    sizeof(noddy_NoddyObject), /*tp_basicsize*/
    0,                         /*tp_itemsize*/
    0,                         /*tp_dealloc*/
    0,                         /*tp_print*/
    0,                         /*tp_getattr*/
    0,                         /*tp_setattr*/
    0,                         /*tp_compare*/
    0,                         /*tp_repr*/
    0,                         /*tp_as_number*/
    0,                         /*tp_as_sequence*/
    0,                         /*tp_as_mapping*/
    0,                         /*tp_hash */
    0,                         /*tp_call*/
    0,                         /*tp_str*/
    0,                         /*tp_getattro*/
    0,                         /*tp_setattro*/
    0,                         /*tp_as_buffer*/
    Py_TPFLAGS_DEFAULT,        /*tp_flags*/
    "Noddy objects",           /*tp_doc*/
};
</code></pre>


<p>这里是定义了一个noddy_NoddyObject结构体，它的第一个字段为 PyObject_HEAD ，因此相当于一个PyObject类型；然后还有一个 noddy_NoddyType 变量，它的第一个字段为 <em>PyVarObject_HEAD_INIT(NULL, 0)</em> ，这个很很重要，按理说这个应该写成 <em>PyVarObject_HEAD_INIT(&amp;PyType_Type, 0)</em> ，即表示Noddy这个类是一个type类型的对象。不过有的C编译器会对这个报错，因此这一项将在后面调用PyType_Ready函数来填充。<br>
noddy_NoddyType 即是 Noddy 类，它保存了该类的元信息；noddy_NoddyObject结构体用于保存该类的实例对象的数据。<br>
<em>只要是定义的结构体以PyObject_HEAD开始就属于是一个PyObject类型。PyObject_VAR_HEAD与PyObject_HEAD相似，只是PyObject_HEAD表示的是该类型占用内存大小是固定的如int、float；而PyObject_VAR_HEAD表示该类型占用的内存是可变的如list、dict。</em>   </p>


<p>然后创建一个新扩展模块，并完成初始化：</p>


<pre><code>static PyMethodDef noddy_methods[] = {
    {NULL}  /* Sentinel */
};
PyMODINIT_FUNC
initnoddy(void) 
{
    PyObject* m;

    noddy_NoddyType.tp_new = PyType_GenericNew;
    if (PyType_Ready(&amp;noddy_NoddyType) &lt; 0)
        return;

    m = Py_InitModule3("noddy", noddy_methods,
                       "Example module that creates an extension type.");

    Py_INCREF(&amp;noddy_NoddyType);
    PyModule_AddObject(m, "Noddy", (PyObject *)&amp;noddy_NoddyType);
}
</code></pre>


<p><strong><em>注意</em></strong>：以上是针对Python2的，在Python3中模块的初始化操作略有不同。请参考第一节的内容。  </p>


<p>noddy_NoddyType即是我们要创建的 Noddy 类，它是 PyTypeObject 类型的结构变量。为了创建新的类型，我们需要指明 tp_new 方法，它相当于Python中的 __new__，这里我们使用默认的 PyType_GenericNew 即可。<br>
然后调用 PyType_Ready 完成新类型的创建。<br>
最后调用 PyModule_AddObject 在该模块中添加刚刚创建的新类型。  </p>


<h2>测试</h2>


<p>最后就是编写一个小程序来测试刚刚的模块是否可用。</p>


<pre><code>import noddy

o = noddy.Noddy()
print(o)
print(type(o), type(noddy.Noddy))

# 这个会报错，noddy.Noddy 类不能被继承
class A(noddy.Noddy):
    pass
</code></pre>

</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
    <h1 class="entry-title"><a href="http://www.xefan.com/archives/84085.html">使用C语言编写Python扩展2——函数</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2014-04-13T00:00:00+08:00'><span class='date'><span class='date-month'>Apr</span> <span class='date-day'>13</span><span class='date-suffix'>th</span>, <span class='date-year'>2014</span></span> <span class='time'>12:00 am</span></time>
        
           | <a href="http://www.xefan.com/archives/84085.html#disqus_thread"
             data-disqus-identifier="http://www.xefan.com/archives/84085.html">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><p>上一节介绍了编写扩展的基本流程。这一回介绍一下在扩展模块中的函数调用，包括在扩展函数的参数提取和关键字参数解析，以及在C语言中调用Python方法。</p>


<p>同样的本文中的示例代码可从 https://github.com/wusuopu/python-c-extension-sample 获取到。  </p>


<h2>参数提取</h2>


<p>接着上一节的例子，我们继续编辑lc_hello.c文件。先往模块中添加一个名为  func1 的函数，即就是在 lc_hello_world_methods 数组中添加一项：  </p>


<pre><code>{"func1", (PyCFunction)func1_function, METH_VARARGS, NULL},
</code></pre>


<p>然后就是对该函数的实现。<br>
参数提取是使用 PyArg_ParseTuple 方法，其定义如下：  </p>


<pre><code>int PyArg_ParseTuple(PyObject *arg, char *format, ...);
</code></pre>


<p>其中 <em>arg</em> 参数为Python向C函数传递的参数列表，是一个无组对象；<em>format</em> 参数是一个格式化字符串，它的格式可以参考 Python/C API 文档。<br>
func1_function 函数实现如下：  </p>


<pre><code>static PyObject* func1_function(PyObject *self, PyObject *args)
{
    int num, i, j;
    long lnum=0;
    const char* s1 = NULL;
    PyObject *obj = NULL;
    if (!PyArg_ParseTuple(args, "is(ii)|l",
                          &amp;num, &amp;s1, &amp;i, &amp;j, &amp;lnum)) {
        printf("传入参数错误！\n");
        return NULL;
    }
    printf("num: %d\tstr1: %s\n"
           "i: %d\tj: %d\tlnum: %ld\n",
           num, s1, i, j, lnum);

    obj = Py_BuildValue("{sisisislss}",
                        "num", num, "i", i, "j", j, "lnum", lnum, "s1", s1);
    return obj;
}
</code></pre>


<p>在Python中该函数可以接收3个或者4个参数。同时该函数使用了 Py_BuildValue 方法构造了一个字典对象并返回。Py_BuildValue的用法与PyArg_ParseTuple类似。<br>
接下来可以在Python中进行测试：  </p>


<pre><code>print(lc_hello_world.func1(11, 'abc', (2, 3), 100))
print(lc_hello_world.func1(11, 'abc', (2, 3)))
</code></pre>


<h2>关键字参数</h2>


<p>再在 lc_hello_world_methods 数组中添加一项：  </p>


<pre><code>{"func2", (PyCFunction)func2_function, METH_VARARGS | METH_KEYWORDS, NULL},
</code></pre>


<p>关键字参数解析是使用 PyArg_ParseTupleAndKeywords 方法，其定义如下：  </p>


<pre><code>int PyArg_ParseTupleAndKeywords(PyObject *arg, PyObject *kwdict,
                                char *format, char *kwlist[], ...);
</code></pre>


<p>其中 <em>arg</em> 参数和 <em>format</em> 参数与PyArg_ParseTuple一样。<em>kwdict</em>参数是一个字典对象，保存了关键字参数。<em>kwlist</em>是一个以NULL结尾的字符串数组。<br>
func2_function 函数实现如下：  </p>


<pre><code>static PyObject* func2_function(PyObject *self, PyObject *args, PyObject *kwargs)
{
    int voltage;
    char *state = "a stiff";
    char *action = "voom";
    char *type = "Norwegian Blue";

    static char *kwlist[] = {"voltage", "state", "action", "type", NULL};

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, "i|sss", kwlist,
                                     &amp;voltage, &amp;state, &amp;action, &amp;type))
        return NULL;

    printf("-- This parrot wouldn't %s if you put %i Volts through it.\n",
           action, voltage);
    printf("-- Lovely plumage, the %s -- It's %s!\n", type, state);
    Py_INCREF(Py_None);
    return Py_None;
}
</code></pre>


<p>接下来可以在Python中进行测试：  </p>


<pre><code>lc_hello_world.func2(state="ok", action="test", type="func", voltage=13)
lc_hello_world.func2(20)
</code></pre>


<h2>在扩展模块中调用Python方法</h2>


<p>在扩展模块中可以使用  PyObject_CallObject 方法来调用Python的函数方法。其定义如下：  </p>


<pre><code>PyObject* PyObject_CallObject(PyObject *callable_object, PyObject *args)
</code></pre>


<p>再在 lc_hello_world_methods 数组中添加一项：  </p>


<pre><code>{"func3", (PyCFunction)func3_function, METH_VARARGS, NULL},
</code></pre>


<p>func3_function 函数实现如下：  </p>


<pre><code>static PyObject* func3_function(PyObject *self, PyObject *args)
{
    PyObject *my_callback = NULL;
    PyObject *result = NULL;
    PyObject *arg = NULL;
    if (!PyArg_ParseTuple(args, "OO:set_callback;argument;", &amp;my_callback, &amp;arg)) {
        printf("传入参数错误！\n");
        return NULL;
    }
    if (!PyCallable_Check(my_callback)) {
        PyErr_SetString(PyExc_TypeError, "parameter must be callable");
        return NULL;
    }
    result = PyObject_CallObject(my_callback, arg);
    if (!result) {
        Py_INCREF(Py_None);
        result = Py_None;
    }
    return result;
}
</code></pre>


<p>接下来可以在Python中进行测试：  </p>


<pre><code>print(lc_hello_world.func3(int, (1.234, )))
</code></pre>

</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
    <h1 class="entry-title"><a href="http://www.xefan.com/archives/84082.html">使用C语言编写Python扩展1——Hello World</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2014-04-12T00:00:00+08:00'><span class='date'><span class='date-month'>Apr</span> <span class='date-day'>12</span><span class='date-suffix'>th</span>, <span class='date-year'>2014</span></span> <span class='time'>12:00 am</span></time>
        
           | <a href="http://www.xefan.com/archives/84082.html#disqus_thread"
             data-disqus-identifier="http://www.xefan.com/archives/84082.html">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><p>能够使用C语言编写扩展是Python一大卖点吧，这可以将一些关键的代码使用C来写以提升程序的性能。本文是参考了Python的官方文档整理而来的，同时结合了Python2跟Python3。按照惯例现在先从一个Hello World开始讲解一下写扩展的基本流程。</p>


<p>详细的内容可以参考官方文档：<br>
https://docs.python.org/2.7/extending/index.html <br>
https://docs.python.org/3/extending/index.html  </p>


<p>https://docs.python.org/2.7/c-api/index.html<br>
https://docs.python.org/3/c-api/index.html  </p>


<p>同时本文中的示例代码可从 https://github.com/wusuopu/python-c-extension-sample 获取到。  </p>


<p>首先介绍一下我当前的开发环境：<br>
 * ArchLinux<br>
 * gcc 4.8.2<br>
 * glibc 2.19<br>
 * Python 2.7.6<br>
 * Python 3.3.5  </p>


<h2>开始</h2>


<p>先创建一个新的C代码文件 lc_hello.c。为了能够正常使用python的api，需要导入Python.h这个头文件。</p>


<pre><code>#include &lt;Python.h&gt;
</code></pre>


<p>然后再定义一个模块的初始化函数。</p>


<pre><code>PyMODINIT_FUNC initlc_hello_world(void)
{
    Py_InitModule("lc_hello_world", lc_hello_world_methods);
    printf("init lc_hello_world module\n");
}
</code></pre>


<p>这个函数是用于模块初始化的，即是在第一次使用import语句导入模块时会执行。其函数名必须为initmodule_name这样的格式，在这里我们的模块名为lc_hello_world，所以函数名就是initlc_hello_world。<br>
在这个函数中又调用了Py_InitModule函数，它执行了模块初始化的操作。Py_InitModule函数传入了两个参数，第一个参数为字符串，表示模块的名称；第二个参数是一个PyMethodDef的结构体数组，表示该模块都具有哪些方法。与Py_InitModule相似的方法还有Py_InitModule3和Py_InitModule4。因此在initlc_hello_world方法之前还需要先定义 lc_hello_world_methods 数组。  </p>


<pre><code>static PyMethodDef lc_hello_world_methods[] = {
    {"test", (PyCFunction)test_function, METH_NOARGS, "lc_hello_world extending test"},
    {"add", (PyCFunction)add_function, METH_VARARGS, NULL},
    {NULL, NULL, 0, NULL}
};
</code></pre>


<p>PyMethodDef结构体有四个字段。<br>
  * 第一个是一个字符串，表示在Python中对应的方法的名称；<br>
  * 第二个是对应的C代码的函数；<br>
  * 第三个是一个标致位，表示该Python方法是否需要参数，METH_NOARGS表示不需要参数，METH_VARARGS表示需要参数；<br>
  * 第四个是一个字符串，它是该方法的__doc__属性，这个不是必须的，可以为NULL。<br>
PyMethodDef结构体数组最后以 {NULL, NULL, 0, NULL}结尾。（感觉好像不是必须的，但是通常都这么做那我们也这么做吧）  </p>


<p><strong>注意</strong>：以上的用法都是针对Python2的，在Python3中又有些不同。<br>
在Python3中模块的初始化函数的函数名变为了PyInit_module_name这样的形式了，因此这里就需要定义一个函数 PyMODINIT_FUNC PyInit_lc_hello_world。并且还需要返回一个 module 类型的变量。<br>
其次在Python3中创建module对象的函数也由 Py_InitModule 变为了 PyModule_Create。<br>
因此在Python3中模块的初始化函数应该定义如下：  </p>


<pre><code>PyMODINIT_FUNC PyInit_lc_hello_world(void)
{
    PyObject *m;
    m = PyModule_Create(&amp;lc_hello_world_module);
    if (m == NULL)
        return NULL;
    printf("init lc_hello_world module\n");
    return m;
}
</code></pre>


<p>PyModule_Create函数需要传入一个 PyModuleDef 类型的指针。<br>
因此在此之前还需要先定义 lc_hello_world_module 变量。  </p>


<pre><code>static struct PyModuleDef lc_hello_world_module = {
    PyModuleDef_HEAD_INIT,
    "lc_hello_world",        /* name of module */
    NULL,                    /* module documentation, may be NULL */
    -1,                      /* size of per-interpreter state of the module, or -1 if the module keeps state in global variables. */
    lc_hello_world_methods   /* A pointer to a table of module-level functions, described by PyMethodDef values. Can be NULL if no functions are present. */
};
</code></pre>


<p>在 lc_hello_world_methods 中我们为模块指定了两个方法，接下来我们需要实现这两个方法。  </p>


<pre><code>static PyObject* test_function(PyObject *self)
{
    PyObject_Print(self, stdout, 0);
    printf("lc_hello_world test\n");
    Py_INCREF(Py_True);
    return Py_True;
}
</code></pre>


<p>这段代码定义了Python的test方法所对应的C函数。在这个函数中就只执行了一条printf语句，然后就返回了Py_True。<br>
Py_True即是Python中的True，Py_INCREF函数执行的操作是对Python对象的计数引用值进行加1。与Py_INCREF对应的是Py_DECREF，它是对计数引用减1,并且计数引用为0时就销毁对象并回收内存。  </p>


<pre><code>static PyObject* add_function(PyObject *self, PyObject *args)
{
    int num1, num2;
    PyObject *result=NULL;
    if (!PyArg_ParseTuple(args, "nn", &amp;num1, &amp;num2)) {
        printf("传入参数错误！\n");
        return NULL;
    }
    result = PyInt_FromLong(num1+num2);
    return result;
}
</code></pre>


<p>这须代码定义了Python的add方法所对应的C函数。该函数需要传入两个整数类型的参数。<br>
PyArg_ParseTuple是对传入的参数进行解析，关于这个函数的说明请查看Python手册。  </p>


<p><strong>注意</strong>：在Python3中整数都是 long 类型的，因此这里的 PyInt_FromLong 需要改为 PyLong_FromLong，其作用是将C的int类型转为Python的int类型。  </p>


<h2>编译</h2>


<p>扩展模块编写完成后，接下来就是对其进行编译了。先编写一个 setup.py 脚本。  </p>


<pre><code>#!/usr/bin/env python
#-*- coding:utf-8 -*-

from setuptools import setup, Extension

hello_world = Extension('lc_hello_world', sources=["lc_hello.c"])
setup(ext_modules=[hello_world])
</code></pre>


<p>然后再执行命令进行编译：</p>


<pre><code>$ python setup.py build
</code></pre>


<p>执行成功后会在当前目录下的build目录中生成扩展模块文件。</p>


<h2>测试</h2>


<p>最后就是编写一个小程序来测试刚刚的模块是否可用。</p>


<pre><code>import lc_hello_world

print(lc_hello_world.test.__doc__)
print(lc_hello_world.add.__doc__)
print(lc_hello_world.test())
print(lc_hello_world.add(1, 2))
print(lc_hello_world.add(1, '2'))    # 这个会报错
</code></pre>

</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
    <h1 class="entry-title"><a href="http://www.xefan.com/archives/84076.html">Mongoengine教程(5)——信号</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2014-04-06T00:00:00+08:00'><span class='date'><span class='date-month'>Apr</span> <span class='date-day'>6</span><span class='date-suffix'>th</span>, <span class='date-year'>2014</span></span> <span class='time'>12:00 am</span></time>
        
           | <a href="http://www.xefan.com/archives/84076.html#disqus_thread"
             data-disqus-identifier="http://www.xefan.com/archives/84076.html">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><p>MongoEngine在进行数据操作时会发出一些信号，我们可以连接这些信号进行一些额外的操作。注意：要在MongoEngine中使用信号，需要安装 <em>blinker</em> 这个库。  </p>


<pre><code>$ pip install blinker
</code></pre>


<p>MongoEngine提供的信号如下：  </p>


<ul>
<li>pre_init: 在创建一个新的 Document 或者 EmbeddedDocument 实例对象之后，并且对象初始化之前调用。  </li>
<li>post_init:在 Document 或者 EmbeddedDocument 实例对象初始化完成之后调用。  </li>
<li>pre_save:在 save 方法执行之前调用。  </li>
<li>pre_save_post_validation:在数据检验完成之后，数据保存之前调用。  </li>
<li>post_save:在数据保存完成之后调用。  </li>
<li>pre_delete:在 delete 方法执行之前调用。  </li>
<li>post_delete:在记录成功删除之后调用。  </li>
<li>pre_bulk_insert:在数据检验之后，数据插入之前调用。  </li>
<li>post_bulk_insert:在数据成功插入之后调用。</li>
</ul>


<h2>事件连接</h2>


<p>使用 signals 将信号与回调函数进行连接。</p>


<pre><code>from mongoengine import *
from mongoengine import signals

class Author(Document):
    name = StringField()

    @classmethod
    def pre_save(cls, sender, document, **kwargs):
        print("Pre Save: %s" % document.name)

    @classmethod
    def post_save(cls, sender, document, **kwargs):
        print("Post Save: %s" % document.name)
        if 'created' in kwargs:
            if kwargs['created']:
                print("Created")
            else:
                print("Updated")

signals.pre_save.connect(Author.pre_save, sender=Author)
signals.post_save.connect(Author.post_save, sender=Author)
</code></pre>


<p>注意：对于 RefereneField 的<em>reverse_delete_rules</em>参数不会触发信号。</p>

</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
    <h1 class="entry-title"><a href="http://www.xefan.com/archives/84072.html">Mongoengine教程(4)——文件存储</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2014-04-05T00:00:00+08:00'><span class='date'><span class='date-month'>Apr</span> <span class='date-day'>5</span><span class='date-suffix'>th</span>, <span class='date-year'>2014</span></span> <span class='time'>12:00 am</span></time>
        
           | <a href="http://www.xefan.com/archives/84072.html#disqus_thread"
             data-disqus-identifier="http://www.xefan.com/archives/84072.html">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><p>MongoDB的GridFS支持直接在数据库中存储文件。要在MongoEngine中使用GridFS，只要使用 FileField 对象即可。以下是一个例子：</p>


<pre><code>class Animal(Document):
    genus = StringField()
    family = StringField()
    photo = FileField()

marmot = Animal(genus='Marmota', family='Sciuridae')

marmot_photo = open('gtk.png', 'rb')
marmot.photo.put(marmot_photo, content_type = 'image/png')
marmot.save()
</code></pre>


<p>这个例子将 gtk.png 这个图片存入了数据库中。<br>
文件的读取也很简单：</p>


<pre><code>marmot = Animal.objects(genus='Marmota').first()
photo = marmot.photo.read()
content_type = marmot.photo.content_type
</code></pre>


<p>FileField不仅可以存储文件，还可以用来存储数据流。只是操作上略微不同。</p>


<p>要存储数据流，首先先创建一个新的文件，然后再往里面写入数据。</p>


<pre><code>marmot.photo.new_file()
marmot.photo.write('some_image_data')
marmot.photo.write('some_more_image_data')
marmot.photo.close()
marmot.save()
</code></pre>


<p>如果要删除存储在数据库中的文件，只需要调用该文件对象的 delete 方法：</p>


<pre><code>marmot.photo.delete()
</code></pre>


<p>注意：一条文档记录中的FileField字段只保存了对GridFS集合中该文件的ID引用。这意味着如果该文档被删除了，对用的文件不会被删除。因此在删除这类文档时需要小心，以免出现孤立文件。</p>


<p>对于已存储的文件可以进行替换修改：</p>


<pre><code>another_marmot = open('python.png', 'rb')
marmot.photo.replace(another_marmot, content_type='image/png')
</code></pre>

</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
    <h1 class="entry-title"><a href="http://www.xefan.com/archives/84069.html">Mongoengine教程(3)——数据查询</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2014-04-05T00:00:00+08:00'><span class='date'><span class='date-month'>Apr</span> <span class='date-day'>5</span><span class='date-suffix'>th</span>, <span class='date-year'>2014</span></span> <span class='time'>12:00 am</span></time>
        
           | <a href="http://www.xefan.com/archives/84069.html#disqus_thread"
             data-disqus-identifier="http://www.xefan.com/archives/84069.html">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><p>与Django一样，Document类都有一个 objects 属性。它用于将类与数据库关联起来。objects属性是一个QuerySetManager类型的对象，它的操作会返回一个QuerySet类型的对象。可以通过对QuerySet对象的迭代获取数据库中的数据。</p>


<pre><code>class User(Document):
    name = StringField()
    country = StringField()

class Paper(Document):
    content = StringField()
    author = ReferenceField(User)
</code></pre>


<h2>查询过滤</h2>


<p>可以在查询是指定过滤条件以获取想要的结果。例如想要查询英国的用户：</p>


<pre><code>uk_users = User.objects(country='uk')
</code></pre>


<p>与Django类似，要查询引用的对象只需要使用双下划线即可。例如想要查询英国用户的论文：</p>


<pre><code>uk_papers = Paper.objects(author__country='uk')
</code></pre>


<h2>查询操作</h2>


<p>与Django类似，MongoEngine同样也提供了一些条件语句。</p>


<ul>
<li>ne - 不相等</li>
<li>lt - 小于</li>
<li>lte - 小于等于</li>
<li>gt - 大于</li>
<li>gte - 大于等于</li>
<li>not - 取反</li>
<li>in - 值在列表中</li>
<li>nin - 值不在列表中</li>
<li>mod - 取模</li>
<li>all - 与列表的值相同</li>
<li>size - 数组的大小</li>
<li>exists - 字段的值存在</li>
</ul>


<p>例如查询年龄小于等于18岁的用户：</p>


<pre><code>young_users = Users.objects(age__lte=18)
</code></pre>


<p>对于不同类型的数据提供了不同的条件语句。</p>


<h3>查询结果个数限制</h3>


<p>跟传统的ORM一样，MongoEngine也可以限制查询结果的个数。一种方法是在QuerySet对象上调用limit和skip方法；另一种方法是使用数组的分片的语法。例如：</p>


<pre><code>users = User.objects[10:15]
users = User.objects.skip(10).limit(5)
</code></pre>


<h2>聚合操作</h2>


<p>MongoEngine提供了一些数据库的聚合操作。</p>


<p>统计结果个数即可以使用QuerySet的count方法，也可以使用Python风格的方法：</p>


<pre><code>num_users = len(User.objects)
num_users = User.objects.count()
</code></pre>


<p>其他的一些聚合操作。<br>
求和：</p>


<pre><code>yearly_expense = Employee.objects.sum('salary')
</code></pre>


<p>求平均数：</p>


<pre><code>mean_age = User.objects.average('age')
</code></pre>


<h2>高级查询</h2>


<p>有时需要将多个条件进行组合，前面提到的方法就不能满足需求了。这时可以使用MongoEngine的Q类。它可以将多个查询条件进行 &amp;(与) 和 |(或) 操作。</p>


<p>例如下面的语句是查询所有年龄大于等于18岁的英国用户，或者所有年龄大于等于20岁的用户。</p>


<pre><code>User.objects((Q(country='uk') &amp; Q(age__gte=18)) | Q(age__gte=20))
</code></pre>


<h2>在服务器端执行javascript代码</h2>


<p>通过MongoEngine QuerySet对象的 exec_js 方法可以将javascript代码作为字符串发送给服务器端执行，然后返回执行的结果。</p>


<p>例如查询该数据库都有那些集合：</p>


<pre><code>User.objects.exec_js("db.getCollectionNames()")
</code></pre>

</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
    <h1 class="entry-title"><a href="http://www.xefan.com/archives/84066.html">Mongoengine教程(2)——文档模式</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2014-04-03T00:00:00+08:00'><span class='date'><span class='date-month'>Apr</span> <span class='date-day'>3</span><span class='date-suffix'>rd</span>, <span class='date-year'>2014</span></span> <span class='time'>12:00 am</span></time>
        
           | <a href="http://www.xefan.com/archives/84066.html#disqus_thread"
             data-disqus-identifier="http://www.xefan.com/archives/84066.html">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><p>在MongoDB中一个文档(document)与关系型数据库中的一行(row)相似；文档保存在集合(collection)中，行保存在表(table)中。</p>


<h2>定义文档的模式</h2>


<p>与django类似，要定义一个文档模式只需要创建一个类继承自 Document，并添加一些 Field 对象。</p>


<pre><code>from mongoengine import *
import datetime

class Page(Document):
    title = StringField(max_length=200, required=True)
    date_modified = DateTimeField(default=datetime.datetime.now)
</code></pre>


<p>如上定义了一个文档模式具有 title和date_modified 两个字段。</p>


<p>同时MongoDB本身就是无模式的，因此我们还可以创建动态的文档模式。它可以在添加数据时为不同的数据设置不同的字段。</p>


<pre><code>class Page(DynamicDocument):
    title = StringField(max_length=200, required=True)
</code></pre>


<p>添加数据：</p>


<pre><code>page = Page(title='Using MongoEngine')
page.tags = ['mongodb', 'mongoengine']
page.save()
</code></pre>


<h2>文档字段</h2>


<p>文档字段(Field)不是必需的，但是使用它来进行数据验证、设置默认值等操作会比较方便。</p>


<p>MongoEngine提供了如下这些类型的Field:</p>


<ul>
<li>BinaryField  </li>
<li>BooleanField  </li>
<li>ComplexDateTimeField  </li>
<li>DateTimeField  </li>
<li>DecimalField  </li>
<li>DictField  </li>
<li>DynamicField  </li>
<li>EmailField  </li>
<li>EmbeddedDocumentField  </li>
<li>FileField  </li>
<li>FloatField  </li>
<li>GenericEmbeddedDocumentField  </li>
<li>GenericReferenceField  </li>
<li>GeoPointField  </li>
<li>ImageField  </li>
<li>IntField  </li>
<li>ListField  </li>
<li>MapField  </li>
<li>ObjectIdField  </li>
<li>ReferenceField  </li>
<li>SequenceField  </li>
<li>SortedListField  </li>
<li>StringField  </li>
<li>URLField  </li>
<li>UUIDField  </li>
</ul>


<h2>文档之间引用关系</h2>


<p>在关系型数据库中多个表可以使用外键进行关联。然而MongoDB是无模式的，因此想要达到这样的效果就这能在应用程序中自己手动的进行关联了。</p>


<p>不过还好，使用MongoEngine的ReferenceField可以很方便的实现。</p>


<pre><code>class User(Document):
    name = StringField()

class Page(Document):
    content = StringField()
    author = ReferenceField(User)

john = User(name="John Smith")
john.save()

post = Page(content="Test Page")
post.author = john
post.save()
</code></pre>


<h3>一对多的关系</h3>


<p>对于一对多的关系可以使用ListField来保存一个ReferenceField列表。在进行查询操作是需要传入一个实例对象。</p>


<pre><code>class User(Document):
    name = StringField()

class Page(Document):
    content = StringField()
    authors = ListField(ReferenceField(User))

bob = User(name="Bob Jones").save()
john = User(name="John Smith").save()

Page(content="Test Page", authors=[bob, john]).save()
Page(content="Another Page", authors=[john]).save()

# Find all pages Bob authored
Page.objects(authors__in=[bob])
</code></pre>


<h3>引用对象的删除操作</h3>


<p>MongoDB默认不会检查数据的完整性，因此在删除一个对象是就需要自己手动的处理引用了该对象的其他对象。</p>


<p>同样的MongoEngine也提供了一样的功能。ReferenceField有一个 reverse_delete_rule 参数可以进行设置。它的取值如下：  </p>


<ul>
<li>mongoengine.DO_NOTHING:默认就是这个值，它不会进行任何操作。  </li>
<li>mongoengine.DENY:如果该对象还被其他对象引用，则拒绝删除。  </li>
<li>mongoengine.NULLIFY:将其他对象对该对象的引用字段设为null。  </li>
<li>mongoengine.CASCADE:将引用了该对象的其他对象也删除掉。  </li>
<li>mongoengine.PULL:移除对该对象的引用。  </li>
</ul>


<h2>索引</h2>


<p>与django的Model相似，MongoEngine的Document也可以在meta属性中设置索引。</p>


<pre><code>class Page(Document):
    title = StringField()
    rating = StringField()
    meta = {
        'indexes': ['title', ('title', '-rating')]
    }
</code></pre>


<p>meta中的indexes可以是一个列表，也可以是一个字典。</p>

</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
    <h1 class="entry-title"><a href="http://www.xefan.com/archives/84063.html">Mongoengine教程(1)——概述</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2014-04-02T00:00:00+08:00'><span class='date'><span class='date-month'>Apr</span> <span class='date-day'>2</span><span class='date-suffix'>nd</span>, <span class='date-year'>2014</span></span> <span class='time'>12:00 am</span></time>
        
           | <a href="http://www.xefan.com/archives/84063.html#disqus_thread"
             data-disqus-identifier="http://www.xefan.com/archives/84063.html">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><p>MongoEngine是MongoDB的一个ODM(Object-Document Mapper)框架，它提供了类似Django的语法来操作MongoDB数据库。</p>


<h2>安装</h2>


<p>安装 MongoEngine 需要先安装 PyMongo。  </p>


<h3>使用pip安装</h3>


<pre><code>$ [sudo] pip install mongoengine
</code></pre>


<h3>通过源代码安装</h3>


<p>先从 <a href="http://pypi.python.org/pypi/mongoengine/">PyPi</a> 或者 <a href="http://github.com/MongoEngine/mongoengine">Github</a> 下载源代码。然后再进行安装。</p>


<pre><code>$ [sudo] python setup.py install
</code></pre>


<h2>使用</h2>


<p>首先启动 mongodb 服务器：</p>


<pre><code>$ mongod
</code></pre>


<h3>连接服务器</h3>


<p>使用 connect 方法进行数据库链接，与pymongo的用法相似，其参数可以是多种型式的。</p>


<pre><code>from mongoengine import connect
connect('project1')
connect('project1', host='mongodb://localhost:27017/test_database')
</code></pre>


<p>从 MongoEngine 0.6 开始增加了多数据库的支持， connect 的第二个参数可以为每个链接设置一个别名。</p>


<h3>定义数据模型</h3>


<p>mongoengine的 Document 与django的 Model 相似。</p>


<pre><code>class User(mongoengine.Document):
    name = mongoengine.StringField()

    meta = {"db_alias": "default"}
</code></pre>


<h3>数据操作</h3>


<p>数据的添加过程也与django相似：</p>


<pre><code>User.objects.create(name="test1")
User.objects.create(name="test2")
User(name="test3").save()
</code></pre>


<p>查询数据：</p>


<pre><code>User.objects.filter(name="test2")
</code></pre>


<p>删除数据：</p>


<pre><code>User.objects.filter(name="test2").delete()
</code></pre>


<p>MongoEngine虽然提供了ODM，但是我们同样还是可以直接对数据库进行操作。<br>
获取 pymongo 的 collection 对象：</p>


<pre><code>User.objects._collection
</code></pre>


<p>然后就可以使用原生的pymongo操作了。</p>

</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
    <h1 class="entry-title"><a href="http://www.xefan.com/archives/84060.html">Pymongo教程(3)——自定义数据类型</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2014-03-30T00:00:00+08:00'><span class='date'><span class='date-month'>Mar</span> <span class='date-day'>30</span><span class='date-suffix'>th</span>, <span class='date-year'>2014</span></span> <span class='time'>12:00 am</span></time>
        
           | <a href="http://www.xefan.com/archives/84060.html#disqus_thread"
             data-disqus-identifier="http://www.xefan.com/archives/84060.html">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><p>pymongo提供一些常用的数据类型，如：数据、字符串、日期等。如果感觉还不能满足需求，那么还可以自定义数据类型。</p>


<p>首先定义一个类：</p>


<pre><code>class Custom(object):
    def __init__(self, x):
        self.__x = x

    def x(self):
        return self.__x
</code></pre>


<p>要将自定义类型的数据存入数据库中需要先进行编码；将数据从数据库读取出来后又需要再解码。</p>


<h2>手动编码/解码</h2>


<p>我们可以定义两个方法，在插入和查询数据时进行手动的编码、解码。</p>


<pre><code>def encode_custom(custom):
    return {"_type": "custom", "x": custom.x()}

def decode_custom(document):
    assert document["_type"] == "custom"
    return Custom(document["x"])

print(db.test.insert({"custom": encode_custom(Custom(5))}))
print(db.test.find_one()['custom'])
</code></pre>


<h2>自动编码/解码</h2>


<p>手动地进行编码虽然可行，但是还是不太方便。我们还可以使用 SONManipulator 进行自动编码。</p>


<pre><code>from pymongo.son_manipulator import SONManipulator
class Transform(SONManipulator):
    def transform_incoming(self, son, collection):
        for (key, value) in son.items():
            if isinstance(value, Custom):
                son[key] = encode_custom(value)
            elif isinstance(value, dict): # Make sure we recurse into sub-docs
                son[key] = self.transform_incoming(value, collection)
        return son

    def transform_outgoing(self, son, collection):
        for (key, value) in son.items():
            if isinstance(value, dict):
                if "_type" in value and value["_type"] == "custom":
                    son[key] = decode_custom(value)
                else: # Again, make sure to recurse into sub-docs
                    son[key] = self.transform_outgoing(value, collection)
        return son

db.add_son_manipulator(Transform())
print(db.test.insert({"custom": Custom(5)}))
print(db.test.find_one())
</code></pre>


<h2>二进制编码</h2>


<p>我们也可以将其编码成二进制进行存储。</p>


<pre><code>from bson.binary import Binary
def to_binary(custom):
    return Binary(str(custom.x()), 128)

def from_binary(binary):
    return Custom(int(binary))

class TransformToBinary(SONManipulator):
    def transform_incoming(self, son, collection):
        for (key, value) in son.items():
            if isinstance(value, Custom):
                son[key] = to_binary(value)
            elif isinstance(value, dict):
                son[key] = self.transform_incoming(value, collection)
        return son

    def transform_outgoing(self, son, collection):
        for (key, value) in son.items():
            if isinstance(value, Binary) and value.subtype == 128:
                son[key] = from_binary(value)
            elif isinstance(value, dict):
                son[key] = self.transform_outgoing(value, collection)
        return son

db.add_son_manipulator(TransformToBinary())
print(db.test.insert({"custom": Custom(5)}))
print(db.test.find_one())
</code></pre>

</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
    <h1 class="entry-title"><a href="http://www.xefan.com/archives/84057.html">Pymongo教程(2)——聚合操作</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2014-03-29T00:00:00+08:00'><span class='date'><span class='date-month'>Mar</span> <span class='date-day'>29</span><span class='date-suffix'>th</span>, <span class='date-year'>2014</span></span> <span class='time'>12:00 am</span></time>
        
           | <a href="http://www.xefan.com/archives/84057.html#disqus_thread"
             data-disqus-identifier="http://www.xefan.com/archives/84057.html">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><p>在MongoDB中常用的聚合操作有 aggregation、map/reduce和group 。</p>


<p>首先先添加一些测试数据：</p>


<pre><code>db.things.insert({"x": 1, "tags": ["dog", "cat"]})
db.things.insert({"x": 2, "tags": ["cat"]})
db.things.insert({"x": 2, "tags": ["mouse", "cat", "dog"]})
db.things.insert({"x": 3, "tags": []})
</code></pre>


<h2>aggregation</h2>


<p>以下例子是统计 tags 字段内的各个值的出现的次数。</p>


<pre><code>from bson.son import SON
db.things.aggregate([
    {"$unwind": "$tags"},
    {"$group": {"_id": "$tags", "count": {"$sum": 1}}},
    {"$sort": SON([("count", -1), ("_id", -1)])}
])

{'ok': 1.0, 'result': [{'count': 3, '_id': 'cat'}, {'count': 2, '_id': 'dog'}, {'count': 1, '_id': 'mouse'}]}
</code></pre>


<p>注意：aggregate操作要求服务器程序为 2.1.0 以上的版本。PyMongo 驱动程序为 2.3 以上的版本。</p>


<h2>Map/Reduce</h2>


<p>上面的操作同样也可以使用 Map/Reduce 完成。</p>


<pre><code>from bson.code import Code
mapper = Code("""
    function () {
      this.tags.forEach(function(z) {
        emit(z, 1);
      });
    }
""")

reducer = Code("""
    function (key, values) {
      var total = 0;
      for (var i = 0; i &lt; values.length; i++) {
        total += values[i];
      }
      return total;
    }
""")

result = db.things.map_reduce(mapper, reducer, "myresults")
for doc in result.find():
    print(doc)

{u'_id': u'cat', u'value': 3.0}
{u'_id': u'dog', u'value': 2.0}
{u'_id': u'mouse', u'value': 1.0}
</code></pre>


<p>map和reduce都是一个javascript的函数； map_reduce 方法会将统计结果保存到一个临时的数据集合中。</p>


<h2>Group</h2>


<p>group 操作与SQL的 GROUP BY 相似，同时比 Map/Reduce 要简单。</p>


<pre><code>reducer = Code("""
    function(obj, prev){
      prev.count++;
    }
""")

results = db.things.group(key={"x":1}, condition={}, initial={"count": 0}, reduce=reducer)
for doc in results:
    print(doc)

{'x': 1.0, 'count': 1.0}
{'x': 2.0, 'count': 2.0}
{'x': 3.0, 'count': 1.0}
</code></pre>


<p>注意：在MongoDB的集群环境中不支持 group 操作，可以使用 aggregation 或者 map/reduce 代替。</p>


<p>完整的MongoDB聚合文档： http://docs.mongodb.org/manual/aggregation/</p>

</div>
  
  


    </article>
  
  <div class="pagination">
    
      <a class="prev" href="/page/4">&larr; Older</a>
    
    <a href="/blog/archives">Blog Archives</a>
    
    <a class="next" href="/page/2">Newer &rarr;</a>
    
  </div>
</div>
<aside class="sidebar">
  
    <section>
  <h1>Subscription</h1>
  <!--以下是QQ邮件列表订阅嵌入代码--><script >var nId = "e7ee5da6d322dc7157c25cfd8a7700bb23a056dd1fb18cb4",nWidth="auto",sColor="light",sText="请输入邮件地址：" ;</script><script src="http://list.qq.com/zh_CN/htmledition/js/qf/page/qfcode.js" charset="gb18030"></script>
</section>
<section>
  <h1>Recent Posts</h1>
  <ul id="recent_posts">
    
      <li class="post">
        <a href="http://www.xefan.com/archives/84139.html">Mongodb分片配置实例</a>
      </li>
    
      <li class="post">
        <a href="http://www.xefan.com/archives/84138.html">使用gunicorn部署Django</a>
      </li>
    
      <li class="post">
        <a href="http://www.xefan.com/archives/84137.html">Mongodb集群配置实例</a>
      </li>
    
      <li class="post">
        <a href="http://www.xefan.com/archives/84136.html">使用VIM进行PHP远程调试</a>
      </li>
    
      <li class="post">
        <a href="http://www.xefan.com/archives/84135.html">Nginx + Uwsgi + Django环境配置</a>
      </li>
    
  </ul>
</section>
<section>
  <h1>Categories</h1>
    <ul id="category-list"><li><a href='/categories/linux栏目/index.html'>linux栏目 (47)</a></li><li><a href='/categories/python栏目/index.html'>python栏目 (34)</a></li><li><a href='/categories/ruby栏目/index.html'>ruby栏目 (26)</a></li><li><a href='/categories/web开发/index.html'>web开发 (18)</a></li><li><a href='/categories/嵌入式栏目/index.html'>嵌入式栏目 (11)</a></li><li><a href='/categories/开源软件/index.html'>开源软件 (20)</a></li><li><a href='/categories/教程/index.html'>教程 (15)</a></li><li><a href='/categories/数据库/index.html'>数据库 (9)</a></li><li><a href='/categories/数据结构和算法/index.html'>数据结构和算法 (16)</a></li><li><a href='/categories/编程开发/index.html'>编程开发 (38)</a></li><li><a href='/categories/网络日志/index.html'>网络日志 (11)</a></li><li><a href='/categories/资源分享/index.html'>资源分享 (23)</a></li></ul>
</section>
<section>
  <h1>Tag Cloud</h1>
    <span id="tag-cloud"><a href='/tags/access/index.html' style='font-size: 105.45454545454545%'>access(6)</a> <a href='/tags/adobe/index.html' style='font-size: 100.9090909090909%'>adobe(1)</a> <a href='/tags/ajax/index.html' style='font-size: 101.81818181818181%'>ajax(2)</a> <a href='/tags/apache/index.html' style='font-size: 100.9090909090909%'>apache(1)</a> <a href='/tags/arch/index.html' style='font-size: 106.36363636363636%'>Arch(7)</a> <a href='/tags/arm/index.html' style='font-size: 107.27272727272727%'>ARM(8)</a> <a href='/tags/asp/index.html' style='font-size: 106.36363636363636%'>asp(7)</a> <a href='/tags/c/index.html' style='font-size: 111.81818181818181%'>C(13)</a> <a href='/tags/css/index.html' style='font-size: 101.81818181818181%'>css(2)</a> <a href='/tags/django/index.html' style='font-size: 102.72727272727273%'>Django(3)</a> <a href='/tags/dreamweaver/index.html' style='font-size: 100.9090909090909%'>Dreamweaver(1)</a> <a href='/tags/fedora/index.html' style='font-size: 101.81818181818181%'>Fedora(2)</a> <a href='/tags/firefox/index.html' style='font-size: 102.72727272727273%'>firefox(3)</a> <a href='/tags/flash/index.html' style='font-size: 100.9090909090909%'>Flash(1)</a> <a href='/tags/ftp/index.html' style='font-size: 100.9090909090909%'>ftp(1)</a> <a href='/tags/gcc/index.html' style='font-size: 105.45454545454545%'>gcc(6)</a> <a href='/tags/gentoo/index.html' style='font-size: 101.81818181818181%'>Gentoo(2)</a> <a href='/tags/git/index.html' style='font-size: 103.63636363636364%'>git(4)</a> <a href='/tags/gobject/index.html' style='font-size: 105.45454545454545%'>GObject(6)</a> <a href='/tags/grub/index.html' style='font-size: 100.9090909090909%'>grub(1)</a> <a href='/tags/gtk/index.html' style='font-size: 115.45454545454545%'>gtk(17)</a> <a href='/tags/hash/index.html' style='font-size: 100.9090909090909%'>Hash(1)</a> <a href='/tags/ibus/index.html' style='font-size: 100.9090909090909%'>ibus(1)</a> <a href='/tags/js/index.html' style='font-size: 100.9090909090909%'>js(1)</a> <a href='/tags/linux/index.html' style='font-size: 160.0%'>Linux(66)</a> <a href='/tags/mongodb/index.html' style='font-size: 110.9090909090909%'>mongodb(12)</a> <a href='/tags/mysql/index.html' style='font-size: 103.63636363636364%'>mysql(4)</a> <a href='/tags/nginx/index.html' style='font-size: 100.9090909090909%'>nginx(1)</a> <a href='/tags/node/index.html' style='font-size: 100.9090909090909%'>node(1)</a> <a href='/tags/php/index.html' style='font-size: 109.0909090909091%'>php(10)</a> <a href='/tags/ps/index.html' style='font-size: 105.45454545454545%'>PS(6)</a> <a href='/tags/pygame/index.html' style='font-size: 110.9090909090909%'>pygame(12)</a> <a href='/tags/python/index.html' style='font-size: 146.36363636363637%'>python(51)</a> <a href='/tags/qt/index.html' style='font-size: 101.81818181818181%'>Qt(2)</a> <a href='/tags/redis/index.html' style='font-size: 100.9090909090909%'>Redis(1)</a> <a href='/tags/ruby/index.html' style='font-size: 123.63636363636364%'>Ruby(26)</a> <a href='/tags/scrapy/index.html' style='font-size: 102.72727272727273%'>Scrapy(3)</a> <a href='/tags/shell/index.html' style='font-size: 100.9090909090909%'>shell(1)</a> <a href='/tags/tq2440/index.html' style='font-size: 104.54545454545455%'>TQ2440(5)</a> <a href='/tags/ubuntu/index.html' style='font-size: 106.36363636363636%'>ubuntu(7)</a> <a href='/tags/usb/index.html' style='font-size: 102.72727272727273%'>USB(3)</a> <a href='/tags/vim/index.html' style='font-size: 123.63636363636364%'>vim(26)</a> <a href='/tags/virtualbox/index.html' style='font-size: 102.72727272727273%'>VirtualBox(3)</a> <a href='/tags/vmware/index.html' style='font-size: 100.9090909090909%'>vmware(1)</a> <a href='/tags/w3m/index.html' style='font-size: 100.9090909090909%'>w3m(1)</a> <a href='/tags/web开发/index.html' style='font-size: 112.72727272727272%'>Web开发(14)</a> <a href='/tags/windows/index.html' style='font-size: 106.36363636363636%'>windows(7)</a> <a href='/tags/wordpress/index.html' style='font-size: 100.9090909090909%'>WordPress(1)</a> <a href='/tags/xml/index.html' style='font-size: 100.9090909090909%'>xml(1)</a> <a href='/tags/免费/index.html' style='font-size: 100.9090909090909%'>免费(1)</a> <a href='/tags/内核/index.html' style='font-size: 100.9090909090909%'>内核(1)</a> <a href='/tags/匹配算法/index.html' style='font-size: 105.45454545454545%'>匹配算法(6)</a> <a href='/tags/单片机/index.html' style='font-size: 101.81818181818181%'>单片机(2)</a> <a href='/tags/嵌入式/index.html' style='font-size: 100.9090909090909%'>嵌入式(1)</a> <a href='/tags/开源软件/index.html' style='font-size: 108.18181818181819%'>开源软件(9)</a> <a href='/tags/排序算法/index.html' style='font-size: 108.18181818181819%'>排序算法(9)</a> <a href='/tags/文件空间/index.html' style='font-size: 100.9090909090909%'>文件空间(1)</a> <a href='/tags/无线网/index.html' style='font-size: 100.9090909090909%'>无线网(1)</a> <a href='/tags/正则式/index.html' style='font-size: 100.9090909090909%'>正则式(1)</a> <a href='/tags/注册机/index.html' style='font-size: 101.81818181818181%'>注册机(2)</a> <a href='/tags/游戏/index.html' style='font-size: 109.0909090909091%'>游戏(10)</a> <a href='/tags/电脑技巧/index.html' style='font-size: 108.18181818181819%'>电脑技巧(9)</a> <a href='/tags/空间/index.html' style='font-size: 100.9090909090909%'>空间(1)</a> <a href='/tags/算法/index.html' style='font-size: 114.54545454545455%'>算法(16)</a> <a href='/tags/红旗/index.html' style='font-size: 100.9090909090909%'>红旗(1)</a> <a href='/tags/经典语录/index.html' style='font-size: 100.9090909090909%'>经典语录(1)</a> <a href='/tags/网络日志/index.html' style='font-size: 105.45454545454545%'>网络日志(6)</a> <a href='/tags/翻译/index.html' style='font-size: 120.9090909090909%'>翻译(23)</a> <a href='/tags/视频教程/index.html' style='font-size: 109.0909090909091%'>视频教程(10)</a> <a href='/tags/资源分享/index.html' style='font-size: 110.9090909090909%'>资源分享(12)</a> <a href='/tags/转载/index.html' style='font-size: 101.81818181818181%'>转载(2)</a> <a href='/tags/随笔/index.html' style='font-size: 100.9090909090909%'>随笔(1)</a> </span>
</section>
<section>
  <h1>Link</h1>
    <ul id="category-list">
      <li><a target="_blank" title="我的Github" href="https://github.com/wusuopu">@Github</a></li>
      <li><a target="_blank" title="我的微博" href="http://www.weibo.com/u/1768691343">@Weibo</a></li>
      <li><a target="_blank" title="我的Twitter" href="https://twitter.com/longchangjin">@Twitter</a></li>
      <li><a target="_blank" title="我的豆瓣" href="http://www.douban.com/people/lchj/">@Douban</a></li>

      <li><a target="_blank" title="" href="http://www.vimer.cn/">Vimer的程序世界</a></li>
      <li><a target="_blank" title="" href="http://pythoner.net/">python开发者社区</a></li>
      <li><a target="_blank" title="" href="http://simple-is-better.com/">python.cn(news, jobs)</a></li>
      <li><a target="_blank" title="" href="http://gtk.awaysoft.com/">GTK+ 中文社区</a></li>
    </ul>
</section>

  
</aside>

    </div>
  </div>
  <footer role="contentinfo"><p>
  Copyright &copy; 2014 - 龍昌 -
  <span class="credit">Powered by <a href="http://octopress.org">Octopress</a></span>
</p>
<div style="display:none;"><script src="http://s94.cnzz.com/stat.php?id=1259846&web_id=1259846&show=pic" language="JavaScript"></script></div>

</footer>
  

<script type="text/javascript">
      var disqus_shortname = 'longchang';
      
        
        var disqus_script = 'count.js';
      
    (function () {
      var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
      dsq.src = '//' + disqus_shortname + '.disqus.com/' + disqus_script;
      (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    }());
</script>











</body>
</html>
