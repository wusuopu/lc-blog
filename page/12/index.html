<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>龍昌博客</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="关注Linux及开源信息">
<meta property="og:type" content="website">
<meta property="og:title" content="龍昌博客">
<meta property="og:url" content="http://www.xefan.com/page/12/index.html">
<meta property="og:site_name" content="龍昌博客">
<meta property="og:description" content="关注Linux及开源信息">
<meta property="og:locale">
<meta property="article:author" content="龍昌">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="龍昌博客" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
<link rel="stylesheet" href="/css/style.css">

  

<meta name="generator" content="Hexo 6.1.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">龍昌博客</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
          <a class="main-nav-link" href="/about">About</a>
        
          <a class="main-nav-link" href="/gbook">留言板</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://www.xefan.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-[翻译]Ruby教程8——表达式" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/archives/83926.html" class="article-date">
  <time datetime="2013-11-10T11:49:31.000Z" itemprop="datePublished">2013-11-10</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Ruby%E6%A0%8F%E7%9B%AE/">Ruby栏目</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/archives/83926.html">[翻译]Ruby教程8——表达式</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><h1>表达式</h1></p>
<p>在这章的教程将介绍Ruby的表达式。</p><br><p>表达式是由操作数和操作符构成的。表达式的操作符表明了对操作数应用什么操作。表达式中操作符的求值顺序由操作符的优先级和结合律决定的。</p><br><p>操作符是一个特殊的符号表明了要执行的确切操作。编程语言中的操作符取自数学运算。程序员使用数据，操作符用于处理数据。操作数是操作符的参数。</p><br><p>以下表格中按优先级展示Ruby的操作符（高优先级在前）：</p><br><table><br>    <thead><br>        <tr><br>            <td>分类</td><br>            <td>符号</td><br>        </tr><br>    </thead><br>    <tbody><br>        <tr><br>            <td>解析，访问操作符</td><br>            <td>:: .</td><br>        </tr><br>        <tr><br>            <td>数组操作符</td><br>            <td>[] []=</td><br>        </tr><br>        <tr><br>            <td>求幂</td><br>            <td><strong></td><br>        </tr><br>        <tr><br>            <td>非，反，一元加、减</td><br>            <td>! ~ + -</td><br>        </tr><br>        <tr><br>            <td>乘、除、模</td><br>            <td><em> / %</td><br>        </tr><br>        <tr><br>            <td>加、减</td><br>            <td>+ -</td><br>        </tr><br>        <tr><br>            <td>移位</td><br>            <td>&lt;&lt; &gt;&gt;</td><br>        </tr><br>        <tr><br>            <td>位与</td><br>            <td>&amp;</td><br>        </tr><br>        <tr><br>            <td>位或、逻辑或</td><br>            <td>^ |</td><br>        </tr><br>        <tr><br>            <td>关系运算</td><br>            <td>&gt; &gt;= &lt; &lt;=</td><br>        </tr><br>        <tr><br>            <td>相等、模式匹配</td><br>            <td>&lt;=&gt; == === != =~ !~</td><br>        </tr><br>        <tr><br>            <td>逻辑与</td><br>            <td>&amp;&amp;</td><br>        </tr><br>        <tr><br>            <td>逻辑或</td><br>            <td>||</td><br>        </tr><br>        <tr><br>            <td>范围操作符</td><br>            <td>.. …</td><br>        </tr><br>        <tr><br>            <td>三目运算</td><br>            <td>?:</td><br>        </tr><br>        <tr><br>            <td>分配操作</td><br>            <td>= += -= </em>= </strong>= /= %= &amp;= |= ^= &lt;&lt;= &gt;&gt;= ||= &amp;&amp;=</td><br>        </tr><br>        <tr><br>            <td>否定</td><br>            <td>not</td><br>        </tr><br>        <tr><br>            <td>逻辑或、与</td><br>            <td>or and</td><br>        </tr><br>    </tbody><br></table><br><br><p>同一行的操作符具有相同的优先级。</p><br><p>一个操作符通常有两个操作数。那些只有一个操作数的操作符称为一元操作符。有两个操作数的称为二元操作符。有一个三元操作符(?:)有三个操作数。</p><br><p>操作符可能用于不同的上下文。例如+操作符，从上面的表格可知它能用于不同情况。数字求和、连接字符串、作为数字的符号。我们称这个操作符被重载了。</p><br><h2>正负号操作符</h2><br><p>有两个正负号操作符，+和-，用于指定或者修改值的符号。</p><br><pre><code>#!/usr/bin/ruby<br><br>puts +2<br>puts -2<br></code></pre><br><p>+和-指明了值的符号。加号表明是正数，通常可省略。</p><br><hr><br><p>接下来的例子我们使用减号。</p><br><pre><code>#!/usr/bin/ruby<br><br>a = 1<br><br>puts a<br>puts -(a)<br>puts -(-(a))<br></code></pre><br><p>减号改变了值的符号。</p><br><p>$ ./sign.rb<br><br>1<br><br>-1<br><br>1  </p><br><p>输出结果。</p><br><h2>分配操作符</h2><br><p>分配操作符<em>=</em>将一个值分配给一个变量。变量是这个值的点位符。数学运算中<em>=</em>操作符有不同的意义。在方程式中<em>=</em>是相等操作，左边的值等于右边的值。</p><br><pre><code>x = 1<br>puts x # prints 1<br></code></pre><br><p>这里分配的一个数字给<em>x</em>变量。</p><br><pre><code>x = x + 1<br>puts x # prints 2<br></code></pre><br><p>前一个表达式中数学运算中是行不通的。但是在程序中是合法的。这个表达式是将<em>x</em>变量加1，右边等于2,并把2赋值给x。</p><br><pre><code>3 = x;<br></code></pre><br><p>这个语法是错误的，我们不能组值分配字面符。</p><br><h2>解析，成员访问操作符</h2><br><p>有两个操作符具有最高的优先级，这意味着它们总是先求解。</p><br><pre><code>#!/usr/bin/ruby<br><br>class MyMath<br>    Pi = 3.1415926535<br>end<br><br>module People<br>    Name = “People”<br>end<br><br>puts MyMath::Pi<br>puts People::Name<br></code></pre><br><p>第一个例子展示了<em>::</em>命名空间解析操作符。它可以访问一个定义在其它类或模块里的常量、模块或者类。它用于提供命名空间，这样方法和类的名字就不会与其他作者的类冲突了。</p><br><pre><code>class MyMath<br>    Pi = 3.1415926535<br>end<br><br>module People<br>    Name = “People”<br>end<br></code></pre><br><p>这里创建了一个模块的一个类，分别定义了一个常量。</p><br><pre><code>puts MyMath::Pi<br>puts People::Name<br></code></pre><br><p>我们使用<em>::</em>操作符访问它们的常量。</p><br><p>$ ./resolution.rb<br><br>3.1415926535<br><br>People  </p><br><p><em>resolution.rb</em>脚本的输出结果。</p><br><hr><br><p>点(.)操作符是成员访问，用于调用对象的方法。</p><br><pre><code>#!/usr/bin/ruby<br><br>class Person<br><br>   def initialize name, age<br>       @name = name<br>       @age = age<br>   end<br><br>   def info<br>       “#&#123;@name&#125; is #&#123;@age&#125; years old”<br>   end<br><br>end<br><br>p = Person.new “Jane”, 17<br>puts p.info<br><br>puts “ZetCode”.reverse<br></code></pre><br><p>这个例子中我们创建了两个对象，一个是用户定义的，一个是预定义的。我们对这些对象使用点操作符。</p><br><pre><code>p = Person.new “Jane”, 17<br>puts p.info<br></code></pre><br><p>在这行使用点操作符调用了两个方法：new和info。</p><br><pre><code>puts “ZetCode”.reverse<br></code></pre><br><p>字符串是内建对象，具有一个<em>reverse</em>方法。</p><br><p>$ ./memberaccess.rb<br><br>Jane is 17 years old<br><br>edoCteZ  </p><br><p>输出结果。</p><br><h2>字符串连接</h2><br><p>Ruby中<em>+</em>操作符同样可以用于字符串连接。在不同上下文中操作符作用不同，我们称这个为重载。</p><br><pre><code>#!/usr/bin/ruby<br><br>puts “Return “ + “of “ + “the “ + “King”<br>puts “Return “.+”of “.+ “the “.+”King”<br></code></pre><br><p>我们将三个字符串连接在一起。</p><br><pre><code>puts “Return “ + “of “ + “the “ + “King”<br></code></pre><br><p>我们使用<em>+</em>操作符连接字符串。</p><br><pre><code>puts “Return “.+”of “.+ “the “.+”King”<br></code></pre><br><p><em>+</em>操作符也是Ruby的一个方法。我们可以使用访问操作符(.)来调用它。</p><br><p>$ ./catstrings.rb <br><br>Return of the King<br><br>Return of the King  </p><br><p><em>catstrings.rb</em>程序的运行结果。</p><br><h2>增、减操作符</h2><br><p>Ruby中没有如下操作。<br><br>x++;<br><br>…<br><br>y–;  </p><br><p>这些是C语言的增、减操作。</p><br><p>如果你熟悉Java、C、C++，你可能了解这些操作符。但是这些在Ruby中无效的。同样在Python中也没有。</p><br><h2>算术操作符</h2><br><p>下面的表格是Ruby中的算术操作符。  </p><br><table><br><thead><br><tr><br><th align="left">符号</th><br><th align="left">名字</th><br></tr><br></thead><br><tbody><br><tr><br><td align="left">+</td><br><td align="left">加</td><br></tr><br><tr><br><td align="left">-</td><br><td align="left">减</td><br></tr><br><tr><br><td align="left"><em></td><br><td align="left">乘</td><br></tr><br><tr><br><td align="left">/</td><br><td align="left">除</td><br></tr><br><tr><br><td align="left">%</td><br><td align="left">模</td><br></tr><br><tr><br><td align="left">**</td><br><td align="left">幂</td><br></tr><br></tbody><br></table><br><p>下面的例子中我们使用了算术操作符。</p><br><pre><code>#!/usr/bin/ruby<br><br>a = 10<br>b = 11<br>c = 12<br><br>puts a + b + c<br>puts c - a<br>puts a </em> b<br>puts c / 3<br>puts c % a<br>puts c <strong> a<br></code></pre><br><p>在前面的例子我们使用了加、减、乘、除和取余操作。这些与数学上的是相同的。</p><br><pre><code>puts c % a<br></code></pre><br><p><em>%</em>操作符是取余或者求模。</p><br><p>$ ./arithmetic.rb<br><br>33<br><br>2<br><br>110<br><br>4<br><br>2<br><br>61917364224  </p><br><p>输出结果。</p><br><hr><br><p>接下来展示整数和浮点数除法的区别。</p><br><pre><code>#!/usr/bin/ruby<br><br>puts 5 / 2<br><br>puts 5 / 2.0<br>puts 5.0 / 2<br>puts 5.to_f / 2<br></code></pre><br><p>上面的例子我们将两个数相除。</p><br><pre><code>puts 5 / 2<br></code></pre><br><p>这个表达式中的操作数都是整数，我们进行的是整数相除。结果返回的也是整数。</p><br><pre><code>puts 5 / 2.0<br>puts 5.0 / 2<br>puts 5.to_f / 2<br></code></pre><br><p>如果其中一个或两个是浮点数，我们进行的是浮点数相除。</p><br><p>$ ./division.rb<br><br>2<br><br>2.5<br><br>2.5<br><br>2.5  </p><br><p><em>division.rb</em>程序的运行结果。</p><br><hr><br><p>Ruby有其他方式进行除运算。这些都是有效的方法调用。</p><br><pre><code>#!/usr/bin/ruby<br><br>puts 5.div 2.0<br>puts 5.fdiv 2<br>puts 5.quo 2<br>puts 5.0.quo 2.0<br></code></pre><br><p>上面例子中我们使用了<em>div</em>、<em>fdiv</em>和<em>quo</em>方法。</p><br><pre><code>puts 5.div 2.0<br></code></pre><br><p><em>div</em>总是进行整数除，即使操作数是浮点数。</p><br><pre><code>puts 5.fdiv 2<br></code></pre><br><p><em>fdiv</em>总是进行浮点数除法。</p><br><pre><code>puts 5.quo 2<br>puts 5.0.quo 2.0<br></code></pre><br><p><em>quo</em>方法进行精确的除法。如果操作数是浮点数则返回浮点数，否则是有理数。</p><br><p>$ ./otherdivision.rb<br><br>2<br><br>2.5<br><br>5/2<br><br>2.5  </p><br><h2>布尔操作符</h2><br><p>Ruby中有以下布尔操作符。</p><br><table><br>    <thead><br>        <tr><br>            <td>符号</td><br>            <td>名字</td><br>        </tr><br>    </thead><br>    <tbody><br>        <tr><br>            <td>&amp;&amp;</td><br>            <td>逻辑与</td><br>        </tr><br>        <tr><br>            <td>||</td><br>            <td>逻辑或</td><br>        </tr><br>        <tr><br>            <td>!</td><br>            <td>否</td><br>        </tr><br>    </tbody><br></table><br><br><p>布尔操作符处理真假值。Ruby中有额外的布尔操作符，<em>and</em>、<em>or</em>、<em>&amp;</em>、<em>not</em>。它们操作是相同的，只是优先级低一些。与Perl语言不同，这需要一个低优先级的布尔操作符。</p><br><pre><code>#!/usr/bin/ruby<br><br>x = 3<br>y = 8<br><br>puts x == y<br>puts y &gt; x<br><br>if y &gt; x then<br>    puts “y is greater than x”<br>end<br></code></pre><br><p>许多表达式的结果都是一个布尔值。布尔值用于条件语句。</p><br><pre><code>puts x == y<br>puts y &gt; x<br></code></pre><br><p>返回布尔值的相关操作符。这两行打印为false和true。</p><br><pre><code>if y &gt; x then<br>    puts “y is greater than x”<br>end<br></code></pre><br><p>仅当月<em>if</em>条件为真时<em>if</em>里的语句才会执行。x &gt; y返回true，因此”y is greater than x”会在终端上打印。</p><br><hr><br><p>下面的例子展示逻辑与操作符。</p><br><pre><code>#!/usr/bin/ruby<br><br>puts true &amp;&amp; true<br>puts true &amp;&amp; false<br>puts false &amp;&amp; true<br>puts false &amp;&amp; false<br></code></pre><br><p>与操作只有在操作数都为true才返回true。</p><br><p>$ ./andoperator.rb<br><br>true<br><br>false<br><br>false<br><br>false  </p><br><p>只有一个表达式的结果为true。</p><br><hr><br><p>逻辑或操作符当有一个操作数为true则返回true。</p><br><pre><code>#!/usr/bin/ruby<br><br>puts true || true<br>puts true || false<br>puts false || true<br>puts false || false<br></code></pre><br><p>如果有一边是true，操作的结果就是true。</p><br><p>$ ./oroperator.rb<br><br>true<br><br>true<br><br>true<br><br>false  </p><br><p>三个表达式结果为true。</p><br><hr><br><p>非操作进行真假反转。</p><br><pre><code>#!/usr/bin/ruby<br><br>puts !0<br>puts !1<br>puts !true<br>puts !false<br><br>puts ! (4&lt;3)<br>puts ! “Ruby”.include?(“a”)<br></code></pre><br><p>这个例子展示了非操作符的用法。</p><br><p>$ ./not.rb<br><br>false<br><br>false<br><br>false<br><br>true<br><br>true<br><br>true  </p><br><p>输出结果。</p><br><hr><br><p><em>||</em>和<em>&amp;&amp;</em>操作符是短路求值（short circuit evaluated）。短路求值意味着只有在第一个参数不足以确定表达式的值时第二个参数才会进行求值。短求值主要用于提高执行效率。</p><br><p>用一个例子解释。</p><br><pre><code>#!/usr/bin/ruby<br><br>def one<br>    puts “Inside one”<br>    false<br>end<br><br>def two<br>    puts “Inside two”<br>    true<br>end<br><br>puts “Short circuit”<br><br>if one &amp;&amp; two<br>    puts “Pass”<br>end<br><br>puts “##############################”<br><br>if two || one<br>    puts “Pass”<br>end<br></code></pre><br><p>在例子中定义了两个方法，用于在布尔操作中作为操作数。我们将看到它们是否被调用了。</p><br><pre><code>if one &amp;&amp; two<br>    puts “Pass”<br>end<br></code></pre><br><p>第一个方法返回false，短路求值不会计算第二个方法。一旦一个操作数是false，那么这个逻辑的结果总是false。</p><br><pre><code>puts “##############################”<br><br>if two || one<br>    puts “Pass”<br>end<br></code></pre><br><p>第二种情况我们使用<em>||</em>操作符，并且第一个操作数为<em>tow</em>方法。这里同样没有必要对第二个操作数求值，只要第一个操作数为true，那么逻辑或总是为true。</p><br><pre><code>$ ./shortcircuit.rb<br>Short circuit<br>Inside one<br>##############################<br>Inside two<br>Pass<br></code></pre><br><p><em>shortcircuit.rb</em>程序的运行结果。</p><br><h2>关系操作符</h2><br><p>关系操作符用于值的比较，其总是返回布尔值。</p><br><table><br><thead><br><tr><br><th align="left">符号</th><br><th align="left">含义</th><br></tr><br></thead><br><tbody><br><tr><br><td align="left">&lt;</td><br><td align="left">小于</td><br></tr><br><tr><br><td align="left">&lt;=</td><br><td align="left">小于等于</td><br></tr><br><tr><br><td align="left">&gt;</td><br><td align="left">大于</td><br></tr><br><tr><br><td align="left">&gt;=</td><br><td align="left">大于等于</td><br></tr><br></tbody><br></table><br><p>关系操作符又称为比较操作符。</p><br><pre><code>#!/usr/bin/ruby<br><br>p 3 &lt; 4<br>p 3 &gt; 5<br>p 3 &gt;= 3<br></code></pre><br><p>表达式<em>3 &lt; 4</em>返回true，因为3小于4。表达式<em>3 &gt; 5</em>返回false，因为3不大于5。</p><br><h2>位操作符</h2><br><p>人类用的是十进制数字，计算机原生的是二进制数。二进制、八进制、十进制和十六进制只是数字的符号。位操作符针对的是二进制数。</p><br><table><br>    <thead><br>        <tr><br>            <td>符号</td><br>            <td>含义</td><br>        </tr><br>    </thead><br>    <tbody><br>        <tr><br>            <td>~</td><br>            <td>按位取反</td><br>        </tr><br>        <tr><br>            <td>^</td><br>            <td>按位异或</td><br>        </tr><br>        <tr><br>            <td>&amp;</td><br>            <td>按位与</td><br>        </tr><br>        <tr><br>            <td>|</td><br>            <td>按位与或</td><br>        </tr><br>        <tr><br>            <td>&lt;&lt;</td><br>            <td>左移位</td><br>        </tr><br>        <tr><br>            <td>&gt;&gt;</td><br>            <td>右移位</td><br>        </tr><br>    </tbody><br></table><br><br><p>位操作在高级语言中很少使用。</p><br><pre><code>#!/usr/bin/ruby<br><br>puts ~ 7   # prints -8<br>puts ~ -8  # prints 7<br><br>puts 6 &amp; 3  # prints 2<br>puts 3 &amp; 6  # prints 2<br><br>puts 6 ^ 3  # prints 5<br>puts 3 ^ 6  # prints 5<br><br>puts 6 | 3  # prints 7<br>puts 3 | 6  # prints 7<br><br>puts 6 &lt;&lt; 1  # prints 12<br>puts 1 &lt;&lt; 6  # prints 64<br><br>puts 6 &gt;&gt; 1  # prints 3<br>puts 1 &gt;&gt; 6  # prints 0<br></code></pre><br><p>上面的例子中展示了这6个位操作符。</p><br><pre><code>puts ~ 7   # prints -8<br>puts ~ -8  # prints 7<br></code></pre><br><p>按位取反是将1变为0，0变为1。将操作会将数字7所有的位都反转，同样包括符号位。如果再次反转所有的位即会得到数字7。</p><br><pre><code>puts 6 &amp; 3  # prints 2<br>puts 3 &amp; 6  # prints 2<br></code></pre><br><p>按位与是将两个数进行逐位与操作，只有两个数对应位的都为1结果才为1。</p><br><pre><code>puts 6 ^ 3  # prints 5<br>puts 3 ^ 6  # prints 5<br></code></pre><br><p>按位异或是将两个数进行逐位异或操作，只要其中一个数（但不是全部）对应位的为1结果就为1。</p><br><pre><code>puts 6 | 3  # prints 7<br>puts 3 | 6  # prints 7<br></code></pre><br><p>按位或是将两个数进行逐位或操作，只要其中一个数对应位的为1结果就为1。</p><br><pre><code>puts 6 &lt;&lt; 1  # prints 12<br>puts 1 &lt;&lt; 6  # prints 64<br><br>puts 6 &gt;&gt; 1  # prints 3<br>puts 1 &gt;&gt; 6  # prints 0<br></code></pre><br><p>移位操作符是按位进行右移或左移，也称为算术移位。</p><br><h2>复合分配操作符</h2><br><p>复合分配操作符是由两个操作符构成。它们是简写操作符。</p><br><pre><code>#!/usr/bin/ruby<br><br>a = 0<br><br>a = a + 1<br>a += 1<br>puts a<br><br><br>b = 0<br><br>b = b - 8<br>b -= 8<br>puts b<br></code></pre><br><p><em>+=</em>和<em>-=</em>操作符是一个简写的操作符。它们的可读性没有全写的好，但是有经验的程序员经常使用它们。</p><br><pre><code>a = a + 1<br>a += 1<br></code></pre><br><p>这两行的操作是一样的，都是将变量<em>a</em>加1。</p><br><p>其他的一些复合操作符。</p><br><pre><code>-=   *=  </strong>=  /=   %=   &amp;=   |=   &lt;&lt;=   &gt;&gt;=<br></code></pre><br><h2>操作符优先级</h2><br><p>操作符的优先级表明了先对哪个操作符进行求值。优先级避免了表达式的二义性。</p><br><p>这个表达式的结果是多少？28还是40？</p><br><p>3 + 5 <em> 5  </p><br><p>跟数学相同，乘法优先级高于加法，加些结果为28。</p><br><p>(3 + 5) </em> 5  </p><br><p>我们可以使用括号来改变优先级。括号里的表达式总是最先求值。</p><br><pre><code>#!/usr/bin/ruby<br><br>puts 3 + 5 <em> 5<br>puts (3 + 5) </em> 5<br><br>puts ! true | true<br>puts ! (true | true)<br></code></pre><br><p>这个例子展示了一些表达式，其结果依赖于操作符优先级。</p><br><pre><code>puts 3 + 5 <em> 5<br></code></pre><br><p>这行打印28，因为乘法操作优先级高于加法。</p><br><pre><code>puts ! true | true<br></code></pre><br><p>这里非操作优先级更高。最后返回为true。</p><br><p>$ ./precedence.rb<br><br>28<br><br>40<br><br>true<br><br>false  </p><br><h2>结合律</h2><br><p>有时优先级不能决定表达式的结果。还有另一条规则称为结合律。它决定相同优先级的求值顺序。</p><br><p>9 / 3 </em> 3  </p><br><p>这个的结果是多少？9还是1？乘、除和取模操作是从左到右结合的。因此结果为9。</p><br><p>数学运算、布尔、关系和位操作都是从左向右结合的。</p><br><p>另外赋值操作是右结合。</p><br><pre><code>a = b = c = d = 0<br>print a, b, c, d # prints 0000<br></code></pre><br><p>复合分配操作是从右向左结合的。</p><br><pre><code>j = 0<br>j *= 3 + 1<br>puts j<br></code></pre><br><p>你可能期望结果为1,但是实际上结果为0。由于结合律，右边表达式先求值再应用复合分配操作。</p><br><h2>范围操作符</h2><br><p>Ruby有两个范围操作符，用于创建一个范围对象。通常是数字或者字母的范围。</p><br><p><em>..</em>范围操作符（两个点）创建一个包含的范围。<em>…</em>操作符（三个点）创建一个非包含的范围，较大的值不包含在其中。</p><br><pre><code>#!/usr/bin/ruby<br><br>p (1..3).to_a<br>p (1…3).to_a<br><br>p (‘a’ .. ‘l’).to_a<br></code></pre><br><p>这个例子中我们使用范围操作符创建了数字范围和字母范围。</p><br><pre><code>p (1..3).to_a<br>p (1…3).to_a<br></code></pre><br><p>这两行都是使用范围操作符创建了两个范围，然后转换为数据。第一个范围的值为1,2,3；第二个为1和2.</p><br><pre><code>p (‘a’ .. ‘l’).to_a<br></code></pre><br><p>这里使用<em>..</em>操作符创建一个’a’到’l’的数组。</p><br><p>$ ./range.rb<br><br>[1, 2, 3]<br><br>[1, 2]<br><br>[“a”, “b”, “c”, “d”, “e”, “f”, “g”, “h”, “i”, “j”, “k”, “l”]  </p><br><p>输出结果。</p><br><h2>三元运算术</h2><br><p>三元运算术是一个条件操作。如果我们需要根据条件表达式从两个值选择一个时这是一个方便的操作。</p><br><p>cond-exp ? exp1 : exp2  </p><br><p>如果<em>cond-exp</em>为真则返回<em>exp1</em>，否则返回<em>exp2</em>。</p><br><pre><code>#!/usr/bin/ruby<br><br>age = 32<br><br>adult = age &gt;= 18 ? true : false<br><br>if adult then<br>    puts “Adult”<br>else<br>    puts “Not adult”<br>end<br></code></pre><br><p>许多国家成年是基于你的年龄。是否成年即为是否超过了一定年龄。这种情况适合于三元操作。</p><br><pre><code>adult = age &gt;= 18 ? true : false<br></code></pre><br><p>首先对赋值符右转进行求值，它的值将赋给<em>adult</em>变量。</p><br><p>$ ./ternary.rb<br><br>Adult  </p><br><p>32年已经成年了。</p><br><h2>计算素数</h2><br><p>我们将计算素数。</p><br><pre><code>#!/usr/bin/ruby<br><br>nums = (4..50).to_a<br><br>puts “Prime numbers:”<br><br>print “2 3 “<br><br>nums.each do |i|<br><br>    not_prime = false<br><br>    (2..Math.sqrt(i).ceil).each do |j|<br>        not_prime = true if i % j == 0<br>    end<br><br>    print i, “ “ unless not_prime<br><br>end<br><br>puts<br></code></pre><br><p>上面的例子中我们用到了一些操作符。</p><br><pre><code>nums = (4..50).to_a<br></code></pre><br><p>我们将从这些数中计算哪些是素数。</p><br><pre><code>print “2 3 “<br></code></pre><br><p>我们路过2和3,因为它们都是素数。</p><br><pre><code>not_prime = false<br></code></pre><br><p><em>not_prime</em>标志表明选择的数不是素数。我们假设选择的数是素数，直到被证明不是为止。</p><br><pre><code>(2..Math.sqrt(i).ceil).each do |j|<br>    not_prime = true if i % j == 0<br>end<br></code></pre><br><p>当取模的结果为0表示这个数不是素数。</p><br><pre><code>print i, “ “ unless not_prime<br></code></pre><br><p>如果<em>not_prime</em>标志没有设置则打印这个数。</p><br><hr><br><p>上面例子展示了一些操作符。实际上有更简单方法计算素数。Ruby中有一个计算素数的模块。</p><br><pre><code>#!/usr/bin/ruby<br><br>require ‘prime’<br><br>Prime.each(50) do |i|<br>    print i, “ “<br>end<br><br>puts<br></code></pre><br><p>使用Ruby的<em>prime</em>模块计算素数。</p><br><pre><code>require ‘prime’<br></code></pre><br><p>导入<em>prime</em>模块。</p><br><pre><code>Prime.each(50) do |i|<br>    print i, “ “<br>end<br></code></pre><br><p>计算到50的素数。</p><br><p>$ ./primes.rb<br><br>2 3 5 7 11 13 17 19 23 29 31 37 41 43 47   </p><br><p>结果输出了2到50之间的素数。</p><br><p>这章的教程介绍了表达式。</p><br><hr><br><p>原文地址： <a target="_blank" rel="noopener" href="http://zetcode.com/lang/rubytutorial/expressions/">http://zetcode.com/lang/rubytutorial/expressions/</a><br><br>翻译：龙昌  admin@longchangjin.cn<br><br>完整教程：<a target="_blank" rel="noopener" href="https://github.com/wusuopu/Ruby-tutorial">https://github.com/wusuopu/Ruby-tutorial</a>  </p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://www.xefan.com/archives/83926.html" data-id="cl1hpb7zv005leqoyfrkxgqgi" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Ruby/" rel="tag">Ruby</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E7%BF%BB%E8%AF%91/" rel="tag">翻译</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-[翻译]Ruby教程7——字符串" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/archives/83921.html" class="article-date">
  <time datetime="2013-11-08T14:47:49.000Z" itemprop="datePublished">2013-11-08</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Ruby%E6%A0%8F%E7%9B%AE/">Ruby栏目</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/archives/83921.html">[翻译]Ruby教程7——字符串</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><h1>字符串</h1></p>
<p>在这部分的教程将详细的介绍字符串。</p><br><p>字符串是计算机语言中最重要的数据类型之一，这就是为什么我们决定要用一整章来介绍字符串。</p><br><p>字符串是序列化的unicode字符。它是一种数据类型存储了序列化的值，它的元素通常代表的是根据字符编码的字符。当一个字符串在代码中以字面量出现，它也称为字符串文本。</p><br><h2>第一个例子</h2><br><p>在Ruby中字符串文本是以单引号或者双引号引起来的。</p><br><pre><code>#!/usr/bin/ruby<br><br># first.rb<br><br>puts ‘Python language’<br>puts “Ruby language”<br></code></pre><br><p>这个例子有两个字符串，第一个是用单引号，另一个是用双引号。</p><br><p>$ ./first.rb <br><br>Python language<br><br>Ruby language  </p><br><p>程序输出。</p><br><h2>使用引号</h2><br><p>如果我们想要显示引号该怎么做，直接引用？这有两种方法实现。</p><br><pre><code>#!/usr/bin/ruby<br><br>puts “There are many stars”<br>puts “He said, \”Which one is your favourite?\””<br><br>puts ‘There are many stars’<br>puts ‘He said, “Which one is your favourite?”‘<br></code></pre><br><p>我们使用()字符将引号转义。通常双引号是用于划定字符串的范围，然后被转义之后它原始的意义就没有了。它在字符串中被作为一个正常的字符。第二种方法是混合使用单引号和双引号。</p><br><p>$ ./quotes.exe <br><br>There are many stars.<br><br>He said, “Which one is your favourite?”  </p><br><p>输出结果。</p><br><h2>转义序列</h2><br><p>转义符是特殊的字符，在字符串中有特殊的含意。</p><br><pre><code>#!/usr/bin/ruby<br><br>puts “one two three four”<br>puts “one\ntwo\nthree\nfour”<br></code></pre><br><p>最常用一个的转义符是换行符\n。它在许多编程语言中都有效。换行符之后的字符将出现在新的一行。</p><br><p>$ ./newline.rb<br><br>one two three four<br><br>one<br><br>two<br><br>three<br><br>four  </p><br><p>以上脚本的输出结果中换行符之后的字符在新的一行。</p><br><hr><br><p><em>r</em>、<em>b</em>和<em>t</em>是正常的字符，当前面加上\字符后就具有特殊意义了。</p><br><pre><code>#!/usr/bin/ruby<br><br>puts “   bbb\raaa”<br>puts “Joan\b\b\bane”<br>puts “Towering\tinferno”<br></code></pre><br><p>这个例子中我们用到了三个不同的转义字符。</p><br><pre><code>puts “   bbb\raaa”<br></code></pre><br><p>回车符<em>\r</em>控制之后的字符回到行首。之前打印到终端上的字符串会被处理。这个转义字符会将<em>aaa</em>字符位于<em>bbb</em>之前，输出为<em>aaabbb</em>。</p><br><pre><code>puts “Joan\b\b\bane”<br></code></pre><br><p><em>\b</em>是退格控制符，它会删掉前一个字符。这个字符串将在终端上打印<em>‘Jane’</em>而不是<em>‘Joan’</em>。</p><br><pre><code>puts “Towering\tinferno”<br></code></pre><br><p>最后<em>\t</em>转义符是用于两个词之间制表空格的。</p><br><p>$ ./escapes.rb <br><br>aaabbb<br><br>Jane<br><br>Towering        inferno  </p><br><p>例子的输出结果。</p><br><hr><br><p>反斜杠<em>\</em>是用于创建转义符的特殊字符。当需要打印反斜杠时，则在它前面加上另一个反斜杠。这意味着转义过了可以打印。在Ruby中单引号和双引号用于划定字符串范围的，想要打印它们同样也需要在前面加上<em>\</em>。</p><br><pre><code>#!/usr/bin/ruby<br><br>puts “The special character \“<br>puts “The special character \’”<br>puts “The special character \””<br></code></pre><br><p>这个例子中我们在终端上打印了这三个字符。</p><br><p>$ ./specials.rb<br><br>The special character \ <br><br>The special character ‘<br><br>The special character “  </p><br><p>输出结果。</p><br><h2>访问字符串的元素</h2><br><p>在Ruby中我们可以使用方括号<em>[]</em>来访问字符串的元素。在括号内可以使用字符串、范围索引。</p><br><pre><code>#!/usr/bin/ruby<br><br>msg = “Ruby language”<br><br>puts msg[“Ruby”]<br>puts msg[“Python”]<br><br>puts msg[0]<br>puts msg[-1]<br><br>puts msg[0, 3]<br>puts msg[0..9]<br>puts msg[0, msg.length]<br></code></pre><br><p>这个例子的代码展示了我们可以访问字符串的一部分。</p><br><pre><code>msg = “Ruby language”<br></code></pre><br><p>这里是我们将要访问的字符串。</p><br><pre><code>puts msg[“Ruby”]<br></code></pre><br><p>这行代码我们测试字符串<em>‘Ruby’</em>是否是<em>msg</em>的子串。如果是将返回该字符串。</p><br><pre><code>puts msg[0]<br></code></pre><br><p>可以通过索引来访问这个字符串的字符。编号是从0开始的，也就是说0号索引是第1个字符。<em>msg[0]</em>返回字符串的第一个字符<em>R</em>。</p><br><pre><code>puts msg[-1]<br></code></pre><br><p>这里我们访问最后一个字符。-1代表了最后一个索引。</p><br><pre><code>puts msg[0, 3]<br></code></pre><br><p>两个用逗号分隔的索引返回了从第1个索引开始到第2个索引的字符，不包括第2个索引。</p><br><pre><code>puts msg[0..9]<br></code></pre><br><p>范围操作符也可以完成同样操作。这里我们打印前10个字符。</p><br><pre><code>puts msg[0, msg.length]<br></code></pre><br><p>这行返回全部的字符。<em>msg.length</em>返回字符串的长度。</p><br><p>$ ./access.rb<br><br>Ruby  </p><br><p>R<br><br>e<br><br>Rub<br><br>Ruby langu<br><br>Ruby language  </p><br><p>输出结果。</p><br><h2>多行字符串</h2><br><p>许多编程语言要创建多行字符串需要额外的努力，在Visual Basic中尤其如此。但是在Ruby中却是很容易。</p><br><pre><code>#!/usr/bin/ruby<br><br>puts “I hear Mariachi static on my radio<br>And the tubes they glow in the dark<br>And I’m there with her in Ensenada<br>And I’m here in Echo Park<br>“<br><br>puts %/<br>Carmelita hold me tighter<br>I think I’m sinking down<br>And I’m all strung out on heroin<br>On the outskirts of town/<br><br>puts &lt;&lt;STRING<br><br>Well, I’m sittin’ here playing solitaire<br>With my pearl-handled deck<br>The county won’t give me no more methadone<br>And they cut off your welfare check<br>STRING<br></code></pre><br><p>这个例子中我们使用了Carmelita歌曲的歌词。我们展示了使用三种方法打印多行字符串。可以使用双引号；可以使用%字符创建多行字符串，用%后面的字符将字符串包围住；最后我们使用定界符，这和语法是使用<em>&lt;&lt;</em>接着一些字符串，用这个字符串包围住多行字符。它必须左对齐。</p><br><h2>变量替换</h2><br><p>变量替换是将字符串的变量替换成它们的值。为了将变量替换成值，这个变量在字符串需要放在<em>#{</em>和<em>}</em>之间。</p><br><pre><code>#!/usr/bin/ruby<br><br>name = “Jane”<br>age = 17<br><br>puts “#&#123;name&#125; is #&#123;age&#125; years old”<br></code></pre><br><p>这个例子中我们替换了字符串中的两个变量：<em>name</em>和<em>age</em>。</p><br><p>$ ./interpolation.rb <br><br>Jane is 17 years old  </p><br><hr><br><p>也可以替换表达式。</p><br><pre><code>#!/usr/bin/ruby<br><br>x = 5<br>y = 6<br><br>puts “The product of #&#123;x&#125; and #&#123;y&#125; is #&#123;x<em>y&#125;”<br></code></pre><br><p>这是一个表达式替换的例子。</p><br><p>$ ./interpolation2.rb<br><br>The product of 5 and 6 is 30  </p><br><p>运行例子脚本。</p><br><hr><br><p>这是另一种替换变量的方法。类似于Python 2.x所支持的替换。</p><br><pre><code>#!/usr/bin/ruby<br><br>name = “Jane”<br>age = 17<br><br>message = “%s is %d years old” % [name, age]<br>puts message<br></code></pre><br><p>以上是一个例子。</p><br><pre><code>message = “%s is %d years old” % [name, age]<br></code></pre><br><p>使用之前先创建一个字符串。<em>%s</em>和<em>%d</em>是格式化字符，分别表示字符串和数字。值由%字符后面的方括号提供。</p><br><h2>字符串连接</h2><br><p>字符串连接是从多个字符串创建一个字符串。</p><br><pre><code>#!/usr/bin/ruby<br><br>lang = “Ruby” + “ programming” + “ languge”<br>puts lang<br><br>lang = “Python” “ programming” “ language”<br>puts lang<br><br>lang = “Perl” &lt;&lt; “ programming” &lt;&lt; “ language”<br>puts lang<br><br>lang = “Java”.concat(“ programming”).concat(“ language”)<br>puts lang<br></code></pre><br><p>Ruby提供多种方法连接字符串。</p><br><pre><code>lang = “Ruby” + “ programming” + “ languge”<br></code></pre><br><p>在计算机语言中加法操作符是最常用的一种。Perl和PHP是用的点操作符(.)。</p><br><pre><code>lang = “Python” “ programming” “ language”<br></code></pre><br><p>Ruby自动连接多个后续的字符串。</p><br><pre><code>lang = “Perl” &lt;&lt; “ programming” &lt;&lt; “ language”<br></code></pre><br><p>另一种方法是使用<em>&lt;&lt;</em>操作符。</p><br><pre><code>lang = “Java”.concat(“ programming”).concat(“ language”)<br></code></pre><br><p>每个字符串字面符实际上都是一个对象。我们可以对Ruby对象调用很多方法。对于字符串对象可以调用<em>concat</em>方法连接两个字符串。它返回最后的结果对象，再对其调用另一个方法。这样我们就将这些方法链接起来了。</p><br><p>$ ./concatenate.rb<br><br>Ruby programming languge<br><br>Python programming language<br><br>Perl programming language<br><br>Java programming language  </p><br><p>输出结果。</p><br><h2>冻结字符串</h2><br><p>在Java或者C#中字符串是不可变的，这意味着不能修改已存在的字符串。只能通过已存在的字符串创建一个新的。在Ruby中字符串同样也是不可修改的。</p><br><p>Ruby中字符串对象有一个<em>freeze</em>方法，可以使它们不可变。</p><br><pre><code>#!/usr/bin/ruby<br><br>msg = “Jane”<br>msg &lt;&lt; “ is “<br>msg &lt;&lt; “17 years old”<br><br>puts msg<br><br>msg.freeze<br><br>#msg &lt;&lt; “and she is pretty”<br></code></pre><br><p>这个例子我们演示了字符串是可变的。然后在调用<em>freeze</em>方法之后我们就不能再作修改了。如果我们取消掉注释将会得到’can’t modify frozen string’错误信息。</p><br><h2>字符串比较</h2><br><p>在编程中字符串比较是件平常的事情。我们可以使用<em>==</em>操作符或者<em>eql?</em>方法来比较两个字符串，如果相等返回<em>true</em>，否则<em>false</em>。</p><br><pre><code>#!/usr/bin/ruby<br><br>puts “12” == “12”<br>puts “17” == “9”<br>puts “aa” == “ab”<br><br>puts “Jane”.eql? “Jan”<br>puts “Jane”.eql? “Jane”<br></code></pre><br><p>这个例子的代码我们比较了一些字符串。</p><br><pre><code>puts “12” == “12”<br></code></pre><br><p>这两个是相等的，这行返回true。</p><br><pre><code>puts “aa” == “ab”<br></code></pre><br><p>第一个字符是相等，然后比较下一个字符。它们不同，因此返回false。</p><br><pre><code>puts “Jane”.eql? “Jan”<br></code></pre><br><p><em>eql?</em>方法用于比较两个字符串。所有对象都内建了<em>eql?</em>方法。这个方法将另一个要比较的字符串作为参数传入。</p><br><p>$ ./comparing.rb<br><br>true<br><br>false<br><br>false<br><br>false<br><br>true  </p><br><p>程序输出结果。</p><br><hr><br><p>Ruby中有一个“飞船(spaceship)”操作符<em>&lt;==&gt;</em>。这个操作符来自Perl，与以上两个比较方法不同，它不是返回<em>true</em>和<em>false</em>，而是返回1、0或者-1。取决于左参数和右参数的关系。如果左参数大于右参数则返回1；如果左参数小于右参数则返回-1；如果相等返回0。什么才是一个字符大于另一个字符呢？字符在表中是有序的，在表中每个字符有一位位置。当比较字符时实际比较它们在表中的位置。例如ASCII表，字符<em>a</em>在<em>b</em>的前面，因此<em>a&lt;==&gt;b</em>返回-1，因为左参数的位置小于右参数<em>b</em>。</p><br><pre><code>#!/usr/bin/ruby<br><br>puts “a” &lt;==&gt; “b”<br>puts “b” &lt;==&gt; “a”<br>puts “a” &lt;==&gt; “a”<br></code></pre><br><p>使用“飞船”操作符比较字符串。</p><br><p>$ ./spaceship.rb<br><br>-1<br><br>1<br><br>0  </p><br><p>输出结果。</p><br><hr><br><p>有可能比较字符串不管大小写。在Ruby中有<em>casecmp</em>方法。这个方法与飞船操作符相同。</p><br><pre><code>#!/usr/bin/ruby<br><br>puts “Jane”.casecmp “Jane”<br>puts “Jane”.casecmp “jane”<br>puts “Jane”.casecmp “Jan”<br></code></pre><br><p>以上是一个例子。</p><br><pre><code>puts “Jane”.casecmp “Jane”<br>puts “Jane”.casecmp “jane”<br></code></pre><br><p>这两行返回结果都是0.因为我们不考虑字符的大小写。</p><br><p>$ ./case.rb<br><br>0<br><br>0<br><br>1  </p><br><p>输出结果。</p><br><h2>字符串对象</h2><br><p>Ruby是面向对象语言。对象是面向对象程序的基本代码块。字符串也是对象。对象由数据和方法组成。在面向对象程序中，创建对象并且相互通信。</p><br><pre><code>#!/usr/bin/ruby<br><br>website = “google.com”<br>puts website<br><br>website = String.new “zetcode.com”<br>puts website<br></code></pre><br><p>以上例子我们展示了两个创建字符串的基本方法。</p><br><pre><code>website = “google.com”<br></code></pre><br><p>这里是使用字符串字面量创建了一个<em>website</em>字符串变量。</p><br><pre><code>website = String.new “zetcode.com”<br></code></pre><br><p>这是标准创建字符串对象的方法。然而第一和更常用，因为它更简洁，并且在计算机语言中更普遍。</p><br><hr><br><pre><code>#!/usr/bin/ruby<br><br>puts “zetcode”.upcase<br>puts “zetcode”.size<br>puts “zetcode”.reverse<br></code></pre><br><p>这个例子中我们对字符串字面量调用了三个方法。如果是熟悉Java或者C的人可能会困惑。在Ruby中调用方法时字符串字面量会转化为一个字符串对象。</p><br><p>$ ./stringobject2.rb<br><br>ZETCODE<br><br>7<br><br>edoctez  </p><br><p>输出结果。</p><br><h2>字符串方法</h2><br><p>Ruby字符串对象有一些有用的方法。如我们见到过的<em>concat</em>或者<em>eql?</em>。</p><br><pre><code>#!/usr/bin/ruby<br><br>word = “Determination”<br><br>puts “The word #&#123;word&#125; has #&#123;word.size&#125; characters”<br><br>puts word.include? “tion”<br>puts word.include? “tic”<br><br>puts<br><br>puts word.empty?<br>word.clear<br>puts word.empty?<br></code></pre><br><p>创建一个字符串变量，展示了四个字符串的方法。</p><br><pre><code>puts “The word #&#123;word&#125; has #&#123;word.size&#125; characters”<br></code></pre><br><p><em>size</em>方法返回字符串的长度。</p><br><pre><code>puts word.include? “tion”<br></code></pre><br><p><em>include?</em>方法判断一个字符串是否为子串。这里返回的是true。</p><br><pre><code>puts word.empty?<br>word.clear<br></code></pre><br><p><em>empty?</em>方法检查字符串是否为空。返回一个布尔值。<em>clear</em>方法清空字符串。</p><br><p>$ ./basicmethods.rb<br><br>The word Determination has 13 characters<br><br>true<br><br>false  </p><br><p>false<br><br>true  </p><br><p>输出结果。</p><br><hr><br><p>接下来的例子介绍字符串大小写的方法。</p><br><pre><code>#!/usr/bin/ruby<br><br>ruby = “Ruby programming language”<br><br>puts ruby.upcase<br>puts ruby.downcase<br>puts ruby.capitalize<br>puts ruby.swapcase<br></code></pre><br><p>Ruby中有四个与大小写相关的方法。<em>upcase</em>方法将字符串全转为大写并返回一个新对象；<em>downcase</em>方法是将字符串全转为小写并返回一个新对象；<em>capitalize</em>方法是将字符串的首字母大写并返回一个新的对象。最后<em>swapcase</em>方法是将大小写反转并返回一个新对象。</p><br><p>$ ./rubylang.rb<br><br>RUBY PROGRAMMING LANGUAGE<br><br>ruby programming language<br><br>Ruby programming language<br><br>rUBY PROGRAMMING LANGUAGE  </p><br><p>输出结果。</p><br><hr><br><p>接下来展示两个Ruby字符串的方法：<em>start_with?</em> 和<em>end_with?</em>。这两个方法都是返回布尔值。它们判断一个字符串是否分别以另一个字符串开头或结尾。</p><br><pre><code>#!/usr/bin/ruby<br><br>ws1 = “zetcode.com”<br>ws2 = “www.gnome.org”<br><br>puts ws1.start_with? “www.”<br>puts ws2.start_with? “www.”<br><br>puts<br><br>puts ws1.end_with? “.com”<br>puts ws2.end_with? “.com”<br></code></pre><br><p>这是一个上述方法的例子。</p><br><pre><code>puts ws1.start_with? “www.”<br></code></pre><br><p>这里检查一个字符串是否以“www.”开头。如果不是则在终端打印false。</p><br><pre><code>puts ws1.end_with? “.com”<br></code></pre><br><p>检查字符串<em>ws1</em>是否以”.com”结尾。如果是则在终端打印true。</p><br><p>$ ./startend.rb<br><br>false<br><br>true  </p><br><p>true<br><br>false  </p><br><p>输出结果。</p><br><hr><br><p>接下来我们介绍<em>inspect</em>方法。这个方法返回被引号包围原始的字符串，对于特殊字符不处理。对于想要检查字符串由哪些字符组成的比较有用。</p><br><pre><code>#!/usr/bin/ruby<br><br>msg = “Jane\t17\nThomas\t23”<br><br>puts msg<br>puts msg.inspect<br></code></pre><br><p><em>inspect</em>方法的一个例子。</p><br><pre><code>msg = “Jane\t17\nThomas\t23”<br></code></pre><br><p>这个字符串有一些特殊的字符。</p><br><pre><code>puts msg<br>puts msg.inspect<br></code></pre><br><p>第一种情况，字符串中的制表符和换行符被解释了。第二种情况我们得到了一个原始格式的字符串。</p><br><pre><code>$ ./inspectmethod.rb<br>Jane    17<br>Thomas  23<br>“Jane\t17\nThomas\t23”<br></code></pre><br><p>输出结果。</p><br><hr><br><p><em>chomp</em>方法是将字符串尾部的分隔符去掉并返回一个新对象。默认的分隔符是换行符(\n)。</p><br><pre><code>#!/usr/bin/ruby<br><br>print “Are you sure to download? (Yes/No) “<br><br>response = gets<br><br>if (response.downcase == “yes”)<br>    puts “Downloaded”<br>else<br>    puts “Download cancelled”<br>end<br><br>puts response.inspect<br></code></pre><br><p>上面的脚本我们从用户输入一些内容，然后再返回给用户。</p><br><p>$ ./chomp.rb<br><br>Are you sure to download? (Yes/No) Yes<br><br>Download cancelled<br><br>“Yes\n”  </p><br><p>这个脚本没有正确的工作。原因很清晰，由<em>inspect</em>返回了。用户输入的内容以回车键结尾，因此换行符也被包含其中了。”Yes”与”Yes\n”不相等。要使用脚本正确运行，我们使用<em>chomp</em>方法移除掉换行符。</p><br><pre><code>#!/usr/bin/ruby<br><br>print “Are you sure to download? (Yes/No) “<br><br>response = gets<br><br>if (response.downcase.chomp == “yes”)<br>    puts “Downloaded”<br>else<br>    puts “Download cancelled”<br>end<br><br>puts response.inspect<br></code></pre><br><p>这个是正确的脚本。</p><br><pre><code>if (response.downcase.chomp == “yes”)<br></code></pre><br><p>这里我们在比”Yes”比较之前对输入内容进行了处理。</p><br><p>$ ./chomp.rb<br><br>Are you sure to download? (Yes/No) Yes<br><br>Downloaded<br><br>“Yes\n”  </p><br><p>现在脚本正确工作了。</p><br><h2>格式化字符串</h2><br><p>Ruby中有格式化说明符。格式化说明符决定了如何显示一个字符串。它以<em>%</em>字符开始。格式化说明符放在单引号或者双引号内。</p><br><p>格式化说明符有以下字段。</p><br><p>%[flags][field width][precision]conversion specifier</p><br><p>方括号内的字段是可选的。</p><br><p>转换说明符表明数据将如何进行转换。</p><br><pre><code>#!/usr/bin/ruby<br><br>puts “There are %d oranges in the basket.” % 12<br>puts “There are %d oranges and %d apples in the basket.” % [12, 10]<br></code></pre><br><p>这是一个格式化说明符的例子。</p><br><pre><code>puts “There are %d oranges in the basket” % 12<br></code></pre><br><p>当我们在字符串中使用%d，我们在这个位置将期望一个数字。<em>d</em>是十进制数的转换说明符。这个数据在<em>%</em>字符后面给出。</p><br><pre><code>puts “There are %d oranges and %d apples in the basket” % [12, 10]<br></code></pre><br><p>当我们在一个字符串中使用多个格式化说明符时，每个都以<em>%</em>开始。多个值放在[]之间并以逗号分隔。</p><br><p>$ ./formatspecifiers.rb<br><br>There are 12 oranges in the basket.<br><br>There are 12 oranges and 10 apples in the basket.  </p><br><p>输出结果。</p><br><hr><br><p>接下来的例子我们介绍一些基本的转换符。</p><br><pre><code>#!/usr/bin/ruby<br><br>puts “There are %d apples.” % 5<br>puts “I can see %i oranges.” % 3<br>puts “The width of iPhone 3G is %f mm.” % 62.1<br>puts “This animal is called a %s” % “rhinoceros.”<br></code></pre><br><p>我们使用了整数、浮点数和字符串的转换符。</p><br><pre><code>puts “There are %d apples.” % 5<br>puts “I can see %i oranges.” % 3<br></code></pre><br><p><em>d</em>和<em>i</em>都是用于整数。</p><br><pre><code>puts “The width of iPhone 3G is %f mm.” % 62.1<br></code></pre><br><p><em>f</em>用于浮点数。默认浮点数有6个小数。</p><br><pre><code>puts “This animal is called a %s” % “rhinoceros.”<br></code></pre><br><p><em>s</em>用于字符串。</p><br><p>$ ./basicspecifiers.rb<br><br>There are 5 apples.<br><br>I can see 3 oranges.<br><br>The width of iPhone 3G is 62.100000 mm.<br><br>This animal is called a rhinoceros.  </p><br><p>输出结果。</p><br><hr><br><p>接下来是一个实践的例子。</p><br><pre><code>#!/usr/bin/ruby<br><br>website = “zetcode.com”<br><br>website.each_char do |c|<br>    print “#&#123;c&#125; has ASCII code %d\n” % c.ord<br>end<br></code></pre><br><p>这个例子我们记遍历字符串的所有字符并在终端上打印它的ASCII值。</p><br><pre><code>website.each_char do |c|<br>    print “#&#123;c&#125; has ASCII code %d\n” % c.ord<br>end<br></code></pre><br><p><em>each_char</em>方法将<em>website</em>字符串中的每个字符传给代码块，一个字符是一次循环。当前的字符保存在这是<em>c</em>中。我们使用<em>ord</em>方法获取字符的ASCII值。</p><br><p>$ ./character.rb<br><br>z has ASCII code 122<br><br>e has ASCII code 101<br><br>t has ASCII code 116<br><br>c has ASCII code 99<br><br>o has ASCII code 111<br><br>d has ASCII code 100<br><br>e has ASCII code 101<br><br>. has ASCII code 46<br><br>c has ASCII code 99<br><br>o has ASCII code 111<br><br>m has ASCII code 109  </p><br><p>输出结果。 </p><br><hr><br><p>数字有多种显示形式。</p><br><pre><code>#!/usr/bin/ruby<br><br># decimal<br>puts “%d” % 300<br><br># hexadecimal<br>puts “%x” % 300<br><br># octal<br>puts “%o” % 300<br><br># binary<br>puts “%b” % 300<br><br># scientific<br>puts “%e” % (5/3.0)<br></code></pre><br><p>上面的例子中我们打印数字的十进制、十六进制、八进制、二进制和科学记数的形式。</p><br><pre><code># hexadecimal<br>puts “%x” % 300<br></code></pre><br><p><em>x</em>转换符用于将数字转为十六进制格式。</p><br><pre><code># binary<br>puts “%b” % 300<br></code></pre><br><p><em>b</em>转换符用于将数字转为二进制格式。</p><br><p>$ ./various.rb<br><br>300<br><br>12c<br><br>454<br><br>100101100<br><br>1.666667e+00  </p><br><p>输出结果。</p><br><hr><br><p>精度是格式化说明符的一个字段。它指明了后面小数点的位数。它对于整数、小数和字符串有不同的意义。当用于整数时表明了最少打印多少个数字。如果数字个数少于精度则前面用0补全。对于整数精度默认为1,表示前面没有0.当用于浮点数时表示小数点后显示多少个数字。最后，用于字符串时精度表示多少个字符会打印。</p><br><pre><code>#!/usr/bin/ruby<br><br>puts ‘Height: %f %s’ % [172.3, ‘cm’]<br>puts ‘Height: %.1f %s’ % [172.3, ‘cm’]<br><br>puts “%d” % 16<br>puts “%.5d” % 16<br><br>puts “%s” % “zetcode”<br>puts “%.5s” % “zetcode”<br></code></pre><br><p>这个例子中我们使用了精度字段。</p><br><pre><code>puts ‘Height: %f %s’ % [172.3, ‘cm’]<br>puts ‘Height: %.1f %s’ % [172.3, ‘cm’]<br></code></pre><br><p>172.3是一个浮点数。如果没有指定精度则会显示6个小数。这里将会显示5个0.第二行的<em>.1</em>是精度，它将小数个数减为1。的</p><br><pre><code>puts “%d” % 16<br>puts “%.5d” % 16<br></code></pre><br><p>对于整数默认精度为1。第二行中我们指明了精度为.5，这将会在16前面加上3个0。</p><br><pre><code>puts “%s” % “zetcode”<br>puts “%.5s” % “zetcode”<br></code></pre><br><p>第一行会打印所有的字符串。第二行仅打印5个，有两个字符将抛弃。</p><br><p>$ ./precision.rb<br><br>Height: 172.300000 cm<br><br>Height: 172.3 cm<br><br>16<br><br>00016<br><br>zetcode<br><br>zetco  </p><br><p>输出结果。</p><br><hr><br><p>宽度字段表示数据最小要显示的宽度。它是一个数字，并且在小数点之前。如果输出比较短，则会被用空格填充，且右对齐。如果宽度前面有减号则会左对齐。如果输出比宽度长则会完整输出。</p><br><pre><code>#!/usr/bin/ruby<br><br>puts “%d” % 1<br>puts “%d” % 16<br>puts “%d” % 165<br>puts “%d” % 1656<br>puts “%d” % 16567<br><br>puts “%10d” % 1<br>puts “%10d” % 16<br>puts “%10d” % 165<br>puts “%10d” % 1656<br>puts “%10d” % 16567<br></code></pre><br><p>第一种情况打印5个数字没有指明宽度。输出的宽度即为数字的位数。第二种情况指明宽度为10。则每个都最少输出10字符的长度，数字右对齐。</p><br><pre><code>puts “%d” % 1<br>puts “%d” % 16<br></code></pre><br><p>打印两个数字，输出的宽度分别为1、2个字符。</p><br><pre><code>puts “%10d” % 1<br>puts “%10d” % 16<br></code></pre><br><p>这里宽度都为10个字符。这两个数被填充了8、9个空格。</p><br><pre><code>$ ./fieldwidth.rb<br>1<br>16<br>165<br>1656<br>16567<br>         1<br>        16<br>       165<br>      1656<br>     16567<br></code></pre><br><p>我们发现第二种情况数字是右对齐的。</p><br><hr><br><p>标志修饰符修改了模式的行为。</p><br><p><em>#</em>标志分别在二进制、八进制各十六进制前加上0b、0和0x。它会给小数加上小数点，即使这个小数人被精度限制了。</p><br><pre><code>#!/usr/bin/ruby<br><br>puts “%#b” % 231<br>puts “%#x” % 231<br>puts “%#o” % 231<br><br>puts “%.0e” % 231<br>puts “%#.0e” % 231<br><br>puts “%.0f” % 231<br>puts “%#.0f” % 231<br></code></pre><br><p>这个例子我们使用了<em>#</em>标志。</p><br><pre><code>puts “%#b” % 231<br>puts “%#x” % 231<br>puts “%#o” % 231<br></code></pre><br><p>十进制数231分别以二进制、八进制和十六进制打印。<em>#</em>标志会给它们加上前缀。</p><br><pre><code>puts “%.0e” % 231<br>puts “%#.0e” % 231<br></code></pre><br><p>这个<em>.0</em>限制了小数个数。然后使用<em>#</em>标志后小数点会显示，即使没有小数值。</p><br><p>$ ./flags1.rb<br><br>0xe7<br><br>0b11100111<br><br>0347<br><br>2e+02<br><br>2.e+02<br><br>231<br><br>231.  </p><br><p>输出结果。</p><br><hr><br><p><em>+</em>标志会给正数加上正号。对于二进制、十六进制和八进制的负数会加上负号并使用它的绝对值。</p><br><pre><code>#!/usr/bin/ruby<br><br>puts “%d” % 231<br>puts “%+d” % 231<br>puts “%d” % -231<br>puts “%+d” % -231<br><br>puts “%b” % -231<br>puts “%o” % -231<br>puts “%x” % -231<br><br>puts “%+b” % -231<br>puts “%+o” % -231<br>puts “%+x” % -231<br></code></pre><br><p>一个演示<em>+</em>标志符的例子。</p><br><pre><code>puts “%d” % 231<br>puts “%+d” % 231<br></code></pre><br><p>通常正数的符号会被忽略掉。如果想要显示正数的符号可以使用<em>+</em>标志符。</p><br><pre><code>puts “%d” % -231<br>puts “%+d” % -231<br></code></pre><br><p><em>+</em>标志符对负数没有影响，输出结果还是一样的。</p><br><pre><code>puts “%b” % -231<br>puts “%o” % -231<br>puts “%x” % -231<br></code></pre><br><p>二进制、八进制和十六进制的数有它们自己生成负数的方法。</p><br><pre><code>puts “%+b” % -231<br>puts “%+o” % -231<br>puts “%+x” % -231<br></code></pre><br><p>如果我们对负数指定了<em>+</em>标志，我们将数字转为不同的格式并加上负号。没有专门的方式表示负数。</p><br><p>$ ./flags2.rb<br><br>231<br><br>+231<br><br>-231<br><br>-231<br><br>..100011001<br><br>..7431<br><br>..f19<br><br>-11100111<br><br>-347<br><br>-e7  </p><br><p>输出结果。</p><br><hr><br><p>这里介绍<em>0</em>标志和<em>-</em>标志。<em>0</em>标志会用0代替空格来填充数字。<em>-</em>标志会将输出左对齐。</p><br><pre><code>#!/usr/bin/ruby<br><br>puts “%010d” % 1<br>puts “%010d” % 16<br>puts “%010d” % 165<br>puts “%010d” % 1656<br>puts “%010d” % 16567<br><br>puts “%-10d” % 1<br>puts “%-10d” % 16<br>puts “%-10d” % 165<br>puts “%-10d” % 1656<br>puts “%-10d” % 16567<br></code></pre><br><p>以上是一个例子。</p><br><pre><code>puts “%010d” % 1<br>puts “%010d” % 16<br></code></pre><br><p>数字会用0填充。</p><br><pre><code>puts “%-10d” % 1<br>puts “%-10d” % 16<br></code></pre><br><p>数字个数比宽度短，且会左对齐。</p><br><p>$ ./fieldwidth2.rb<br><br>0000000001<br><br>0000000016<br><br>0000000165<br><br>0000001656<br><br>0000016567<br><br>1        <br><br>16        <br><br>165       <br><br>1656     <br><br>16567  </p><br><p>输出结果。</p><br><hr><br><p></em>标志符用于精度和宽度。当我们使用<em>符号时精度和宽度将作为一个参数。</p><br><pre><code>#!/usr/bin/ruby<br><br>puts “%.</em>f” % [3, 1.1111111]<br>puts “%0<em>d” % [10, 2]<br>puts “%0</em>.<em>f” % [10, 3, 1.1111]<br></code></pre><br><p>使用了</em>标志的的例子。</p><br><pre><code>puts “%.<em>f” % [3, 1.1111111]<br></code></pre><br><p>这里使用<em>作为精度，则第一个数字3是精度的参数。它只为显示</em>1.1111111</em>的3个小数。</p><br><pre><code>puts “%0<em>d” % [10, 2]<br></code></pre><br><p>这行的代码我们使用</em>标志作为宽度。我们必须在[]之间加上宽度。第一个数字是宽度，第十个数字是要转换的值。</p><br><pre><code>puts “%0<em>.</em>f” % [10, 3, 1.1111]<br></code></pre><br><p>*标志可以同时用于宽度和精度。这样我们就必须都在[]中指明。</p><br><p>$ ./flags3.rb<br><br>1.111<br><br>0000000002<br><br>000001.111  </p><br><p>输出结果。</p><br><p>这章的教程介绍的Ruby的字符串。</p><br><hr><br><p>原文地址： <a target="_blank" rel="noopener" href="http://zetcode.com/lang/rubytutorial/strings/">http://zetcode.com/lang/rubytutorial/strings/</a><br><br>翻译：龙昌  admin@longchangjin.cn<br><br>完整教程：<a target="_blank" rel="noopener" href="https://github.com/wusuopu/Ruby-tutorial">https://github.com/wusuopu/Ruby-tutorial</a>  </p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://www.xefan.com/archives/83921.html" data-id="cl1hpb7zu005keqoyd516h3nf" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Ruby/" rel="tag">Ruby</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E7%BF%BB%E8%AF%91/" rel="tag">翻译</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-[翻译]Ruby教程6——数据类型" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/archives/83913.html" class="article-date">
  <time datetime="2013-11-07T12:27:33.000Z" itemprop="datePublished">2013-11-07</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Ruby%E6%A0%8F%E7%9B%AE/">Ruby栏目</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/archives/83913.html">[翻译]Ruby教程6——数据类型</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><h1>数据类型</h1></p>
<p>在这一章的教程中我们开始讨论数据类型。</p><br><p>所有类别的计算机程序，包括电子表格、文本编辑器、计算器和聊天软件都使用数据。现代计算机语言中各种数据类型是必不可少的。一种数据类型是一些可操作的值的集合。</p><br><p>Ruby中有一些数据类型，这些类型都是基于类的。以下是Ruby中公认的数据类型：  </p><br><ul><br><li>布尔(Booleans)  </li><br><li>符号(Symbols)  </li><br><li>数字(Numbers)  </li><br><li>字符串(Strings)</li><br><li>数组(Arrays)  </li><br><li>哈希(Hashes)</li><br></ul><br><p>下面的例子中我们展示Ruby中所有重要的数据类型。</p><br><pre><code>#!/usr/bin/ruby<br><br>h = &#123; :name =&gt; “Jane”, :age =&gt; 17 &#125;<br><br>p true.class, false.class<br>p “Ruby”.class<br>p 1.class<br>p 4.5.class<br>p 3_463_456_457.class<br>p :age.class<br>p [1, 2, 3].class<br>p h.class<br></code></pre><br><p>我们将它们的类型名打印出来，类型是用于创建对象的模块。  </p><br><pre><code>p true.class, false.class<br></code></pre><br><p><em>true</em>和<em>false</em>对象展示的布尔类型。</p><br><pre><code>p “Ruby”.class<br></code></pre><br><p>这个是字符串。</p><br><pre><code>p 1.class<br>p 4.5.class<br>p 3_463_456_457.class<br></code></pre><br><p>这些是数字。</p><br><pre><code>p :age.class<br></code></pre><br><p>这个是符号标志，Ruby的一种特殊数据类型。</p><br><pre><code>p [1, 2, 3].class<br>p h.class<br></code></pre><br><p>这是两个容器，数组和哈希表。</p><br><p>$ ./types.rb<br><br>TrueClass<br><br>FalseClass<br><br>String<br><br>Fixnum<br><br>Float<br><br>Bignum<br><br>Symbol<br><br>Array<br><br>Hash  </p><br><p>这个程序列出了属于Ruby的类型。</p><br><h2>布尔值</h2><br><p>在我们的世界里存在着对偶关系。天与地、水与火、男与女、爱与恨。这些就是我们自然中的“布尔”。在Ruby里，布尔类型只有一种，具有两个值：<em>true</em>(真)与<em>false</em>(假)。布尔是一种基本的数据类型，它在计算机程序中非常普遍。</p><br><p>高兴的父母等待着孩子的诞生。他们可能会给孩子取个名字。如果是男孩就叫John，如果是女孩就叫Victoria。</p><br><pre><code>#!/usr/bin/ruby<br><br># kid.rb<br><br>bool = [true, false]<br><br>male = bool[rand(2)]<br><br><br>if male<br>    puts “We will use name John”<br>else<br>    puts “We will use name Victoria”<br>end<br></code></pre><br><p>在这个程序中我们使用随机数来模拟这种情况。</p><br><pre><code>bool = [true, false]<br></code></pre><br><p>我们创建一个名为<em>bool</em>的变量，它是一个数组包含了两个布尔值。这个数组是使用方括号创建的。</p><br><pre><code>male = bool[rand(2)]<br></code></pre><br><p>我们使用<em>rand()</em>方法生成一个随机数。这个方法返回0或1。返回的数用于数组的索引。</p><br><pre><code>if male<br>    puts “We will use name John”<br>else<br>    puts “We will use name Victoria”<br>end<br></code></pre><br><p>根据<em>male</em>变量我们打印一条信息。如果<em>male</em>是<em>true</em>则名字选择John，否则选择Vactoria。类似<em>is/else</em>的结构控制语句是根据布尔值来选择的。</p><br><p>$ ./kid.rb <br><br>We will use name Victoria <br><br>$ ./kid.rb <br><br>We will use name Victoria<br><br>$ ./kid.rb <br><br>We will use name John<br><br>$ ./kid.rb <br><br>We will use name John<br><br>$ ./kid.rb <br><br>We will use name John  </p><br><p>程序运行多次的结果如上。</p><br><h2>符号标志</h2><br><p>符号标志代表其他对象。使用符号标志而不是字符串，是因为可能保存一些资源。一个符号标志是<em>Symbol</em>类的一个实例对象。符号标志通常是在标识符的前面加上冒号，比如 :name。一些对象具有<em>to_sym</em>方法，用于将这些对象转化为符号标志。</p><br><p>Ruby的符号标志在程序运行时是不可改变的。它通常用于当作哈希表的键，因为一个键不需要完整的字符串功能。</p><br><pre><code>#!/usr/bin/ruby<br><br>p :name<br>p :name.class<br>p :name.methods.size<br>p “Jane”.methods.size<br><br>p :name.object_id<br>p :name.object_id<br>p “name”.object_id<br>p “name”.object_id<br></code></pre><br><p>第一个例子展示了符号标志的基本操作。</p><br><pre><code>p :name<br>p :name.class<br></code></pre><br><p>在终端上打印一个符号标志和它的类型。符号标志的类型是<em>Symbol</em>。</p><br><pre><code>p :name.methods.size<br>p “Jane”.methods.size<br></code></pre><br><p>比较字符串实例与符号标志实例分配的方法数量。字符串的方法数是符号标志的两位多。</p><br><pre><code>p :name.object_id<br>p :name.object_id<br>p “name”.object_id<br>p “name”.object_id<br></code></pre><br><p>相同的符号标志具有相同的id，相同的字符串的id却不同。</p><br><p>$ ./symbols.rb<br><br>:name<br><br>Symbol<br><br>79<br><br>162<br><br>10328<br><br>10328<br><br>77344750<br><br>77344730  </p><br><p>程序输出结果。</p><br><hr><br><p>符号标志也可以作为常量标志，类似于C/C++中的枚举类型。</p><br><pre><code>#!/usr/bin/ruby<br><br>light = :on<br><br>if light == :on<br>    puts “The light is on”<br>else<br>    puts “The light is off”<br>end<br><br>light = :off<br><br>if light == :on<br>    puts “The light is on”<br>else<br>    puts “The light is off”<br>end<br></code></pre><br><p>电灯不是开就是关。对于这两种情况定义了符号标志。</p><br><pre><code>light = :on<br></code></pre><br><p>灯是开的。</p><br><pre><code>if light == :on<br>    puts “The light is on”<br>else<br>    puts “The light is off”<br>end<br></code></pre><br><p>程序的逻辑依赖于<em>light</em>变量的状态。</p><br><hr><br><p>符号标志通常在哗然容器中作为键。这比字符串更加有效。</p><br><pre><code>#!/usr/bin/ruby<br><br>domains = &#123;:sk =&gt; “Slovakia”, :no =&gt; “Norway”, :hu =&gt; “Hungary”&#125;<br><br>puts domains[:sk]<br>puts domains[:no]<br>puts domains[:hu]<br></code></pre><br><p>在这个脚本中创建了一个名为<em>domains</em>的哈希表。它的键全是符号标志。</p><br><pre><code>puts domains[:sk]<br>puts domains[:no]<br>puts domains[:hu]<br></code></pre><br><p>在哈希表中键是用于访问值的。接下来我们打印出这个哈希表的值。</p><br><p>$ ./symbols3.rb<br><br>Slovakia<br><br>Norway<br><br>Hungary  </p><br><p>以上是例子的输出结果。</p><br><hr><br><p>Ruby解释器将内部引用存储为符号标志。</p><br><pre><code>#!/usr/bin/ruby<br><br>class Being<br><br>    def initialize<br>        @is = true<br>    end<br><br>    def say<br>        “I am being”<br>    end<br>end<br><br>b = Being.new<br><br>p b.method :say<br>p b.instance_variable_get :@is<br></code></pre><br><p>定义了一个<em>Being</em>类。该类有一个自定义实例变量<em>@is</em>和一个方法<em>say</em>。这两个实体在Ruby中保存为符号标志。</p><br><pre><code>p b.method :say<br></code></pre><br><p><em>method</em>方法用于在<em>b</em>对象在查找给定名字的方法。我们查找的是<em>:say</em>符号。</p><br><pre><code>p b.instance_variable_get :@is<br></code></pre><br><p>使用<em>instance_variable_get</em>检查<em>@is</em>是不是<em>b</em>对象的一个实例变量。在内部变量存储为<em>:@is</em>符号。</p><br><p>$ ./symbols4.rb   </p><br><h1><Method: Being#say></h1><br><p>true  </p><br><p>输出结果。</p><br><hr><br><p>所有的符号都存储在符号表中。下一个例子我们来看看这个表。<em>Symbol</em>类的<em>all_symbols</em>方法返回了一个数组包含这个表的全部符号。</p><br><pre><code>#!/usr/bin/ruby<br><br>def info<br>  “info method”<br>end<br><br>@v = “Ruby”<br>@@n = “16”<br><br>p Symbol.all_symbols.include? :info<br>p Symbol.all_symbols.include? :@v<br>p Symbol.all_symbols.include? :@@n<br></code></pre><br><p>在这个Ruby脚本中创建了一个方法、一个实例变量和一个类变量。我们检查这些实体是否存储在符号表中。</p><br><pre><code>p Symbol.all_symbols.include? :info<br></code></pre><br><p>检查<em>:info</em>符号是否在符号表中。这行返回的是<em>true</em>。</p><br><p>$ ./symbols5.rb<br><br>true<br><br>true<br><br>true  </p><br><p>三个符号都在符号表中。</p><br><h2>整数</h2><br><p>整数是实数的一个子集。它没有分数或者小数。整数属于集合Z = {…, -2, -1, 0, 1, 2, …} 。这个集合是无限的。</p><br><p>在计算机语言中，整数是原始的数据类型。实际中计算机仅支持整数的一个子集，因为计算机的能力有限。整数用于统计离散的实体。我们有3、4、6个人，但是不能有3.33个人。我们有3.33千克。</p><br><p>在Ruby中整数是<em>Fixnum</em>或者<em>Bignum</em>类的实例对象。不同于其他语言，如Java或者C，在Ruby中整数是一个对象。这两种类型的大小不同。<em>Fixnum</em>类型的整数有一些限制，这些限制与机器有关。<em>Bignum</em>的值表示范围比<em>Fixnum</em>大。如果一些操作超出了<em>Fixnum</em>的范围，它会自动的转换成<em>Bignum</em>。程序员通常不需要关心整数的类型。</p><br><pre><code>#!/usr/bin/ruby<br><br>p -2<br>p 121<br>p 123265<br>p -34253464356<br>p 34867367893463476<br><br>p 1.class<br>p 23453246.class<br>p 234532423563456346.class<br>p 2345324235632363463456456346.class<br><br>p 5 / 2<br>p 5.div 2<br></code></pre><br><p>这个例子中我们处理的一些整数。</p><br><pre><code>p -2<br>p 121<br>p 123265<br>p -34253464356<br>p 34867367893463476<br></code></pre><br><p>这是一些不同大小的正数和负数。</p><br><pre><code>p 1.class<br>p 23453246.class<br>p 234532423563456346.class<br>p 2345324235632363463456456346.class<br></code></pre><br><p>打印出这些数的类型。前两个整数是<em>Fixnum</em>类型，其余两个是<em>Bignum</em>类型。</p><br><pre><code>p 5 / 2<br>p 5.div 2<br></code></pre><br><p>这两行展示的整数的相除。当两个数相除时我们使用了相除操作符/方法,结果也是一个整数。</p><br><p>$ ./integers.rb<br><br>-2<br><br>121<br><br>123265<br><br>-34253464356<br><br>34867367893463476<br><br>Fixnum<br><br>Fixnum<br><br>Bignum<br><br>Bignum<br><br>2<br><br>2  </p><br><p>例子的输出结果。</p><br><hr><br><p>在Ruby中整数可以有不同的表现符号。十进制、十六进制、八进制和二进制数都是可用的。十六进制数以0x字符开头，八进制以0字符开头，二进制以0b字符开头。</p><br><pre><code>#!/usr/bin/ruby<br><br>puts 122<br>puts 0x7a<br>puts 0172<br>puts 0b1111010<br></code></pre><br><p>这个例子中我们打印了十进制数<em>122</em>的所有表现形式。</p><br><p>$ ./inotations.rb<br><br>122<br><br>122<br><br>122<br><br>122  </p><br><p>以上是输出结果。</p><br><hr><br><p>我们使用整数的话，那么就是用于处理离散的实体。也许我们用于统计苹果的数量。</p><br><pre><code>#!/usr/bin/ruby<br><br>baskets = 16<br>apples_in_basket = 24<br><br>total = baskets <em> apples_in_basket<br><br>puts “There are total of #&#123;total&#125; apples”<br></code></pre><br><p>在这个程序中我们使用整数统计苹果的总数。</p><br><p>$ ./apples.rb<br><br>There are total of 384 apples  </p><br><p>以上是程序的输出。</p><br><hr><br><p>大数字读起来比较困难。如果我们有一个数245342395423452，我们发现很难快速的将它读出来。计算机之外大的数字是用空格或者逗号分隔开来。为了可读性，Ruby允许数字包含下划线。Ruby解释器会忽略整数中的下划线。</p><br><pre><code>#!/usr/bin/ruby<br><br>p 23482345629<br>p 23_482_345_629<br><br>p 23482345629 == 23_482_345_629<br></code></pre><br><p>这个例子演示了下划线的使用。</p><br><pre><code>p 23482345629 == 23_482_345_629<br></code></pre><br><p>这行展示了两个数据是相等的。</p><br><p>$ ./underscore.rb<br><br>23482345629<br><br>23482345629<br><br>true  </p><br><p>例子的输出结果。</p><br><h2>浮点数</h2><br><p>在计算中浮点数表示实数。实例意味着连续的数量，如：重量、高度和速度。Ruby中小数是<em>Float</em>或者<em>BigDecimal</em>类对象。<em>BigDecimal</em>类是Ruby的核心类，是Ruby标准库的一部分。此外我们还可以使用<em>Rational</em>对象。</p><br><p>我们需要理解数字是不业精确的。Ruby的官方文档清楚地说道浮点数对象表示的是不精确的实数。</p><br><pre><code>#!/usr/bin/ruby<br><br>p 15.4<br>p 0.3455<br>p -343.4563<br><br>p 12.5.class<br>p -12.5.class<br>p (5.0 / 2).class<br><br>p 5.fdiv 2<br>p 12.to_f<br></code></pre><br><p>上面的这个例子我们使用了浮点数。</p><br><pre><code>p 15.4<br>p 0.3455<br>p -343.4563<br></code></pre><br><p>这里我们打印三个小数的值。小数包含了小数点字符。</p><br><pre><code>p 12.5.class<br>p -12.5.class<br>p (5.0 / 2).class<br></code></pre><br><p>以上展示的数字的类型，全都是浮点数。最后一个整数与浮点数相除结果为浮点数。</p><br><pre><code>p 5.fdiv 2<br>p 12.to_f<br></code></pre><br><p>这里我们创建浮点数除法<em>fdiv</em>和转换方法<em>to_f</em>来创建浮点数。</p><br><p>$ ./decimals.rb<br><br>15.4<br><br>0.3455<br><br>-343.4563<br><br>Float<br><br>Float<br><br>Float<br><br>2.5<br><br>12.0  </p><br><p>以上为转出结果。</p><br><hr><br><p>一个小数默认最多只显示小数点后16个数字。我们可以使用<em>sprintf</em>或者<em>printf</em>方法来控制浮点数的格式。</p><br><pre><code>#!/usr/bin/ruby<br><br>p 1/3.0<br>p 1.fdiv 2<br><br>puts sprintf “%.4f” % (1/3.0)<br>puts sprintf “%.7f” % (5/3.0)<br></code></pre><br><p>格式化小数。</p><br><pre><code>p 1/3.0<br>p 13.fdiv 4<br>p 1.fdiv 2<br></code></pre><br><p>第一行打印的小数在小数点后有16个数字。第二行打印的有两个。第三行打印的有一个。</p><br><pre><code>puts sprintf “%.4f” % (1/3.0)<br>puts sprintf “%.7f” % (5/3.0)<br></code></pre><br><p>这里我们使用<em>sprintf</em>方法控制小数点后面的数字个数。<em>sprintf</em>方法的格式说明符是精确的。它是一个数字接着<em>%</em>符号。<em>f</em>是一个转换说明符，表示处理的是一个浮点数。</p><br><p>$ ./formatfloat.rb<br><br>0.3333333333333333<br><br>3.25<br><br>0.5<br><br>0.3333<br><br>1.6666667  </p><br><p>以上是输出结果。</p><br><hr><br><p>Ruby支持使用科学的记数法来表示一个浮点数。这也称为指数记数法，它是将非常大或者非常小的数转换成正常的小数形式。</p><br><pre><code>#!/usr/bin/ruby<br><br>p 1.2e-3<br>p 0.0012<br><br>p 1.5E-4<br>p 0.00015<br></code></pre><br><p>这个例子展示了两个使用科学记数表示的小数。</p><br><p>$ ./scientific.rb<br><br>0.0012<br><br>0.0012<br><br>0.00015<br><br>0.00015  </p><br><p>这是以上程序的输出。</p><br><hr><br><p>前面我们主说过浮点数的值稍微有些不精确。在很多计算中，普通的浮点小数已经足够精确了，如：我们的体重是60kg还是60.000024kg并不重要。对于其他计算，包括科学和工程应用，精确度是非常重要的。</p><br><p>Ruby有一个<em>BigDecimal</em>标准库。这个类对于非常大或者非常精准的浮点数提供了任意的精度。</p><br><pre><code>#!/usr/bin/ruby<br><br>require ‘bigdecimal’<br><br>sum = 0<br><br>1000.times do<br>    sum = sum + 0.0001<br>end<br><br>p sum<br><br><br>sum = BigDecimal.new(“0”)<br><br>1000.times do<br>    sum = sum + BigDecimal.new(“0.0001”)<br>end<br><br>puts sum.to_s(‘F’)<br>puts sum.to_s(‘E’)<br></code></pre><br><p>在这个例子中我们比较了<em>Float</em>与<em>BigDecimal</em>的精度。 </p><br><pre><code>require ‘bigdecimal’<br></code></pre><br><p><em>BigDecimal</em>类必须导入。</p><br><pre><code>sum = 0<br><br>1000.times do<br>    sum = sum + 0.0001<br>end<br><br>p sum<br></code></pre><br><p>通过循环对一个很小的浮点数求和。最后会出现一点误差。</p><br><pre><code>sum = BigDecimal.new(“0”)<br><br>1000.times do<br>    sum = sum + BigDecimal.new(“0.0001”)<br>end<br></code></pre><br><p>然后再对<em>BigDecimal</em>做同样的事情。</p><br><pre><code>puts sum.to_s(‘F’)<br>puts sum.to_s(‘E’)<br></code></pre><br><p>将<em>sum</em>浮点数打印为工程记数形式。</p><br><p>$ ./bigdecimal.rb<br><br>0.10000000000000184<br><br>0.1<br><br>0.1E0  </p><br><p>输出结果表示<em>BigDecimal</em>比<em>Float</em>更精确。</p><br><hr><br><p>如果一个短路运动员100m跑9.87s，那么他的时速是多少？</p><br><pre><code>#!/usr/bin/ruby<br><br>distance = 0.1<br>time = 9.87 / 3600<br><br>speed = distance / time<br><br>puts “The average speed of a sprinter is #&#123;speed&#125; km/h”<br></code></pre><br><p>这个例子必需使用浮点数。</p><br><pre><code>distance = 0.1<br></code></pre><br><p>100m等于0.1km。</p><br><pre><code>time = 9.87 / 3600<br></code></pre><br><p>9.87s等于9.87/60</em>60 h。</p><br><pre><code>speed = distance / time<br></code></pre><br><p>要计算速度，我们用距离除以时间。</p><br><p>$ ./speed.rb<br><br>The average speed of a sprinter is 36.4741641337386 km/h  </p><br><p>以上是<em>speed.rb</em>脚本的输出。</p><br><h2>有理数</h2><br><p>Ruby支持有理数。有理数是一个确切的数。使用有理数可以避免舍入错误。Ruby中有理数是<em>Rational</em>类的对象。我们可以使用某些对象的<em>to_r</em>方法来创建有理数。</p><br><p>有理数可以用于表示两个整数相除的分数，a/b（b!=0）。如果b为1,每个整数都是一个有理数。</p><br><pre><code>#!/usr/bin/ruby<br><br>puts 2.to_r<br>puts “23”.to_r<br>puts 2.6.to_r<br><br>p Rational 0<br>p Rational 1/5.0<br>p Rational 0.5<br></code></pre><br><p>这个例子展示了一些有理数。</p><br><pre><code>puts 2.to_r<br></code></pre><br><p>变量我们使用<em>to_r</em>方法将整数2转化为有理数2/1。</p><br><pre><code>p Rational 0.5<br></code></pre><br><p>使用<em>Rational</em>方法创建一个有理数》</p><br><p>$ ./rational.rb<br><br>2/1<br><br>23/1<br><br>5854679515581645/2251799813685248<br><br>(0/1)<br><br>(3602879701896397/18014398509481984)<br><br>(1/2)  </p><br><p>例子的输出结果。</p><br><h2>空值</h2><br><p>Ruby有一个特殊的值<em>nil</em>。它表示空值。<em>nil</em>是<em>NilClass</em>类的单实例，仅有一个<em>nil</em>。</p><br><pre><code>#!/usr/bin/ruby<br><br>puts nil<br>p nil<br><br>p $val<br><br>p [1, 2, 3][4]<br><br>p $val1 == $val2<br></code></pre><br><p><em>nil</em>的一个例子。</p><br><pre><code>puts nil<br>p nil<br></code></pre><br><p>在终端上打印<em>nil</em>的值。<em>puts</em>方法打印空字符串，<em>p</em>方法打印<em>‘nil’</em>字符串。</p><br><pre><code>p $val<br></code></pre><br><p>当我们引用一个没有定义的全局变量时会返回<em>nil</em>值。</p><br><pre><code>p [1, 2, 3][3]<br></code></pre><br><p>这行代码我们引用了一个3元素数组的第4个元素，结果返回<em>nil</em>。Ruby中的许多方法对于无效的值都返回<em>nil</em>。</p><br><pre><code>p $val1 == $val2<br></code></pre><br><p>这行返回<em>true</em>，这实际上是因为<em>nil</em>是<em>NilClass</em>的单实例对象。</p><br><p>$ ./nilvalue.rb  </p><br><p>nil<br><br>nil<br><br>nil<br><br>true  </p><br><p>输出结果。</p><br><h2>字符串</h2><br><p>字符串在计算机程序代表文本数据。Ruby字符串是一个序列化的unicode字符。字符串是<em>String</em>的一个对象。字符串的字面量是字符加上双引号或者单引号。</p><br><p>字符串是一个非常重要的数据类型。它需要专门用一章来介绍。这里我们仅包含一个小例子。</p><br><pre><code>#!/usr/bin/ruby<br><br>p “Ruby”<br>p ‘Python’<br><br>p “Ruby”.size<br>p “Ruby”.upcase<br><br>p 23.to_s<br></code></pre><br><p>这个例子中我们使用了Ruby的字符串。我们使用<em>p</em>方法是为了在输出中看到数据类型。</p><br><pre><code>p “Ruby”<br>p ‘Python’<br></code></pre><br><p>在终端中打印两个字符串的字面值。第一个字面量是使用双引号，第二个是单引号。</p><br><pre><code>p “Ruby”.size<br>p “Ruby”.upcase<br></code></pre><br><p>这两行调用了两个字符串的方法。<em>size</em>方法返回字符串的长度，在这里是4个字符。<em>upcase</em>方法是将字符串转为大写。</p><br><pre><code>p 23.to_s<br></code></pre><br><p><em>to_s</em>方法是将整数转为字符串。</p><br><p>$ ./strings.rb<br><br>“Ruby”<br><br>“Python”<br><br>4<br><br>“RUBY”<br><br>“23”  </p><br><p>在输出中我们看到字符串是在引号内。这就是我们使用<em>p</em>方法的结果，<em>print</em>和<em>puts</em>方法都不会带上引号。</p><br><h2>数组和哈希表</h2><br><p>数组和哈希表是对象的集合。他们将对象集合在一起。</p><br><p>数组是对象的有序集合。哈希表是键-值对的集合。我们将会用单独的一章来介绍数组和哈希表。以下仅是一个预览的例子。</p><br><pre><code>#!/usr/bin/ruby<br><br>nums = [1, 2, 3, 4]<br><br>puts “There are #&#123;nums.size&#125; items in the array”<br><br>nums.each do |num|<br>    puts num<br>end<br><br><br>domains = &#123; :de =&gt; “Germany”, :sk =&gt; “Slovakia”,<br>            :us =&gt; “United States”, :no =&gt; “Norway” &#125;<br><br>puts domains.keys<br>puts domains.values<br></code></pre><br><p>这是一个Ruby数组和哈希表的例子。</p><br><pre><code>nums = [1, 2, 3, 4]<br><br>puts “There are #&#123;nums.size&#125; items in the array”<br><br>nums.each do |num|<br>    puts num<br>end<br></code></pre><br><p>这里创建一个有4项内容的数组。第二行统计了这个数组数据项的数量，并合并到了消息中。随后我们使用<em>each</em>方法将每个元素打印在终端上。</p><br><pre><code>domains = &#123; :de =&gt; “Germany”, :sk =&gt; “Slovakia”,<br>            :us =&gt; “United States”, :no =&gt; “Norway” &#125;<br><br>puts domains.keys<br>puts domains.values<br></code></pre><br><p>创建了Ruby的哈希表，然后打印它的键和值。</p><br><p>$ ./arrayshashes.rb<br><br>There are 4 items in the array<br><br>1<br><br>2<br><br>3<br><br>4<br><br>de<br><br>sk<br><br>us<br><br>no<br><br>Germany<br><br>Slovakia<br><br>United States<br><br>Norway  </p><br><p>例子的输出结果。</p><br><h2>类型转换</h2><br><p>我们经常是一次使用多种数据类型。在编程中从一种数据类型转换为其他类型是很平常的。类型转换或者类型的引用会将一个实体从一个类型转换成另一个类型。有两种类型转换的方式：隐式和显式。隐式类型转换又称为强制转换，是被编译器自动的转换。Ruby只有显式转换。</p><br><p>Ruby有内建的转换方法。如：<em>to_i</em>、<em>to_s</em>或者<em>to_f</em>。内核模块有一些公共的方法用来转换，如<em>Interger</em>、<em>String</em>或者<em>Float</em>。这些方法还要与Ruby的类混淆。</p><br><p>#!/usr/bin/ruby</p><br><pre><code>p Array(1..6)<br>p Complex 6<br>p Float 12<br>p Integer “34”<br>p Rational 6<br>p String 22<br></code></pre><br><p>这里我们展示了内核模块的转换方法。</p><br><p>$ ./convertmethods.rb<br><br>[1, 2, 3, 4, 5, 6]<br><br>(6+0i)<br><br>12.0<br><br>34<br><br>(6/1)<br><br>“22”  </p><br><p>例子的输出结果。</p><br><hr><br><pre><code>#!/usr/bin/ruby<br><br>p “12”.to_i<br>p 12.5.to_i<br>p nil.to_i<br><br>p 12.to_f<br>p “11”.to_f<br>p nil.to_f<br></code></pre><br><p>以上例子我们展示了数字的转换。一些对象具有<em>to_i</em>和<em>to_f</em>方法将对象转换成整数和浮点数。</p><br><pre><code>p “12”.to_i<br>p 12.5.to_i<br>p nil.to_i<br></code></pre><br><p>这里我们将字符串、小数和nil转换成整数。</p><br><pre><code>p 12.to_f<br>p “11”.to_f<br>p nil.to_f<br></code></pre><br><p>这三行将整数、字符串和nil转换成小数。</p><br><p>$ ./conversions.rb<br><br>12<br><br>12<br><br>0<br><br>12.0<br><br>11.0<br><br>0.0  </p><br><p>例子的输出结果。</p><br><hr><br><p>第二个例子展示了一些字符串的转换。</p><br><pre><code>#!/usr/bin/ruby<br><br>p “12”.to_i<br>p “13”.to_f<br>p “12”.to_r<br>p “13”.to_c<br><br>p “Jane”.to_sym<br><br>v = “Ruby Python Tcl PHP Perl”.split<br>p v.class<br></code></pre><br><p>上面的例子中我们将字符串转换为不同类型的对象。</p><br><pre><code>p “12”.to_i<br>p “13”.to_f<br>p “12”.to_r<br>p “13”.to_c<br></code></pre><br><p>这里将字符串转换成整数、小数、有理数和复数。</p><br><pre><code>p “Jane”.to_sym<br></code></pre><br><p>将字符串变为符号标志。</p><br><pre><code>v = “Ruby Python Tcl PHP Perl”.split<br>p v.class<br></code></pre><br><p>使用字符串的<em>split</em>方法将字符串转换成数组。</p><br><p>$ ./stringconv.rb<br><br>12<br><br>13.0<br><br>(12/1)<br><br>(13+0i)<br><br>:Jane<br><br>Array  </p><br><p>输出结果。</p><br><hr><br><p>下面的小例子展示了数组哈希表的转换。</p><br><pre><code>#!/usr/bin/ruby<br><br>h = &#123;:de =&gt; “Germany”, :sk =&gt; “Slovakia”&#125;<br>p h.to_a<br><br>a = [:de, “Germany”, :sk, “Slovakia”,<br>     :hu, “Hungary”, :no, “Norway”]<br>p Hash[<em>a]<br></code></pre><br><p>这个例子的代码我们创建了一个哈希表并转换成数组，创建一个数组并转换成哈希表。</p><br><pre><code>h = &#123;:de =&gt; “Germany”, :sk =&gt; “Slovakia”&#125;<br>p h.to_a<br></code></pre><br><p>哈希表转换为数组使用<em>to_a</em>方法。</p><br><pre><code>a = [:de, “Germany”, :sk, “Slovakia”,<br>     :hu, “Hungary”, :no, “Norway”]<br>p Hash[</em>a]<br></code></pre><br><p>将数组转换成哈希表。在这里的上下文中使用了星号操作符。这个风格来自<em>Perl</em>。它将一个数组分割成多个变量。</p><br><p>$ ./h2a.rb<br><br>[[:de, “Germany”], [:sk, “Slovakia”]]<br><br>{:de=&gt;”Germany”, :sk=&gt;”Slovakia”, :hu=&gt;”Hungary”, :no=&gt;”Norway”}  </p><br><p>输出结果。</p><br><p>这章在教程覆盖了数据类型和它们的转换。</p><br><hr><br><p>原文地址： <a target="_blank" rel="noopener" href="http://zetcode.com/lang/rubytutorial/datatypes/">http://zetcode.com/lang/rubytutorial/datatypes/</a><br><br>翻译：龙昌  admin@longchangjin.cn<br><br>完整教程：<a target="_blank" rel="noopener" href="https://github.com/wusuopu/Ruby-tutorial">https://github.com/wusuopu/Ruby-tutorial</a>  </p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://www.xefan.com/archives/83913.html" data-id="cl1hpb7zu005jeqoy2xn9gfp7" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Ruby/" rel="tag">Ruby</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E7%BF%BB%E8%AF%91/" rel="tag">翻译</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-[翻译]Ruby教程5——对象" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/archives/83909.html" class="article-date">
  <time datetime="2013-11-06T12:50:14.000Z" itemprop="datePublished">2013-11-06</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Ruby%E6%A0%8F%E7%9B%AE/">Ruby栏目</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/archives/83909.html">[翻译]Ruby教程5——对象</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><h1>Ruby中的对象</h1></p>
<p>在这章的教程中我们将简要的介绍下Ruby语言对象的概念。更多的内容将会在面向对象的章节中学习。由于Ruby的许多特性可以会使新手们迷惑，尤其是已经学习过其他编程语言的，因此才编写了这个关于对象的预备章节。</p><br><p>Ruby是一门面向对象的编程语言。这意味着我们可以在Ruby语言中使用对象。对于语言程序员来说Ruby程序就是一些字符流。这些符号就是Ruby的关键字、操作符、变量符号和字面量。从语言的角度来看Ruby程序是由对象组成的。这些对象在Ruby脚本程序执行进程来创建和修改。</p><br><p>有两种类型的对象：内置对象和自定义对象。内置对象是所有程序员都可以使用的预定义对象。它们由Ruby语言的内核或者变量库提示。自定义对象是由应用程序开发者在他们的应用程序域中创建的。</p><br><p>所有的对象都必须在使用之前创建。我们把创建对象叫做对象实例化。对象是由数据和方法组成，数据是对象静态的部分，方法是动态的形式。对象的修改以及与其他对象通信都是通过方法进行的。</p><br><pre><code>#!/usr/bin/ruby<br>puts “Ruby language”<br></code></pre><br><p>以上是一个简单的Ruby脚本。如果我们熟悉Pascal或者C之类的程序语言，我们可以看到一个名为<em>puts</em>的关键字或者是一个函数和一个字符串参数<em>“Ruby language”</em>。</p><br><p>看起来有点不同，Ruby是一门纯面向对象语言。<em>“Ruby language”</em>确实是一个字符串，常见的一种数据类型。但是它也是一个对象。与所有的对象一样，我们可以调用它们的方法。这与其他的语言有点不同。<em>puts</em>是一个方法。方法是定义在一个对象中的函数。方法是不能独自存在的。实际上<em>puts</em>方法是<em>Kernel</em>模块的一部分。</p><br><pre><code>#!/usr/bin/ruby<br>Kernel.puts “Ruby language”<br>Kernel.puts “Ruby language”.size<br></code></pre><br><p>在以上的脚本中我们写了两行代码。</p><br><pre><code>Kernel.puts “Ruby language”<br></code></pre><br><p><em>Kernel</em>是可以省略的，在第一个例子中我们调用<em>puts</em>方法就没有使用<em>Kernel</em>。这样可以少打些字节约时间。实际上它是对于<em>Kernel.puts</em>这个正式调用的简写。正如在C#中的Console.writeln和Java中的System.println。因此方法必须与一个对象相关联，或者如果是类方法就必须与类相关联。</p><br><pre><code>Kernel.puts “Ruby language”.size<br></code></pre><br><p>在这行代码中我们在终端上打印了<em>“Ruby language”</em>这个字符串的长度。对于有其他编程语言经验的程序员来说可能会困惑。在其他语言中字符串是一个原始数据类型，不能修改，并且没有自己的方法。在Ruby中字符串是一个完整的对象，有自己的方法。<em>size</em>方法其中一个，用于返回这个字符串的长度。</p><br><p>$ ./simple2.rb<br><br>Ruby language<br><br>13  </p><br><p>以上是这个例子的输出。</p><br><hr><br><p>接下来的例子我们看看整数。与字符串相似一个数字也是一个对象。</p><br><pre><code>#!/usr/bin/ruby<br>puts 6.object_id<br>puts 6.even?<br>puts 6.zero?<br>puts 6.class<br></code></pre><br><p>这个例子中我们定义了一个数字<em>6</em>。然后调用了一些这个数字的方法。</p><br><pre><code>puts 6.object_id<br></code></pre><br><p>这里<em>6</em>是一个对象，<em>object_id</em>是一个方法。这个方法返回了与这个对象相关联的id号。每个对象都拥有一个id号。如果我们要在对象上调用一个方法，就必须在他们之间加点号。</p><br><pre><code>puts 6.even?<br>puts 6.zero?<br></code></pre><br><p>这里我们对<em>6</em>这个对象调用了两个方法。如果一个数是偶数，那么<em>even?</em>返回<em>true</em>；如果一个数等于0,那么<em>zero?</em>返回<em>true</em>。注意这两个方法都是以问号能结尾的。在Ruby中约定了如果一个方法返回值是布尔类型，那么方法名以问号结尾。</p><br><pre><code>puts 6.class<br></code></pre><br><p><em>class</em>方法告诉我们当前正在处理的这个对象是什么类型的。在这里<em>6</em>是一个<em>Fixnum</em>类型。</p><br><p>$ ./objectnumber.rb<br><br>13<br><br>true<br><br>false<br><br>Fixnum  </p><br><p>以上是这个例子的输出结果。</p><br><h2>创建对象</h2><br><p>我们之前提到了在Ruby是对象使用之前必须先创建。对象可以被隐式创建或者显式创建。使用字面量符号创建对象是隐式创建；使用<em>new</em>关键字创建对象是显式创建。自定义对象都是显式创建的。自定义对象必须是从某个特定的类创建的。类是对象的模块，一个类可以创建多个对象。</p><br><pre><code>#!/usr/bin/ruby<br>class Being<br>end<br><br>puts 67<br>puts “ZetCode”<br><br>s = String.new “ZetCode”<br>puts s<br><br># n1 = Fixnum.new 67<br># puts n1<br><br>b = Being.new<br>puts b<br></code></pre><br><p>这个例子演示了Ruby中的对象创建。</p><br><pre><code>class Being<br>end<br></code></pre><br><p>这里是一个名为<em>Being</em>的对象模块。对象模块使用<em>class</em>关键字创建。自定义对象模块通常放在代码文件的顶部，或者分开放在另外的文件中。</p><br><pre><code>puts 67<br>puts “ZetCode”<br></code></pre><br><p>这两行代码我们用到了两个对象。<em>Fixnum</em>类型的<em>67</em>和<em>String</em>类型的<em>“ZetCode”</em>。<em>67</em>和<em>“ZetCode”</em>是使用字面符号创建了。字面符号是一个文本，表示了一个类型的特定值。这两个对象是Ruby解释器幕后创建的。在源代码中Ruby的一些对象是使用他们特定的字面符号创建的。</p><br><pre><code>s = String.new “ZetCode”<br>puts s<br></code></pre><br><p>这是正式的方法创建字符串对象。它与之前的隐式创建是等价的。</p><br><pre><code># n1 = Fixnum.new 67<br># puts n1<br></code></pre><br><p>不是所有的内置对象都可以使用<em>new</em>方法来创建。以上代码就不能编译通过。<em>Fixnum</em>对象只能通过字面符号来创建。</p><br><pre><code>b = Being.new<br>puts b<br></code></pre><br><p>这里我们创建了自定义对象的一个实例。<em>puts</em>方法输出了这个对象的简短描述。</p><br><p>$ ./ocreation.rb<br><br>67<br><br>ZetCode<br><br>ZetCode<br><br>#&lt;Being:0x9944d9c&gt;  </p><br><p>以上是输出结果。</p><br><hr><br><p>继续介绍一些正式的对象创建。  </p><br><pre><code>#!/usr/bin/ruby<br><br>s1 = String.new “Ruby”<br>puts s1.size<br>puts s1.downcase<br><br>a1 = Array.new<br>a1.push 1, 2, 3<br>puts a1.include? 3<br>puts a1.empty?<br><br>r1 = Range.new 1, 6<br>puts r1.class<br>puts r1.include? 4<br></code></pre><br><p>在这个例子中，我们创建三个内建对象并且调用了几个它们的方法。</p><br><pre><code>s1 = String.new “Ruby”<br>puts s1.size<br>puts s1.downcase<br></code></pre><br><p>创建一个字符串对象，并且调用了它的两个方法。<em>size</em>方法返回这个字符串的长度。<em>downcase</em>方法将这个字符串转为小写。</p><br><pre><code>a1 = Array.new<br>a1.push 1, 2, 3<br>puts a1.include? 3<br>puts a1.empty?<br></code></pre><br><p>这里创建了一个数组，并往其中添加了三个数字。然后调用了两个数组的方法。<em>include?</em>方法用于检查一个特定的值（在这个例子中是3）是否在数组内。<em>empty?</em>方法返回一个布尔类型的值表明这个数组是否为空。</p><br><pre><code>r1 = Range.new 1, 6<br>puts r1.class<br>puts r1.include? 4<br></code></pre><br><p>创建了一个<em>Range</em>类型的实例对象。它包含了1到6的数字。<em>class</em>方法返回这个对象的类型名称。在这个例子中<em>include?</em>方法检查数字<em>4</em>是否在这个范围内。</p><br><p>$ ./formal.rb<br><br>4<br><br>ruby<br><br>true<br><br>false<br><br>Range<br><br>true  </p><br><p>这个例子的运行输出结果。</p><br><h2>对象字面符</h2><br><p>前面提到了一些内建对象可以使用对象字面符创建。接下来的例子展示了一些对象字面符。</p><br><pre><code>#!/usr/bin/ruby<br><br>4.times &#123; puts “Ruby” &#125;<br><br>puts “Ruby”.size<br>puts “Ruby”.downcase<br><br>puts [1, 2, 3].include? 3<br>puts [1, 2, 3].empty?<br><br>puts :name.class<br>puts :name.frozen?<br><br>puts (1..6).class<br>puts (1..6).include? 4<br></code></pre><br><p>在这个例子中我们使用字面符创建了<em>Fixnum</em>、<em>Strings</em>、<em>Arrays</em>、 <em>Symbols</em>和<em>Ranges</em>对象。</p><br><pre><code>4.times &#123; puts “Ruby” &#125;<br></code></pre><br><p>我们可以直接对一个整数字面符号调用方法。这行代码将在终端上打印4次”Ruby”字符串。</p><br><pre><code>puts “Ruby”.size<br>puts “Ruby”.downcase<br></code></pre><br><p>我们对使用字面符号创建的字符串调用了两个方法。</p><br><pre><code>puts [1, 2, 3].include? 3<br>puts [1, 2, 3].empty?<br></code></pre><br><p>这里我们使用字面符号创建了两个数组。然后使用<em>include?</em>方法检查一个特定的数字是否是这个数组里；使用<em>empty?</em>方法检查这个数组是否为空。</p><br><pre><code>puts :name.class<br>puts :name.frozen?<br></code></pre><br><p>使用以冒号开头的字面符号创建了符号对象，并且调用的它的两个方法。</p><br><pre><code>puts (1..6).class<br>puts (1..6).include? 4<br></code></pre><br><p>使用字面符号创建了两个范围对象，并且调用了他们的两个方法。<em>class</em>方法返回这个类的名称，<em>include?</em>方法检查给定的数字是否是这个范围内。</p><br><p>$ ./literals.rb<br><br>Ruby<br><br>Ruby<br><br>Ruby<br><br>Ruby<br><br>4<br><br>ruby<br><br>true<br><br>false<br><br>Symbol<br><br>false<br><br>Range<br><br>true  </p><br><p>以上是例子的输出结果。</p><br><h2>对象层级</h2><br><p>在许多面向对象语言中对象是层级形式的。Ruby中也有对象层级。与树形层级相似，我们也有父对象和子对象。对象从它的父对象中继承数据和行为。层级的顶级是根对象，称为<em>Object</em>。在Ruby中每个对象都至少有一个父对象。也就是就每个对象都继承至<em>Object</em>对象的基类。</p><br><p>根据Ruby的官方文档，<em>Object</em>是Ruby的类层级的根。它的所有方法在所有的类中都是一样的，除非显示的覆盖了。</p><br><pre><code>#!/usr/bin/ruby<br><br>puts 4.is_a? Object<br>puts “Ruby”.is_a? Object<br>puts [2, 3].is_a? Object<br>puts :name.is_a? Object<br>puts (1..2).is_a? Object<br></code></pre><br><p>以上例子的代码展示了所有对象都是继承至根对象<em>Object</em>。</p><br><pre><code>puts 4.is_a? Object<br></code></pre><br><p>使用<em>is_a?</em>方法检查一个数字是否为特定的类型，也就是说它是否继承至给定的对象类型。</p><br><p>$ ./mother.rb <br><br>true<br><br>true<br><br>true<br><br>true<br><br>true  </p><br><p>所有方法都返回<em>true</em>，意味着所有的对象都继承至母类。</p><br><hr><br><p>即使是基本的Ruby对象，它们的继承层级也可能是很复杂的。</p><br><pre><code>#!/usr/bin/ruby<br><br>puts 6.class<br><br>puts 6.is_a? BasicObject<br>puts 6.is_a? Object<br>puts 6.is_a? Numeric<br>puts 6.is_a? Integer<br>puts 6.is_a? Fixnum<br><br>puts 6.is_a? Bignum<br>puts 6.is_a? String<br></code></pre><br><p>这个例子展示了小数字的继承层级。</p><br><pre><code>puts 6.class<br></code></pre><br><p>我们发现数字6的类型是<em>Fixnum</em>。</p><br><pre><code>puts 6.is_a? BasicObject<br>puts 6.is_a? Object<br>puts 6.is_a? Numeric<br>puts 6.is_a? Integer<br>puts 6.is_a? Fixnum<br></code></pre><br><p>以上这些代码全都返回<em>true</em>。数字6是<em>Fixnum</em>类型。从Ruby文档中我们发现另外四个对象是<em>Fuxnum</em>对象的父类。</p><br><pre><code>puts 6.is_a? Bignum<br>puts 6.is_a? String<br></code></pre><br><p>$ ./inheritance.rb<br><br>Fixnum<br><br>true<br><br>true<br><br>true<br><br>true<br><br>true<br><br>false<br><br>false  </p><br><p>以上是输出结果。</p><br><hr><br><p>这节的最后再举个例子展示下自定义对象的继承。</p><br><pre><code>#!/usr/bin/ruby<br><br>class Being<br><br>    def to_s<br>        “This is Being”<br>    end<br><br>    def get_id<br>        9<br>    end<br>end<br><br>class Living &lt; Being<br><br>    def to_s<br>        “This is Living”<br>    end<br>end<br><br>l = Living.new<br><br>puts l<br>puts l.get_id<br>puts l.is_a? Being<br>puts l.is_a? Object<br>puts l.is_a? BasicObject<br></code></pre><br><p>在这个例子中我们创建了两个对象。<em>Being</em>和<em>Living</em>。<em>Living</em>对象继承至<em>Being</em>。第一个是父对象，第二介是子对象。</p><br><pre><code>class Being<br><br>    def to_s<br>        “This is Being”<br>    end<br><br>    def get_id<br>        9<br>    end<br>end<br></code></pre><br><p>这里定义了一个Ruby的自定义对象。定义内容是<em>class</em>和<em>end</em>关键字之间。在定义里我们创建了两个方法。当<em>puts</em>方法接了一个对象作为参数时，会调用它的<em>to_s</em>方法。它通常返回这个对象的字符串描述。</p><br><pre><code>class Living &lt; Being<br><br>    def to_s<br>        “This is Living”<br>    end<br>end<br></code></pre><br><p>定义了一个<em>Living</em>对象，这个对象继承至<em>Being</em>对象。<em>&lt;</em>操作符用于创建继承关系。<em>to_s</em>方法被覆盖了。</p><br><pre><code>l = Living.new<br></code></pre><br><p>我们创建了一个Living实例对象。自定义对象使用<em>new</em>关键字创建。</p><br><pre><code>puts l<br></code></pre><br><p><em>puts</em>方法调用<em>Living</em>对象的<em>to_s</em>方法。只有当<em>Living</em>类没有定义<em>to_s</em>方法时，<em>Being</em>类的<em>to_s</em>方法才会被调用。</p><br><pre><code>puts l.get_id<br></code></pre><br><p><em>Living</em>对象没有定义<em>get_id</em>方法。在这种情况下就检查它的父类是否有此方法。在这里<em>Being</em>有这个方法，并且被调用。</p><br><pre><code>puts l.is_a? Being<br></code></pre><br><p>这行将返回<em>true</em>。<em>Living</em>对象是<em>Being</em>类型的，因为它继承至<em>Being</em>类。</p><br><pre><code>puts l.is_a? Object<br>puts l.is_a? BasicObject<br></code></pre><br><p>我们的<em>Living</em>自定义对象中，没有特别显示的指定与<em>Object</em>或者<em>BasicObject</em>的关系。然而这两行也返回<em>true</em>。这是因为在Ruby中所有对象都是自动设置为这两个对象的后代。这是Ruby解释器在幕后完成的。</p><br><p>$ ./custominher.rb<br><br>This is Living<br><br>9<br><br>true<br><br>true<br><br>true  </p><br><p>以上是输出结果。</p><br><h2>Ruby的顶级环境</h2><br><p>Ruby中有一个特殊的对象引用到Ruby的顶级环境，这是定义在其他上下文之外的默认执行环境。顶级环境名字是<em>main</em>。它是一个<em>Object</em>类型的实例对象。以下<em>main</em>分配了一个局部空间，所有的局部变量有属于它。</p><br><pre><code>#!/usr/bin/ruby<br><br>n1 = 3<br>n2 = 5<br><br>puts local_variables<br><br>Kernel.puts self<br>puts self.class<br></code></pre><br><p>这是描述Ruby顶级环境的第一个例子。</p><br><pre><code>n1 = 3<br>n2 = 5<br></code></pre><br><p>我们定义了两个数字类型的变量，这些变量是顶级环境的局部变量。</p><br><pre><code>puts local_variables<br></code></pre><br><p>这里我们输出所有的局部变量。<em>local_variables</em>是<em>Kernel</em>模块的一个方法，它包含了每个顶级环境的对象。</p><br><pre><code>Kernel.puts self<br></code></pre><br><p><em>self</em>是Ruby的伪变量。它返回当前对象的接收者。这行将在终端打印<em>“main”</em>。这是顶级环境的名字。<em>Kernel.puts</em>代码部分的<em>Kernel</em>可以省略。完整的名字表示的<em>puts</em>方法属于<em>Kernel</em>模块。</p><br><pre><code>puts self.class<br></code></pre><br><p>这行打印了顶级环境的类型。我们得到顶级环境的对象类型。它是<em>Object</em>类型，Ruby类层级的根。</p><br><p>$ ./toplevel.rb<br><br>n1<br><br>n2 <br><br>main <br><br>Object  </p><br><p>这是这个例子的输出结果。<em>n1</em>、<em>n2</em>是顶级环境所分配的局部变量。<em>main</em>是Ruby顶级执行环境的名字。最后<em>Object</em>是顶级环境的类型。</p><br><hr><br><p>我们再展示另一个关于Ruby顶级环境的例子。</p><br><pre><code>#!/usr/bin/ruby<br><br>@name = “Jane”<br>@age = 17<br><br>def info<br>   “#&#123;@name&#125; is #&#123;@age&#125; years old”<br>end<br><br>puts self.instance_variables<br>puts self.private_methods.include? :info<br><br>puts info<br></code></pre><br><p>我们展示的属于顶级环境的实例变量和方法。</p><br><pre><code>@name = “Jane”<br>@age = 17<br></code></pre><br><p>我们定义了两个实例变量。在Ruby中实例变量以<em>@</em>符号开头。实例变量属于指定的对象实例。在这里是属于Ruby的顶级环境。</p><br><pre><code>def info<br>   “#&#123;@name&#125; is #&#123;@age&#125; years old”<br>end<br></code></pre><br><p>这里定义了一个方法。每个方法都必须属于一个对象。这个方法是属于顶级环境的。所有顶级环境的方法都是私有的。私有方法的访问是受制的。</p><br><pre><code>puts self.instance_variables<br></code></pre><br><p><em>instance_variables</em>方法打印<em>self</em>的所有实例变量。</p><br><pre><code>puts self.private_methods.include? :info<br></code></pre><br><p>所有的顶级环境的方法都自动设为私有。<em>private_methods</em>返回该对象所有的私有方法。由于内容太多，我们就调用<em>include?</em>方法来检查<em>info</em>方法是否是其中一个。注意我们是通过符号名来引用<em>info</em>的。</p><br><p>$ ./toplevel2.rb<br><br>@name<br><br>@age<br><br>true<br><br>Jane is 17 years old  </p><br><p>以上是例子的输出结果。</p><br><p>这章包含了Ruby对象的基本内容。</p><br><hr><br><p>原文地址： <a target="_blank" rel="noopener" href="http://zetcode.com/lang/rubytutorial/objects/">http://zetcode.com/lang/rubytutorial/objects/</a><br><br>翻译：龙昌  admin@longchangjin.cn<br><br>完整教程：<a target="_blank" rel="noopener" href="https://github.com/wusuopu/Ruby-tutorial">https://github.com/wusuopu/Ruby-tutorial</a>  </p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://www.xefan.com/archives/83909.html" data-id="cl1hpb7zu005ieqoy525x30iz" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Ruby/" rel="tag">Ruby</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E7%BF%BB%E8%AF%91/" rel="tag">翻译</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-[翻译]Ruby教程4——变量" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/archives/83905.html" class="article-date">
  <time datetime="2013-11-05T12:18:38.000Z" itemprop="datePublished">2013-11-05</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Ruby%E6%A0%8F%E7%9B%AE/">Ruby栏目</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/archives/83905.html">[翻译]Ruby教程4——变量</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><h1>变量</h1></p>
<p>在这章的教程中我们将详细介绍变量。  </p><br><p>变量是保存数据的地址。每个变量都有唯一的一个名字，变量命名存在着一些约定。变量保存着数据对象，更确切的说变量是对数据所在的计算机内存地址的引用。每一个对象都具有一定的数据类型，内置的类型或者自定义的类型。Ruby属于动态语言，与Java、C或者Pascal之类的强类型语言不同，动态语言不用为变量定义确切数据类型，而是解释器在分配变量时决定它的类型。在Ruby中程序运行过程变量可以包含不同类型的不同值。</p><br><blockquote><br><p>#!/usr/bin/ruby  </p><br><p>i = 5<br><br> puts i<br><br> i = 7<br><br> puts i  </p><br></blockquote><br><p>变量是可变的，与常量不同，在程序运行过程中它们可以保存不同的值。在上面这个例子中有一个名为<em>i</em>的变量，首先赋值为5,然后又改为7。</p><br><h2>命名约定</h2><br><p>与其他语言一样，Ruby对变量标识符也有些命名约定。<br><br>Ruby是区分大小写的，这意味着<em>age</em>和<em>Age</em>是两个变量名。许多语言都是区分大小写的，但是BASIC例外。我们改变字符的大小写可以创建不同的变量，但是不推荐这种做法。</p><br><blockquote><br><p>#!/usr/bin/ruby  </p><br><p>i = 5<br><br> p i<br><br> I = 7<br><br> p I  </p><br></blockquote><br><p>这个例子定义了两个变量<em>I</em>和<em>i</em>，它们保存了不同的值。</p><br><p>./case.rb<br><br>5<br><br>7  </p><br><p>以上是<em>case.rb</em>脚本的输出结果。</p><br><hr><br><p>在Ruby中变量名可由字母数字和下划线组成。为了使解释器能简单的从字面上区分数字和变量，变量名不能以数字开头。变量名同样也不能以大写字母开头，在Ruby中以大写字母开头会被认为是常量。</p><br><blockquote><br><p>#!/usr/bin/ruby  </p><br><p>name = “Jane”<br><br> placeOfBirth = “Bratislava”<br><br> placeOfBirth = “Kosice”<br><br> favorite_season = “autumn”  </p><br><p>n1 = 2<br><br> n2 = 4<br><br> n3 = 7  </p><br><p>p name, placeOfBirth, favorite_season<br><br> p n1, n2, n3  </p><br></blockquote><br><p>在这个脚本中我们展示一些变量的命名。</p><br><hr><br><p>变量名应该是有意义的。好的编程习惯是给变量取个具有描述性的名字，使得程序更加可读。</p><br><pre><code>#!/usr/bin/ruby<br><br>name = “Jane”<br>place_of_birth = “Bratislava”<br>occupation = “student”<br><br>i = 5<br>while i &gt; 0 do<br>    puts name<br>    i -= 1<br>end<br></code></pre><br><p>这个脚本展示三个具有描述性的变量名。对于程序员来说<em>place_of_birth</em>比其他的名字如<em>pob</em>更具有描述性。在循环的时候通常选择一个比较简单的变量名。</p><br><h2>印章(Sigils)</h2><br><p>变量标识符可以以一些特殊的印章（Sigils）符号开头。印章（Sigils）是附加在标识符上的符号。在Ruby中变量印章（Sigils）表示了变量的作用域范围。在Perl中它是表示数据的类型。Ruby的变量印章（Sigils）符号有<em>$</em>和<em>@</em>。  </p><br><blockquote><br><p>#!/usr/bin/ruby  </p><br><p>tree_name = “pine”<br><br> $car_name = “Peugeot”<br><br> @sea_name = “Black sea”<br><br> @@species = “Cat”  </p><br><p>p local_variables<br><br> p global_variables.include? :$car_name<br><br> p self.instance_variables<br><br> p Object.class_variables  </p><br></blockquote><br><p>我们定义了四个不同作用域范围的变量。作用域表示了该变量可以被引用到的范围。我们使用了内置的方法来决定变量的作用域。</p><br><blockquote><br><p>tree_name = “pine”  </p><br></blockquote><br><p>不包含印章（Sigils）符号的变量是一个局部变量。局部变量只在局部有效，如在方法、代码块、模块内。</p><br><blockquote><br><p>$car_name = “Peugeot”  </p><br></blockquote><br><p>全局变量以<em>$</em>符号开头。它们在所有地方都是有效的。在程序中不要滥用全局变量。</p><br><blockquote><br><p>@sea_name = “Black sea”  </p><br></blockquote><br><p>实例变量是以<em>@</em>符号开头。它只有在实例对象中才有效。</p><br><blockquote><br><p>@@species = “Cat”  </p><br></blockquote><br><p>最后我们定义了一个类变量。它在所有属于这个类的实例中都有效。</p><br><blockquote><br><p>p local_variables  </p><br></blockquote><br><p><em>local_variables</em>是保存了当前环境下所有定义的局部变量的数组。</p><br><blockquote><br><p>p global_variables.include? :$car_name  </p><br></blockquote><br><p>类似的，<em>global_variables</em>是保存的全部全局变量的数组。由于全局变量很多，我们就不将它们全部在终端上打印了。每次Ruby脚本启动时都会预定义一些变量。我们使用数组的<em>include?</em>方法来检查我们全局变量是否定义了。同时请注意我们引用变量是用的符号。（符号是以一个冒号开头）</p><br><blockquote><br><p>p self.instance_variables  </p><br></blockquote><br><p><em>self</em>伪变量指向了<em>instance_variables</em>方法的接收对象。这个例子中的接收对象是<em>main</em>，Ruby的顶级执行区域。</p><br><blockquote><br><p>p Object.class_variables </p><br></blockquote><br><p>最后我们获取所有的类变量数组。<em>main</em>是一个Object类的实例。</p><br><p>$ ./sigils.rb<br><br>[:tree_name]<br><br>true<br><br>[:@sea_name]<br><br>[:@@species]  </p><br><p>以上是这个例子的输出结果，我们看到了变量的符号名。</p><br><h2>局部变量</h2><br><p>局部变量是只在Ruby源代码的局部区域有效。这个区域也称为局部作用域。局部变量是在Ruby的模块、方法、类中定义。</p><br><pre><code>#!/usr/bin/ruby<br><br>def method1<br>   x = 5<br>   p x<br>end<br><br>method1<br><br>p x<br></code></pre><br><p>我们定义了一个名为<em>method1</em>的方法，它有一个变量。这个变量是局部变量。这意味着这个变量只在这个方法内有效。我们只能在这个方法名到<em>end</em>关键字之间访问<em>x</em>变量。</p><br><pre><code>def method1<br>   x = 5<br>   p x<br>end<br></code></pre><br><p>以上定义了一个<em>method1</em>方法。在方法内部创建了一个局部变量<em>x</em>，然后将它的值打印到终端。</p><br><blockquote><br><p>method1  </p><br></blockquote><br><p>方法被调用。</p><br><blockquote><br><p>p x  </p><br></blockquote><br><p>我们试图在方法外部访问这个局部变量。这将导致<em>NameError</em>错误，Ruby解释器找不到这个标识符。</p><br><p>$ ./locals.rb<br><br>5<br><br>./locals.rb:11:in <code>&lt;main&gt;’: undefined local variable<br>or method</code>x’ for main:Object (NameError)  </p><br><p>以上是这个例子的输出结果。</p><br><hr><br><p>以下例子是对前一个例子的简单修改。</p><br><pre><code>#!/usr/bin/ruby<br><br>x = 5<br><br>def method1<br>    x = 10<br>    p x<br>end<br><br>method1<br><br>p x<br></code></pre><br><p>我们定义了两个<em>x</em>变量。一个是在<em>method1</em>内部定义的，另一个是在外部定义的。他们是两个不同的局部变量，并不会相互冲突。</p><br><pre><code>x = 5<br></code></pre><br><p>我们创建了一个局部变量，它的值为5。这个变量的局部作用范围是<em>main</em>区域。它在<em>method1</em>内部是无效的。  </p><br><pre><code>def method1<br>    x = 10<br>    p x<br>end<br></code></pre><br><p>在<em>method1</em>内部创建了一个新的<em>x</em>局部变量，它的值是10.它存在于<em>method1</em>方法内部，在<em>end</em>关键字之后就会失效。</p><br><p>$ ./locals2.rb<br><br>10<br><br>5  </p><br><p>以上是输出结果。</p><br><hr><br><p>如果一个方法接收了参数，那么就会创建与这些参数相对应的局部变量。  </p><br><pre><code>#!/usr/bin/ruby<br><br><br>def rectangle_area a, b<br>    puts local_variables<br>    return a <em> b<br>end<br><br>puts rectangle_area 5, 6<br></code></pre><br><p>我们定义了一个方法，它接收两个值，然后返回这个矩形的面积。</p><br><pre><code>def rectangle_area a, b<br>    puts local_variables<br>    return a </em> b<br>end<br></code></pre><br><p><em>rectangle_area</em>方法接收两个参数。它们是矩形的边长，然后我们计算它的面积。对应于标识符<em>a</em>、<em>b</em>的两个局部变量将自动创建了。我们调用<em>local_variables</em>方法查看方法内部的所有局部变量。</p><br><pre><code>puts rectangle_area 5, 6<br></code></pre><br><p>这里我们给<em>rectangle_area</em>方法传了两个值。这两个值将会分配给在方法内部创建的两个局部变量。  </p><br><p>$ ./parameters.rb<br><br>a<br><br>b<br><br>30  </p><br><p>输出了三个结果。前两个是<em>rectangle_area</em>方法内部的局部变量名。第三个是面积的计算结果。</p><br><hr><br><p>一个方法可以定义在另一个方法的内部。内嵌方法有它自己的局部变量。</p><br><pre><code>#!/usr/bin/ruby<br><br>def method1<br><br>    def method2<br><br>        def method3<br>            m5, m6 = 3<br>            puts “Level 3”<br>            puts local_variables<br>        end<br><br>        m3, m4 = 3<br>        puts “Level 2”<br>        puts local_variables<br>        method3<br>    end<br><br>    m1, m2 = 3<br>    puts “Level 1”<br>    puts local_variables<br>    method2<br><br>end<br><br>method1<br></code></pre><br><p>在这个Ruby脚本中我们创建了三个方法。<em>method2</em>和<em>method3</em>是内嵌方法。<em>method2</em>定义在<em>method1</em>内部，<em>method3</em>又定义在<em>method2</em>内部。每一个方法的局部变量仅在这个方法内是可访问的。</p><br><p>$ ./lms.rb<br><br>Level 1<br><br>m1<br><br>m2<br><br>Level 2<br><br>m3<br><br>m4<br><br>Level 3<br><br>m5<br><br>m6  </p><br><p>从输出结果我们可以知道<em>method1</em>有两个局部变量<em>m1</em>和<em>m2</em>。内嵌方法<em>method2</em>的局部变量有<em>m3</em>、<em>m4</em>。最内部的方法<em>method3</em>的局部变量是<em>m5</em>、<em>m6</em>。  </p><br><hr><br><p>这一节的最后一个例子将展示一些局部作用域的示范。</p><br><pre><code>module ModuleM<br>    m1, m2 = 4<br><br>    puts “Inside module”<br>    puts local_variables<br>end<br><br><br>def method1<br>    v, w = 3<br>    puts “Inside method”<br>    puts local_variables<br>end<br><br><br>class Some<br>    x, y = 2<br>    puts “Inside class”<br>    puts local_variables<br>end<br><br>method1<br><br>t1, t2 = 7<br><br>puts “Inside toplevel”<br>puts local_variables<br></code></pre><br><p>在这个例子我们分别在模块、方法、类和顶级环境中创建局部变量。<em>local_variables</em>是内核模块的一个方法，用于获取当前的所有局部变量。</p><br><pre><code>module ModuleM<br>    m1, m2 = 4<br><br>    puts “Inside module”<br>    puts local_variables<br>end<br></code></pre><br><p>模块是一个方法和常量的集合。我们创建了两个局部变量<em>m1</em>和<em>m2</em>。</p><br><pre><code>def method1<br>    v, w = 3<br>    puts “Inside method”<br>    puts local_variables<br>end<br></code></pre><br><p>在<em>method1</em>方法中创建了两个局部变量<em>v</em>、<em>w</em>。</p><br><pre><code>class Some<br>    x, y = 2<br>    puts “Inside class”<br>    puts local_variables<br>end<br></code></pre><br><p>在<em>Some</em>类中创建了两个局部变量<em>x</em>、<em>y</em>。</p><br><pre><code>t1, t2 = 7<br></code></pre><br><p>最后我们为Ruby顶级环境创建两个局部变量。</p><br><p>$ ./locals3.rb <br><br>Inside module<br><br>m1<br><br>m2<br><br>Inside class<br><br>x<br><br>y<br><br>Inside method<br><br>v<br><br>w<br><br>Inside toplevel<br><br>t1<br><br>t2  </p><br><p>输出结果展示了各个作用域的局部变量。</p><br><h2>全局变量</h2><br><p>全局变量可以在脚本的任何地方访问到。它们以<em>$</em>符号开头。<br><br>全局变量可能会引起很多程序错误，因此不鼓励使用全局变量。除非有原因要使用，否则建议使用局部变量。</p><br><pre><code>#!/usr/bin/ruby<br><br>$gb = 6<br><br><br>module ModuleM<br>    puts “Inside module”<br>    puts $gb<br>end<br><br><br>def method1<br>    puts “Inside method”<br>    puts $gb<br>end<br><br><br>class Some<br>    puts “Inside class”<br>    puts $gb<br>end<br><br>method1<br><br>puts “Inside toplevel”<br>puts $gb<br>puts global_variables.include? :$gb<br></code></pre><br><p>在这个例子中我们创建了一个全局变量<em>$gb</em>。这个变量在模块、方法、类和顶级环境都可以访问。全部变量<em>$gb</em>是所有的实体中都是有效的。</p><br><pre><code>$gb = 6<br></code></pre><br><p>创建全局变量<em>$gb</em>，它的值为6。</p><br><pre><code>module ModuleM<br>    puts “Inside module”<br>    puts $gb<br>end<br></code></pre><br><p>在一个模块定义中我们打印全局变量的值。</p><br><pre><code>def method1<br>    puts “Inside method”<br>    puts $gb<br>end<br></code></pre><br><p>在一个方法定义中我们打印全局变量的值。</p><br><pre><code>class Some<br>    puts “Inside class”<br>    puts $gb<br>end<br></code></pre><br><p>在一个类定义中我们打印全局变量的值。</p><br><pre><code>puts $gb<br>puts global_variables.include? :$gb<br></code></pre><br><p>在顶级环境下打印全局变量的值，并检查这个变量是否为全局变量。</p><br><p>$ ./globals.rb<br><br>Inside module<br><br>6<br><br>Inside class<br><br>6<br><br>Inside method<br><br>6<br><br>Inside toplevel<br><br>6<br><br>true  </p><br><p>这个例子的输出结果确认了全局变量可以任何地方访问到。  </p><br><hr><br><p>当一个Ruby脚本启动时，它会访问多个预定义的全局变量。这些全局变量不认为有害并且能帮助完成一些常见的任务。</p><br><pre><code>#!/usr/bin/ruby<br><br>p $LOAD_PATH<br>p $:<br></code></pre><br><p>这个脚本显示了<em>$LOAD_PATH</em>这个全局变量。这个变量列出了<em>require</em>方法会搜索的所有目录。<em>$:</em>是<em>$LOAD_PATH</em>的缩写。<br><br>更多的全局变量会在本章的变量预定义这节中介绍。</p><br><h2>实例变量、类变量</h2><br><p>在这节将简要的介绍下实例变量和类变量。它们将会在面向对象那一章详细介绍。<br><br>实例变量是属于具体某个对象实例的变量。每个对象都有它自己的变量。实例变量以<em>@</em>符号开头。类变量属于特定某个类的。这个类所创建的对象实例共享这个类的类变量。类变量以<em>@@</em>符号开头。</p><br><pre><code>#!/usr/bin/ruby<br><br>class Being<br><br>    @@is = true<br><br>    def initialize nm<br>        @name = nm<br>    end<br><br>    def to_s<br>        “This is #&#123;@name&#125;”<br>    end<br><br>    def does_exist?<br>        @@is<br>    end<br>end<br><br>b1 = Being.new “Being 1”<br>b2 = Being.new “Being 2”<br>b3 = Being.new “Being 3”<br><br>p b1, b2, b3<br><br>p b1.does_exist?<br>p b2.does_exist?<br>p b3.does_exist?<br></code></pre><br><p>我们创建一个自定义<em>Being</em>类。这个<em>Being</em>类有一个类变量和一个实例变量。</p><br><pre><code>class Being<br>    @@is = true<br></code></pre><br><p><em>@@is</em>是一个类变量。这个类变量被所有<em>Being</em>类的实例所共享。这个例子的逻辑是判断是不是<em>Being</em>。</p><br><pre><code>def initialize nm<br>    @name = nm<br>end<br></code></pre><br><p><em>initialize</em>方法是构造函数。这个方法在对象被创建时调用。用于创建<em>@name</em>实例变量。  </p><br><pre><code>def to_s<br>    “This is #&#123;@name&#125;”<br>end<br></code></pre><br><p>当这个对象作为打印方法如p或者puts的参数时<em>to_s method</em>方法会被调用。这个方法返回这个对象便于人类阅读的描述内容。  </p><br><pre><code>def does_exist?<br>    @@is<br>end<br></code></pre><br><p><em>does_exist?</em>返回类变量。</p><br><pre><code>b1 = Being.new “Being 1”<br>b2 = Being.new “Being 2”<br>b3 = Being.new “Being 3”<br></code></pre><br><p>创建Being类的三个实例对象。每个对象拥有不同的名字。这个名字存储在实例变量中，对于每个对象它是唯一的。名字将会在<em>to_s</em>方法中使用，用于返回一个对该对象的简短描述。</p><br><pre><code>p b1, b2, b3<br></code></pre><br><p>这个方法将刚创建的三个对象作为参数，它将调用每个对象的<em>to_s</em>方法。  </p><br><pre><code>p b1.does_exist?<br>p b2.does_exist?<br>p b3.does_exist?<br></code></pre><br><p>最后我们调用每个实例对象的<em>does_exist?</em>方法。这三个方法会输出相同的结果，因为这个方法返回的是类变量。</p><br><pre><code>$ ./icvars.rb<br>This is Being 1<br>This is Being 2<br>This is Being 3<br>true<br>true<br>true<br></code></pre><br><p>以上是这个例子的输出结果。前三条信息是唯一的，因为这个字符串是存储在实例变量中的。<em>true</em>值是类变量，它被调用的三次。  </p><br><h2>环境&amp;命令行变量</h2><br><p>可以用<em>ENV</em>常量来访问环境变量。它是一个Ruby的hash对象。每个环境变量都是<em>ENV</em>这个hash对象的键值。  </p><br><p><em>ARGV</em>常量存储了命令行的参数值。它们是在脚本启动时传递的。<em>ARGV</em>是一个数组，参数以字符串存储。<em>S<em></em>是<em>ARGV</em>的别名。</p><br><p><em>ENV</em>和<em>ARGV</em>都是全局常量。</p><br><pre><code>#!/usr/bin/ruby<br><br>ARGV.each do |a|<br>  puts “Argument: #&#123;a&#125;”<br>end<br></code></pre><br><p>这个脚本我们通过循环遍历打印了<em>ARGV</em>的每个值。</p><br><p>$ ./commandline.rb 1 2 3<br><br>Argument: 1<br><br>Argument: 2<br><br>Argument: 3  </p><br><p>我们给了三个命令行参数。它们在终端上各打印了一行。</p><br><hr><br><p>接下来的例子介绍了处理环境变量。</p><br><pre><code>#!/usr/bin/ruby<br><br>puts ENV[‘SHELL’]<br>puts ENV[‘LANG’]<br>puts ENV[‘TERM’]<br></code></pre><br><p>这个脚本在终端上打印了三个环境变量的值。这些变量值的内容依赖于我们操作系统的系统设置。 </p><br><p>$ ./environment.rb<br><br>/bin/bash<br><br>en_US.utf8<br><br>xterm  </p><br><p>以上是一个输出例子。</p><br><h2>伪变量</h2><br><p>在Ruby中有一些变量被称作伪变量。它们不同于常规的变量，不能给它们设置值。<br><br><em>self</em>是当前方法的接收者。<em>nil</em>是<em>NilClass</em>的唯一实例，它代表值不存在。<em>true</em>是<em>TrueClass</em>的唯一实例，它代表布尔真。<em>flase</em>是<em>FalseClass</em>是唯一实例，它代表布尔假。<br><br><em>true</em>和<em>false</em>是布尔数据类型。从另一个角度来看他们是特殊的类实例，这是因为在Ruby中一切皆对象。</p><br><pre><code>#!/usr/bin/ruby<br><br>p self<br>p nil<br>p true<br>p false<br><br>p self.class<br>p nil.class<br>p true.class<br>p false.class<br></code></pre><br><p>这是一个伪变量的例子。我们打印所有的伪变量，然后再看它们的类名。  </p><br><pre><code>p self<br></code></pre><br><p>在当前上下文<em>self</em>伪变量返回的是<em>main</em>执行的上下文。  </p><br><p>$ ./pseudo.rb<br><br>main<br><br>nil<br><br>true<br><br>false<br><br>Object<br><br>NilClass<br><br>TrueClass<br><br>FalseClass  </p><br><p>以上是例子的输出结果。</p><br><hr><br><p>在本节的第二个例子，我们将进一步分析<em>self</em>。</p><br><pre><code>#!/usr/bin/ruby<br><br>class Some<br>    puts self<br>end<br><br>class Other<br>    puts self<br>end<br><br>puts self<br></code></pre><br><p>之前我们说过，<em>self</em>是对当前方法接收者的引用。以上例子展示了三个不同的接收者。 </p><br><pre><code>class Some<br>    puts self<br>end<br></code></pre><br><p>这个接收者名为<em>Some</em>。</p><br><pre><code>class Other<br>    puts self<br>end<br></code></pre><br><p>这是另一个接收者，名为：<em>Other</em>。</p><br><pre><code>puts self<br></code></pre><br><p>第三个接收者是Ruby顶级环境。</p><br><p>$ ./pseudoself.rb <br><br>Some <br><br>Other <br><br>main   </p><br><p>以上是例子的输出结果。</p><br><hr><br><p>本节的最后一个例子展示了另外三个伪变量。</p><br><pre><code>#!/usr/bin/ruby<br><br>if true<br>    puts “This message is shown”<br>end<br><br>if false<br>    puts “This message is not shown”<br>end<br><br>p $name<br>p $age<br></code></pre><br><p>上面的例子展示了<em>true</em>、<em>false</em>和<em>nil</em>伪变量。 </p><br><pre><code>if true<br>    puts “This message is shown”<br>end<br></code></pre><br><p><em>true</em>用于布尔表达式中。这条消息总是会打印的。  </p><br><pre><code>if false<br>    puts “This message is not shown”<br>end<br></code></pre><br><p>这条消息永远不会打印。这个条件不成立。这个布尔表达式总是会返回一个负值。  </p><br><pre><code>p $name<br>p $age<br></code></pre><br><p>如果全局变量没有初始化就引用，那么它们就会包含一个<em>nil</em>伪变量。这代表值不存在。  </p><br><p>$ ./pseudo2.rb<br><br>This message is shown<br><br>nil<br><br>nil  </p><br><p>以上是<em>pseudo2.rb</em>脚本的输出结果。</p><br><h2>预定义变量</h2><br><p>Ruby中有很多预定义的全局变量。这是继承到Perl，Ruby受Perl的影响很大。Ruby脚本启动之后就可以访问这些变量了。接下来有些例子展示预定义变量。</p><br><pre><code>#!/usr/bin/ruby<br><br>print “Script name: “, $0, “\n”<br>print “Command line arguments: “, $</em>, “\n”<br><br>puts “Process number of this script: #&#123;$$&#125;”<br></code></pre><br><p>以上使用了三个预定义变量。<em>$0</em>、<em>$<em></em>和<em>$$</em>。<em>$0</em>存储了当前脚本的名字。<em>$</em></em>存储了命令行参数。 <em>$$</em>存储了当前脚本程序的PID。  </p><br><p>$ ./predefined.rb 1 2 3 <br><br>Script name: ./predefined.rb<br><br>Command line arguments: [“1”, “2”, “3”]<br><br>Process number of this script: 3122  </p><br><p>以上是一个输出例子。</p><br><hr><br><p><em>$?</em>全局变量存储了最后一个子进程的退出状态。  </p><br><pre><code>#!/usr/bin/ruby<br><br>system ‘echo “Ruby”‘<br>puts $?<br><br>%x[exit ‘1’]<br>puts $?<br></code></pre><br><p>我们执行两个子进程，然后使用<em>$?</em>查看它们的退出状态。</p><br><pre><code>system ‘echo “Ruby”‘<br>puts $?<br></code></pre><br><p>使用<em>system</em>方法启动一个子进程。它是一个bash的echo命令，用于在终端输出消息。  </p><br><pre><code>%x[exit ‘1’]<br>puts $?<br></code></pre><br><p>第二个情况是使用状态1执行bash的exit命令。这次我们使用<em>%x</em> 操作符，用于执行一条被分隔符所选择的命令。</p><br><p>$ ./predefined2.rb<br><br>Ruby<br><br>pid 3131 exit 0<br><br>pid 3133 exit 1  </p><br><p>第一个子进程退出状态为0,第二为1。 </p><br><hr><br><p><em>$;</em>变量存储了字符串<em>split</em>方法的默认分隔符。  </p><br><pre><code>#!/usr/bin/ruby<br><br>str = “1,2,3,4,5,6,7”<br>p str.split<br><br>$; = “,”<br>p str.split<br></code></pre><br><p>我们使用<em>$;</em>变量来控制字符串的<em>split</em>方法是如何分隔的。这个方法接收一个参数，用于确定字符串应该何处分隔。 如果这个参数省略了，那么将会使用<em>$;</em>的值。  </p><br><pre><code>$; = “,”<br>p str.split<br></code></pre><br><p>我们为<em>$;</em>分隔符指定个值。当<em>split</em>方法没有传递参数时，<em>$;</em>的值将会被使用。  </p><br><p>$ ./predefined3.rb<br><br>[“1,2,3,4,5,6,7”]<br><br>[“1”, “2”, “3”, “4”, “5”, “6”, “7”]  </p><br><p>在第一种情况下字符串没有被分割，第二种情况下字符串正确的被分割了。  </p><br><hr><br><p>最后我们展示三个用于正则表达式的全局预定义变量。  </p><br><pre><code>#!/usr/bin/ruby<br><br>“Her name is Jane” =~ /name/<br><br>p $<code>p $&amp;amp;
p $&#39;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;当我们对字符串使用&lt;em&gt;=~&lt;/em&gt;保用符时，Ruby设置了一些变量。&lt;em&gt;$&amp;amp;&lt;/em&gt;变量设为最后一个匹配该正则式的内容。&lt;em&gt;$</code></em>设为<em>$&amp;</em>之前的内容.<em>$’</em>为<em>$&amp;</em>之后的内容。</p><br><p>$ ./predefined4.rb<br><br>“Her “<br><br>“name”<br><br>“ is Jane”  </p><br><p>以上是这个例子的输出结果。</p><br><p>在这一章的教程中我们深入的学习了Ruby的变量。</p><br><hr><br><p>原文地址： <a target="_blank" rel="noopener" href="http://zetcode.com/lang/rubytutorial/variables/">http://zetcode.com/lang/rubytutorial/variables/</a><br><br>翻译：龙昌  admin@longchangjin.cn<br><br>完整教程：<a target="_blank" rel="noopener" href="https://github.com/wusuopu/Ruby-tutorial">https://github.com/wusuopu/Ruby-tutorial</a>  </p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://www.xefan.com/archives/83905.html" data-id="cl1hpb7zt005heqoybvtp5kci" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Ruby/" rel="tag">Ruby</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E7%BF%BB%E8%AF%91/" rel="tag">翻译</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-[翻译]Ruby教程3——基础" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/archives/83902.html" class="article-date">
  <time datetime="2013-11-04T12:48:35.000Z" itemprop="datePublished">2013-11-04</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Ruby%E6%A0%8F%E7%9B%AE/">Ruby栏目</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/archives/83902.html">[翻译]Ruby教程3——基础</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><h1>基础</h1></p>
<p>在这一章我们将覆盖Ruby语言的基本程序概念。我们展示一些非常基础的程序，使用到了变量、常量和基本的数据类型。从终端读取、写入内容；我们将会介绍变量的插值（interpolation）。</p><br><p>我们从一个非常简单的代码例子开始。  </p><br><blockquote><br><p>#!/usr/bin/ruby<br><br>  puts “This is Ruby”</p><br></blockquote><br><p>这个简单的脚本会在终端打印<em>“This is Ruby”</em>信息。  </p><br><blockquote><br><p>#!/usr/bin/ruby</p><br></blockquote><br><p>这用于执行这个脚本的Ruby解释器的路径。</p><br><blockquote><br><p>puts “This is Ruby”</p><br></blockquote><br><p><em>puts</em>是Ruby的关键字，用于将它的参数打印到终端上。在这个例子中它的参数是一个被双引号分隔的字符串。</p><br><p>$ ./first.rb <br><br>This is Ruby</p><br><p>以上是这个例子的输出结果。</p><br><hr><br><p>我们可以从终端读取值。</p><br><blockquote><br><p>#!/usr/bin/ruby<br><br>   print “What is your name? “<br><br>   name = gets<br>   puts “Hello #{name}”</p><br></blockquote><br><p>第二个程序将会从终端读取一个值并输出。  </p><br><blockquote><br><p>print “What is your name? “</p><br></blockquote><br><p><em>print</em>关键字是将参数打印到终端上。<em>print</em>与<em>puts</em>的不同在于<em>print</em>不同自动换行，而<em>puts</em>会自动换行。</p><br><blockquote><br><p>name = gets</p><br></blockquote><br><p>这里我们将从用户输入中读取值并将其保存在<em>name</em>变量中。<em>gets</em>是一个方法用于从终端读取一行内容。它是一个内置的方法。</p><br><blockquote><br><p>puts “Hello #{name}”</p><br></blockquote><br><p>在这行代码我们展示变量的插值。变量插值（Variable interpolation）是将字符串字面量中的变量替换成它真实的值。变量插值（interpolation）的其他说法是：变量置换和变量扩展。  </p><br><blockquote><br><p>$ ./name.rb <br><br> What is your name? Jan<br><br> Hello Jan  </p><br></blockquote><br><p>以上是第二个程序的输出结果。</p><br><hr><br><p>Ruby代码可以从命令行运行。这个是借鉴至Perl的单行方式，小块代码执行小任务。</p><br><blockquote><br><p>$ ruby -e “puts RUBY_VERSION”<br><br> 2.0.0</p><br></blockquote><br><p><em>-e</em>参数告诉Ruby要执行的代码从命令行中给定，而不是Ruby代码文件。我们例子将在终端输出Ruby解释器的版本号。<br><br>译注：原文的作者使用的是ruby 1.9.3，而如今ruby最新版已经是2.0.0了。</p><br><hr><br><p>Ruby解释器有一个<em>-c</em>选项用于检查代码的语法。如果启用了的话，代码将不会被执行。如果代码没有语法错误，那么将会打印<em>“Syntax OK”</em>。</p><br><blockquote><br><p>#!/usr/bin/ruby<br><br> class Being end <br><br> m = Test.new<br><br> p m  </p><br></blockquote><br><p>以上例子中有一个语法错误。如果我们将<em>class</em>和<em>end</em>关键字放在同一行，那么我们就必须还要使用分号字符(;)。</p><br><p>$ ruby -c syntax_check.rb <br><br>syntax_check.rb:3: syntax error, unexpected keyword_end, expecting ‘&lt;’ or ‘;’ or ‘\n’<br><br>syntax_check.rb:6: syntax error, unexpected $end, expecting keyword_end  </p><br><p>发现了语法错误。如果我们在<em>Being</em>的后面加上分号，错误提示消息就会消失。  </p><br><h2>命令行参数</h2><br><p>Ruby程序可以从命令行接收参数。当我们执行程序时参数接在程序名的后面。</p><br><blockquote><br><p>#!/usr/bin/ruby<br><br> puts ARGV  </p><br></blockquote><br><p>接在文件名后面的有效命令行参数被Ruby程序保存在全局数组ARGV中。</p><br><p>这里我们将所有的命令行参数打印到终端上。  </p><br><p>$ ./args.rb 1 2 3<br><br>1<br><br>2<br><br>3  </p><br><p>我们提供了三个数字作为命令行参数，并且它们都打印到终端上了。</p><br><hr><br><p>在下面的例子中我们将打印所有的参数还有脚本名。</p><br><blockquote><br><p>#!/usr/bin/ruby<br><br> puts $0<br><br> puts $<em>  </p><br></blockquote><br><p><em>$0</em>是全局变量，包含被执行的脚本的名称。在Ruby中全局变量是以<em>$</em>字符开头。<em>$</em></em>是另一个全局变量。它与ARGV是相等的，包含了命令行的所有参数。</p><br><p>$ ./args2.rb Ruby Python Perl<br><br>./args2.rb<br><br>Ruby<br><br>Python<br><br>Perl  </p><br><p><em>args2.rb</em>脚本接收了三个参数。脚本名和这三个参数都打印到终端上了。  </p><br><h2>变量和常量</h2><br><p>变量是保存数据的地址。变量包括名称和数据类型。数据类型表示了数据的不同类型。整数、字符串和浮点数都是数据类型。Ruby是一门动态语言，这意味着我们不需要（也不能）定义一个变量的确定类型。而是Ruby解释器在分配变量时决定它的数据类型。此外，在程序运行时一个变量还可以包含不同类型的不同值。这与Java、C或者Pascal之类的强类型语言不同。与变量不同，常量（应该）保持它的值。一旦初始化了就不能修改。然后在Ruby中是有可能修改常量的值，这种情况下会出现一个警告。</p><br><blockquote><br><p>#!/usr/bin/ruby<br><br> city = “New York”<br><br> name = “Paul”; age = 35<br><br> nationality = “American”  </p><br><p>puts city<br><br> puts name<br><br> puts age<br><br> puts nationality  </p><br><p>city = “London”  </p><br><p>puts city  </p><br></blockquote><br><p>在上面的例子中我们使用了四个变量。</p><br><blockquote><br><p>city = “New York”</p><br></blockquote><br><p>我们给<em>city</em>变量分配了一个字符串。这个变量是动态创建的。 </p><br><blockquote><br><p>name = “Paul”; age = 35</p><br></blockquote><br><p>创建两个变量。我们可以将两条语句放在一行里。然后为了提高可读性应该每行一条语句。</p><br><blockquote><br><p>puts city<br><br> puts name<br><br> puts age<br><br> puts nationality  </p><br></blockquote><br><p>将变量的值打印到终端。</p><br><blockquote><br><p>city = “London”  </p><br></blockquote><br><p>给<em>city</em>变量分配新的值。  </p><br><p>$ ./variables.rb <br><br>New York<br><br>Paul<br><br>35<br><br>American<br><br>London  </p><br><p>这是以上例子的输出。</p><br><hr><br><p>之前我们已经介绍过常量了，它一直都保存着一个值。但是不同于其他语言，Ruby没有对这个进行强制限制。</p><br><blockquote><br><p>#!/usr/bin/ruby  </p><br><p>WIDTH = 100<br><br> HEIGHT = 150   </p><br><p>var = 40<br><br> puts var  </p><br><p>var = 50<br><br> puts var  </p><br><p>puts WIDTH<br><br> WIDTH = 110<br><br> puts WIDTH  </p><br></blockquote><br><p>在这个例子中定义了两个常量和一个变量。</p><br><blockquote><br><p>WIDTH = 100<br><br> HEIGHT = 150   </p><br></blockquote><br><p>在Ruby中常量是以大写字母开头的。通常是将所有字母都大写。</p><br><blockquote><br><p>var = 40<br><br> puts var  </p><br><p>var = 50  </p><br></blockquote><br><p>定义并初始化一个变量。随后又给它分配了一个新的值，这是合法的。</p><br><blockquote><br><p>WIDTH = 100  </p><br></blockquote><br><p>我们给常量分配了一个新的值。常量一旦创建就不应该改变，否则它就不意味着是一个常量。Ruby解释器将会给出一条警告。</p><br><p>$ ./constants.rb <br><br>40<br><br>50<br><br>100<br><br>./constants.rb:13: warning: already initialized constant WIDTH<br><br>110  </p><br><p>以上是脚本的输出。</p><br><h2>变量插值</h2><br><p>变量插值（interpolation）是将字符串中的变量替换成它的值。变量插值的其他说法是：变量置换和变量扩展。</p><br><blockquote><br><p>#!/usr/bin/ruby  </p><br><p>age = 34<br><br> name = “William”  </p><br><p>puts “#{name} is #{age} years old”   </p><br></blockquote><br><p>在Ruby中字符串是不可变的。我们不能修改一个已存在的字符串。变量插值是字符创建时进行的。  </p><br><blockquote><br><p>age = 34<br><br> name = “William”  </p><br></blockquote><br><p>定义两个变量。</p><br><blockquote><br><p>puts “#{name} is #{age} years old” </p><br></blockquote><br><p>字符串是被双引号所引起来。当我们将变量名放在<em>#{</em>和<em>}</em>字符之间时,这个变量会被它的值所篡改。</p><br><p>$ ./interpolation.rb <br><br>William is 34 years old  </p><br><p>以上是这个例子的输出。</p><br><p>这一章覆盖了Ruby语言的一些基础。 </p><br><hr><br><p>原文地址： <a target="_blank" rel="noopener" href="http://zetcode.com/lang/rubytutorial/basics/">http://zetcode.com/lang/rubytutorial/basics/</a><br><br>翻译：龙昌  admin@longchangjin.cn<br><br>完整教程：<a target="_blank" rel="noopener" href="https://github.com/wusuopu/Ruby-tutorial">https://github.com/wusuopu/Ruby-tutorial</a>  </p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://www.xefan.com/archives/83902.html" data-id="cl1hpb7zt005geqoye2hj45fc" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Ruby/" rel="tag">Ruby</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E7%BF%BB%E8%AF%91/" rel="tag">翻译</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-[翻译]Ruby教程2——词法结构" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/archives/83899.html" class="article-date">
  <time datetime="2013-11-02T14:11:14.000Z" itemprop="datePublished">2013-11-02</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Ruby%E6%A0%8F%E7%9B%AE/">Ruby栏目</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/archives/83899.html">[翻译]Ruby教程2——词法结构</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><h1>Ruby 词法结构</h1></p>
<p>计算机语言跟人类语言类似也有词法结构。一个Ruby程序的源代码由符号构成。符号标志是最基本的代码元素。在Ruby语言中我们有多种词法结构，如：注释、变量、字面量、空白符号、操作符、分隔符和关键字。</p><br><h2>注释</h2><br><p>注释是用于向人们阐明源代码。在Ruby中有两种注释的方法，单行注释和多行注释。单行注释以#字符开始；多行注释是放置在<em>=bgin</em>和<em>=end</em> 等号标志之间。</p><br><blockquote><br><p>#!/usr/bin/ruby  </p><br><p>=begin  </p><br><blockquote><br><p>comments.rb<br><br>      author Jan Bodnar<br><br>      ZetCode 2011    </p><br></blockquote><br><p>=end  </p><br><p># prints message to the terminal<br><br> puts “Comments example”  </p><br></blockquote><br><p>这个例子同时展示的两种方法的注释。注释的内容将会被Ruby解释器忽略掉。</p><br><blockquote><br><pre><code>=begin<br>    comments.rb<br>    author Jan Bodnar<br>    ZetCode 2011<br>=end<br></code></pre><br></blockquote><br><p>这是一个多行注释的例子，两个符号标志必须在行首。</p><br><h2>空白符号</h2><br><p>在源文件中Ruby的空白符号被用于分隔符号标志和结束语句。它也用于增强代码的可读性。  </p><br><p>if true then<br><br>&nbsp;&nbsp;puts “A message”<br><br>end  </p><br><p>空白字符在一些时候是必须的。例如在<em>if</em>关键字和<em>true</em>关键字之间；或者在<em>puts</em>方法和实际的字符串之间。而有时它又是被禁止的，如它不能包含在变量标识符或者语言关键字中。  </p><br><p>a=1<br><br>b&nbsp;=&nbsp;2<br><br>c&nbsp;&nbsp;=&nbsp;&nbsp;3  </p><br><p>这些在符号标志之间的空白字符对于Ruby解释器是无关紧要的。但是它于整个项目的风格统一非常重要。</p><br><hr><br><blockquote><br><p>#!/usr/bin/ruby  </p><br><p>x = 5 + 3<br><br> puts x  </p><br><p>x = 5 <br><br>   &nbsp;&nbsp;&nbsp;&nbsp;+ 3<br><br> puts x      </p><br><p>x = 5 + <br><br>   &nbsp;&nbsp;&nbsp;&nbsp;3<br><br> puts x</p><br></blockquote><br><p>换行是一种用于结束语句的空白字符形式。  </p><br><p>x = 5 + 3  </p><br><p>在第一种情况，我们有一条语句。它将相加求和的值赋给x变量。这个变量的值为8。  </p><br><p>x = 5<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;+3</p><br><p>现在第二种情况。第1条语句被换行符终止了，x变量的值是5。另一条语句<em>+3</em>，没有任何影响。  </p><br><p>x = 5 +<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3  </p><br><p>最后，第1条语句的换行符之前有一个+二元操作符，因此解释器期望另一个值，它将检查第二行。在这种情况它将这两种作为一条语句，因此x这是的值为8。  </p><br><p>$ ./whitespace.rb<br><br>8<br><br>5<br><br>8  </p><br><p>以上为输出结果。  </p><br><h2>变量</h2><br><p>变量是一个保存了值的标识符。在编程时我们说我们给一个变量分配一个值。专业一点的说法是一个变量是对计算机中存储了值的内存的引用。在Ruby中一个变量可以保存字符串、数字或者多种对象。不同时间变量可以被分配不同的值。<br><br>在Ruby中变量名由字母数字和下划线组成，但是不能以数字开头。Ruby解释器可以很容易地区分原始的数字跟变量。变量名不能以大写字母开头，在Ruby中以大写字母开头的标识符会被认为是一个常量。</p><br><blockquote><br><p>Value<br><br>   value2<br><br>   company_name  </p><br></blockquote><br><p>以上这些都是合法的变量名。</p><br><blockquote><br><p>12Val<br><br>   exx$<br><br>   first-name  </p><br></blockquote><br><p>以上这些都不是合法的变量名。  </p><br><p>变量名前可以加<em>$</em>和<em>@</em>这两个特殊的字符，它们用于创建特殊作用域的变量。  </p><br><p>变量名是大小写敏感的，这意味着<em>price</em>和<em>pRice</em>是两个不同的标识符。  </p><br><blockquote><br><p>#!/usr/bin/ruby<br><br> number = 10<br><br> numBER = 11  </p><br><p>puts number, numBER  </p><br></blockquote><br><p>在这个脚本中我们给两个标识符分配了两个数字。<em>number</em>和<em>numBER</em>是两个不同的变量。</p><br><blockquote><br><p>$ ./case.rb<br><br>   10<br><br>   11  </p><br></blockquote><br><p>以上是这个脚本运行的输出结果。</p><br><h2>常量</h2><br><p>常量的值在程序运行过程中是不变的。在Ruby中一个标识符的首字母大写即为一个常量。编程时对于常量约定是所有字母全都大写。<br><br>与其他语言不同，Ruby不会强制要求常量的值始终不变。当我们给一个常量分配新的值时解释器只会提示一个警告。  </p><br><blockquote><br><p>#!/usr/bin/ruby<br><br> Name = “Robert”<br><br> AGE = 23<br><br> Name = “Juliet”  </p><br></blockquote><br><p>在上面的例子中我们创建了两个常量，其中一个被重新定义了。  </p><br><blockquote><br><p>Name = “Robert”<br><br> AGE = 23  </p><br></blockquote><br><p>创建两个常量。在Ruby中标识符的首字母大写即定义为常量。作为约定常量通常是所有字母都大写的。  </p><br><blockquote><br><p>Name = “Juliet”  </p><br></blockquote><br><p>我们重新定义了一个常量，这会引起一个警告。</p><br><blockquote><br><p>$ ./constants.rb<br><br>   ./constants.rb:6: warning: already initialized constant Name  </p><br></blockquote><br><p>以上是这个例子运行的输出。</p><br><h2>字面量</h2><br><p>字面量（literal）是按原文本内容所表示的特殊类型的值。字面量类型包括布尔型、整型、浮点型、字符串、字符和日期。专业的说一个字面量在编译时会分配一个值，该值在运行时会分配给对应的变量。</p><br><blockquote><br><p>age = 29<br><br> nationality = “Hungarian”  </p><br></blockquote><br><p>这里我们分配了两个字面量变量。数字<em>29</em>和字符串<em>“Hungarian”</em>都是字面量。  </p><br><pre><code>#!/usr/bin/ruby<br><br>require ‘date’<br><br>sng = true<br>name = “James”<br>job = nil<br>weight = 68.5<br>born = Date.parse(“November 12, 1986”)<br><br>puts “His name is #&#123;name&#125;”<br><br>if sng == true<br>    puts “He is single”<br>else<br>    puts “He is in a relationship”<br>end<br><br>puts “His job is #&#123;job&#125;”<br>puts “He weighs #&#123;weight&#125; kilograms”<br>puts “He was born in #&#123;born&#125;”<br></code></pre><br><p>在上面这个例子中，我们使用了多个字面量。布尔字面量的值可能为<em>true</em>或者<em>false</em>，<em>James</em>是一个字符串字面量，<em>nil</em>表示一个不存在的值，<em>68.5</em>是一个浮点数，最后<em>November 12,1986</em>是一个日期。</p><br><blockquote><br><p>$ ./literals.rb<br><br>   His name is James<br><br>   He is single<br><br>   His job is <br><br>   He weighs 68.5 kilograms<br><br>   He was born in 1986-11-12  </p><br></blockquote><br><p>以上为<em>literals.rb</em>脚本的输出结果。 </p><br><h2>代码块</h2><br><p>Ruby语句通常是放在代码块中。一个代码块可以被<em>{}</em>符号或者<em>do</em>、<em>end</em>关键字分隔。  </p><br><pre><code>#!/usr/bin/ruby<br><br>puts [2, -1, -4, 0].delete_if &#123; |x| x &lt; 0 &#125;<br><br>[1, 2, 3].each do |e|<br>    puts e<br>end<br></code></pre><br><p>这个例子中我们展示了两个代码块。  </p><br><p>Ruby代码的控制流通常是使用<em>if</em>关键字。这个关键字k跟随着一个代码块，在这种情况下代码块被<em>then</em>、<em>end</em>关键字分隔，<em>then</em>关键字是可选的。</p><br><pre><code>#!/usr/bin/ruby<br><br>if true then<br>    puts “Ruby language”<br>    puts “Ruby script”<br>end<br></code></pre><br><p>在上面这个例子中，我们展示了一个简单的代码块。它有两条语句。这个代码块被<em>then</em>、<em>end</em>关键字分隔。<em>then</em>关键字可以省略。</p><br><h2>符号</h2><br><p>符号<em>$</em>、<em>@</em>是特殊字符用于表示变量的作用域，<em>$</em>表示全局变量，<em>@</em>表示实例变量，<em>@@</em>表示类变量。  </p><br><blockquote><br><p>$car_name = “Peugeot”<br><br>  @sea_name = “Black sea”<br><br>  @@species = “Cat”  </p><br></blockquote><br><p>这些符号总是位于变量标识符的开头。</p><br><h2>操作符</h2><br><p>操作符是一个用于对值执行一个动作的符号。  </p><br><pre><code>!    +    -    ~    <em>    **    /    %<br>&lt;&lt;    &gt;&gt;    &amp;    |    ^<br>==    ===    !=    &lt;=&gt;    &gt;=    &gt;<br>&lt;    &lt;=    =    %=    /=    -=<br>+=    </em>=    <em>*=    ..    …    not<br>and    or    ?:    &amp;&amp;    ||<br></code></pre><br><p>以上是在Ruby中所有有效的操作符，我们将在之后的教程中介绍它们。  </p><br><h2>分隔符</h2><br><p>分隔符是一个或多个用于在纯文本或者其他数据流中指定分隔独立区域范围的字符序列。  </p><br><pre><code>(       )       [       ]       &#123;       &#125;<br>,       ;       ‘       “       |       |<br><br>#!/usr/bin/ruby<br><br>name = “Jane”<br>occupation = ‘Student’<br>numbers = [ 2, 3, 5, 3, 6, 2 ]<br><br>puts name; puts occupation<br>puts numbers[2]<br>numbers.each &#123; |i| puts i &#125;<br>puts ( 2 + 3 ) </em> 5<br></code></pre><br><p>在上面这个例子中我们展示多种Ruby分隔符的用法。  </p><br><blockquote><br><p>name = “Jane”<br><br> occupation = ‘Student’  </p><br></blockquote><br><p>在Ruby中单引号和双引号被用于分隔字符串。</p><br><blockquote><br><p>numbers = [ 2, 3, 5, 3, 6, 2 ]  </p><br></blockquote><br><p>中括号用于指定数组的范围。逗号用于分隔数组项。  </p><br><blockquote><br><p>puts name; puts occupation  </p><br></blockquote><br><p>在Ruby中分号用于分隔两条语句。</p><br><blockquote><br><p>puts numbers[2]  </p><br></blockquote><br><p>分隔符可用于不同的环境中，这里中括号用于访问数组。</p><br><blockquote><br><p>numbers.each { |i| puts i }  </p><br></blockquote><br><p>大括号用于定义代码块。管道用于定义在每次循环中被当前数组项所填充的元素。</p><br><blockquote><br><p>puts ( 2 + 3 ) * 5</p><br></blockquote><br><p>括号用于改变一个表达式的求值。</p><br><h2>关键字</h2><br><p>关键字是在Ruby语言中被保留的字。关键字用于在计算机程序中展示特定的任务。例如：在终端中打印一个值，执行重复的任务或者展示逻辑操作。程序员不能使用关键字作为普通的变量。  </p><br><pre><code>alias    and      BEGIN      begin    break    case<br>class    def      defined?   do       else     elsif<br>END      end      ensure     false    for      if<br>in       module   next       nil      not      or<br>redo     rescue   retry      return   self     super<br>then     true     undef      unless   until    when<br>while    yield<br></code></pre><br><p>这些是Ruby的关键列表。</p><br><p>以上就是Ruby的词法结构了。</p><br><hr><br><p>原文地址： <a target="_blank" rel="noopener" href="http://zetcode.com/lang/rubytutorial/lexis/">http://zetcode.com/lang/rubytutorial/lexis/</a><br><br>翻译：龙昌  admin@longchangjin.cn<br><br>完整教程：<a target="_blank" rel="noopener" href="https://github.com/wusuopu/Ruby-tutorial">https://github.com/wusuopu/Ruby-tutorial</a>  </p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://www.xefan.com/archives/83899.html" data-id="cl1hpb7zt005feqoy5dls6ibd" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Ruby/" rel="tag">Ruby</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E7%BF%BB%E8%AF%91/" rel="tag">翻译</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-[翻译]Ruby教程1——Ruby语言介绍" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/archives/83895.html" class="article-date">
  <time datetime="2013-11-02T11:37:43.000Z" itemprop="datePublished">2013-11-02</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Ruby%E6%A0%8F%E7%9B%AE/">Ruby栏目</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/archives/83895.html">[翻译]Ruby教程1——Ruby语言介绍</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><h1>Ruby</h1></p>
<p>在这部分Ruby教程中，我们将介绍Ruby编程语言。</p><br><h2>目标</h2><br><p>这个教程的目标是让你入门Ruby。这个教程覆盖了Ruby的主要内容，包括变量、表达式、集合、流程控制结构以及其他的一些主要特性。同样也会描述一些高级的概念，例如面向对象和正则表达式。这不会完全地覆盖这个语言。</p><br><h2>Ruby</h2><br><p>Ruby是一门动态的、反射的、通用的面向对象编程语言。它的源作者是一个日本程序员——松本行弘 (まつもとゆきひろ)。Ruby第一次发表是在1995年。</p><br><p>Ruby支持多种程序范式。包括面向对象、反射、命令式的和反射的编程。Ruby语言主要是受到Perl、Smalltalk、Eiffel和Lisp的影响。不同于java、C#以及C，Ruby没有官方的规范。取而代之的是用原始的C实现的Ruby语言作为实际参考。同时也还存在一些用其他方法实现的Ruby语言，如：JRuby、IronRuby或者MacRuby。</p><br><p>Ruby的官方网站是: <a href="htp://ruby-lang.org">ruby-lang.org</a></p><br><h2>人气</h2><br><p>如今有上百种编程语言，而Ruby属于最流行的一个。在<a target="_blank" rel="noopener" href="http://langpop.com">langpop.com</a>和<a target="_blank" rel="noopener" href="http://www.tiobe.com/index.php/content/paperinfo/tpci/index.html">tiobe</a>网站Ruby都排在第10名左右。Ruby on Rails——一个非常流行的web应用框架是使用Ruby开发第一个杀手级的应用。</p><br><h2>交互式的解释器</h2><br><p>我们可以通过脚本或者交互式的解释器来运行Ruby语句。在这个教程中我们将使用交互式的Ruby会话来展示一些小的代码片段。大的代码例子将放在Ruby脚本中。</p><br><blockquote><br><p>$ irb<br><br>  irb(main):001:0&gt; puts RUBY_VERSION<br><br>  2.0.0<br><br>  =&gt; nil  </p><br></blockquote><br><p>这是一个Ruby交互会式会话的例子。我们在终端中打印了一个特别的常量RUBY<em>VERSION，它被设置为当前使用的Ruby的版本。<br><br>译注：原文的作者使用的是ruby 1.8.7，而如今ruby最新版已经是2.0.0了，因此我在翻译的时候也结合了当前新的内容。</p><br><h2>Ruby脚本</h2><br><p>我们开始我们的第一个简单的Ruby脚本例子。  </p><br><blockquote><br><p>#!/usr/bin/ruby<br><br> # first.rb<br><br> puts “This is Ruby”  </p><br></blockquote><br><p>这个脚本我们将在终端上打印一条消息。</p><br><blockquote><br><p>#!/usr/bin/ruby</p><br></blockquote><br><p>UNIX下的每一个脚本都是以shebang符号开始的。shebang是脚本中开始的前两个字符：<strong>#!</strong>。shebang后面是执行我们脚本的解释器的路径。/usr/bin是Ruby解释器最常用的位置。它也可以定位在/usr/local/bin或者其他什么地方。</p><br><blockquote><br><p># first.rb  </p><br></blockquote><br><p>在Ruby中注释是以#开始。</p><br><blockquote><br><p>puts “This is Ruby” </p><br></blockquote><br><p>puts方法是将字符串打印到终端。</p><br><blockquote><br><p>$ which ruby<br><br> /usr/bin/ruby  </p><br></blockquote><br><p>Ruby解释器的路径可以使用which命令找到。</p><br><blockquote><br><p>$ chmod +x first.rb<br><br> $ ./first.rb<br><br> This is Ruby  </p><br></blockquote><br><p>通过chmod命令，我们给脚本增加可执行的权限。</p><br><h2>资源</h2><br><p>以下资源在编写该教程时会使用到：<br><br><em> <a target="_blank" rel="noopener" href="http://www.ruby-lang.org/">ruby-lang.org</a><br><br></em> <a target="_blank" rel="noopener" href="http://ruby-doc.org/">ruby-doc.org</a><br><br><em> &lt;a href=”<a target="_blank" rel="noopener" href="http://en.wikipedia.org/wiki/Ruby">http://en.wikipedia.org/wiki/Ruby</a></em>(programming_language)”&gt;Ruby article on wikipedia.org</a><br><br></em> <a target="_blank" rel="noopener" href="http://ruby.runpaint.org/">ruby.runpaint.org</a></p><br><p>在这章的教程中我们介绍了Ruby语言。  </p><br><hr><br><p>原文地址： <a target="_blank" rel="noopener" href="http://zetcode.com/lang/rubytutorial/ruby/">http://zetcode.com/lang/rubytutorial/ruby/</a><br><br>翻译：龙昌  admin@longchangjin.cn<br><br>完整教程：<a target="_blank" rel="noopener" href="https://github.com/wusuopu/Ruby-tutorial">https://github.com/wusuopu/Ruby-tutorial</a>  </p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://www.xefan.com/archives/83895.html" data-id="cl1hpb7zt005eeqoy17s3eh2f" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Ruby/" rel="tag">Ruby</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E7%BF%BB%E8%AF%91/" rel="tag">翻译</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-Scrapy框架学习笔记3—— Scrapy与mongodb结合" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/archives/83890.html" class="article-date">
  <time datetime="2013-10-07T09:14:00.000Z" itemprop="datePublished">2013-10-07</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Python%E6%A0%8F%E7%9B%AE/">Python栏目</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/archives/83890.html">Scrapy框架学习笔记3—— Scrapy与mongodb结合</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>创建一个新的Item Pipeline，并将其添加到settings.py的ITEM_PIPELINES列表中。<br>在process_item方法中将item的数据保存到mongodb中。<br>scrapy的Item与dict相似，而mongodb中的数据是心bson格式保存的。因此Item的数据应该可以直接存储到mongodb中而几乎不用做额外的处理。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyMongoDBPipeline</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, mongodb_server, mongodb_port, mongodb_db, mongodb_collection</span>):</span><br><span class="line">        connection = pymongo.Connection(mongodb_server, mongodb_port)</span><br><span class="line">        self.mongodb_db = mongodb_db</span><br><span class="line">        self.db = connection[mongodb_db]</span><br><span class="line">        self.mongodb_collection = mongodb_collection</span><br><span class="line">        self.collection = self.db[mongodb_collection]</span><br><span class="line"></span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">from_crawler</span>(<span class="params">cls, crawler</span>):</span><br><span class="line">        <span class="comment"># 连接mongodb</span></span><br><span class="line">        <span class="keyword">return</span> cls(<span class="string">&#x27;localhost&#x27;</span>, <span class="number">27017</span>, <span class="string">&#x27;scrapy&#x27;</span>, <span class="string">&#x27;items&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">process_item</span>(<span class="params">self, item, spider</span>):</span><br><span class="line">        result = self.collection.insert(<span class="built_in">dict</span>(item))</span><br><span class="line">        log.msg(<span class="string">&quot;Item %s wrote to MongoDB database %s/%s&quot;</span> % (result, self.mongodb_db, self.mongodb_collection),</span><br><span class="line">                level=log.DEBUG, spider=spider)</span><br><span class="line">        <span class="keyword">return</span> item</span><br></pre></td></tr></table></figure>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://www.xefan.com/archives/83890.html" data-id="cl1hpb7zs005deqoyeghycwvj" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Scrapy/" rel="tag">Scrapy</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/mongodb/" rel="tag">mongodb</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/python/" rel="tag">python</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-Scrapy框架学习笔记2—— Scrapy与Django结合" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/archives/83887.html" class="article-date">
  <time datetime="2013-10-07T09:04:40.000Z" itemprop="datePublished">2013-10-07</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Python%E6%A0%8F%E7%9B%AE/">Python栏目</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/archives/83887.html">Scrapy框架学习笔记2—— Scrapy与Django结合</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>前面也介绍过了Scrapy与Django的设计思想非常相似，因此这个两个结合也是比较容易的。<br>以下方法在Scrapy 0.18与Django 1.5下面测试是可以用的。</p>
<p><h3>1.首先设置Django的运行环境</h3><br>在settings.py中添加如下代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">setup_django_environment</span>(<span class="params">path</span>):</span><br><span class="line">    <span class="keyword">import</span> imp, os, sys</span><br><span class="line">    <span class="keyword">from</span> django.core.management <span class="keyword">import</span> setup_environ</span><br><span class="line">    m = imp.load_module(<span class="string">&#x27;settings&#x27;</span>, *imp.find_module(<span class="string">&#x27;settings&#x27;</span>, [path]))</span><br><span class="line">    setup_environ(m)</span><br><span class="line">    sys.path.append(os.path.abspath(os.path.join(path, os.path.pardir)))</span><br><span class="line"></span><br><span class="line">setup_django_environment(<span class="string">&quot;/django/project/path&quot;</span>)</span><br></pre></td></tr></table></figure>
<p>注意：如果你的Django项目是用的sqlite数据库的话，那就需要设置为绝对路径，不能使用相对路径。</p>
<p><h3>2.创建django item</h3><br>首先在Django项目代码中创建一个Django的model，例如:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> django.db <span class="keyword">import</span> models</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ScrapyModel</span>(models.Model):</span><br><span class="line">    title = models.CharField(max_length=<span class="number">200</span>)</span><br><span class="line">    link = models.CharField(max_length=<span class="number">200</span>)</span><br><span class="line">    desc = models.TextField()</span><br></pre></td></tr></table></figure>
<p>然后在Scrapy项目中创建一个新的Item，只不过这次我们不再是继承自scrapy.item.Item，而是scrapy.contrib.djangoitem.DjangoItem:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Test1DjItem</span>(<span class="title class_ inherited__">DjangoItem</span>):</span><br><span class="line">    django_model = ScrapyModel</span><br></pre></td></tr></table></figure>
<p>用法与原来的Item相同，只是最后要执行一个save函数来调用django的save方法将数据存入数据库。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://www.xefan.com/archives/83887.html" data-id="cl1hpb7zs005ceqoygc5m7vml" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Django/" rel="tag">Django</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Scrapy/" rel="tag">Scrapy</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/python/" rel="tag">python</a></li></ul>

    </footer>
  </div>
  
</article>



  


  <nav id="page-nav">
    <a class="extend prev" rel="prev" href="/page/11/">«Prev</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/10/">10</a><a class="page-number" href="/page/11/">11</a><span class="page-number current">12</span><a class="page-number" href="/page/13/">13</a><a class="page-number" href="/page/14/">14</a><span class="space">&hellip;</span><a class="page-number" href="/page/31/">31</a><a class="extend next" rel="next" href="/page/13/">Next»</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Categories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Linux%E6%A0%8F%E7%9B%AE/">Linux栏目</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Python%E6%A0%8F%E7%9B%AE/">Python栏目</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Ruby%E6%A0%8F%E7%9B%AE/">Ruby栏目</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/Ruby%E6%A0%8F%E7%9B%AE/Web%E5%BC%80%E5%8F%91/">Web开发</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/Web%E5%BC%80%E5%8F%91/">Web开发</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/Web%E5%BC%80%E5%8F%91/Python%E6%A0%8F%E7%9B%AE/">Python栏目</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%89%8D%E7%AB%AF%E7%9B%B8%E5%85%B3/">前端相关</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%B5%8C%E5%85%A5%E5%BC%8F%E6%A0%8F%E7%9B%AE/">嵌入式栏目</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%BC%80%E6%BA%90%E8%BD%AF%E4%BB%B6/">开源软件</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%95%99%E7%A8%8B/">教程</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/">数据库</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/">数据结构和算法</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%BC%96%E7%A8%8B%E5%BC%80%E5%8F%91/">编程开发</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%BD%91%E7%BB%9C%E6%97%A5%E5%BF%97/">网络日志</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E8%B5%84%E6%BA%90%E5%88%86%E4%BA%AB/">资源分享</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/ARM/" rel="tag">ARM</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Android/" rel="tag">Android</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Arch/" rel="tag">Arch</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/C/" rel="tag">C</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Django/" rel="tag">Django</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Docker/" rel="tag">Docker</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Dreamweaver/" rel="tag">Dreamweaver</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Fedora/" rel="tag">Fedora</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Flash/" rel="tag">Flash</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/GObject/" rel="tag">GObject</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Gentoo/" rel="tag">Gentoo</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Hash/" rel="tag">Hash</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Linux/" rel="tag">Linux</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Mac/" rel="tag">Mac</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/PS/" rel="tag">PS</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Qt/" rel="tag">Qt</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Raspberry-pi/" rel="tag">Raspberry pi</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Redis/" rel="tag">Redis</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Ruby/" rel="tag">Ruby</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Scrapy/" rel="tag">Scrapy</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/TQ2440/" rel="tag">TQ2440</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/USB/" rel="tag">USB</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/VirtualBox/" rel="tag">VirtualBox</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Web%E5%BC%80%E5%8F%91/" rel="tag">Web开发</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/WordPress/" rel="tag">WordPress</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Xcode/" rel="tag">Xcode</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/access/" rel="tag">access</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/adobe/" rel="tag">adobe</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/ajax/" rel="tag">ajax</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/angular/" rel="tag">angular</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/apache/" rel="tag">apache</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/asp/" rel="tag">asp</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/css/" rel="tag">css</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/docker/" rel="tag">docker</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/firefox/" rel="tag">firefox</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/ftp/" rel="tag">ftp</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/gcc/" rel="tag">gcc</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/git/" rel="tag">git</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/grub/" rel="tag">grub</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/gtk/" rel="tag">gtk</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/gulp/" rel="tag">gulp</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/ibus/" rel="tag">ibus</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/js/" rel="tag">js</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/k8s/" rel="tag">k8s</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/mongodb/" rel="tag">mongodb</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/mysql/" rel="tag">mysql</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/nginx/" rel="tag">nginx</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/node/" rel="tag">node</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/php/" rel="tag">php</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/pygame/" rel="tag">pygame</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/python/" rel="tag">python</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/react/" rel="tag">react</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/redis/" rel="tag">redis</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/ruby/" rel="tag">ruby</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/shell/" rel="tag">shell</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/typescript/" rel="tag">typescript</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/ubuntu/" rel="tag">ubuntu</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/vim/" rel="tag">vim</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/vmware/" rel="tag">vmware</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/w3m/" rel="tag">w3m</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/windows/" rel="tag">windows</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/xml/" rel="tag">xml</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%85%8D%E8%B4%B9/" rel="tag">免费</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%86%85%E6%A0%B8/" rel="tag">内核</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%8C%B9%E9%85%8D%E7%AE%97%E6%B3%95/" rel="tag">匹配算法</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%8D%95%E7%89%87%E6%9C%BA/" rel="tag">单片机</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%B5%8C%E5%85%A5%E5%BC%8F/" rel="tag">嵌入式</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%BC%80%E6%BA%90%E8%BD%AF%E4%BB%B6/" rel="tag">开源软件</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/" rel="tag">排序算法</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%96%87%E4%BB%B6%E7%A9%BA%E9%97%B4/" rel="tag">文件空间</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%97%A0%E7%BA%BF%E7%BD%91/" rel="tag">无线网</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%A0%91%E8%8E%93%E6%B4%BE/" rel="tag">树莓派</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%AD%A3%E5%88%99%E5%BC%8F/" rel="tag">正则式</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%B3%A8%E5%86%8C%E6%9C%BA/" rel="tag">注册机</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%B8%B8%E6%88%8F/" rel="tag">游戏</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%94%B5%E8%84%91%E6%8A%80%E5%B7%A7/" rel="tag">电脑技巧</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%A9%BA%E9%97%B4/" rel="tag">空间</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%AE%97%E6%B3%95/" rel="tag">算法</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%BA%A2%E6%97%97/" rel="tag">红旗</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%BB%8F%E5%85%B8%E8%AF%AD%E5%BD%95/" rel="tag">经典语录</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%BD%91%E7%BB%9C%E6%97%A5%E5%BF%97/" rel="tag">网络日志</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%BF%BB%E8%AF%91/" rel="tag">翻译</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%A7%86%E9%A2%91%E6%95%99%E7%A8%8B/" rel="tag">视频教程</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%B5%84%E6%BA%90%E5%88%86%E4%BA%AB/" rel="tag">资源分享</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%BD%AC%E8%BD%BD/" rel="tag">转载</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%9A%8F%E7%AC%94/" rel="tag">随笔</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/ARM/" style="font-size: 13.68px;">ARM</a> <a href="/tags/Android/" style="font-size: 10.53px;">Android</a> <a href="/tags/Arch/" style="font-size: 13.16px;">Arch</a> <a href="/tags/C/" style="font-size: 15.79px;">C</a> <a href="/tags/Django/" style="font-size: 11.05px;">Django</a> <a href="/tags/Docker/" style="font-size: 11.05px;">Docker</a> <a href="/tags/Dreamweaver/" style="font-size: 10px;">Dreamweaver</a> <a href="/tags/Fedora/" style="font-size: 10.53px;">Fedora</a> <a href="/tags/Flash/" style="font-size: 10px;">Flash</a> <a href="/tags/GObject/" style="font-size: 12.63px;">GObject</a> <a href="/tags/Gentoo/" style="font-size: 10.53px;">Gentoo</a> <a href="/tags/Hash/" style="font-size: 10px;">Hash</a> <a href="/tags/Linux/" style="font-size: 20px;">Linux</a> <a href="/tags/Mac/" style="font-size: 10.53px;">Mac</a> <a href="/tags/PS/" style="font-size: 12.63px;">PS</a> <a href="/tags/Qt/" style="font-size: 10.53px;">Qt</a> <a href="/tags/Raspberry-pi/" style="font-size: 10px;">Raspberry pi</a> <a href="/tags/Redis/" style="font-size: 10px;">Redis</a> <a href="/tags/Ruby/" style="font-size: 18.95px;">Ruby</a> <a href="/tags/Scrapy/" style="font-size: 11.05px;">Scrapy</a> <a href="/tags/TQ2440/" style="font-size: 12.11px;">TQ2440</a> <a href="/tags/USB/" style="font-size: 11.05px;">USB</a> <a href="/tags/VirtualBox/" style="font-size: 11.05px;">VirtualBox</a> <a href="/tags/Web%E5%BC%80%E5%8F%91/" style="font-size: 16.84px;">Web开发</a> <a href="/tags/WordPress/" style="font-size: 10px;">WordPress</a> <a href="/tags/Xcode/" style="font-size: 10px;">Xcode</a> <a href="/tags/access/" style="font-size: 12.63px;">access</a> <a href="/tags/adobe/" style="font-size: 10px;">adobe</a> <a href="/tags/ajax/" style="font-size: 11.05px;">ajax</a> <a href="/tags/angular/" style="font-size: 13.16px;">angular</a> <a href="/tags/apache/" style="font-size: 10px;">apache</a> <a href="/tags/asp/" style="font-size: 13.16px;">asp</a> <a href="/tags/css/" style="font-size: 10.53px;">css</a> <a href="/tags/docker/" style="font-size: 10px;">docker</a> <a href="/tags/firefox/" style="font-size: 11.05px;">firefox</a> <a href="/tags/ftp/" style="font-size: 10px;">ftp</a> <a href="/tags/gcc/" style="font-size: 12.63px;">gcc</a> <a href="/tags/git/" style="font-size: 13.16px;">git</a> <a href="/tags/grub/" style="font-size: 10px;">grub</a> <a href="/tags/gtk/" style="font-size: 17.89px;">gtk</a> <a href="/tags/gulp/" style="font-size: 10px;">gulp</a> <a href="/tags/ibus/" style="font-size: 10px;">ibus</a> <a href="/tags/js/" style="font-size: 16.32px;">js</a> <a href="/tags/k8s/" style="font-size: 10.53px;">k8s</a> <a href="/tags/mongodb/" style="font-size: 15.26px;">mongodb</a> <a href="/tags/mysql/" style="font-size: 11.58px;">mysql</a> <a href="/tags/nginx/" style="font-size: 10px;">nginx</a> <a href="/tags/node/" style="font-size: 10.53px;">node</a> <a href="/tags/php/" style="font-size: 14.74px;">php</a> <a href="/tags/pygame/" style="font-size: 15.26px;">pygame</a> <a href="/tags/python/" style="font-size: 19.47px;">python</a> <a href="/tags/react/" style="font-size: 12.63px;">react</a> <a href="/tags/redis/" style="font-size: 10px;">redis</a> <a href="/tags/ruby/" style="font-size: 10px;">ruby</a> <a href="/tags/shell/" style="font-size: 10px;">shell</a> <a href="/tags/typescript/" style="font-size: 10px;">typescript</a> <a href="/tags/ubuntu/" style="font-size: 13.16px;">ubuntu</a> <a href="/tags/vim/" style="font-size: 18.42px;">vim</a> <a href="/tags/vmware/" style="font-size: 10px;">vmware</a> <a href="/tags/w3m/" style="font-size: 10px;">w3m</a> <a href="/tags/windows/" style="font-size: 13.16px;">windows</a> <a href="/tags/xml/" style="font-size: 10px;">xml</a> <a href="/tags/%E5%85%8D%E8%B4%B9/" style="font-size: 10px;">免费</a> <a href="/tags/%E5%86%85%E6%A0%B8/" style="font-size: 10px;">内核</a> <a href="/tags/%E5%8C%B9%E9%85%8D%E7%AE%97%E6%B3%95/" style="font-size: 12.63px;">匹配算法</a> <a href="/tags/%E5%8D%95%E7%89%87%E6%9C%BA/" style="font-size: 10.53px;">单片机</a> <a href="/tags/%E5%B5%8C%E5%85%A5%E5%BC%8F/" style="font-size: 10px;">嵌入式</a> <a href="/tags/%E5%BC%80%E6%BA%90%E8%BD%AF%E4%BB%B6/" style="font-size: 14.21px;">开源软件</a> <a href="/tags/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/" style="font-size: 14.21px;">排序算法</a> <a href="/tags/%E6%96%87%E4%BB%B6%E7%A9%BA%E9%97%B4/" style="font-size: 10px;">文件空间</a> <a href="/tags/%E6%97%A0%E7%BA%BF%E7%BD%91/" style="font-size: 10px;">无线网</a> <a href="/tags/%E6%A0%91%E8%8E%93%E6%B4%BE/" style="font-size: 10px;">树莓派</a> <a href="/tags/%E6%AD%A3%E5%88%99%E5%BC%8F/" style="font-size: 10px;">正则式</a> <a href="/tags/%E6%B3%A8%E5%86%8C%E6%9C%BA/" style="font-size: 10.53px;">注册机</a> <a href="/tags/%E6%B8%B8%E6%88%8F/" style="font-size: 14.74px;">游戏</a> <a href="/tags/%E7%94%B5%E8%84%91%E6%8A%80%E5%B7%A7/" style="font-size: 14.21px;">电脑技巧</a> <a href="/tags/%E7%A9%BA%E9%97%B4/" style="font-size: 10px;">空间</a> <a href="/tags/%E7%AE%97%E6%B3%95/" style="font-size: 17.37px;">算法</a> <a href="/tags/%E7%BA%A2%E6%97%97/" style="font-size: 10px;">红旗</a> <a href="/tags/%E7%BB%8F%E5%85%B8%E8%AF%AD%E5%BD%95/" style="font-size: 10px;">经典语录</a> <a href="/tags/%E7%BD%91%E7%BB%9C%E6%97%A5%E5%BF%97/" style="font-size: 13.16px;">网络日志</a> <a href="/tags/%E7%BF%BB%E8%AF%91/" style="font-size: 18.42px;">翻译</a> <a href="/tags/%E8%A7%86%E9%A2%91%E6%95%99%E7%A8%8B/" style="font-size: 14.74px;">视频教程</a> <a href="/tags/%E8%B5%84%E6%BA%90%E5%88%86%E4%BA%AB/" style="font-size: 15.26px;">资源分享</a> <a href="/tags/%E8%BD%AC%E8%BD%BD/" style="font-size: 10.53px;">转载</a> <a href="/tags/%E9%9A%8F%E7%AC%94/" style="font-size: 10px;">随笔</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/09/">September 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/04/">April 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/11/">November 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/05/">May 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/04/">April 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/02/">February 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/11/">November 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/05/">May 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/03/">March 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/11/">November 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/06/">June 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/05/">May 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/01/">January 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/11/">November 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/08/">August 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/07/">July 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/06/">June 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/04/">April 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/03/">March 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/01/">January 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/12/">December 2015</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/08/">August 2015</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/05/">May 2015</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/04/">April 2015</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/02/">February 2015</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/01/">January 2015</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2014/12/">December 2014</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2014/11/">November 2014</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2014/10/">October 2014</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2014/09/">September 2014</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2014/08/">August 2014</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2014/07/">July 2014</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2014/06/">June 2014</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2014/05/">May 2014</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2014/04/">April 2014</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2014/03/">March 2014</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2014/01/">January 2014</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2013/12/">December 2013</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2013/11/">November 2013</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2013/10/">October 2013</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2013/08/">August 2013</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2013/07/">July 2013</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2013/06/">June 2013</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2013/05/">May 2013</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2013/04/">April 2013</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2013/01/">January 2013</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2012/10/">October 2012</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2012/09/">September 2012</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2012/08/">August 2012</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2012/07/">July 2012</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2012/05/">May 2012</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2012/04/">April 2012</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2012/03/">March 2012</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2012/02/">February 2012</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2011/12/">December 2011</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2011/11/">November 2011</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2011/10/">October 2011</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2011/09/">September 2011</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2011/08/">August 2011</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2011/07/">July 2011</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2011/05/">May 2011</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2011/04/">April 2011</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2011/03/">March 2011</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2011/02/">February 2011</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2011/01/">January 2011</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2010/12/">December 2010</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2010/11/">November 2010</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2010/10/">October 2010</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2010/09/">September 2010</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2010/08/">August 2010</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2010/07/">July 2010</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2010/06/">June 2010</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2010/05/">May 2010</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2010/04/">April 2010</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2010/03/">March 2010</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2009/12/">December 2009</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2009/11/">November 2009</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2009/10/">October 2009</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2009/09/">September 2009</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2009/08/">August 2009</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2009/07/">July 2009</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2009/05/">May 2009</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2008/12/">December 2008</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2008/07/">July 2008</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/archives/84183.html">记录在docker中运行whenever遇到的问题</a>
          </li>
        
          <li>
            <a href="/archives/84182.html">Gitlab Runner 配置</a>
          </li>
        
          <li>
            <a href="/archives/84181.html">Github Runner 配置</a>
          </li>
        
          <li>
            <a href="/archives/84180.html">使用python编写帝国时代2修改器</a>
          </li>
        
          <li>
            <a href="/archives/84179.html">使用Vagrant和Docker搭建Kubernetes集群</a>
          </li>
        
      </ul>
    </div>
  </div>

  
    <div class="widget-wrap">
  <h3 class="widget-title">Link</h3>
    <div class="widget">
      <ul id="category-list">
        <li><a target="_blank" title="我的Github" href="https://github.com/wusuopu">@Github</a></li>
        <li><a target="_blank" title="我的微博" href="http://www.weibo.com/u/1768691343">@Weibo</a></li>
        <li><a target="_blank" title="我的Twitter" href="https://twitter.com/longchangjin">@Twitter</a></li>
        <li><a target="_blank" title="我的豆瓣" href="http://www.douban.com/people/lchj/">@Douban</a></li>

        <li><a target="_blank" title="" href="http://gtk.awaysoft.com/">GTK+ 中文社区</a></li>
      </ul>
    </div>
</div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2022 龍昌<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
<div style="display:none;"><script src="http://s94.cnzz.com/stat.php?id=1259846&web_id=1259846&show=pic" language="JavaScript"></script></div>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
    <a href="/about" class="mobile-nav-link">About</a>
  
    <a href="/gbook" class="mobile-nav-link">留言板</a>
  
</nav>
    


<script src="/js/jquery.min.js"></script>



  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">

  
<script src="/fancybox/jquery.fancybox.pack.js"></script>




<script src="/js/script.js"></script>


  </div>
</body>
</html>