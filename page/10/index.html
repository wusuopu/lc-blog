
<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js" lang="en"><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <title>龍昌博客</title>
  <meta name="author" content="龍昌">

  
  <meta name="description" content="数组 这一部分的教程将介绍数组。数组是有序对象的集合。 一个这是在某个时刻只能保存一项数值。不过数组可以保存多项。这些数据项被称为数组的元素。数组可以保存任何类型的数据。每个元素可以使用索引来引用。第一个元素的索引值为0。 注意Ruby的数组与C、C++或者Java中的数组有很大的不同。 #!/ &hellip;">
  

  <!-- http://t.co/dKP3o1e -->
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  
  <link rel="canonical" href="http://www.xefan.com/page/10/index.html">
  <link href="/favicon.png" rel="icon">
  <link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
  <link href="/atom.xml" rel="alternate" title="龍昌博客" type="application/atom+xml">
  <script src="/javascripts/modernizr-2.0.js"></script>
  <script src="//ajax.useso.com/ajax/libs/jquery/1.9.1/jquery.min.js"></script>
  <script>!window.jQuery && document.write(unescape('%3Cscript src="./javascripts/libs/jquery.min.js"%3E%3C/script%3E'))</script>
  <script src="/javascripts/octopress.js" type="text/javascript"></script>
  <!--Fonts from Google"s Web font directory at http://google.com/webfonts -->
<link href="//fonts.useso.com/css?family=PT+Serif:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">
<link href="//fonts.useso.com/css?family=PT+Sans:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">

  

</head>

<body   >
  <header role="banner"><hgroup>
  <h1><a href="/">龍昌博客</a></h1>
  
    <h2>从Pythoneer转向Rubist</h2>
  
</hgroup>

</header>
  <nav role="navigation"><ul class="subscription" data-subscription="rss">
  <li><a href="/atom.xml" rel="subscribe-rss" title="subscribe via RSS">RSS</a></li>
  
</ul>
  
<form action="https://www.google.com/search" method="get">
  <fieldset role="search">
    <input type="hidden" name="q" value="site:www.xefan.com" />
    <input class="search" type="text" name="q" results="0" placeholder="Search"/>
  </fieldset>
</form>
  
<ul class="main-navigation">
  <li><a href="/">Home</a></li>
  <li><a href="/blog/archives">Archives</a></li>
 <li><a href="/about/">About</a></li>  <li><a href="/gbook/">留言板</a></li> 
</ul>

</nav>
  <div id="main">
    <div id="content">
      <div class="blog-index">
  
  
  
    <article>
      
  <header>
    
    <h1 class="entry-title"><a href="http://www.xefan.com/archives/83932.html">[翻译]Ruby教程10——数组</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2013-11-14T00:00:00+08:00'><span class='date'><span class='date-month'>Nov</span> <span class='date-day'>14</span><span class='date-suffix'>th</span>, <span class='date-year'>2013</span></span> <span class='time'>12:00 am</span></time>
        
           | <a href="http://www.xefan.com/archives/83932.html#disqus_thread"
             data-disqus-identifier="http://www.xefan.com/archives/83932.html">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><h1>数组</h1>


<p>这一部分的教程将介绍数组。数组是有序对象的集合。</p>


<p>一个这是在某个时刻只能保存一项数值。不过数组可以保存多项。这些数据项被称为数组的元素。数组可以保存任何类型的数据。每个元素可以使用索引来引用。第一个元素的索引值为0。</p>


<p>注意Ruby的数组与C、C++或者Java中的数组有很大的不同。</p>


<pre><code>#!/usr/bin/ruby

nums = [1, 2, 3, 4, 5]

nums.each do |num|
    puts num
end
</code></pre>


<p>我们的第一个例子创建了一个包含5个整数的数组，然后在终端上打印这些元素。</p>


<pre><code>nums = [1, 2, 3, 4, 5]
</code></pre>


<p>这行创建了一个包含5个整数的数组，每个元素使用逗号分隔开来。</p>


<pre><code>nums.each do |num|
    puts num
end
</code></pre>


<p>我们使用<em>each</em>方法遍历数组并在终端上打印每个元素。</p>


<p>$ ./array.rb<br>
1<br>
2<br>
3<br>
4<br>
5  </p>


<p>程序的输出结果。</p>


<h2>创建数组</h2>


<p>Ruby中数组是一个对象，可以使用<em>new</em>方法进行实例化。</p>


<pre><code>#!/usr/bin/ruby

nums = Array.new

nums.push 1
nums.push 2
nums.push 3
nums.push 4
nums.push 5

puts nums
</code></pre>


<p>这个脚本中我们创建了一个数组<em>nums</em>，然后往里面添加了5个整数。</p>


<pre><code>nums = Array.new
</code></pre>


<p>创建数组对象。</p>


<pre><code>nums.push 1
</code></pre>


<p><em>push</em>方法是往数组尾部添加一项数据。</p>


<hr>


<p>我们继续使用<em>new</em>方法创建数组。</p>


<pre><code>#!/usr/bin/ruby

a1 = Array.new 
a2 = Array.new 3
a3 = Array.new 6, "coin"
a4 = Array.new [11]
a5 = Array.new (15) {|e| e*e}

puts [a1, a2, a3, a4, a5].inspect
</code></pre>


<p><em>Array</em>类的<em>new</em>方法有一些选项。</p>


<pre><code>a1 = Array.new
</code></pre>


<p>创建一个空的数组，支持稍后再往其中填充数据。</p>


<pre><code>a2 = Array.new 3
</code></pre>


<p>创建一个数组包含3个<em>nil</em>对象。</p>


<pre><code>a3 = Array.new 6, "coin"
</code></pre>


<p>创建一个数组包含6个<em>&#8220;coin&#8221;</em>字符串。第一个选项是数组的大小；第二个选项是填充的对象。</p>


<pre><code>a4 = Array.new [11]
</code></pre>


<p>第四个数组只有一项数据。</p>


<pre><code>a5 = Array.new (15) {|e| e*e}
</code></pre>


<p>创建一个有15个元素的数组，第个元素都是在代码块中创建。这里计算了序号数的平方。</p>


<pre><code>puts [a1, a2, a3, a4, a5].inspect
</code></pre>


<p>将所有的数组放在一个数组中。数组是可以放入另一个数组里的。然后调用数组的<em>inspect</em>方法，它将对其所有的元素都调用该方法。<em>inspect</em>方法将返回代表这个数组的字符串。当我们需要快速检查数组内容时它非常有用。</p>


<p>$ ./arraynew.rb<br>
[[], [nil, nil, nil], [&#8220;coin&#8221;, &#8220;coin&#8221;, &#8220;coin&#8221;, &#8220;coin&#8221;, &#8220;coin&#8221;, &#8220;coin&#8221;], <br>
[11], [0, 1, 4, 9, 16, 25, 36, 49, 64, 81, 100, 121, 144, 169, 196]]  </p>


<p>我们可以所有创建的数组。</p>


<hr>


<p>接下来的脚本展示了多种创建数组的方法。</p>


<pre><code>#!/usr/bin/ruby

integers = [1, 2, 3, 4, 5]
animals = %w( donkey dog cat dolphin eagle )
weights = Array.new
weights &lt;&lt; 4.55 &lt;&lt; 3.22 &lt;&lt; 3.55 &lt;&lt; 8.55 &lt;&lt; 3.23

puts integers.inspect
puts animals.inspect
puts weights.inspect
</code></pre>


<p>我们创建了三个数组分别包含了整数、字符串和小数。</p>


<pre><code>integers = [1, 2, 3, 4, 5]
</code></pre>


<p>这行创建了一个包含5个整数的数组。这是最经典的方法。数组的每个元素放在中括号中用逗号隔开。</p>


<pre><code>animals = %w( donkey dog cat dolphin eagle )
</code></pre>


<p>这行代码创建了一个有5个元素的字符串数组。这种方式我们不需要逗号和双引号，减少了按键次数。</p>


<pre><code>weights = Array.new
weights &lt;&lt; 4.55 &lt;&lt; 3.22 &lt;&lt; 3.55 &lt;&lt; 8.55 &lt;&lt; 3.23
</code></pre>


<p>第三种方法有两步。首先创建一个数组对象，然后用数据将其初始化。这是正式的数组创建方法。上面方法实际上是这个的简写。</p>


<pre><code>puts integers.inspect
</code></pre>


<p>The inspect method prints the string representation of the array to the terminal.</p>


<p>$ ./creation.rb<br>
[1, 2, 3, 4, 5]<br>
[&#8220;donkey&#8221;, &#8220;dog&#8221;, &#8220;cat&#8221;, &#8220;dolphin&#8221;, &#8220;eagle&#8221;]<br>
[4.55, 3.22, 3.55, 8.55, 3.23]  </p>


<p>例子的输出结果。</p>


<hr>


<p>数组的数据项没限制必须是数字和字符串。数组可以包含Ruby中的所有类型的数据。</p>


<pre><code>#!/usr/bin/ruby

class Empty

end

nums = [1, 2, 3, 4, 5]

various = [1, -1, "big", 3.4, Empty.new, nums, :two]

puts various.inspect
</code></pre>


<p>我们在数组中放了多种Ruby对象。</p>


<pre><code>various = [1, -1, "big", 3.4, Empty.new, nums, :two]
</code></pre>


<p>这个数组包含了数字、字符串、自定义对象、另一个数组和一个符号。</p>


<pre><code>$ ./arrayobjects.rb                                                                                   
[1, -1, "big", 3.4, #&lt;Empty:0x987f704&gt;, [1, 2, 3, 4, 5], :two]
</code></pre>


<p><em>arrayobjects.rb</em>脚本的运行结果。</p>


<hr>


<p>下一个例子展示嵌套数组；即一个数组包含另一个数组。Ruby中可以在数组中嵌套数组。</p>


<pre><code>#!/usr/bin/ruby

numbers = [1, 2, 3, [2, 4, 6, [11, 12]]]

puts numbers.length
puts numbers[0], numbers[1]

puts numbers[3][0]
puts numbers[3][1]

puts numbers[3][3][0]
puts numbers[3][3][1]

puts numbers.flatten!.inspect
</code></pre>


<p>数组<em>[11, 12]</em>被嵌套在<em>[2, 4, 6, &#8230;]</em>里，这个数组又被嵌套在<em>[1, 2, 3, &#8230;]</em>数组里。</p>


<pre><code>puts numbers.length
</code></pre>


<p><em>length</em>方法返回4。内嵌数组只算一个元素。</p>


<pre><code>puts numbers[0], numbers[1]
</code></pre>


<p>这里<em>[]</em>字符用于访问数组的元素。上面这行代码返回第一个和第二个元素。</p>


<pre><code>puts numbers[3][0]
puts numbers[3][1]
</code></pre>


<p>这里我们访问内嵌数组的元素。<em>[3][0]</em>返回内嵌数组的第一个元素，在这里是2。同样的<em>[3][1]</em>返回内嵌数组的第二个元素，这里是4。</p>


<pre><code>puts numbers[3][3][0]
puts numbers[3][3][1]
</code></pre>


<p>现在我们进入更深一层。我们访问更深一层数组的元素。<em>[3][3]</em>返回<em>[11, 12]</em>数组。然后从这个数组获取第一个和第二个元素。</p>


<pre><code>puts numbers.flatten!.inspect
</code></pre>


<p><em>flatten!</em>方法将数组变为平坦。它将所有的内嵌数组元素创建成一个新的数组。</p>


<p>$ ./arrayofarrays.rb<br>
4<br>
1<br>
2<br>
2<br>
4<br>
11<br>
12<br>
[1, 2, 3, 2, 4, 6, 11, 12]  </p>


<p>输出结果。 </p>


<h2>打印数组内容</h2>


<p>要在终端上打印数组的元素有多种方法可以完成。</p>


<pre><code>#!/usr/bin/ruby

integers = [1, 2, 3, 4, 5]

puts integers
puts integers.inspect

integers.each do |e|
    puts e
end
</code></pre>


<p>这个脚本我们将数组的元素打印了三次。</p>


<pre><code>puts integers
</code></pre>


<p>数组作为puts/print方法的参数是最简单的方式。每行将打印一个元素。</p>


<pre><code>puts integers.inspect
</code></pre>


<p>使用<em>inspect</em>方法输出结果的可读性更好。</p>


<pre><code>integers.each do |e|
    puts e
end
</code></pre>


<p><em>each</em>方法为每个元素都调用一次一个代码块，元素作为参数传递。我们简单的参元素使用<em>puts</em>方法。</p>


<p>$ ./printarray1.rb<br>
1<br>
2<br>
3<br>
4<br>
5<br>
[1, 2, 3, 4, 5]<br>
1<br>
2<br>
3<br>
4<br>
5  </p>


<p>数组在终端上打印了三次。</p>


<hr>


<p>第二个例子我们提供了两个额外的方法打印数组。</p>


<pre><code>#!/usr/bin/ruby

integers = [1, 2, 3, 4, 5]

integers.length.times do |idx|
    puts integers[idx]
end

integers.each_with_index do |num, idx|
    puts "value #{num} has index #{idx}"
end
</code></pre>


<p>第一种情况我们组合使用了<em>length</em>和<em>times</em>方法。第二种情况我们使用了<em>each_with_index</em>方法。</p>


<pre><code>integers.length.times do |idx|
    puts integers[idx]
end
</code></pre>


<p><em>length</em>方法返回数组的长度。<em>times</em>方法将接下来的代码块迭代<em>length</em>次，传递的值从0到length-1。这些数字作为数组的索引使用。</p>


<pre><code>integers.each_with_index do |num, idx|
    puts "value #{num} has index #{idx}"
end
</code></pre>


<p><em>each_with_index</em>方法迭代数组并将元素及其索引传递给代码块。用这种方法我们可以简单的打印元素和它的索引。</p>


<p>$ ./printarray2.rb<br>
1<br>
2<br>
3<br>
4<br>
5<br>
value 1 has index 0<br>
value 2 has index 1<br>
value 3 has index 2<br>
value 4 has index 3<br>
value 5 has index 4  </p>


<p>输出结果。</p>


<h2>读取数组元素</h2>


<p>这节我们将从数组读取数据。</p>


<pre><code>#!/usr/bin/ruby

lts = %w{ a b c d e f g h}

puts lts.first
puts lts.last
puts lts.at(3)
</code></pre>


<p>第一个例子我们展示了三个简单的方法进行数据检索。</p>


<pre><code>puts lts.first
puts lts.last
</code></pre>


<p><em>first</em>方法读取数组的第一个元素；<em>last</em>方法读取数组的最后一个元素。</p>


<pre><code>puts lts.at(3)
</code></pre>


<p><em>at</em>方法返回指定索引的元素。</p>


<p>$ ./retrieval.rb<br>
a<br>
h<br>
d  </p>


<p><em>retrieval.rb</em>程序的输出结果。</p>


<hr>


<p><em>[]</em>符号可以用于访问数据。这是传统访问数据的方法，许多语言都使用这种方法。</p>


<pre><code>#!/usr/bin/ruby

lts = %w{ a b c d e f g h }

puts lts[0]
puts lts[-1]
puts lts[0, 3].inspect
puts lts[2..6].inspect
puts lts[2...6].inspect
</code></pre>


<p>我们展示了5个使用[]符号的例子。</p>


<pre><code>puts lts[0]
puts lts[-1]
</code></pre>


<p>我们获取数组的第一个和最后一个元素。第一项的索引为0,最后一项的索引为-1。</p>


<pre><code>puts lts[0, 3].inspect
</code></pre>


<p>当中括号里有两个数时，第一个是开始的索引，第二个是长度。这行代码返回从0开始的3个元素。注意<em>inspect</em>方法仅是为了让输出可读而已。</p>


<pre><code>puts lts[2..6].inspect
puts lts[2...6].inspect
</code></pre>


<p>我们可以在中括号使用范围操作符。第一行读取第2个到第6个元素，第二行读取第2个到第5个元素。</p>


<hr>


<p>接下来展示<em>values_at</em>方法。这个方法的优势是可以选择多个位置的元素。</p>


<pre><code>#!/usr/bin/ruby

lts = %w{ a b c d e f g h}

puts lts.values_at(1..5).inspect
puts lts.values_at(1, 3, 5).inspect
puts lts.values_at(1, 3, 5, 6, 8).inspect
puts lts.values_at(-1, -3).inspect
</code></pre>


<p><em>values_at method</em>方法返回一个数组包含选中的元素。<em>inspect</em>方法仅是为了让输出可读而已。</p>


<pre><code>puts lts.values_at(1..5).inspect
</code></pre>


<p>这行代码返回索引为1到5的元素。</p>


<pre><code>puts lts.values_at(1, 3, 5).inspect
</code></pre>


<p>这里我们读取索引为1、3、5的元素。</p>


<pre><code>puts lts.values_at(1, 3, 5, 6, 8).inspect
</code></pre>


<p>我们可以指定多个索引，如果指定的索引没有元素则返回<em>nil</em>。</p>


<pre><code>puts lts.values_at(-1, -3).inspect
</code></pre>


<p>负数的索引表示从数组尾部开始。</p>


<p>$ ./retrieval3.rb<br>
[&#8220;b&#8221;, &#8220;c&#8221;, &#8220;d&#8221;, &#8220;e&#8221;, &#8220;f&#8221;]<br>
[&#8220;b&#8221;, &#8220;d&#8221;, &#8220;f&#8221;]<br>
[&#8220;b&#8221;, &#8220;d&#8221;, &#8220;f&#8221;, &#8220;g&#8221;, nil]<br>
[&#8220;h&#8221;, &#8220;f&#8221;]  </p>


<p>脚本的输出结果。</p>


<hr>


<p>我们使用<em>fetch</em>方法从数组读取数据。</p>


<pre><code>#!/usr/bin/ruby

lts = [0, 1, 2, 3, 4, 5, 6]

puts lts.fetch(0)
puts lts.fetch(-2)
puts lts.fetch(8, 'undefined')
puts lts.fetch(8) { |e| -2*e }
</code></pre>


<p>我们展示了<em>fetch</em>方法的一些形式的用法。</p>


<pre><code>puts lts.fetch(0)
puts lts.fetch(-2)
</code></pre>


<p>第一行打印了数组的第一个元素。第二行打印了倒数第二个元素。</p>


<pre><code>puts lts.fetch(8, 'undefined')
</code></pre>


<p>第三种形式是返回指定索引的元素，如果索引超出范围则返回默认值，这里是<em>&#8216;undefined&#8217;</em>。没有第二个参数则会抛出IndexError错误。</p>


<pre><code>puts lts.fetch(8) { |e| -2*e}
</code></pre>


<p>最后一种形式我们定义了一个代码块，传递了索引对应的值，这个方法返回了代码块调用的结果。</p>


<p>$ ./retrieval4.rb<br>
0<br>
5<br>
undefined<br>
-16  </p>


<p>脚本的输出结果。</p>


<hr>


<p>我们将展示<em>take</em>和<em>take_while</em>方法的用法。</p>


<pre><code>#!/usr/bin/ruby

lts = %w{ a b c d e f g h}


puts lts.take(4).inspect

lts2 = lts.take_while { |e| e &lt; 'f' }
puts lts2.inspect
</code></pre>


<p><em>take</em> n方法返回开头的n个元素。<em>take_while</em>方法将元素传递给一个代码块，直到代码块返回<em>nil</em>或者<em>false</em>才停止迭代，并返回之前的元素。</p>


<pre><code>puts lts.take(4).inspect
</code></pre>


<p>这里我们返回开头的4个元素。</p>


<pre><code>lts2 = lts.take_while { |e| e &lt; 'f' }
puts lts2.inspect
</code></pre>


<p>这里我们从源数组创建了一个新的数组，这个新数组包含了所有小于&#8217;f&#8217;的字符。</p>


<p>$ ./retrieval5.rb<br>
[&#8220;a&#8221;, &#8220;b&#8221;, &#8220;c&#8221;, &#8220;d&#8221;]<br>
[&#8220;a&#8221;, &#8220;b&#8221;, &#8220;c&#8221;, &#8220;d&#8221;, &#8220;e&#8221;]  </p>


<p><em>retrieval5.rb</em>程序的输出结果。</p>


<hr>


<p><em>slice</em>方法与[]符号相同。返回一个或者多个元素。</p>


<pre><code>#!/usr/bin/ruby

lts = %w{ a b c d e f g h}

puts lts.slice(0)
puts lts.slice(-1)
puts lts.slice(0, 3).inspect
puts lts.slice(2..6).inspect
puts lts.slice(2...6).inspect
</code></pre>


<p>展示了5个<em>slice</em> 方法的例子。</p>


<pre><code>puts lts.slice(0)
puts lts.slice(-1)
</code></pre>


<p>这些形式的<em>slice</em>方法返回一个数组元素。第行代码返回第一个元素，第二行代码返回最后一个元素。</p>


<pre><code>puts lts.slice(0, 3).inspect
</code></pre>


<p>第一个参数是起始索引，第二个参数是长度。这一行代码返回从0开始的3个元素。</p>


<pre><code>puts lts.slice(2..6).inspect
puts lts.slice(2...6).inspect
</code></pre>


<p>我们可以在<em>slice</em>方法中使用范围操作符。第一行读取第2到6的元素，第二行读取第2到5的元素。</p>


<p>$ ./retrieval6.rb<br>
a<br>
h<br>
[&#8220;a&#8221;, &#8220;b&#8221;, &#8220;c&#8221;]<br>
[&#8220;c&#8221;, &#8220;d&#8221;, &#8220;e&#8221;, &#8220;f&#8221;, &#8220;g&#8221;]<br>
[&#8220;c&#8221;, &#8220;d&#8221;, &#8220;e&#8221;, &#8220;f&#8221;]  </p>


<p><em>slice</em>方法返回数组的一部分，一个或者多个元素。</p>


<hr>


<p>可以随机选择数组的一个元素。Ruby中的<em>sample</em>方法可以实现。</p>


<pre><code>#!/usr/bin/ruby

lts = %w{ a b c d e f g h}

puts lts.sample
puts lts.sample(3).inspect
</code></pre>


<p><em>sample</em>方法有两种形式。第一种我们选择一个随机元素。第二种我们选择n个随机元素。</p>


<p>$ ./random.rb<br>
b<br>
[&#8220;c&#8221;, &#8220;f&#8221;, &#8220;d&#8221;]<br>
$ ./random.rb<br>
d<br>
[&#8220;c&#8221;, &#8220;d&#8221;, &#8220;e&#8221;]  </p>


<p>执行两次结果不同。</p>


<h2>使用数组</h2>


<p>接下来的例子介绍一些Ruby数组的方法。</p>


<pre><code>#!/usr/bin/ruby

num1 = [1, 2, 3, 4, 5]
num2 = [6, 7, 8, 9, 10]

puts num1 + num2 
puts num1.concat num2
</code></pre>


<p>我们定义了两个数组，将它们相加。</p>


<pre><code>puts num1 + num2 
puts num1.concat num2
</code></pre>


<p>有两个数组相加的方法。使用+操作符或者<em>concat</em>方法。</p>


<hr>


<p>Ruby中数组有丰富的方法。例如<em>length</em>方法返回数组的元素个数。</p>


<pre><code>#!/usr/bin/ruby

lts = %w{ a b c d e f}

puts lts.inspect
puts "Array has #{lts.length} elements"
puts "The first element is #{lts.first}"
puts "The last element is #{lts.last}"

puts lts.eql? lts.dup
puts lts.eql? lts.dup.delete_at(0)

lts.clear
puts lts.inspect
puts lts.empty?
</code></pre>


<p>上面的脚本我们介绍了7个新方法。</p>


<pre><code>puts "Array has #{lts.length} elements"
</code></pre>


<p><em>length</em>方法决定数组的大小。</p>


<pre><code>puts "The first element is #{lts.first}"
puts "The last element is #{lts.last}"
</code></pre>


<p>这里我们获取第一个和最后一个元素。</p>


<pre><code>puts lts.eql? lts.dup
</code></pre>


<p><em>eql?</em>方法指出两个数组是否相等。这里是返回<em>true</em>。<em>dup</em>方法创建一个浅复制对象。</p>


<pre><code>puts lts.eql? lts.dup.delete_at(0)
</code></pre>


<p><em>delete_at</em>方法从数组的开头删除元素。现在两个数组不相同了。</p>


<pre><code>lts.clear
</code></pre>


<p><em>clear</em>方法删除数组的所有元素。</p>


<pre><code>puts lts.empty?
</code></pre>


<p><em>empty?</em>方法检查数组是否为空。这里返回<em>true</em>，因为我们已经将所有元素都删除了。</p>


<p>$ ./basics.rb<br>
[&#8220;a&#8221;, &#8220;b&#8221;, &#8220;c&#8221;, &#8220;d&#8221;, &#8220;e&#8221;, &#8220;f&#8221;]<br>
Array has 6 elements<br>
The first element is a<br>
The last element is f<br>
true<br>
false<br>
[]<br>
true  </p>


<p>输出结果。</p>


<hr>


<p>一些Ruby的数组方法以感叹号结尾。这是Ruby的习惯。感叹号告诉程序员这个方法会修改数据。感叹号本身没有什么作用，它只是名字的约定。</p>


<pre><code>#!/usr/bin/ruby

chars = %w{a b c d e}

reversed_chars = chars.reverse
puts reversed_chars.inspect
puts chars.inspect

reversed_chars = chars.reverse!
puts reversed_chars.inspect
puts chars.inspect
</code></pre>


<p>Ruby中有一些比较相似的方法。<em>reverse</em>和<em>reverse!</em>方法都是改为数组元素的顺序，将它们反转。不同在于<em>reverse</em>方法返回反转后的数组，原数组不变。<em>reverse!</em>方法会同时修改原数组。</p>


<p>$ ./twotypes.rb<br>
[&#8220;e&#8221;, &#8220;d&#8221;, &#8220;c&#8221;, &#8220;b&#8221;, &#8220;a&#8221;]<br>
[&#8220;a&#8221;, &#8220;b&#8221;, &#8220;c&#8221;, &#8220;d&#8221;, &#8220;e&#8221;]<br>
[&#8220;e&#8221;, &#8220;d&#8221;, &#8220;c&#8221;, &#8220;b&#8221;, &#8220;a&#8221;]<br>
[&#8220;e&#8221;, &#8220;d&#8221;, &#8220;c&#8221;, &#8220;b&#8221;, &#8220;a&#8221;]  </p>


<p>我们清晰的看到前两个数组不同，第三和第四个数组是相同的。</p>


<hr>


<p>一些其他的方法展示。</p>


<pre><code>#!/usr/bin/ruby

numbers = [1, 2, 2, 2, 3, 4, 5, 8, 11]

puts numbers.index 2
puts numbers.index 11
puts numbers.rindex 2

puts numbers.include? 3
puts numbers.include? 10

puts numbers.join '-'
puts numbers.uniq!.inspect
</code></pre>


<p>介绍5个额外的方法。</p>


<pre><code>puts numbers.index 2
puts numbers.index 11
</code></pre>


<p><em>index</em>方法返回数组中元素对应的索引。索引是从左算起。第一行返回1,它是第一个2的索引。数组中仅有一个11,它的索引是8。</p>


<pre><code>puts numbers.rindex 2
</code></pre>


<p><em>rindex</em>方法返回从右边开始的索引。这里2的最右索引为3。</p>


<pre><code>puts numbers.include? 3
puts numbers.include? 10
</code></pre>


<p><em>include?</em>方法检查一个元素是否在数组中。第一行返回<em>true</em>，3在数组中。第二行返回<em>false</em>，数组中没有10。作为约定Ruby中以问号结尾的方法返回一个布尔值，并且对数组没有影响。</p>


<pre><code>puts numbers.join '-'
</code></pre>


<p><em>join</em>方法返回一个字符串，它是将数组的元素用指定的符号分隔开来。</p>


<pre><code>puts numbers.uniq!.inspect
</code></pre>


<p><em>uniq!</em>方法移除重复的元素。在数组中有3个2,调用方法之后就只剩一个2了。</p>


<p>$ ./methods2.rb <br>
1<br>
8<br>
3<br>
true<br>
false<br>
1-2-2-2-3-4-5-8-11<br>
[1, 2, 3, 4, 5, 8, 11]  </p>


<p>注意<em>join</em>方法产生的是一个字符串，它是数组的数字用<em>-</em>符号分隔。</p>


<h2>修改数组</h2>


<p>这一节我们介绍与数组修改相关的方法。基本的我们做一些插入和删除操作。</p>


<pre><code>#!/usr/bin/ruby

lts = []

lts.insert 0, 'E', 'F', 'G'
lts.push 'H'
lts.push 'I', 'J', 'K'
lts &lt;&lt; 'L' &lt;&lt; 'M' 
lts.unshift 'A', 'B', 'C'
lts.insert(3, 'D')

puts lts.inspect
</code></pre>


<p>从一个空数组开始，我们使用不同的插入方法。</p>


<pre><code>lts.insert 0, 'E', 'F', 'G'
</code></pre>


<p><em>insert</em>方法往<em>lts</em>数组插入了3个元素。</p>


<pre><code>lts.push 'H'
lts.push 'I', 'J', 'K'
</code></pre>


<p><em>push</em>方法往数组添加元素，我们可以添加一个或多个元素。</p>


<pre><code>lts &lt;&lt; 'L' &lt;&lt; 'M'
</code></pre>


<p><em>&lt;&lt;</em>与<em>push</em>方法相同。这个操作可以链式调用。</p>


<pre><code>lts.unshift 'A', 'B', 'C'
</code></pre>


<p><em>unshift</em>方法将元素插入在数组前端。</p>


<pre><code>lts.insert(3, 'D')
</code></pre>


<p>这里<em>insert</em>方法在指定的位置插入&#8217;D&#8217;字符。</p>


<p>$ ./insertion.rb<br>
[&#8220;A&#8221;, &#8220;B&#8221;, &#8220;C&#8221;, &#8220;D&#8221;, &#8220;E&#8221;, &#8220;F&#8221;, &#8220;G&#8221;, &#8220;H&#8221;, &#8220;I&#8221;, &#8220;J&#8221;, &#8220;K&#8221;, &#8220;L&#8221;, &#8220;M&#8221;]  </p>


<p>使用上面的方法，我们创建了一个包含大写字母的数组。</p>


<hr>


<p>一些删除数组元素的方法。</p>


<pre><code>#!/usr/bin/ruby

lts = %w{ a b c d e f g h}

lts.pop
lts.pop

puts lts.inspect

lts.shift
lts.shift

puts lts.inspect

lts.delete_at(0)
lts.delete('d')

puts lts.inspect

puts lts.clear
puts lts.inspect
</code></pre>


<p>这个脚本展示了5个用于删除数组元素的方法。</p>


<pre><code>lts = %w{ a b c d e f g h}
</code></pre>


<p>创建一个有8个元素的数组。</p>


<pre><code>lts.pop
</code></pre>


<p><em>pop</em>方法移除最后一个元素。</p>


<pre><code>lts.shift
</code></pre>


<p><em>shift</em>方法移除数组的第一个元素。</p>


<pre><code>lts.delete_at(0)
</code></pre>


<p><em>delete_at</em>方法删除指定位置的元素。我们删除剩余元素的第一个元素。</p>


<pre><code>puts lts.clear
</code></pre>


<p><em>clear</em>方法清除所有元素。</p>


<pre><code>lts.delete('d')
</code></pre>


<p><em>delete</em>方法删除指定的一项数据。</p>


<p>$ ./deletion.rb<br>
[&#8220;a&#8221;, &#8220;b&#8221;, &#8220;c&#8221;, &#8220;d&#8221;, &#8220;e&#8221;, &#8220;f&#8221;]<br>
[&#8220;c&#8221;, &#8220;d&#8221;, &#8220;e&#8221;, &#8220;f&#8221;]<br>
[&#8220;e&#8221;, &#8220;f&#8221;]<br>
[]  </p>


<p>输出结果。</p>


<hr>


<p>目前为止我们使用的方法同时只修改一个数组项。Ruby中有一些方法可以一次修改多个数组项的。</p>


<pre><code>#!/usr/bin/ruby

nms = [2, -1, -4, 0, 4, 3, -2, 3, 5]

nms.delete_if { |x| x &lt; 0 }

puts nms.inspect
</code></pre>


<p>例子介绍了<em>delete_if</em>方法用于删除所有符合条件式的数据项。</p>


<pre><code>nms.delete_if { |x| x &lt; 0 }
</code></pre>


<p>这行删除所有的负数。</p>


<p>$ ./delete_if.rb<br>
[2, 0, 4, 3, 3, 5]  </p>


<p>我们从<em>nms</em>数组中删除了所有的负数。</p>


<hr>


<p>我们展示两个其他的方法处理多数据项。</p>


<pre><code>#!/usr/bin/ruby

lts = %w{ a b c d e f g}

puts lts.inspect

lts.reject! do |e|
    e =~ /[c language="-y"][/c]/
end

puts lts.inspect

lts.replace(["x", "y", "z"])
puts lts.inspect
</code></pre>


<p>我们使用了两个方法，<em>reject!</em>和<em>replace</em>。</p>


<pre><code>lts.reject! do |e|
    e =~ /[c language="-y"][/c]/
end
</code></pre>


<p><em>reject!</em>方法移除了所有项满足条件式的数据。这里我们删除所有符合正则式的字母。</p>


<pre><code>lts.replace(["x", "y", "z"])
</code></pre>


<p><em>replace</em>方法将使用给定的数据替换数组项。如果可能它会截断或者扩展数组。</p>


<p>$ ./modify.rb <br>
[&#8220;a&#8221;, &#8220;b&#8221;, &#8220;c&#8221;, &#8220;d&#8221;, &#8220;e&#8221;, &#8220;f&#8221;, &#8220;g&#8221;]<br>
[&#8220;a&#8221;, &#8220;b&#8221;]<br>
[&#8220;x&#8221;, &#8220;y&#8221;, &#8220;z&#8221;]  </p>


<p><em>modify.rb</em>例子的输出结果。</p>


<h2>集合操作</h2>


<p>这一节中我们展示Ruby数组的集合操作。数学中集合是独立对象的收集。</p>


<pre><code>#!/usr/bin/ruby

A = [1, 2, 3, 4, 5]
B = [4, 5, 6, 7, 8]

union = A | B
isect = A &amp; B
diff1  = A - B
diff2  = B - A
sdiff = (A - B) | (B - A)

puts "Union of arrays: #{union}"
puts "Intersection of arrays: #{isect}"
puts "Difference of arrays A - B: #{diff1}"
puts "Difference of arrays B - A: #{diff2}"    
puts "Symmetric difference of arrays: #{sdiff}"
</code></pre>


<p>上面的脚本我们展示了一些集合操作，并集、交集、差集和对称差集。</p>


<pre><code>nums1 = [1, 2, 3, 4, 5]
nums2 = [4, 5, 6, 7, 8]
</code></pre>


<p>字义了两个整数数组。都是集合，因此每个元素都只出现了一次。两个数组有两个相同的数，4和5。</p>


<pre><code>union = nums1 | nums2
</code></pre>


<p>数组的并集。两个数组相加，每个元素最终也只出现一次。</p>


<pre><code>isect = A &amp; B
</code></pre>


<p>数组交集。输出两个数组都存在的元素。这里是4和5。</p>


<pre><code>diff1  = A - B
diff2  = B - A
</code></pre>


<p>两个差集，也称补集。第一行我们得到了所有在A中出现B中没有出现的元素。第二行我们得到B中出现A中没有出现的元素。</p>


<pre><code>sdiff = (A - B) | (B - A)
</code></pre>


<p>对称差集。A或B中存在，但不同时存在于A和B。</p>


<p>$ ./setoperations.rb<br>
Union of arrays: [1, 2, 3, 4, 5, 6, 7, 8]<br>
Intersection of arrays: [4, 5]<br>
Difference of arrays A - B: [1, 2, 3]<br>
Difference of arrays B - A: [6, 7, 8]<br>
Symmetric difference of arrays: [1, 2, 3, 6, 7, 8]  </p>


<p>输出结果。</p>


<h2>select、collect、map方法</h2>


<p>下面的例子我们展示三个方法：<em>select</em>、<em>collect</em>和<em>map</em>。</p>


<pre><code>#!/usr/bin/ruby

nums = [1, 3, 2, 6, 7, 12, 8, 15]

selected = nums.select do |e|
    e &gt; 10
end

puts selected.inspect

collected = nums.collect do |e|
    e &lt; 10
end

puts collected.inspect

mapped = nums.map do |e|
    e*2
end

puts mapped.inspect
</code></pre>


<p>所有这些方法都对数组的元素执行许多操作。</p>


<pre><code>selected = nums.select do |e|
    e &gt; 10
end
</code></pre>


<p>上面的代码使用<em>collect</em>方法创建了一个新数组。我们只选择了满足条件式的元素。这里我们选择了所有大于10的元素。</p>


<pre><code>collected = nums.collect do |e|
    e &lt; 10
end
</code></pre>


<p><em>collect</em>方法稍微不同。它只收集代码块的返回值。新的数组只包含true和false。</p>


<pre><code>mapped = nums.map do |e|
    e*2
end
</code></pre>


<p><em>map</em>方法与<em>collect</em>方法相同。上面的代码根据已存在的数组创建了一个新的数组。每个元素都乘以2.</p>


<p>$ ./mass.rb<br>
[12, 15]<br>
[true, true, true, true, true, false, true, false]<br>
[2, 6, 4, 12, 14, 24, 16, 30]  </p>


<p>创建了新数组。</p>


<h2>元素排序</h2>


<p>最后我们对数组元素进行排序。</p>


<pre><code>#!/usr/bin/ruby

planets = %w{ Mercury Venus Earth Mars Jupiter
                Saturn Uranus Neptune Pluto }

puts "#{planets.sort}"                
puts "#{planets.reverse}"
puts "#{planets.shuffle}"
</code></pre>


<p>例子中使用了三个Ruby数组的方法对数组元素进行重组。</p>


<pre><code>puts "#{planets.sort}"
</code></pre>


<p><em>sort</em>方法按字母顺序进行排序。</p>


<pre><code>puts "#{planets.reverse}"
</code></pre>


<p><em>reverse</em>方法反转元素并返回新的数组。</p>


<pre><code>puts "#{planets.shuffle}"
</code></pre>


<p><em>shuffle</em>方法将数组元素随机重组。</p>


<p>$ ./ordering.rb<br>
[&#8220;Earth&#8221;, &#8220;Jupiter&#8221;, &#8220;Mars&#8221;, &#8220;Mercury&#8221;, &#8220;Neptune&#8221;, &#8220;Pluto&#8221;, &#8220;Saturn&#8221;, &#8230;]<br>
[&#8220;Pluto&#8221;, &#8220;Neptune&#8221;, &#8220;Uranus&#8221;, &#8220;Saturn&#8221;, &#8220;Jupiter&#8221;, &#8220;Mars&#8221;, &#8220;Earth&#8221;, &#8230;]<br>
[&#8220;Earth&#8221;, &#8220;Jupiter&#8221;, &#8220;Mercury&#8221;, &#8220;Saturn&#8221;, &#8220;Mars&#8221;, &#8220;Venus&#8221;, &#8220;Uranus&#8221;, &#8230;]  </p>


<p>例子的输出结果。</p>


<p>在这章我们学习了Ruby的数组。</p>


<hr>


<p>原文地址： <a href="http://zetcode.com/lang/rubytutorial/arrays/">http://zetcode.com/lang/rubytutorial/arrays/</a><br>
翻译：龙昌  admin@longchangjin.cn<br>
完整教程：<a href="https://github.com/wusuopu/Ruby-tutorial">https://github.com/wusuopu/Ruby-tutorial</a> </p>

</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
    <h1 class="entry-title"><a href="http://www.xefan.com/archives/83929.html">[翻译]Ruby教程9——控制流</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2013-11-12T00:00:00+08:00'><span class='date'><span class='date-month'>Nov</span> <span class='date-day'>12</span><span class='date-suffix'>th</span>, <span class='date-year'>2013</span></span> <span class='time'>12:00 am</span></time>
        
           | <a href="http://www.xefan.com/archives/83929.html#disqus_thread"
             data-disqus-identifier="http://www.xefan.com/archives/83929.html">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><h1>控制流</h1>


<p>这章的教程我们将讨论控制流。</p>


<p>条件和循环改变了Ruby程序的流程。条件式是执行条件语句下面的特定语句。循环是执行多次的代码块。程序开始后，语句从源文件顶部到底部一行一行的执行。</p>


<h2>if语句</h2>


<p>if关键字用于检查一个表达式是否为真。如果为真则执行语句。这个语句可以是单一的语句，也可以是复合语句。复合语句是由多条语句构成的闭合代码块。代码块用<em>end</em>关键字闭合，<em>then</em>关键字是可选的。</p>


<pre><code>#!/usr/bin/ruby

num = gets.to_i

if num &gt; 0 then

    puts "num variable is positive"
    puts "num variable equals to #{num}"
end
</code></pre>


<p>输入一个数字，如果这个数字大于0则打印两条消息，否则什么也不做。</p>


<p>$ ./simpleif.rb <br>
4<br>
num variable is positive<br>
num variable equals to 4  </p>


<p>条件为真并且消息在终端上打印了。</p>


<hr>


<p>我们可以使用<em>else</em>关键字不创建一个简单的分支。如果<em>if</em>关键字后的表达式求值为假，那么<em>else</em>后面的语句将自动执行。这些代码使用<em>end</em>关键字闭合起来。</p>


<pre><code>#!/usr/bin/ruby

age = 17

if age &gt; 18

    puts "Driving licence issued"
else

    puts "Driving licence not permitted"
end
</code></pre>


<p>这里创建了一个<em>age</em>变量，布尔表达式求值为假，因此在终端上打印&#8221;Driving licence not permitted&#8221;。</p>


<p>$ ./licence.rb <br>
Driving licence not permitted  </p>


<p>我们可以使用<em>elsif</em>关键字创建多个分支。仅当前一个条件不为真时<em>elsif</em>关键字才会测试另一个条件。注意我们可以使用多个<em>elsif</em>关键字。</p>


<pre><code>#!/usr/bin/ruby

print "Enter a number: "

num = gets.to_i

if num &lt; 0

    puts "#{num} is negative"
elsif num == 0

   puts "#{num} is zero"
elsif num &gt; 0

   puts "#{num} is positive"
end
</code></pre>


<p>创建一个数字变量判断它是正数、负数还是0。根据输入值的不同将打印不同的消息。</p>


<h2>case语句</h2>


<p><em>case</em>语句是一个程序控制流语句。它允许一个变量或者表达式的值控制程序的执行流程。相比<em>if</em>、<em>elsif</em>它创建多分支更简单。</p>


<p>我们创建一个变量或者表达式。<em>case</em>关键字用于针对一个列表的值测试这个变量或者表达式的值。这个列表的值是使用<em>when</em>关键字呈现出来。如果值匹配，那么<em>when</em>关键字后面的语句将执行。有一个可选的<em>else</em>语句，如果没有匹配的它将执行。</p>


<pre><code>#!/usr/bin/ruby

print "Enter top level domain: "

domain = gets.chomp

case domain
    when "us"
        puts "United States"
    when "de" 
        puts "Germany"
    when "sk" 
        puts "Slovakia"
    when "hu" 
        puts "Hungary"
    else
        puts "Unknown"
end
</code></pre>


<p>这个程序中我们创建了一个<em>domain</em>变量，它的值从命令行读取。使用<em>when</em>语句测试这个变量的值。这有些选项。如果值等于&#8221;us&#8221;则打印&#8221;United States&#8221;字符串。</p>


<pre><code>domain = gets.chomp
</code></pre>


<p>我们使用<em>gets</em>方法获取一个输入值。使用<em>chomp</em>方法去掉换行符。</p>


<p>$ ./domains.rb <br>
Enter top level domain: hu<br>
Hungary  </p>


<p>我们输入&#8221;hu&#8221;，程序返回&#8221;Hungary&#8221;。</p>


<h2>while、until语句</h2>


<p><em>while</em>语句是一个控制流语句允许代码多次执行。当的条件为真时代码将执行。</p>


<p><em>while</em>关键字执行使用<em>end</em>闭合的代码块语句。每次表达式为真时这些语句将执行。</p>


<pre><code>#!/usr/bin/ruby

i = 0
sum = 0

while i &lt; 10  do
   i = i + 1
   sum = sum + i
end

puts "The sum of 0..9 values is #{sum}"
</code></pre>


<p>这个例子计算了一个范围数的和。</p>


<p>while循环有三部分：初始化、测试和更新。每次执行语句称为周期。</p>


<pre><code>i = 0
sum = 0
</code></pre>


<p>初始化变量<em>i</em>和<em>sum</em>。<em>i</em>用于计数。</p>


<pre><code>while i &lt; 10  do
   ...
end
</code></pre>


<p><em>while</em>和<em>do</em>之间的表达式是第二阶段，测试。注意<em>do</em>关键字是可选的。，内部的语句将会执行直到表达式的值为假。</p>


<pre><code>i = i + 1
</code></pre>


<p>这是循环的第三阶段——更新。我们增加计数值。注意不当的处理会导致死循环。</p>


<p>$ ./while.rb <br>
The sum of 0..9 values is 55  </p>


<p>This is the output of the example. </p>


<hr>


<p>当条件为假时<em>until</em>控制流语句将执行。当条件为真时循环停止。</p>


<pre><code>#!/usr/bin/ruby

hours_left = 12

until hours_left == 0

    if hours_left == 1
        puts "There is #{hours_left} hour left"
    else
        puts "There are #{hours_left} hours left"
    end

    hours_left -= 1
end
</code></pre>


<p>这个例子中创建了一个变量<em>hours_left</em>。我们开始计数，每次循环打印还有几个小时。当变量值等于0时循环停止。</p>


<p>$ ./until.rb <br>
There are 12 hours left<br>
There are 11 hours left<br>
There are 10 hours left<br>
There are 9 hours left<br>
There are 8 hours left<br>
There are 7 hours left<br>
There are 6 hours left<br>
There are 5 hours left<br>
There are 4 hours left<br>
There are 3 hours left<br>
There are 2 hours left<br>
There is 1 hour left  </p>


<p>程序运行的结果。</p>


<h2>for语句</h2>


<p>当循环次数是已知时，我们可以使用<em>for</em>语句。<em>for</em>循环使用<em>in</em>接着一个范围。对这个范围的每个元素都执行代码块的语句。这些语句使用<em>end</em>关键字闭合。<em>do</em>关键字是可选的。</p>


<pre><code>#!/usr/bin/ruby

for i in 0..9 do

    puts "#{i}"
end
</code></pre>


<p>这个例子中我们打印了0到9的数。每次循环<em>i</em>变量保存了这个范围的一个数，这个数将在终端上打印。</p>


<p>$ ./forloop.rb <br>
0<br>
1<br>
2<br>
3<br>
4<br>
5<br>
6<br>
7<br>
8<br>
9  </p>


<p>例子运行结果。</p>


<hr>


<p>要遍历一个数组的元素可以使用数组的<em>length</em>方法。</p>


<pre><code>#!/usr/bin/ruby

planets = ["Mercury", "Venus", "Earth", "Mars", "Jupiter",
    "Saturn", "Uranus", "Neptune"]

for i in 0...planets.length

    puts planets[i]
end
</code></pre>


<p>这个例子中我们创建了一个数组<em>planets</em>，我们遍历这个数组打印这个数组的每个元素。</p>


<pre><code>planets = ["Mercury", "Venus", "Earth", "Mars", "Jupiter",
    "Saturn", "Uranus", "Neptune"]
</code></pre>


<p><em>planets</em>数组。</p>


<pre><code>for i in 0...planets.length
</code></pre>


<p><em>length</em>方法返回数组的长度。数组从0开始，最后一个索引是n-1。</p>


<pre><code>puts planets[i]
</code></pre>


<p>打印数组指定的一个元素。</p>


<p>$ ./planets2.rb <br>
Mercury<br>
Venus<br>
Earth<br>
Mars<br>
Jupiter<br>
Saturn<br>
Uranus<br>
Neptune  </p>


<p>程序的运行结果。</p>


<h2>each方法</h2>


<p>在Ruby中我们可以使用<em>each</em>方法遍历数组的每个元素。它接受两个参数。一个元素和一个代码块。元素放在管道之间，它保存了当前循环的数据项。代码块是每次要执行的内容。</p>


<pre><code>#!/usr/bin/ruby

planets = ["Mercury", "Venus", "Earth", "Mars", "Jupiter",
    "Saturn", "Uranus", "Neptune"]

planets.each do |planet|

    puts planet
end
</code></pre>


<p>这个例子我们使用<em>each</em>迭代器遍历<em>planets</em>数组。</p>


<pre><code>planets.each do |planet|

    puts planet
end
</code></pre>


<p><em>each</em>迭代器是<em>planets</em>数组的一个方法。<em>planet</em>保存了此次迭代的数据项。我们可以使用任何我们想使用的字符。我们可以使用{}代替<em>do</em>和<em>end</em>关键字。</p>


<h2>break、next语句</h2>


<p><em>break</em>语句用于终止<em>while</em>、<em>for</em>或者<em>case</em>的代码块语句。</p>


<pre><code>#!/usr/bin/ruby

while true

    r = 1 + rand(30)
    print "#{r} "

    if r == 22
        break
    end
end

puts
</code></pre>


<p>我们定义了一个无限循环，使用<em>break</em>语句退出这个循环。我们选择1到30的数，打印它。如果等于22则结束<em>while</em>循环。</p>


<pre><code>while true
   ...
end
</code></pre>


<p>这是一个无限循环，<em>while</em>的条件总是为真。退出无限循环的唯一方法是使用<em>break</em>。</p>


<pre><code>r = 1 + rand(30)
print "#{r} "
</code></pre>


<p>计算从1到30的随机数，并将其打印。</p>


<pre><code>if r == 22
    break
end
</code></pre>


<p>如果数等于22,结束循环。</p>


<p>$ ./break.rb <br>
20 14 6 26 30 12 2 10 18 29 28 11 30 26 20 22   </p>


<p>可能的输出结果。</p>


<hr>


<p><em>next</em>语句用于跳过此次循环，继续下次循环。它可与<em>for</em>和<em>while</em>联合使用。</p>


<p>接下来的例子我们打印不能被2整除的数一列表。</p>


<pre><code>#!/usr/bin/ruby

num = 0

while num &lt; 100

    num += 1

    if (num % 2 == 0)
        next
    end

    print "#{num} " 
end

puts
</code></pre>


<p>我们使用<em>while</em>循环迭代1到99的数。</p>


<pre><code>if (num % 2 == 0)
    next
end
</code></pre>


<p>如果这个数可以被2整除，<em>next</em>语句将执行，循环的其余将跳过。</p>


<p>$ ./next.rb <br>
1 3 5 7 9 11 13 15 17 19 21 23 25 27 29 31 33 35 37 39 <br>
41 43 45 47 49 51 53 55 57 59 61 63 65 67 69 71 73 75 77 <br>
79 81 83 85 87 89 91 93 95 97 99   </p>


<p>程序的输出结果。</p>


<h2>redo语句</h2>


<p><em>redo</em>语句重新开始循环而不检查循环的条件式。下面的例子有点复杂，它展示了<em>redo</em>语句和其它的一些特性。</p>


<pre><code>#!/usr/bin/ruby

options = ["rock", "scissors", "paper"]

while true

    print &lt;&lt;TEXT
1 - rock
2 - scissors
3 - paper
9 - end game
TEXT

    val = gets.to_i

    r = rand(3) + 1

    if val == 9 
        puts "End"
        exit
    end

    if ![1, 2, 3, 9].include?(val)
        puts "Invalid option"
        redo
    end

    computer = options[r-1]
    human = options[val-1]

    puts "I have #{computer}, you have #{human}"

    if val == r
        puts "Tie, next throw"
        redo
    end


    if val == 1 and r == 2
        puts "Rock blunts scissors, you win"

    elsif val == 2 and r == 1
        puts "Rock blunts scissors, you loose"

    elsif val == 2 and r == 3
        puts "Scissors cut paper, you win"

    elsif val == 3 and r == 2
        puts "Scissors cut paper, you loose"

    elsif val == 3 and r == 1
        puts "Paper covers rock, you win"

    elsif val == 1 and r == 3
        puts "Paper covers rock, you loose"

    end    
end
</code></pre>


<p>这是一个简单的Rock-paper-scissors游戏。这个例子中我们用到了<em>redo</em>语句、条件式、随机数、数组和输入。</p>


<pre><code>options = ["rock", "scissors", "paper"]
</code></pre>


<p>定义了游戏可能用到的选项数组。这三个词在打印消息时会用到。</p>


<pre><code>    print &lt;&lt;TEXT
1 - rock
2 - scissors
3 - paper
9 - end game
TEXT
</code></pre>


<p>使用定界符在终端上打印一个菜单。菜单在每次游戏循环时都打印。</p>


<pre><code>val = gets.to_i

r = rand(3) + 1
</code></pre>


<p>这几行代码从终端输入一个值，然后选择一个1、2、3的随机数。</p>


<pre><code>if val == 9 
    puts "End"
    exit
end
</code></pre>


<p>如果输入为9，打印&#8217;End&#8217;并退出程序。</p>


<pre><code>if ![1, 2, 3, 9].include?(val)
    puts "Invalid option"
    redo
end
</code></pre>


<p>如果用户选择了一个不是菜单的值，我们提示无效选项并重新循环。</p>


<pre><code>computer = options[r-1]
human = options[val-1]

puts "I have #{computer}, you have #{human}"
</code></pre>


<p>将数字转化为字符串，并同时打印用户的选择和计算机的选择。</p>


<pre><code>if val == r
    puts "Tie, next throw"
    redo
end
</code></pre>


<p>如果选择相同则是平局，开始新的游戏循环。</p>


<pre><code>if val == 1 and r == 2
    puts "Rock blunts scissors, you win"

elsif val == 2 and r == 1
    puts "Rock blunts scissors, you loose"
...
</code></pre>


<p>使用多个<em>if</em>、<em>elsif</em>分支，比较用户和计算机的选择以决定谁是赢家。</p>


<p>$ ./redo.rb <br>
1 - rock<br>
2 - scissors<br>
3 - paper<br>
9 - end game<br>
3<br>
I have paper, you have paper<br>
Tie, next throw<br>
1 - rock<br>
2 - scissors<br>
3 - paper<br>
9 - end game<br>
2<br>
I have rock, you have scissors<br>
Rock blunts scissors, you loose<br>
1 - rock<br>
2 - scissors<br>
3 - paper<br>
9 - end game<br>
1<br>
I have scissors, you have rock<br>
Rock blunts scissors, you win<br>
1 - rock<br>
2 - scissors<br>
3 - paper<br>
9 - end game<br>
9<br>
End  </p>


<p>程序输出结果。</p>


<p>这部分的Ruby教程我们谈论了结构控制流。</p>


<hr>


<p>原文地址： <a href="http://zetcode.com/lang/rubytutorial/flowcontrol/">http://zetcode.com/lang/rubytutorial/flowcontrol/</a><br>
翻译：龙昌  admin@longchangjin.cn<br>
完整教程：<a href="https://github.com/wusuopu/Ruby-tutorial">https://github.com/wusuopu/Ruby-tutorial</a> </p>

</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
    <h1 class="entry-title"><a href="http://www.xefan.com/archives/83926.html">[翻译]Ruby教程8——表达式</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2013-11-10T00:00:00+08:00'><span class='date'><span class='date-month'>Nov</span> <span class='date-day'>10</span><span class='date-suffix'>th</span>, <span class='date-year'>2013</span></span> <span class='time'>12:00 am</span></time>
        
           | <a href="http://www.xefan.com/archives/83926.html#disqus_thread"
             data-disqus-identifier="http://www.xefan.com/archives/83926.html">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><h1>表达式</h1>


<p>在这章的教程将介绍Ruby的表达式。</p>


<p>表达式是由操作数和操作符构成的。表达式的操作符表明了对操作数应用什么操作。表达式中操作符的求值顺序由操作符的优先级和结合律决定的。</p>


<p>操作符是一个特殊的符号表明了要执行的确切操作。编程语言中的操作符取自数学运算。程序员使用数据，操作符用于处理数据。操作数是操作符的参数。</p>


<p>以下表格中按优先级展示Ruby的操作符（高优先级在前）：</p>


<table>
    <thead>
        <tr>
            <td>分类</td>
            <td>符号</td>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td>解析，访问操作符</td>
            <td>:: .</td>
        </tr>
        <tr>
            <td>数组操作符</td>
            <td>[] []=</td>
        </tr>
        <tr>
            <td>求幂</td>
            <td>**</td>
        </tr>
        <tr>
            <td>非，反，一元加、减</td>
            <td>! ~ + -</td>
        </tr>
        <tr>
            <td>乘、除、模</td>
            <td>* / %</td>
        </tr>
        <tr>
            <td>加、减</td>
            <td>+ -</td>
        </tr>
        <tr>
            <td>移位</td>
            <td><< >></td>
        </tr>
        <tr>
            <td>位与</td>
            <td>&</td>
        </tr>
        <tr>
            <td>位或、逻辑或</td>
            <td>^ |</td>
        </tr>
        <tr>
            <td>关系运算</td>
            <td>> >= < <=</td>
        </tr>
        <tr>
            <td>相等、模式匹配</td>
            <td><=> == === != =~ !~</td>
        </tr>
        <tr>
            <td>逻辑与</td>
            <td>&&</td>
        </tr>
        <tr>
            <td>逻辑或</td>
            <td>||</td>
        </tr>
        <tr>
            <td>范围操作符</td>
            <td>.. &#8230;</td>
        </tr>
        <tr>
            <td>三目运算</td>
            <td>?:</td>
        </tr>
        <tr>
            <td>分配操作</td>
            <td>= += -= *= **= /= %= &= |= ^= <<= >>= ||= &&=</td>
        </tr>
        <tr>
            <td>否定</td>
            <td>not</td>
        </tr>
        <tr>
            <td>逻辑或、与</td>
            <td>or and</td>
        </tr>
    </tbody>
</table>




<p>同一行的操作符具有相同的优先级。</p>


<p>一个操作符通常有两个操作数。那些只有一个操作数的操作符称为一元操作符。有两个操作数的称为二元操作符。有一个三元操作符(?:)有三个操作数。</p>


<p>操作符可能用于不同的上下文。例如+操作符，从上面的表格可知它能用于不同情况。数字求和、连接字符串、作为数字的符号。我们称这个操作符被重载了。</p>


<h2>正负号操作符</h2>


<p>有两个正负号操作符，+和-，用于指定或者修改值的符号。</p>


<pre><code>#!/usr/bin/ruby

puts +2
puts -2
</code></pre>


<p>+和-指明了值的符号。加号表明是正数，通常可省略。</p>


<hr>


<p>接下来的例子我们使用减号。</p>


<pre><code>#!/usr/bin/ruby

a = 1

puts a
puts -(a)
puts -(-(a))
</code></pre>


<p>减号改变了值的符号。</p>


<p>$ ./sign.rb<br>
1<br>
-1<br>
1  </p>


<p>输出结果。</p>


<h2>分配操作符</h2>


<p>分配操作符<em>=</em>将一个值分配给一个变量。变量是这个值的点位符。数学运算中<em>=</em>操作符有不同的意义。在方程式中<em>=</em>是相等操作，左边的值等于右边的值。</p>


<pre><code>x = 1
puts x # prints 1
</code></pre>


<p>这里分配的一个数字给<em>x</em>变量。</p>


<pre><code>x = x + 1
puts x # prints 2
</code></pre>


<p>前一个表达式中数学运算中是行不通的。但是在程序中是合法的。这个表达式是将<em>x</em>变量加1，右边等于2,并把2赋值给x。</p>


<pre><code>3 = x;
</code></pre>


<p>这个语法是错误的，我们不能组值分配字面符。</p>


<h2>解析，成员访问操作符</h2>


<p>有两个操作符具有最高的优先级，这意味着它们总是先求解。</p>


<pre><code>#!/usr/bin/ruby

class MyMath
    Pi = 3.1415926535    
end

module People
    Name = "People"
end

puts MyMath::Pi
puts People::Name
</code></pre>


<p>第一个例子展示了<em>::</em>命名空间解析操作符。它可以访问一个定义在其它类或模块里的常量、模块或者类。它用于提供命名空间，这样方法和类的名字就不会与其他作者的类冲突了。</p>


<pre><code>class MyMath
    Pi = 3.1415926535    
end

module People
    Name = "People"
end
</code></pre>


<p>这里创建了一个模块的一个类，分别定义了一个常量。</p>


<pre><code>puts MyMath::Pi
puts People::Name
</code></pre>


<p>我们使用<em>::</em>操作符访问它们的常量。</p>


<p>$ ./resolution.rb<br>
3.1415926535<br>
People  </p>


<p><em>resolution.rb</em>脚本的输出结果。</p>


<hr>


<p>点(.)操作符是成员访问，用于调用对象的方法。</p>


<pre><code>#!/usr/bin/ruby

class Person

   def initialize name, age
       @name = name
       @age = age       
   end

   def info
       "#{@name} is #{@age} years old"
   end

end

p = Person.new "Jane", 17
puts p.info

puts "ZetCode".reverse
</code></pre>


<p>这个例子中我们创建了两个对象，一个是用户定义的，一个是预定义的。我们对这些对象使用点操作符。</p>


<pre><code>p = Person.new "Jane", 17
puts p.info
</code></pre>


<p>在这行使用点操作符调用了两个方法：new和info。</p>


<pre><code>puts "ZetCode".reverse
</code></pre>


<p>字符串是内建对象，具有一个<em>reverse</em>方法。</p>


<p>$ ./memberaccess.rb<br>
Jane is 17 years old<br>
edoCteZ  </p>


<p>输出结果。</p>


<h2>字符串连接</h2>


<p>Ruby中<em>+</em>操作符同样可以用于字符串连接。在不同上下文中操作符作用不同，我们称这个为重载。</p>


<pre><code>#!/usr/bin/ruby

puts "Return " + "of " + "the " + "King"
puts "Return ".+"of ".+ "the ".+"King"
</code></pre>


<p>我们将三个字符串连接在一起。</p>


<pre><code>puts "Return " + "of " + "the " + "King"
</code></pre>


<p>我们使用<em>+</em>操作符连接字符串。</p>


<pre><code>puts "Return ".+"of ".+ "the ".+"King"
</code></pre>


<p><em>+</em>操作符也是Ruby的一个方法。我们可以使用访问操作符(.)来调用它。</p>


<p>$ ./catstrings.rb <br>
Return of the King<br>
Return of the King  </p>


<p><em>catstrings.rb</em>程序的运行结果。</p>


<h2>增、减操作符</h2>


<p>Ruby中没有如下操作。<br>
x++;<br>
&#8230;<br>
y&#8211;;  </p>


<p>这些是C语言的增、减操作。</p>


<p>如果你熟悉Java、C、C++，你可能了解这些操作符。但是这些在Ruby中无效的。同样在Python中也没有。</p>


<h2>算术操作符</h2>


<p>下面的表格是Ruby中的算术操作符。  </p>


<table>
<thead>
<tr>
<th align="left">符号</th>
<th align="left">名字</th>
</tr>
</thead>
<tbody>
<tr>
<td align="left">+</td>
<td align="left">加</td>
</tr>
<tr>
<td align="left">-</td>
<td align="left">减</td>
</tr>
<tr>
<td align="left">*</td>
<td align="left">乘</td>
</tr>
<tr>
<td align="left">/</td>
<td align="left">除</td>
</tr>
<tr>
<td align="left">%</td>
<td align="left">模</td>
</tr>
<tr>
<td align="left">**</td>
<td align="left">幂</td>
</tr>
</tbody>
</table>


<p>下面的例子中我们使用了算术操作符。</p>


<pre><code>#!/usr/bin/ruby

a = 10
b = 11
c = 12

puts a + b + c
puts c - a
puts a * b
puts c / 3
puts c % a
puts c ** a
</code></pre>


<p>在前面的例子我们使用了加、减、乘、除和取余操作。这些与数学上的是相同的。</p>


<pre><code>puts c % a
</code></pre>


<p><em>%</em>操作符是取余或者求模。</p>


<p>$ ./arithmetic.rb<br>
33<br>
2<br>
110<br>
4<br>
2<br>
61917364224  </p>


<p>输出结果。</p>


<hr>


<p>接下来展示整数和浮点数除法的区别。</p>


<pre><code>#!/usr/bin/ruby

puts 5 / 2

puts 5 / 2.0
puts 5.0 / 2
puts 5.to_f / 2
</code></pre>


<p>上面的例子我们将两个数相除。</p>


<pre><code>puts 5 / 2
</code></pre>


<p>这个表达式中的操作数都是整数，我们进行的是整数相除。结果返回的也是整数。</p>


<pre><code>puts 5 / 2.0
puts 5.0 / 2
puts 5.to_f / 2
</code></pre>


<p>如果其中一个或两个是浮点数，我们进行的是浮点数相除。</p>


<p>$ ./division.rb<br>
2<br>
2.5<br>
2.5<br>
2.5  </p>


<p><em>division.rb</em>程序的运行结果。</p>


<hr>


<p>Ruby有其他方式进行除运算。这些都是有效的方法调用。</p>


<pre><code>#!/usr/bin/ruby

puts 5.div 2.0
puts 5.fdiv 2
puts 5.quo 2
puts 5.0.quo 2.0
</code></pre>


<p>上面例子中我们使用了<em>div</em>、<em>fdiv</em>和<em>quo</em>方法。</p>


<pre><code>puts 5.div 2.0
</code></pre>


<p><em>div</em>总是进行整数除，即使操作数是浮点数。</p>


<pre><code>puts 5.fdiv 2
</code></pre>


<p><em>fdiv</em>总是进行浮点数除法。</p>


<pre><code>puts 5.quo 2
puts 5.0.quo 2.0
</code></pre>


<p><em>quo</em>方法进行精确的除法。如果操作数是浮点数则返回浮点数，否则是有理数。</p>


<p>$ ./otherdivision.rb<br>
2<br>
2.5<br>
5/2<br>
2.5  </p>


<h2>布尔操作符</h2>


<p>Ruby中有以下布尔操作符。</p>


<table>
    <thead>
        <tr>
            <td>符号</td>
            <td>名字</td>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td>&&</td>
            <td>逻辑与</td>
        </tr>
        <tr>
            <td>||</td>
            <td>逻辑或</td>
        </tr>
        <tr>
            <td>!</td>
            <td>否</td>
        </tr>
    </tbody>
</table>




<p>布尔操作符处理真假值。Ruby中有额外的布尔操作符，<em>and</em>、<em>or</em>、<em>&amp;</em>、<em>not</em>。它们操作是相同的，只是优先级低一些。与Perl语言不同，这需要一个低优先级的布尔操作符。</p>


<pre><code>#!/usr/bin/ruby

x = 3
y = 8

puts x == y
puts y &gt; x

if y &gt; x then
    puts "y is greater than x"
end
</code></pre>


<p>许多表达式的结果都是一个布尔值。布尔值用于条件语句。</p>


<pre><code>puts x == y
puts y &gt; x
</code></pre>


<p>返回布尔值的相关操作符。这两行打印为false和true。</p>


<pre><code>if y &gt; x then
    puts "y is greater than x"
end
</code></pre>


<p>仅当月<em>if</em>条件为真时<em>if</em>里的语句才会执行。x &gt; y返回true，因此&#8221;y is greater than x&#8221;会在终端上打印。</p>


<hr>


<p>下面的例子展示逻辑与操作符。</p>


<pre><code>#!/usr/bin/ruby

puts true &amp;&amp; true
puts true &amp;&amp; false
puts false &amp;&amp; true
puts false &amp;&amp; false
</code></pre>


<p>与操作只有在操作数都为true才返回true。</p>


<p>$ ./andoperator.rb<br>
true<br>
false<br>
false<br>
false  </p>


<p>只有一个表达式的结果为true。</p>


<hr>


<p>逻辑或操作符当有一个操作数为true则返回true。</p>


<pre><code>#!/usr/bin/ruby

puts true || true
puts true || false
puts false || true
puts false || false
</code></pre>


<p>如果有一边是true，操作的结果就是true。</p>


<p>$ ./oroperator.rb<br>
true<br>
true<br>
true<br>
false  </p>


<p>三个表达式结果为true。</p>


<hr>


<p>非操作进行真假反转。</p>


<pre><code>#!/usr/bin/ruby

puts !0
puts !1
puts !true
puts !false

puts ! (4&lt;3)
puts ! "Ruby".include?("a")
</code></pre>


<p>这个例子展示了非操作符的用法。</p>


<p>$ ./not.rb<br>
false<br>
false<br>
false<br>
true<br>
true<br>
true  </p>


<p>输出结果。</p>


<hr>


<p><em>||</em>和<em>&amp;&amp;</em>操作符是短路求值（short circuit evaluated）。短路求值意味着只有在第一个参数不足以确定表达式的值时第二个参数才会进行求值。短求值主要用于提高执行效率。</p>


<p>用一个例子解释。</p>


<pre><code>#!/usr/bin/ruby

def one
    puts "Inside one"
    false
end

def two
    puts "Inside two"
    true
end

puts "Short circuit"

if one &amp;&amp; two
    puts "Pass"
end

puts "##############################"

if two || one
    puts "Pass"
end
</code></pre>


<p>在例子中定义了两个方法，用于在布尔操作中作为操作数。我们将看到它们是否被调用了。</p>


<pre><code>if one &amp;&amp; two
    puts "Pass"
end
</code></pre>


<p>第一个方法返回false，短路求值不会计算第二个方法。一旦一个操作数是false，那么这个逻辑的结果总是false。</p>


<pre><code>puts "##############################"

if two || one
    puts "Pass"
end
</code></pre>


<p>第二种情况我们使用<em>||</em>操作符，并且第一个操作数为<em>tow</em>方法。这里同样没有必要对第二个操作数求值，只要第一个操作数为true，那么逻辑或总是为true。</p>


<pre><code>$ ./shortcircuit.rb
Short circuit
Inside one
##############################
Inside two
Pass
</code></pre>


<p><em>shortcircuit.rb</em>程序的运行结果。</p>


<h2>关系操作符</h2>


<p>关系操作符用于值的比较，其总是返回布尔值。</p>


<table>
<thead>
<tr>
<th align="left">符号</th>
<th align="left">含义</th>
</tr>
</thead>
<tbody>
<tr>
<td align="left">&lt;</td>
<td align="left">小于</td>
</tr>
<tr>
<td align="left">&lt;=</td>
<td align="left">小于等于</td>
</tr>
<tr>
<td align="left">&gt;</td>
<td align="left">大于</td>
</tr>
<tr>
<td align="left">&gt;=</td>
<td align="left">大于等于</td>
</tr>
</tbody>
</table>


<p>关系操作符又称为比较操作符。</p>


<pre><code>#!/usr/bin/ruby

p 3 &lt; 4
p 3 &gt; 5
p 3 &gt;= 3
</code></pre>


<p>表达式<em>3 &lt; 4</em>返回true，因为3小于4。表达式<em>3 &gt; 5</em>返回false，因为3不大于5。</p>


<h2>位操作符</h2>


<p>人类用的是十进制数字，计算机原生的是二进制数。二进制、八进制、十进制和十六进制只是数字的符号。位操作符针对的是二进制数。</p>


<table>
    <thead>
        <tr>
            <td>符号</td>
            <td>含义</td>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td>~</td>
            <td>按位取反</td>
        </tr>
        <tr>
            <td>^</td>
            <td>按位异或</td>
        </tr>
        <tr>
            <td>&</td>
            <td>按位与</td>
        </tr>
        <tr>
            <td>|</td>
            <td>按位与或</td>
        </tr>
        <tr>
            <td>&lt;&lt;</td>
            <td>左移位</td>
        </tr>
        <tr>
            <td>&gt;&gt;</td>
            <td>右移位</td>
        </tr>
    </tbody>
</table>




<p>位操作在高级语言中很少使用。</p>


<pre><code>#!/usr/bin/ruby

puts ~ 7   # prints -8 
puts ~ -8  # prints 7

puts 6 &amp; 3  # prints 2
puts 3 &amp; 6  # prints 2

puts 6 ^ 3  # prints 5
puts 3 ^ 6  # prints 5

puts 6 | 3  # prints 7
puts 3 | 6  # prints 7

puts 6 &lt;&lt; 1  # prints 12
puts 1 &lt;&lt; 6  # prints 64

puts 6 &gt;&gt; 1  # prints 3
puts 1 &gt;&gt; 6  # prints 0
</code></pre>


<p>上面的例子中展示了这6个位操作符。</p>


<pre><code>puts ~ 7   # prints -8 
puts ~ -8  # prints 7
</code></pre>


<p>按位取反是将1变为0，0变为1。将操作会将数字7所有的位都反转，同样包括符号位。如果再次反转所有的位即会得到数字7。</p>


<pre><code>puts 6 &amp; 3  # prints 2
puts 3 &amp; 6  # prints 2
</code></pre>


<p>按位与是将两个数进行逐位与操作，只有两个数对应位的都为1结果才为1。</p>


<pre><code>puts 6 ^ 3  # prints 5
puts 3 ^ 6  # prints 5
</code></pre>


<p>按位异或是将两个数进行逐位异或操作，只要其中一个数（但不是全部）对应位的为1结果就为1。</p>


<pre><code>puts 6 | 3  # prints 7
puts 3 | 6  # prints 7
</code></pre>


<p>按位或是将两个数进行逐位或操作，只要其中一个数对应位的为1结果就为1。</p>


<pre><code>puts 6 &lt;&lt; 1  # prints 12
puts 1 &lt;&lt; 6  # prints 64

puts 6 &gt;&gt; 1  # prints 3
puts 1 &gt;&gt; 6  # prints 0
</code></pre>


<p>移位操作符是按位进行右移或左移，也称为算术移位。</p>


<h2>复合分配操作符</h2>


<p>复合分配操作符是由两个操作符构成。它们是简写操作符。</p>


<pre><code>#!/usr/bin/ruby

a = 0

a = a + 1
a += 1
puts a


b = 0

b = b - 8
b -= 8
puts b
</code></pre>


<p><em>+=</em>和<em>-=</em>操作符是一个简写的操作符。它们的可读性没有全写的好，但是有经验的程序员经常使用它们。</p>


<pre><code>a = a + 1
a += 1
</code></pre>


<p>这两行的操作是一样的，都是将变量<em>a</em>加1。</p>


<p>其他的一些复合操作符。</p>


<pre><code>-=   *=  **=  /=   %=   &amp;=   |=   &lt;&lt;=   &gt;&gt;=
</code></pre>


<h2>操作符优先级</h2>


<p>操作符的优先级表明了先对哪个操作符进行求值。优先级避免了表达式的二义性。</p>


<p>这个表达式的结果是多少？28还是40？</p>


<p>3 + 5 * 5  </p>


<p>跟数学相同，乘法优先级高于加法，加些结果为28。</p>


<p>(3 + 5) * 5  </p>


<p>我们可以使用括号来改变优先级。括号里的表达式总是最先求值。</p>


<pre><code>#!/usr/bin/ruby

puts 3 + 5 * 5
puts (3 + 5) * 5

puts ! true | true
puts ! (true | true)
</code></pre>


<p>这个例子展示了一些表达式，其结果依赖于操作符优先级。</p>


<pre><code>puts 3 + 5 * 5
</code></pre>


<p>这行打印28，因为乘法操作优先级高于加法。</p>


<pre><code>puts ! true | true
</code></pre>


<p>这里非操作优先级更高。最后返回为true。</p>


<p>$ ./precedence.rb<br>
28<br>
40<br>
true<br>
false  </p>


<h2>结合律</h2>


<p>有时优先级不能决定表达式的结果。还有另一条规则称为结合律。它决定相同优先级的求值顺序。</p>


<p>9 / 3 * 3  </p>


<p>这个的结果是多少？9还是1？乘、除和取模操作是从左到右结合的。因此结果为9。</p>


<p>数学运算、布尔、关系和位操作都是从左向右结合的。</p>


<p>另外赋值操作是右结合。</p>


<pre><code>a = b = c = d = 0
print a, b, c, d # prints 0000
</code></pre>


<p>复合分配操作是从右向左结合的。</p>


<pre><code>j = 0
j *= 3 + 1
puts j
</code></pre>


<p>你可能期望结果为1,但是实际上结果为0。由于结合律，右边表达式先求值再应用复合分配操作。</p>


<h2>范围操作符</h2>


<p>Ruby有两个范围操作符，用于创建一个范围对象。通常是数字或者字母的范围。</p>


<p><em>..</em>范围操作符（两个点）创建一个包含的范围。<em>&#8230;</em>操作符（三个点）创建一个非包含的范围，较大的值不包含在其中。</p>


<pre><code>#!/usr/bin/ruby

p (1..3).to_a
p (1...3).to_a

p ('a' .. 'l').to_a
</code></pre>


<p>这个例子中我们使用范围操作符创建了数字范围和字母范围。</p>


<pre><code>p (1..3).to_a
p (1...3).to_a
</code></pre>


<p>这两行都是使用范围操作符创建了两个范围，然后转换为数据。第一个范围的值为1,2,3；第二个为1和2.</p>


<pre><code>p ('a' .. 'l').to_a
</code></pre>


<p>这里使用<em>..</em>操作符创建一个&#8217;a&#8217;到&#8217;l&#8217;的数组。</p>


<p>$ ./range.rb<br>
[1, 2, 3]<br>
[1, 2]<br>
[&#8220;a&#8221;, &#8220;b&#8221;, &#8220;c&#8221;, &#8220;d&#8221;, &#8220;e&#8221;, &#8220;f&#8221;, &#8220;g&#8221;, &#8220;h&#8221;, &#8220;i&#8221;, &#8220;j&#8221;, &#8220;k&#8221;, &#8220;l&#8221;]  </p>


<p>输出结果。</p>


<h2>三元运算术</h2>


<p>三元运算术是一个条件操作。如果我们需要根据条件表达式从两个值选择一个时这是一个方便的操作。</p>


<p>cond-exp ? exp1 : exp2  </p>


<p>如果<em>cond-exp</em>为真则返回<em>exp1</em>，否则返回<em>exp2</em>。</p>


<pre><code>#!/usr/bin/ruby

age = 32

adult = age &gt;= 18 ? true : false

if adult then
    puts "Adult"
else
    puts "Not adult"
end
</code></pre>


<p>许多国家成年是基于你的年龄。是否成年即为是否超过了一定年龄。这种情况适合于三元操作。</p>


<pre><code>adult = age &gt;= 18 ? true : false
</code></pre>


<p>首先对赋值符右转进行求值，它的值将赋给<em>adult</em>变量。</p>


<p>$ ./ternary.rb<br>
Adult  </p>


<p>32年已经成年了。</p>


<h2>计算素数</h2>


<p>我们将计算素数。</p>


<pre><code>#!/usr/bin/ruby

nums = (4..50).to_a

puts "Prime numbers:"

print "2 3 "

nums.each do |i|

    not_prime = false

    (2..Math.sqrt(i).ceil).each do |j|
        not_prime = true if i % j == 0    
    end

    print i, " " unless not_prime

end

puts
</code></pre>


<p>上面的例子中我们用到了一些操作符。</p>


<pre><code>nums = (4..50).to_a
</code></pre>


<p>我们将从这些数中计算哪些是素数。</p>


<pre><code>print "2 3 "
</code></pre>


<p>我们路过2和3,因为它们都是素数。</p>


<pre><code>not_prime = false
</code></pre>


<p><em>not_prime</em>标志表明选择的数不是素数。我们假设选择的数是素数，直到被证明不是为止。</p>


<pre><code>(2..Math.sqrt(i).ceil).each do |j|
    not_prime = true if i % j == 0    
end
</code></pre>


<p>当取模的结果为0表示这个数不是素数。</p>


<pre><code>print i, " " unless not_prime
</code></pre>


<p>如果<em>not_prime</em>标志没有设置则打印这个数。</p>


<hr>


<p>上面例子展示了一些操作符。实际上有更简单方法计算素数。Ruby中有一个计算素数的模块。</p>


<pre><code>#!/usr/bin/ruby

require 'prime'

Prime.each(50) do |i|
    print i, " "
end

puts
</code></pre>


<p>使用Ruby的<em>prime</em>模块计算素数。</p>


<pre><code>require 'prime'
</code></pre>


<p>导入<em>prime</em>模块。</p>


<pre><code>Prime.each(50) do |i|
    print i, " "
end
</code></pre>


<p>计算到50的素数。</p>


<p>$ ./primes.rb<br>
2 3 5 7 11 13 17 19 23 29 31 37 41 43 47   </p>


<p>结果输出了2到50之间的素数。</p>


<p>这章的教程介绍了表达式。</p>


<hr>


<p>原文地址： <a href="http://zetcode.com/lang/rubytutorial/expressions/">http://zetcode.com/lang/rubytutorial/expressions/</a><br>
翻译：龙昌  admin@longchangjin.cn<br>
完整教程：<a href="https://github.com/wusuopu/Ruby-tutorial">https://github.com/wusuopu/Ruby-tutorial</a>  </p>

</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
    <h1 class="entry-title"><a href="http://www.xefan.com/archives/83921.html">[翻译]Ruby教程7——字符串</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2013-11-08T00:00:00+08:00'><span class='date'><span class='date-month'>Nov</span> <span class='date-day'>8</span><span class='date-suffix'>th</span>, <span class='date-year'>2013</span></span> <span class='time'>12:00 am</span></time>
        
           | <a href="http://www.xefan.com/archives/83921.html#disqus_thread"
             data-disqus-identifier="http://www.xefan.com/archives/83921.html">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><h1>字符串</h1>


<p>在这部分的教程将详细的介绍字符串。</p>


<p>字符串是计算机语言中最重要的数据类型之一，这就是为什么我们决定要用一整章来介绍字符串。</p>


<p>字符串是序列化的unicode字符。它是一种数据类型存储了序列化的值，它的元素通常代表的是根据字符编码的字符。当一个字符串在代码中以字面量出现，它也称为字符串文本。</p>


<h2>第一个例子</h2>


<p>在Ruby中字符串文本是以单引号或者双引号引起来的。</p>


<pre><code>#!/usr/bin/ruby

# first.rb

puts 'Python language'
puts "Ruby language"
</code></pre>


<p>这个例子有两个字符串，第一个是用单引号，另一个是用双引号。</p>


<p>$ ./first.rb <br>
Python language<br>
Ruby language  </p>


<p>程序输出。</p>


<h2>使用引号</h2>


<p>如果我们想要显示引号该怎么做，直接引用？这有两种方法实现。</p>


<pre><code>#!/usr/bin/ruby

puts "There are many stars" 
puts "He said, \"Which one is your favourite?\""

puts 'There are many stars'
puts 'He said, "Which one is your favourite?"'
</code></pre>


<p>我们使用()字符将引号转义。通常双引号是用于划定字符串的范围，然后被转义之后它原始的意义就没有了。它在字符串中被作为一个正常的字符。第二种方法是混合使用单引号和双引号。</p>


<p>$ ./quotes.exe <br>
There are many stars.<br>
He said, &#8220;Which one is your favourite?&#8221;  </p>


<p>输出结果。</p>


<h2>转义序列</h2>


<p>转义符是特殊的字符，在字符串中有特殊的含意。</p>


<pre><code>#!/usr/bin/ruby

puts "one two three four"
puts "one\ntwo\nthree\nfour"
</code></pre>


<p>最常用一个的转义符是换行符\n。它在许多编程语言中都有效。换行符之后的字符将出现在新的一行。</p>


<p>$ ./newline.rb<br>
one two three four<br>
one<br>
two<br>
three<br>
four  </p>


<p>以上脚本的输出结果中换行符之后的字符在新的一行。</p>


<hr>


<p><em>r</em>、<em>b</em>和<em>t</em>是正常的字符，当前面加上\字符后就具有特殊意义了。</p>


<pre><code>#!/usr/bin/ruby

puts "   bbb\raaa" 
puts "Joan\b\b\bane" 
puts "Towering\tinferno"
</code></pre>


<p>这个例子中我们用到了三个不同的转义字符。</p>


<pre><code>puts "   bbb\raaa"
</code></pre>


<p>回车符<em>\r</em>控制之后的字符回到行首。之前打印到终端上的字符串会被处理。这个转义字符会将<em>aaa</em>字符位于<em>bbb</em>之前，输出为<em>aaabbb</em>。</p>


<pre><code>puts "Joan\b\b\bane"
</code></pre>


<p><em>\b</em>是退格控制符，它会删掉前一个字符。这个字符串将在终端上打印<em>&#8216;Jane&#8217;</em>而不是<em>&#8216;Joan&#8217;</em>。</p>


<pre><code>puts "Towering\tinferno"
</code></pre>


<p>最后<em>\t</em>转义符是用于两个词之间制表空格的。</p>


<p>$ ./escapes.rb <br>
aaabbb<br>
Jane<br>
Towering        inferno  </p>


<p>例子的输出结果。</p>


<hr>


<p>反斜杠<em>\</em>是用于创建转义符的特殊字符。当需要打印反斜杠时，则在它前面加上另一个反斜杠。这意味着转义过了可以打印。在Ruby中单引号和双引号用于划定字符串范围的，想要打印它们同样也需要在前面加上<em>\</em>。</p>


<pre><code>#!/usr/bin/ruby

puts "The special character \\"
puts "The special character \'"
puts "The special character \""
</code></pre>


<p>这个例子中我们在终端上打印了这三个字符。</p>


<p>$ ./specials.rb<br>
The special character \ <br>
The special character &#8217;<br>
The special character &#8221;  </p>


<p>输出结果。</p>


<h2>访问字符串的元素</h2>


<p>在Ruby中我们可以使用方括号<em>[]</em>来访问字符串的元素。在括号内可以使用字符串、范围索引。</p>


<pre><code>#!/usr/bin/ruby

msg = "Ruby language"

puts msg["Ruby"]
puts msg["Python"]

puts msg[0]
puts msg[-1]

puts msg[0, 3]
puts msg[0..9]
puts msg[0, msg.length]
</code></pre>


<p>这个例子的代码展示了我们可以访问字符串的一部分。</p>


<pre><code>msg = "Ruby language"
</code></pre>


<p>这里是我们将要访问的字符串。</p>


<pre><code>puts msg["Ruby"]
</code></pre>


<p>这行代码我们测试字符串<em>&#8216;Ruby&#8217;</em>是否是<em>msg</em>的子串。如果是将返回该字符串。</p>


<pre><code>puts msg[0]
</code></pre>


<p>可以通过索引来访问这个字符串的字符。编号是从0开始的，也就是说0号索引是第1个字符。<em>msg[0]</em>返回字符串的第一个字符<em>R</em>。</p>


<pre><code>puts msg[-1]
</code></pre>


<p>这里我们访问最后一个字符。-1代表了最后一个索引。</p>


<pre><code>puts msg[0, 3]
</code></pre>


<p>两个用逗号分隔的索引返回了从第1个索引开始到第2个索引的字符，不包括第2个索引。</p>


<pre><code>puts msg[0..9]
</code></pre>


<p>范围操作符也可以完成同样操作。这里我们打印前10个字符。</p>


<pre><code>puts msg[0, msg.length]
</code></pre>


<p>这行返回全部的字符。<em>msg.length</em>返回字符串的长度。</p>


<p>$ ./access.rb<br>
Ruby  </p>


<p>R<br>
e<br>
Rub<br>
Ruby langu<br>
Ruby language  </p>


<p>输出结果。</p>


<h2>多行字符串</h2>


<p>许多编程语言要创建多行字符串需要额外的努力，在Visual Basic中尤其如此。但是在Ruby中却是很容易。</p>


<pre><code>#!/usr/bin/ruby

puts "I hear Mariachi static on my radio 
And the tubes they glow in the dark 
And I'm there with her in Ensenada 
And I'm here in Echo Park
"

puts %/
Carmelita hold me tighter
I think I'm sinking down 
And I'm all strung out on heroin
On the outskirts of town/

puts &lt;&lt;STRING

Well, I'm sittin' here playing solitaire
With my pearl-handled deck 
The county won't give me no more methadone 
And they cut off your welfare check
STRING
</code></pre>


<p>这个例子中我们使用了Carmelita歌曲的歌词。我们展示了使用三种方法打印多行字符串。可以使用双引号；可以使用%字符创建多行字符串，用%后面的字符将字符串包围住；最后我们使用定界符，这和语法是使用<em>&lt;&lt;</em>接着一些字符串，用这个字符串包围住多行字符。它必须左对齐。</p>


<h2>变量替换</h2>


<p>变量替换是将字符串的变量替换成它们的值。为了将变量替换成值，这个变量在字符串需要放在<em>#{</em>和<em>}</em>之间。</p>


<pre><code>#!/usr/bin/ruby

name = "Jane"
age = 17

puts "#{name} is #{age} years old"
</code></pre>


<p>这个例子中我们替换了字符串中的两个变量：<em>name</em>和<em>age</em>。</p>


<p>$ ./interpolation.rb <br>
Jane is 17 years old  </p>


<hr>


<p>也可以替换表达式。</p>


<pre><code>#!/usr/bin/ruby

x = 5
y = 6

puts "The product of #{x} and #{y} is #{x*y}"
</code></pre>


<p>这是一个表达式替换的例子。</p>


<p>$ ./interpolation2.rb<br>
The product of 5 and 6 is 30  </p>


<p>运行例子脚本。</p>


<hr>


<p>这是另一种替换变量的方法。类似于Python 2.x所支持的替换。</p>


<pre><code>#!/usr/bin/ruby

name = "Jane"
age = 17

message = "%s is %d years old" % [name, age]
puts message
</code></pre>


<p>以上是一个例子。</p>


<pre><code>message = "%s is %d years old" % [name, age]
</code></pre>


<p>使用之前先创建一个字符串。<em>%s</em>和<em>%d</em>是格式化字符，分别表示字符串和数字。值由%字符后面的方括号提供。</p>


<h2>字符串连接</h2>


<p>字符串连接是从多个字符串创建一个字符串。</p>


<pre><code>#!/usr/bin/ruby

lang = "Ruby" + " programming" + " languge"
puts lang

lang = "Python" " programming" " language"
puts lang

lang = "Perl" &lt;&lt; " programming" &lt;&lt; " language"
puts lang

lang = "Java".concat(" programming").concat(" language")
puts lang
</code></pre>


<p>Ruby提供多种方法连接字符串。</p>


<pre><code>lang = "Ruby" + " programming" + " languge"
</code></pre>


<p>在计算机语言中加法操作符是最常用的一种。Perl和PHP是用的点操作符(.)。</p>


<pre><code>lang = "Python" " programming" " language"
</code></pre>


<p>Ruby自动连接多个后续的字符串。</p>


<pre><code>lang = "Perl" &lt;&lt; " programming" &lt;&lt; " language"
</code></pre>


<p>另一种方法是使用<em>&lt;&lt;</em>操作符。</p>


<pre><code>lang = "Java".concat(" programming").concat(" language")
</code></pre>


<p>每个字符串字面符实际上都是一个对象。我们可以对Ruby对象调用很多方法。对于字符串对象可以调用<em>concat</em>方法连接两个字符串。它返回最后的结果对象，再对其调用另一个方法。这样我们就将这些方法链接起来了。</p>


<p>$ ./concatenate.rb<br>
Ruby programming languge<br>
Python programming language<br>
Perl programming language<br>
Java programming language  </p>


<p>输出结果。</p>


<h2>冻结字符串</h2>


<p>在Java或者C#中字符串是不可变的，这意味着不能修改已存在的字符串。只能通过已存在的字符串创建一个新的。在Ruby中字符串同样也是不可修改的。</p>


<p>Ruby中字符串对象有一个<em>freeze</em>方法，可以使它们不可变。</p>


<pre><code>#!/usr/bin/ruby

msg = "Jane"
msg &lt;&lt; " is " 
msg &lt;&lt; "17 years old"

puts msg

msg.freeze

#msg &lt;&lt; "and she is pretty"
</code></pre>


<p>这个例子我们演示了字符串是可变的。然后在调用<em>freeze</em>方法之后我们就不能再作修改了。如果我们取消掉注释将会得到&#8217;can&#8217;t modify frozen string&#8217;错误信息。</p>


<h2>字符串比较</h2>


<p>在编程中字符串比较是件平常的事情。我们可以使用<em>==</em>操作符或者<em>eql?</em>方法来比较两个字符串，如果相等返回<em>true</em>，否则<em>false</em>。</p>


<pre><code>#!/usr/bin/ruby

puts "12" == "12"
puts "17" == "9"
puts "aa" == "ab"

puts "Jane".eql? "Jan"
puts "Jane".eql? "Jane"
</code></pre>


<p>这个例子的代码我们比较了一些字符串。</p>


<pre><code>puts "12" == "12"
</code></pre>


<p>这两个是相等的，这行返回true。</p>


<pre><code>puts "aa" == "ab"
</code></pre>


<p>第一个字符是相等，然后比较下一个字符。它们不同，因此返回false。</p>


<pre><code>puts "Jane".eql? "Jan"
</code></pre>


<p><em>eql?</em>方法用于比较两个字符串。所有对象都内建了<em>eql?</em>方法。这个方法将另一个要比较的字符串作为参数传入。</p>


<p>$ ./comparing.rb<br>
true<br>
false<br>
false<br>
false<br>
true  </p>


<p>程序输出结果。</p>


<hr>


<p>Ruby中有一个“飞船(spaceship)”操作符<em>&lt;==&gt;</em>。这个操作符来自Perl，与以上两个比较方法不同，它不是返回<em>true</em>和<em>false</em>，而是返回1、0或者-1。取决于左参数和右参数的关系。如果左参数大于右参数则返回1；如果左参数小于右参数则返回-1；如果相等返回0。什么才是一个字符大于另一个字符呢？字符在表中是有序的，在表中每个字符有一位位置。当比较字符时实际比较它们在表中的位置。例如ASCII表，字符<em>a</em>在<em>b</em>的前面，因此<em>a&lt;==&gt;b</em>返回-1，因为左参数的位置小于右参数<em>b</em>。</p>


<pre><code>#!/usr/bin/ruby

puts "a" &lt;==&gt; "b"
puts "b" &lt;==&gt; "a"
puts "a" &lt;==&gt; "a"
</code></pre>


<p>使用“飞船”操作符比较字符串。</p>


<p>$ ./spaceship.rb<br>
-1<br>
1<br>
0  </p>


<p>输出结果。</p>


<hr>


<p>有可能比较字符串不管大小写。在Ruby中有<em>casecmp</em>方法。这个方法与飞船操作符相同。</p>


<pre><code>#!/usr/bin/ruby

puts "Jane".casecmp "Jane"
puts "Jane".casecmp "jane"
puts "Jane".casecmp "Jan"
</code></pre>


<p>以上是一个例子。</p>


<pre><code>puts "Jane".casecmp "Jane"
puts "Jane".casecmp "jane"
</code></pre>


<p>这两行返回结果都是0.因为我们不考虑字符的大小写。</p>


<p>$ ./case.rb<br>
0<br>
0<br>
1  </p>


<p>输出结果。</p>


<h2>字符串对象</h2>


<p>Ruby是面向对象语言。对象是面向对象程序的基本代码块。字符串也是对象。对象由数据和方法组成。在面向对象程序中，创建对象并且相互通信。</p>


<pre><code>#!/usr/bin/ruby

website = "google.com"
puts website

website = String.new "zetcode.com"
puts website
</code></pre>


<p>以上例子我们展示了两个创建字符串的基本方法。</p>


<pre><code>website = "google.com"
</code></pre>


<p>这里是使用字符串字面量创建了一个<em>website</em>字符串变量。</p>


<pre><code>website = String.new "zetcode.com"
</code></pre>


<p>这是标准创建字符串对象的方法。然而第一和更常用，因为它更简洁，并且在计算机语言中更普遍。</p>


<hr>


<pre><code>#!/usr/bin/ruby

puts "zetcode".upcase
puts "zetcode".size
puts "zetcode".reverse
</code></pre>


<p>这个例子中我们对字符串字面量调用了三个方法。如果是熟悉Java或者C的人可能会困惑。在Ruby中调用方法时字符串字面量会转化为一个字符串对象。</p>


<p>$ ./stringobject2.rb<br>
ZETCODE<br>
7<br>
edoctez  </p>


<p>输出结果。</p>


<h2>字符串方法</h2>


<p>Ruby字符串对象有一些有用的方法。如我们见到过的<em>concat</em>或者<em>eql?</em>。</p>


<pre><code>#!/usr/bin/ruby

word = "Determination"

puts "The word #{word} has #{word.size} characters"

puts word.include? "tion"
puts word.include? "tic"

puts

puts word.empty?
word.clear
puts word.empty?
</code></pre>


<p>创建一个字符串变量，展示了四个字符串的方法。</p>


<pre><code>puts "The word #{word} has #{word.size} characters"
</code></pre>


<p><em>size</em>方法返回字符串的长度。</p>


<pre><code>puts word.include? "tion"
</code></pre>


<p><em>include?</em>方法判断一个字符串是否为子串。这里返回的是true。</p>


<pre><code>puts word.empty?
word.clear
</code></pre>


<p><em>empty?</em>方法检查字符串是否为空。返回一个布尔值。<em>clear</em>方法清空字符串。</p>


<p>$ ./basicmethods.rb<br>
The word Determination has 13 characters<br>
true<br>
false  </p>


<p>false<br>
true  </p>


<p>输出结果。</p>


<hr>


<p>接下来的例子介绍字符串大小写的方法。</p>


<pre><code>#!/usr/bin/ruby

ruby = "Ruby programming language"

puts ruby.upcase
puts ruby.downcase
puts ruby.capitalize
puts ruby.swapcase
</code></pre>


<p>Ruby中有四个与大小写相关的方法。<em>upcase</em>方法将字符串全转为大写并返回一个新对象；<em>downcase</em>方法是将字符串全转为小写并返回一个新对象；<em>capitalize</em>方法是将字符串的首字母大写并返回一个新的对象。最后<em>swapcase</em>方法是将大小写反转并返回一个新对象。</p>


<p>$ ./rubylang.rb<br>
RUBY PROGRAMMING LANGUAGE<br>
ruby programming language<br>
Ruby programming language<br>
rUBY PROGRAMMING LANGUAGE  </p>


<p>输出结果。</p>


<hr>


<p>接下来展示两个Ruby字符串的方法：<em>start_with?</em> 和<em>end_with?</em>。这两个方法都是返回布尔值。它们判断一个字符串是否分别以另一个字符串开头或结尾。</p>


<pre><code>#!/usr/bin/ruby

ws1 = "zetcode.com"
ws2 = "www.gnome.org"

puts ws1.start_with? "www."
puts ws2.start_with? "www."

puts

puts ws1.end_with? ".com"
puts ws2.end_with? ".com"
</code></pre>


<p>这是一个上述方法的例子。</p>


<pre><code>puts ws1.start_with? "www."
</code></pre>


<p>这里检查一个字符串是否以“www.”开头。如果不是则在终端打印false。</p>


<pre><code>puts ws1.end_with? ".com"
</code></pre>


<p>检查字符串<em>ws1</em>是否以&#8221;.com&#8221;结尾。如果是则在终端打印true。</p>


<p>$ ./startend.rb<br>
false<br>
true  </p>


<p>true<br>
false  </p>


<p>输出结果。</p>


<hr>


<p>接下来我们介绍<em>inspect</em>方法。这个方法返回被引号包围原始的字符串，对于特殊字符不处理。对于想要检查字符串由哪些字符组成的比较有用。</p>


<pre><code>#!/usr/bin/ruby

msg = "Jane\t17\nThomas\t23"

puts msg
puts msg.inspect
</code></pre>


<p><em>inspect</em>方法的一个例子。</p>


<pre><code>msg = "Jane\t17\nThomas\t23"
</code></pre>


<p>这个字符串有一些特殊的字符。</p>


<pre><code>puts msg
puts msg.inspect
</code></pre>


<p>第一种情况，字符串中的制表符和换行符被解释了。第二种情况我们得到了一个原始格式的字符串。</p>


<pre><code>$ ./inspectmethod.rb 
Jane    17
Thomas  23
"Jane\t17\nThomas\t23"
</code></pre>


<p>输出结果。</p>


<hr>


<p><em>chomp</em>方法是将字符串尾部的分隔符去掉并返回一个新对象。默认的分隔符是换行符(\n)。</p>


<pre><code>#!/usr/bin/ruby

print "Are you sure to download? (Yes/No) "

response = gets

if (response.downcase == "yes")
    puts "Downloaded"
else
    puts "Download cancelled"
end

puts response.inspect
</code></pre>


<p>上面的脚本我们从用户输入一些内容，然后再返回给用户。</p>


<p>$ ./chomp.rb<br>
Are you sure to download? (Yes/No) Yes<br>
Download cancelled<br>
&#8220;Yes\n&#8221;  </p>


<p>这个脚本没有正确的工作。原因很清晰，由<em>inspect</em>返回了。用户输入的内容以回车键结尾，因此换行符也被包含其中了。&#8221;Yes&#8221;与&#8221;Yes\n&#8221;不相等。要使用脚本正确运行，我们使用<em>chomp</em>方法移除掉换行符。</p>


<pre><code>#!/usr/bin/ruby

print "Are you sure to download? (Yes/No) "

response = gets

if (response.downcase.chomp == "yes")
    puts "Downloaded"
else
    puts "Download cancelled"
end

puts response.inspect
</code></pre>


<p>这个是正确的脚本。</p>


<pre><code>if (response.downcase.chomp == "yes")
</code></pre>


<p>这里我们在比&#8221;Yes&#8221;比较之前对输入内容进行了处理。</p>


<p>$ ./chomp.rb<br>
Are you sure to download? (Yes/No) Yes<br>
Downloaded<br>
&#8220;Yes\n&#8221;  </p>


<p>现在脚本正确工作了。</p>


<h2>格式化字符串</h2>


<p>Ruby中有格式化说明符。格式化说明符决定了如何显示一个字符串。它以<em>%</em>字符开始。格式化说明符放在单引号或者双引号内。</p>


<p>格式化说明符有以下字段。</p>


<p>%[flags][field width][precision]conversion specifier</p>


<p>方括号内的字段是可选的。</p>


<p>转换说明符表明数据将如何进行转换。</p>


<pre><code>#!/usr/bin/ruby

puts "There are %d oranges in the basket." % 12
puts "There are %d oranges and %d apples in the basket." % [12, 10]
</code></pre>


<p>这是一个格式化说明符的例子。</p>


<pre><code>puts "There are %d oranges in the basket" % 12
</code></pre>


<p>当我们在字符串中使用%d，我们在这个位置将期望一个数字。<em>d</em>是十进制数的转换说明符。这个数据在<em>%</em>字符后面给出。</p>


<pre><code>puts "There are %d oranges and %d apples in the basket" % [12, 10]
</code></pre>


<p>当我们在一个字符串中使用多个格式化说明符时，每个都以<em>%</em>开始。多个值放在[]之间并以逗号分隔。</p>


<p>$ ./formatspecifiers.rb<br>
There are 12 oranges in the basket.<br>
There are 12 oranges and 10 apples in the basket.  </p>


<p>输出结果。</p>


<hr>


<p>接下来的例子我们介绍一些基本的转换符。</p>


<pre><code>#!/usr/bin/ruby

puts "There are %d apples." % 5
puts "I can see %i oranges." % 3
puts "The width of iPhone 3G is %f mm." % 62.1
puts "This animal is called a %s" % "rhinoceros."
</code></pre>


<p>我们使用了整数、浮点数和字符串的转换符。</p>


<pre><code>puts "There are %d apples." % 5
puts "I can see %i oranges." % 3
</code></pre>


<p><em>d</em>和<em>i</em>都是用于整数。</p>


<pre><code>puts "The width of iPhone 3G is %f mm." % 62.1
</code></pre>


<p><em>f</em>用于浮点数。默认浮点数有6个小数。</p>


<pre><code>puts "This animal is called a %s" % "rhinoceros."
</code></pre>


<p><em>s</em>用于字符串。</p>


<p>$ ./basicspecifiers.rb<br>
There are 5 apples.<br>
I can see 3 oranges.<br>
The width of iPhone 3G is 62.100000 mm.<br>
This animal is called a rhinoceros.  </p>


<p>输出结果。</p>


<hr>


<p>接下来是一个实践的例子。</p>


<pre><code>#!/usr/bin/ruby

website = "zetcode.com"

website.each_char do |c|
    print "#{c} has ASCII code %d\n" % c.ord    
end
</code></pre>


<p>这个例子我们记遍历字符串的所有字符并在终端上打印它的ASCII值。</p>


<pre><code>website.each_char do |c|
    print "#{c} has ASCII code %d\n" % c.ord    
end
</code></pre>


<p><em>each_char</em>方法将<em>website</em>字符串中的每个字符传给代码块，一个字符是一次循环。当前的字符保存在这是<em>c</em>中。我们使用<em>ord</em>方法获取字符的ASCII值。</p>


<p>$ ./character.rb<br>
z has ASCII code 122<br>
e has ASCII code 101<br>
t has ASCII code 116<br>
c has ASCII code 99<br>
o has ASCII code 111<br>
d has ASCII code 100<br>
e has ASCII code 101<br>
. has ASCII code 46<br>
c has ASCII code 99<br>
o has ASCII code 111<br>
m has ASCII code 109  </p>


<p>输出结果。 </p>


<hr>


<p>数字有多种显示形式。</p>


<pre><code>#!/usr/bin/ruby

# decimal
puts "%d" % 300

# hexadecimal
puts "%x" % 300

# octal
puts "%o" % 300

# binary
puts "%b" % 300

# scientific
puts "%e" % (5/3.0)
</code></pre>


<p>上面的例子中我们打印数字的十进制、十六进制、八进制、二进制和科学记数的形式。</p>


<pre><code># hexadecimal
puts "%x" % 300
</code></pre>


<p><em>x</em>转换符用于将数字转为十六进制格式。</p>


<pre><code># binary
puts "%b" % 300
</code></pre>


<p><em>b</em>转换符用于将数字转为二进制格式。</p>


<p>$ ./various.rb<br>
300<br>
12c<br>
454<br>
100101100<br>
1.666667e+00  </p>


<p>输出结果。</p>


<hr>


<p>精度是格式化说明符的一个字段。它指明了后面小数点的位数。它对于整数、小数和字符串有不同的意义。当用于整数时表明了最少打印多少个数字。如果数字个数少于精度则前面用0补全。对于整数精度默认为1,表示前面没有0.当用于浮点数时表示小数点后显示多少个数字。最后，用于字符串时精度表示多少个字符会打印。</p>


<pre><code>#!/usr/bin/ruby

puts 'Height: %f %s' % [172.3, 'cm']
puts 'Height: %.1f %s' % [172.3, 'cm']

puts "%d" % 16
puts "%.5d" % 16

puts "%s" % "zetcode"
puts "%.5s" % "zetcode"
</code></pre>


<p>这个例子中我们使用了精度字段。</p>


<pre><code>puts 'Height: %f %s' % [172.3, 'cm']
puts 'Height: %.1f %s' % [172.3, 'cm']
</code></pre>


<p>172.3是一个浮点数。如果没有指定精度则会显示6个小数。这里将会显示5个0.第二行的<em>.1</em>是精度，它将小数个数减为1。的</p>


<pre><code>puts "%d" % 16
puts "%.5d" % 16
</code></pre>


<p>对于整数默认精度为1。第二行中我们指明了精度为.5，这将会在16前面加上3个0。</p>


<pre><code>puts "%s" % "zetcode"
puts "%.5s" % "zetcode"
</code></pre>


<p>第一行会打印所有的字符串。第二行仅打印5个，有两个字符将抛弃。</p>


<p>$ ./precision.rb<br>
Height: 172.300000 cm<br>
Height: 172.3 cm<br>
16<br>
00016<br>
zetcode<br>
zetco  </p>


<p>输出结果。</p>


<hr>


<p>宽度字段表示数据最小要显示的宽度。它是一个数字，并且在小数点之前。如果输出比较短，则会被用空格填充，且右对齐。如果宽度前面有减号则会左对齐。如果输出比宽度长则会完整输出。</p>


<pre><code>#!/usr/bin/ruby

puts "%d" % 1
puts "%d" % 16
puts "%d" % 165
puts "%d" % 1656
puts "%d" % 16567

puts "%10d" % 1
puts "%10d" % 16
puts "%10d" % 165
puts "%10d" % 1656
puts "%10d" % 16567
</code></pre>


<p>第一种情况打印5个数字没有指明宽度。输出的宽度即为数字的位数。第二种情况指明宽度为10。则每个都最少输出10字符的长度，数字右对齐。</p>


<pre><code>puts "%d" % 1
puts "%d" % 16
</code></pre>


<p>打印两个数字，输出的宽度分别为1、2个字符。</p>


<pre><code>puts "%10d" % 1
puts "%10d" % 16
</code></pre>


<p>这里宽度都为10个字符。这两个数被填充了8、9个空格。</p>


<pre><code>$ ./fieldwidth.rb
1
16
165
1656
16567
         1
        16
       165
      1656
     16567
</code></pre>


<p>我们发现第二种情况数字是右对齐的。</p>


<hr>


<p>标志修饰符修改了模式的行为。</p>


<p><em>#</em>标志分别在二进制、八进制各十六进制前加上0b、0和0x。它会给小数加上小数点，即使这个小数人被精度限制了。</p>


<pre><code>#!/usr/bin/ruby

puts "%#b" % 231
puts "%#x" % 231
puts "%#o" % 231

puts "%.0e" % 231
puts "%#.0e" % 231

puts "%.0f" % 231
puts "%#.0f" % 231
</code></pre>


<p>这个例子我们使用了<em>#</em>标志。</p>


<pre><code>puts "%#b" % 231
puts "%#x" % 231
puts "%#o" % 231
</code></pre>


<p>十进制数231分别以二进制、八进制和十六进制打印。<em>#</em>标志会给它们加上前缀。</p>


<pre><code>puts "%.0e" % 231
puts "%#.0e" % 231
</code></pre>


<p>这个<em>.0</em>限制了小数个数。然后使用<em>#</em>标志后小数点会显示，即使没有小数值。</p>


<p>$ ./flags1.rb<br>
0xe7<br>
0b11100111<br>
0347<br>
2e+02<br>
2.e+02<br>
231<br>
231.  </p>


<p>输出结果。</p>


<hr>


<p><em>+</em>标志会给正数加上正号。对于二进制、十六进制和八进制的负数会加上负号并使用它的绝对值。</p>


<pre><code>#!/usr/bin/ruby

puts "%d" % 231
puts "%+d" % 231
puts "%d" % -231
puts "%+d" % -231

puts "%b" % -231
puts "%o" % -231
puts "%x" % -231

puts "%+b" % -231
puts "%+o" % -231
puts "%+x" % -231
</code></pre>


<p>一个演示<em>+</em>标志符的例子。</p>


<pre><code>puts "%d" % 231
puts "%+d" % 231
</code></pre>


<p>通常正数的符号会被忽略掉。如果想要显示正数的符号可以使用<em>+</em>标志符。</p>


<pre><code>puts "%d" % -231
puts "%+d" % -231
</code></pre>


<p><em>+</em>标志符对负数没有影响，输出结果还是一样的。</p>


<pre><code>puts "%b" % -231
puts "%o" % -231
puts "%x" % -231
</code></pre>


<p>二进制、八进制和十六进制的数有它们自己生成负数的方法。</p>


<pre><code>puts "%+b" % -231
puts "%+o" % -231
puts "%+x" % -231
</code></pre>


<p>如果我们对负数指定了<em>+</em>标志，我们将数字转为不同的格式并加上负号。没有专门的方式表示负数。</p>


<p>$ ./flags2.rb<br>
231<br>
+231<br>
-231<br>
-231<br>
..100011001<br>
..7431<br>
..f19<br>
-11100111<br>
-347<br>
-e7  </p>


<p>输出结果。</p>


<hr>


<p>这里介绍<em>0</em>标志和<em>-</em>标志。<em>0</em>标志会用0代替空格来填充数字。<em>-</em>标志会将输出左对齐。</p>


<pre><code>#!/usr/bin/ruby

puts "%010d" % 1
puts "%010d" % 16
puts "%010d" % 165
puts "%010d" % 1656
puts "%010d" % 16567

puts "%-10d" % 1
puts "%-10d" % 16
puts "%-10d" % 165
puts "%-10d" % 1656
puts "%-10d" % 16567
</code></pre>


<p>以上是一个例子。</p>


<pre><code>puts "%010d" % 1
puts "%010d" % 16
</code></pre>


<p>数字会用0填充。</p>


<pre><code>puts "%-10d" % 1
puts "%-10d" % 16
</code></pre>


<p>数字个数比宽度短，且会左对齐。</p>


<p>$ ./fieldwidth2.rb<br>
0000000001<br>
0000000016<br>
0000000165<br>
0000001656<br>
0000016567<br>
1        <br>
16        <br>
165       <br>
1656     <br>
16567  </p>


<p>输出结果。</p>


<hr>


<p>*标志符用于精度和宽度。当我们使用*符号时精度和宽度将作为一个参数。</p>


<pre><code>#!/usr/bin/ruby

puts "%.*f" % [3, 1.1111111]
puts "%0*d" % [10, 2]
puts "%0*.*f" % [10, 3, 1.1111]
</code></pre>


<p>使用了*标志的的例子。</p>


<pre><code>puts "%.*f" % [3, 1.1111111]
</code></pre>


<p>这里使用<em>作为精度，则第一个数字3是精度的参数。它只为显示</em>1.1111111*的3个小数。</p>


<pre><code>puts "%0*d" % [10, 2]
</code></pre>


<p>这行的代码我们使用*标志作为宽度。我们必须在[]之间加上宽度。第一个数字是宽度，第十个数字是要转换的值。</p>


<pre><code>puts "%0*.*f" % [10, 3, 1.1111]
</code></pre>


<p>*标志可以同时用于宽度和精度。这样我们就必须都在[]中指明。</p>


<p>$ ./flags3.rb<br>
1.111<br>
0000000002<br>
000001.111  </p>


<p>输出结果。</p>


<p>这章的教程介绍的Ruby的字符串。</p>


<hr>


<p>原文地址： <a href="http://zetcode.com/lang/rubytutorial/strings/">http://zetcode.com/lang/rubytutorial/strings/</a><br>
翻译：龙昌  admin@longchangjin.cn<br>
完整教程：<a href="https://github.com/wusuopu/Ruby-tutorial">https://github.com/wusuopu/Ruby-tutorial</a>  </p>

</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
    <h1 class="entry-title"><a href="http://www.xefan.com/archives/83913.html">[翻译]Ruby教程6——数据类型</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2013-11-07T00:00:00+08:00'><span class='date'><span class='date-month'>Nov</span> <span class='date-day'>7</span><span class='date-suffix'>th</span>, <span class='date-year'>2013</span></span> <span class='time'>12:00 am</span></time>
        
           | <a href="http://www.xefan.com/archives/83913.html#disqus_thread"
             data-disqus-identifier="http://www.xefan.com/archives/83913.html">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><h1>数据类型</h1>


<p>在这一章的教程中我们开始讨论数据类型。</p>


<p>所有类别的计算机程序，包括电子表格、文本编辑器、计算器和聊天软件都使用数据。现代计算机语言中各种数据类型是必不可少的。一种数据类型是一些可操作的值的集合。</p>


<p>Ruby中有一些数据类型，这些类型都是基于类的。以下是Ruby中公认的数据类型：  </p>


<ul>
<li>布尔(Booleans)  </li>
<li>符号(Symbols)  </li>
<li>数字(Numbers)  </li>
<li>字符串(Strings)</li>
<li>数组(Arrays)  </li>
<li>哈希(Hashes)</li>
</ul>


<p>下面的例子中我们展示Ruby中所有重要的数据类型。</p>


<pre><code>#!/usr/bin/ruby

h = { :name =&gt; "Jane", :age =&gt; 17 }

p true.class, false.class
p "Ruby".class
p 1.class
p 4.5.class
p 3_463_456_457.class
p :age.class
p [1, 2, 3].class
p h.class
</code></pre>


<p>我们将它们的类型名打印出来，类型是用于创建对象的模块。  </p>


<pre><code>p true.class, false.class
</code></pre>


<p><em>true</em>和<em>false</em>对象展示的布尔类型。</p>


<pre><code>p "Ruby".class
</code></pre>


<p>这个是字符串。</p>


<pre><code>p 1.class
p 4.5.class
p 3_463_456_457.class
</code></pre>


<p>这些是数字。</p>


<pre><code>p :age.class
</code></pre>


<p>这个是符号标志，Ruby的一种特殊数据类型。</p>


<pre><code>p [1, 2, 3].class
p h.class
</code></pre>


<p>这是两个容器，数组和哈希表。</p>


<p>$ ./types.rb<br>
TrueClass<br>
FalseClass<br>
String<br>
Fixnum<br>
Float<br>
Bignum<br>
Symbol<br>
Array<br>
Hash  </p>


<p>这个程序列出了属于Ruby的类型。</p>


<h2>布尔值</h2>


<p>在我们的世界里存在着对偶关系。天与地、水与火、男与女、爱与恨。这些就是我们自然中的“布尔”。在Ruby里，布尔类型只有一种，具有两个值：<em>true</em>(真)与<em>false</em>(假)。布尔是一种基本的数据类型，它在计算机程序中非常普遍。</p>


<p>高兴的父母等待着孩子的诞生。他们可能会给孩子取个名字。如果是男孩就叫John，如果是女孩就叫Victoria。</p>


<pre><code>#!/usr/bin/ruby

# kid.rb

bool = [true, false]

male = bool[rand(2)]


if male
    puts "We will use name John"
else 
    puts "We will use name Victoria"
end
</code></pre>


<p>在这个程序中我们使用随机数来模拟这种情况。</p>


<pre><code>bool = [true, false]
</code></pre>


<p>我们创建一个名为<em>bool</em>的变量，它是一个数组包含了两个布尔值。这个数组是使用方括号创建的。</p>


<pre><code>male = bool[rand(2)]
</code></pre>


<p>我们使用<em>rand()</em>方法生成一个随机数。这个方法返回0或1。返回的数用于数组的索引。</p>


<pre><code>if male
    puts "We will use name John"
else 
    puts "We will use name Victoria"
end
</code></pre>


<p>根据<em>male</em>变量我们打印一条信息。如果<em>male</em>是<em>true</em>则名字选择John，否则选择Vactoria。类似<em>is/else</em>的结构控制语句是根据布尔值来选择的。</p>


<p>$ ./kid.rb <br>
We will use name Victoria <br>
$ ./kid.rb <br>
We will use name Victoria<br>
$ ./kid.rb <br>
We will use name John<br>
$ ./kid.rb <br>
We will use name John<br>
$ ./kid.rb <br>
We will use name John  </p>


<p>程序运行多次的结果如上。</p>


<h2>符号标志</h2>


<p>符号标志代表其他对象。使用符号标志而不是字符串，是因为可能保存一些资源。一个符号标志是<em>Symbol</em>类的一个实例对象。符号标志通常是在标识符的前面加上冒号，比如 :name。一些对象具有<em>to_sym</em>方法，用于将这些对象转化为符号标志。</p>


<p>Ruby的符号标志在程序运行时是不可改变的。它通常用于当作哈希表的键，因为一个键不需要完整的字符串功能。</p>


<pre><code>#!/usr/bin/ruby

p :name
p :name.class
p :name.methods.size
p "Jane".methods.size

p :name.object_id
p :name.object_id
p "name".object_id
p "name".object_id
</code></pre>


<p>第一个例子展示了符号标志的基本操作。</p>


<pre><code>p :name
p :name.class
</code></pre>


<p>在终端上打印一个符号标志和它的类型。符号标志的类型是<em>Symbol</em>。</p>


<pre><code>p :name.methods.size
p "Jane".methods.size
</code></pre>


<p>比较字符串实例与符号标志实例分配的方法数量。字符串的方法数是符号标志的两位多。</p>


<pre><code>p :name.object_id
p :name.object_id
p "name".object_id
p "name".object_id
</code></pre>


<p>相同的符号标志具有相同的id，相同的字符串的id却不同。</p>


<p>$ ./symbols.rb<br>
:name<br>
Symbol<br>
79<br>
162<br>
10328<br>
10328<br>
77344750<br>
77344730  </p>


<p>程序输出结果。</p>


<hr>


<p>符号标志也可以作为常量标志，类似于C/C++中的枚举类型。</p>


<pre><code>#!/usr/bin/ruby

light = :on

if light == :on
    puts "The light is on"
else
    puts "The light is off"
end

light = :off

if light == :on
    puts "The light is on"
else
    puts "The light is off"
end
</code></pre>


<p>电灯不是开就是关。对于这两种情况定义了符号标志。</p>


<pre><code>light = :on
</code></pre>


<p>灯是开的。</p>


<pre><code>if light == :on
    puts "The light is on"
else
    puts "The light is off"
end
</code></pre>


<p>程序的逻辑依赖于<em>light</em>变量的状态。</p>


<hr>


<p>符号标志通常在哗然容器中作为键。这比字符串更加有效。</p>


<pre><code>#!/usr/bin/ruby

domains = {:sk =&gt; "Slovakia", :no =&gt; "Norway", :hu =&gt; "Hungary"}

puts domains[:sk]
puts domains[:no]
puts domains[:hu]
</code></pre>


<p>在这个脚本中创建了一个名为<em>domains</em>的哈希表。它的键全是符号标志。</p>


<pre><code>puts domains[:sk]
puts domains[:no]
puts domains[:hu]
</code></pre>


<p>在哈希表中键是用于访问值的。接下来我们打印出这个哈希表的值。</p>


<p>$ ./symbols3.rb<br>
Slovakia<br>
Norway<br>
Hungary  </p>


<p>以上是例子的输出结果。</p>


<hr>


<p>Ruby解释器将内部引用存储为符号标志。</p>


<pre><code>#!/usr/bin/ruby

class Being

    def initialize
        @is = true
    end

    def say
        "I am being"
    end
end

b = Being.new

p b.method :say
p b.instance_variable_get :@is
</code></pre>


<p>定义了一个<em>Being</em>类。该类有一个自定义实例变量<em>@is</em>和一个方法<em>say</em>。这两个实体在Ruby中保存为符号标志。</p>


<pre><code>p b.method :say
</code></pre>


<p><em>method</em>方法用于在<em>b</em>对象在查找给定名字的方法。我们查找的是<em>:say</em>符号。</p>


<pre><code>p b.instance_variable_get :@is
</code></pre>


<p>使用<em>instance_variable_get</em>检查<em>@is</em>是不是<em>b</em>对象的一个实例变量。在内部变量存储为<em>:@is</em>符号。</p>


<p>$ ./symbols4.rb   </p>


<h1><Method: Being#say></h1>


<p>true  </p>


<p>输出结果。</p>


<hr>


<p>所有的符号都存储在符号表中。下一个例子我们来看看这个表。<em>Symbol</em>类的<em>all_symbols</em>方法返回了一个数组包含这个表的全部符号。</p>


<pre><code>#!/usr/bin/ruby

def info
  "info method"
end

@v = "Ruby"
@@n = "16"

p Symbol.all_symbols.include? :info
p Symbol.all_symbols.include? :@v
p Symbol.all_symbols.include? :@@n
</code></pre>


<p>在这个Ruby脚本中创建了一个方法、一个实例变量和一个类变量。我们检查这些实体是否存储在符号表中。</p>


<pre><code>p Symbol.all_symbols.include? :info
</code></pre>


<p>检查<em>:info</em>符号是否在符号表中。这行返回的是<em>true</em>。</p>


<p>$ ./symbols5.rb<br>
true<br>
true<br>
true  </p>


<p>三个符号都在符号表中。</p>


<h2>整数</h2>


<p>整数是实数的一个子集。它没有分数或者小数。整数属于集合Z = {&#8230;, -2, -1, 0, 1, 2, &#8230;} 。这个集合是无限的。</p>


<p>在计算机语言中，整数是原始的数据类型。实际中计算机仅支持整数的一个子集，因为计算机的能力有限。整数用于统计离散的实体。我们有3、4、6个人，但是不能有3.33个人。我们有3.33千克。</p>


<p>在Ruby中整数是<em>Fixnum</em>或者<em>Bignum</em>类的实例对象。不同于其他语言，如Java或者C，在Ruby中整数是一个对象。这两种类型的大小不同。<em>Fixnum</em>类型的整数有一些限制，这些限制与机器有关。<em>Bignum</em>的值表示范围比<em>Fixnum</em>大。如果一些操作超出了<em>Fixnum</em>的范围，它会自动的转换成<em>Bignum</em>。程序员通常不需要关心整数的类型。</p>


<pre><code>#!/usr/bin/ruby

p -2
p 121
p 123265
p -34253464356
p 34867367893463476

p 1.class
p 23453246.class
p 234532423563456346.class
p 2345324235632363463456456346.class

p 5 / 2
p 5.div 2
</code></pre>


<p>这个例子中我们处理的一些整数。</p>


<pre><code>p -2
p 121
p 123265
p -34253464356
p 34867367893463476
</code></pre>


<p>这是一些不同大小的正数和负数。</p>


<pre><code>p 1.class
p 23453246.class
p 234532423563456346.class
p 2345324235632363463456456346.class
</code></pre>


<p>打印出这些数的类型。前两个整数是<em>Fixnum</em>类型，其余两个是<em>Bignum</em>类型。</p>


<pre><code>p 5 / 2
p 5.div 2
</code></pre>


<p>这两行展示的整数的相除。当两个数相除时我们使用了相除操作符/方法,结果也是一个整数。</p>


<p>$ ./integers.rb<br>
-2<br>
121<br>
123265<br>
-34253464356<br>
34867367893463476<br>
Fixnum<br>
Fixnum<br>
Bignum<br>
Bignum<br>
2<br>
2  </p>


<p>例子的输出结果。</p>


<hr>


<p>在Ruby中整数可以有不同的表现符号。十进制、十六进制、八进制和二进制数都是可用的。十六进制数以0x字符开头，八进制以0字符开头，二进制以0b字符开头。</p>


<pre><code>#!/usr/bin/ruby

puts 122
puts 0x7a
puts 0172
puts 0b1111010
</code></pre>


<p>这个例子中我们打印了十进制数<em>122</em>的所有表现形式。</p>


<p>$ ./inotations.rb<br>
122<br>
122<br>
122<br>
122  </p>


<p>以上是输出结果。</p>


<hr>


<p>我们使用整数的话，那么就是用于处理离散的实体。也许我们用于统计苹果的数量。</p>


<pre><code>#!/usr/bin/ruby

baskets = 16
apples_in_basket = 24

total = baskets * apples_in_basket

puts "There are total of #{total} apples"
</code></pre>


<p>在这个程序中我们使用整数统计苹果的总数。</p>


<p>$ ./apples.rb<br>
There are total of 384 apples  </p>


<p>以上是程序的输出。</p>


<hr>


<p>大数字读起来比较困难。如果我们有一个数245342395423452，我们发现很难快速的将它读出来。计算机之外大的数字是用空格或者逗号分隔开来。为了可读性，Ruby允许数字包含下划线。Ruby解释器会忽略整数中的下划线。</p>


<pre><code>#!/usr/bin/ruby

p 23482345629
p 23_482_345_629

p 23482345629 == 23_482_345_629
</code></pre>


<p>这个例子演示了下划线的使用。</p>


<pre><code>p 23482345629 == 23_482_345_629
</code></pre>


<p>这行展示了两个数据是相等的。</p>


<p>$ ./underscore.rb<br>
23482345629<br>
23482345629<br>
true  </p>


<p>例子的输出结果。</p>


<h2>浮点数</h2>


<p>在计算中浮点数表示实数。实例意味着连续的数量，如：重量、高度和速度。Ruby中小数是<em>Float</em>或者<em>BigDecimal</em>类对象。<em>BigDecimal</em>类是Ruby的核心类，是Ruby标准库的一部分。此外我们还可以使用<em>Rational</em>对象。</p>


<p>我们需要理解数字是不业精确的。Ruby的官方文档清楚地说道浮点数对象表示的是不精确的实数。</p>


<pre><code>#!/usr/bin/ruby

p 15.4
p 0.3455
p -343.4563

p 12.5.class
p -12.5.class
p (5.0 / 2).class

p 5.fdiv 2
p 12.to_f
</code></pre>


<p>上面的这个例子我们使用了浮点数。</p>


<pre><code>p 15.4
p 0.3455
p -343.4563
</code></pre>


<p>这里我们打印三个小数的值。小数包含了小数点字符。</p>


<pre><code>p 12.5.class
p -12.5.class
p (5.0 / 2).class
</code></pre>


<p>以上展示的数字的类型，全都是浮点数。最后一个整数与浮点数相除结果为浮点数。</p>


<pre><code>p 5.fdiv 2
p 12.to_f
</code></pre>


<p>这里我们创建浮点数除法<em>fdiv</em>和转换方法<em>to_f</em>来创建浮点数。</p>


<p>$ ./decimals.rb<br>
15.4<br>
0.3455<br>
-343.4563<br>
Float<br>
Float<br>
Float<br>
2.5<br>
12.0  </p>


<p>以上为转出结果。</p>


<hr>


<p>一个小数默认最多只显示小数点后16个数字。我们可以使用<em>sprintf</em>或者<em>printf</em>方法来控制浮点数的格式。</p>


<pre><code>#!/usr/bin/ruby

p 1/3.0
p 1.fdiv 2

puts sprintf "%.4f" % (1/3.0)
puts sprintf "%.7f" % (5/3.0)
</code></pre>


<p>格式化小数。</p>


<pre><code>p 1/3.0
p 13.fdiv 4
p 1.fdiv 2
</code></pre>


<p>第一行打印的小数在小数点后有16个数字。第二行打印的有两个。第三行打印的有一个。</p>


<pre><code>puts sprintf "%.4f" % (1/3.0)
puts sprintf "%.7f" % (5/3.0)
</code></pre>


<p>这里我们使用<em>sprintf</em>方法控制小数点后面的数字个数。<em>sprintf</em>方法的格式说明符是精确的。它是一个数字接着<em>%</em>符号。<em>f</em>是一个转换说明符，表示处理的是一个浮点数。</p>


<p>$ ./formatfloat.rb<br>
0.3333333333333333<br>
3.25<br>
0.5<br>
0.3333<br>
1.6666667  </p>


<p>以上是输出结果。</p>


<hr>


<p>Ruby支持使用科学的记数法来表示一个浮点数。这也称为指数记数法，它是将非常大或者非常小的数转换成正常的小数形式。</p>


<pre><code>#!/usr/bin/ruby

p 1.2e-3
p 0.0012

p 1.5E-4
p 0.00015
</code></pre>


<p>这个例子展示了两个使用科学记数表示的小数。</p>


<p>$ ./scientific.rb<br>
0.0012<br>
0.0012<br>
0.00015<br>
0.00015  </p>


<p>这是以上程序的输出。</p>


<hr>


<p>前面我们主说过浮点数的值稍微有些不精确。在很多计算中，普通的浮点小数已经足够精确了，如：我们的体重是60kg还是60.000024kg并不重要。对于其他计算，包括科学和工程应用，精确度是非常重要的。</p>


<p>Ruby有一个<em>BigDecimal</em>标准库。这个类对于非常大或者非常精准的浮点数提供了任意的精度。</p>


<pre><code>#!/usr/bin/ruby

require 'bigdecimal'

sum = 0

1000.times do
    sum = sum + 0.0001
end

p sum


sum = BigDecimal.new("0")

1000.times do
    sum = sum + BigDecimal.new("0.0001")
end

puts sum.to_s('F')
puts sum.to_s('E')
</code></pre>


<p>在这个例子中我们比较了<em>Float</em>与<em>BigDecimal</em>的精度。 </p>


<pre><code>require 'bigdecimal'
</code></pre>


<p><em>BigDecimal</em>类必须导入。</p>


<pre><code>sum = 0

1000.times do
    sum = sum + 0.0001
end

p sum
</code></pre>


<p>通过循环对一个很小的浮点数求和。最后会出现一点误差。</p>


<pre><code>sum = BigDecimal.new("0")

1000.times do
    sum = sum + BigDecimal.new("0.0001")
end
</code></pre>


<p>然后再对<em>BigDecimal</em>做同样的事情。</p>


<pre><code>puts sum.to_s('F')
puts sum.to_s('E')
</code></pre>


<p>将<em>sum</em>浮点数打印为工程记数形式。</p>


<p>$ ./bigdecimal.rb<br>
0.10000000000000184<br>
0.1<br>
0.1E0  </p>


<p>输出结果表示<em>BigDecimal</em>比<em>Float</em>更精确。</p>


<hr>


<p>如果一个短路运动员100m跑9.87s，那么他的时速是多少？</p>


<pre><code>#!/usr/bin/ruby

distance = 0.1
time = 9.87 / 3600

speed = distance / time

puts "The average speed of a sprinter is #{speed} km/h"
</code></pre>


<p>这个例子必需使用浮点数。</p>


<pre><code>distance = 0.1
</code></pre>


<p>100m等于0.1km。</p>


<pre><code>time = 9.87 / 3600
</code></pre>


<p>9.87s等于9.87/60*60 h。</p>


<pre><code>speed = distance / time
</code></pre>


<p>要计算速度，我们用距离除以时间。</p>


<p>$ ./speed.rb<br>
The average speed of a sprinter is 36.4741641337386 km/h  </p>


<p>以上是<em>speed.rb</em>脚本的输出。</p>


<h2>有理数</h2>


<p>Ruby支持有理数。有理数是一个确切的数。使用有理数可以避免舍入错误。Ruby中有理数是<em>Rational</em>类的对象。我们可以使用某些对象的<em>to_r</em>方法来创建有理数。</p>


<p>有理数可以用于表示两个整数相除的分数，a/b（b!=0）。如果b为1,每个整数都是一个有理数。</p>


<pre><code>#!/usr/bin/ruby

puts 2.to_r
puts "23".to_r
puts 2.6.to_r

p Rational 0
p Rational 1/5.0
p Rational 0.5
</code></pre>


<p>这个例子展示了一些有理数。</p>


<pre><code>puts 2.to_r
</code></pre>


<p>变量我们使用<em>to_r</em>方法将整数2转化为有理数2/1。</p>


<pre><code>p Rational 0.5
</code></pre>


<p>使用<em>Rational</em>方法创建一个有理数》</p>


<p>$ ./rational.rb<br>
2/1<br>
23/1<br>
5854679515581645/2251799813685248<br>
(0/1)<br>
(3602879701896397/18014398509481984)<br>
(1/2)  </p>


<p>例子的输出结果。</p>


<h2>空值</h2>


<p>Ruby有一个特殊的值<em>nil</em>。它表示空值。<em>nil</em>是<em>NilClass</em>类的单实例，仅有一个<em>nil</em>。</p>


<pre><code>#!/usr/bin/ruby

puts nil
p nil

p $val

p [1, 2, 3][4]

p $val1 == $val2
</code></pre>


<p><em>nil</em>的一个例子。</p>


<pre><code>puts nil
p nil
</code></pre>


<p>在终端上打印<em>nil</em>的值。<em>puts</em>方法打印空字符串，<em>p</em>方法打印<em>&#8216;nil&#8217;</em>字符串。</p>


<pre><code>p $val
</code></pre>


<p>当我们引用一个没有定义的全局变量时会返回<em>nil</em>值。</p>


<pre><code>p [1, 2, 3][3]
</code></pre>


<p>这行代码我们引用了一个3元素数组的第4个元素，结果返回<em>nil</em>。Ruby中的许多方法对于无效的值都返回<em>nil</em>。</p>


<pre><code>p $val1 == $val2
</code></pre>


<p>这行返回<em>true</em>，这实际上是因为<em>nil</em>是<em>NilClass</em>的单实例对象。</p>


<p>$ ./nilvalue.rb  </p>


<p>nil<br>
nil<br>
nil<br>
true  </p>


<p>输出结果。</p>


<h2>字符串</h2>


<p>字符串在计算机程序代表文本数据。Ruby字符串是一个序列化的unicode字符。字符串是<em>String</em>的一个对象。字符串的字面量是字符加上双引号或者单引号。</p>


<p>字符串是一个非常重要的数据类型。它需要专门用一章来介绍。这里我们仅包含一个小例子。</p>


<pre><code>#!/usr/bin/ruby

p "Ruby"
p 'Python'

p "Ruby".size
p "Ruby".upcase

p 23.to_s
</code></pre>


<p>这个例子中我们使用了Ruby的字符串。我们使用<em>p</em>方法是为了在输出中看到数据类型。</p>


<pre><code>p "Ruby"
p 'Python'
</code></pre>


<p>在终端中打印两个字符串的字面值。第一个字面量是使用双引号，第二个是单引号。</p>


<pre><code>p "Ruby".size
p "Ruby".upcase
</code></pre>


<p>这两行调用了两个字符串的方法。<em>size</em>方法返回字符串的长度，在这里是4个字符。<em>upcase</em>方法是将字符串转为大写。</p>


<pre><code>p 23.to_s
</code></pre>


<p><em>to_s</em>方法是将整数转为字符串。</p>


<p>$ ./strings.rb<br>
&#8220;Ruby&#8221;<br>
&#8220;Python&#8221;<br>
4<br>
&#8220;RUBY&#8221;<br>
&#8220;23&#8221;  </p>


<p>在输出中我们看到字符串是在引号内。这就是我们使用<em>p</em>方法的结果，<em>print</em>和<em>puts</em>方法都不会带上引号。</p>


<h2>数组和哈希表</h2>


<p>数组和哈希表是对象的集合。他们将对象集合在一起。</p>


<p>数组是对象的有序集合。哈希表是键-值对的集合。我们将会用单独的一章来介绍数组和哈希表。以下仅是一个预览的例子。</p>


<pre><code>#!/usr/bin/ruby

nums = [1, 2, 3, 4]

puts "There are #{nums.size} items in the array"

nums.each do |num|
    puts num
end


domains = { :de =&gt; "Germany", :sk =&gt; "Slovakia",
            :us =&gt; "United States", :no =&gt; "Norway" }

puts domains.keys
puts domains.values
</code></pre>


<p>这是一个Ruby数组和哈希表的例子。</p>


<pre><code>nums = [1, 2, 3, 4]

puts "There are #{nums.size} items in the array"

nums.each do |num|
    puts num
end
</code></pre>


<p>这里创建一个有4项内容的数组。第二行统计了这个数组数据项的数量，并合并到了消息中。随后我们使用<em>each</em>方法将每个元素打印在终端上。</p>


<pre><code>domains = { :de =&gt; "Germany", :sk =&gt; "Slovakia",
            :us =&gt; "United States", :no =&gt; "Norway" }

puts domains.keys
puts domains.values
</code></pre>


<p>创建了Ruby的哈希表，然后打印它的键和值。</p>


<p>$ ./arrayshashes.rb<br>
There are 4 items in the array<br>
1<br>
2<br>
3<br>
4<br>
de<br>
sk<br>
us<br>
no<br>
Germany<br>
Slovakia<br>
United States<br>
Norway  </p>


<p>例子的输出结果。</p>


<h2>类型转换</h2>


<p>我们经常是一次使用多种数据类型。在编程中从一种数据类型转换为其他类型是很平常的。类型转换或者类型的引用会将一个实体从一个类型转换成另一个类型。有两种类型转换的方式：隐式和显式。隐式类型转换又称为强制转换，是被编译器自动的转换。Ruby只有显式转换。</p>


<p>Ruby有内建的转换方法。如：<em>to_i</em>、<em>to_s</em>或者<em>to_f</em>。内核模块有一些公共的方法用来转换，如<em>Interger</em>、<em>String</em>或者<em>Float</em>。这些方法还要与Ruby的类混淆。</p>


<p>#!/usr/bin/ruby</p>


<pre><code>p Array(1..6)
p Complex 6
p Float 12
p Integer "34"
p Rational 6
p String 22
</code></pre>


<p>这里我们展示了内核模块的转换方法。</p>


<p>$ ./convertmethods.rb<br>
[1, 2, 3, 4, 5, 6]<br>
(6+0i)<br>
12.0<br>
34<br>
(6/1)<br>
&#8220;22&#8221;  </p>


<p>例子的输出结果。</p>


<hr>


<pre><code>#!/usr/bin/ruby

p "12".to_i
p 12.5.to_i
p nil.to_i

p 12.to_f
p "11".to_f
p nil.to_f
</code></pre>


<p>以上例子我们展示了数字的转换。一些对象具有<em>to_i</em>和<em>to_f</em>方法将对象转换成整数和浮点数。</p>


<pre><code>p "12".to_i
p 12.5.to_i
p nil.to_i
</code></pre>


<p>这里我们将字符串、小数和nil转换成整数。</p>


<pre><code>p 12.to_f
p "11".to_f
p nil.to_f
</code></pre>


<p>这三行将整数、字符串和nil转换成小数。</p>


<p>$ ./conversions.rb<br>
12<br>
12<br>
0<br>
12.0<br>
11.0<br>
0.0  </p>


<p>例子的输出结果。</p>


<hr>


<p>第二个例子展示了一些字符串的转换。</p>


<pre><code>#!/usr/bin/ruby

p "12".to_i
p "13".to_f
p "12".to_r
p "13".to_c

p "Jane".to_sym

v = "Ruby Python Tcl PHP Perl".split
p v.class
</code></pre>


<p>上面的例子中我们将字符串转换为不同类型的对象。</p>


<pre><code>p "12".to_i
p "13".to_f
p "12".to_r
p "13".to_c
</code></pre>


<p>这里将字符串转换成整数、小数、有理数和复数。</p>


<pre><code>p "Jane".to_sym
</code></pre>


<p>将字符串变为符号标志。</p>


<pre><code>v = "Ruby Python Tcl PHP Perl".split
p v.class
</code></pre>


<p>使用字符串的<em>split</em>方法将字符串转换成数组。</p>


<p>$ ./stringconv.rb<br>
12<br>
13.0<br>
(12/1)<br>
(13+0i)<br>
:Jane<br>
Array  </p>


<p>输出结果。</p>


<hr>


<p>下面的小例子展示了数组哈希表的转换。</p>


<pre><code>#!/usr/bin/ruby

h = {:de =&gt; "Germany", :sk =&gt; "Slovakia"}
p h.to_a

a = [:de, "Germany", :sk, "Slovakia", 
     :hu, "Hungary", :no, "Norway"]
p Hash[*a]
</code></pre>


<p>这个例子的代码我们创建了一个哈希表并转换成数组，创建一个数组并转换成哈希表。</p>


<pre><code>h = {:de =&gt; "Germany", :sk =&gt; "Slovakia"}
p h.to_a
</code></pre>


<p>哈希表转换为数组使用<em>to_a</em>方法。</p>


<pre><code>a = [:de, "Germany", :sk, "Slovakia", 
     :hu, "Hungary", :no, "Norway"]
p Hash[*a]
</code></pre>


<p>将数组转换成哈希表。在这里的上下文中使用了星号操作符。这个风格来自<em>Perl</em>。它将一个数组分割成多个变量。</p>


<p>$ ./h2a.rb<br>
[[:de, &#8220;Germany&#8221;], [:sk, &#8220;Slovakia&#8221;]]<br>
{:de=&gt;&#8221;Germany&#8221;, :sk=&gt;&#8221;Slovakia&#8221;, :hu=&gt;&#8221;Hungary&#8221;, :no=&gt;&#8221;Norway&#8221;}  </p>


<p>输出结果。</p>


<p>这章在教程覆盖了数据类型和它们的转换。</p>


<hr>


<p>原文地址： <a href="http://zetcode.com/lang/rubytutorial/datatypes/">http://zetcode.com/lang/rubytutorial/datatypes/</a><br>
翻译：龙昌  admin@longchangjin.cn<br>
完整教程：<a href="https://github.com/wusuopu/Ruby-tutorial">https://github.com/wusuopu/Ruby-tutorial</a>  </p>

</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
    <h1 class="entry-title"><a href="http://www.xefan.com/archives/83909.html">[翻译]Ruby教程5——对象</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2013-11-06T00:00:00+08:00'><span class='date'><span class='date-month'>Nov</span> <span class='date-day'>6</span><span class='date-suffix'>th</span>, <span class='date-year'>2013</span></span> <span class='time'>12:00 am</span></time>
        
           | <a href="http://www.xefan.com/archives/83909.html#disqus_thread"
             data-disqus-identifier="http://www.xefan.com/archives/83909.html">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><h1>Ruby中的对象</h1>


<p>在这章的教程中我们将简要的介绍下Ruby语言对象的概念。更多的内容将会在面向对象的章节中学习。由于Ruby的许多特性可以会使新手们迷惑，尤其是已经学习过其他编程语言的，因此才编写了这个关于对象的预备章节。</p>


<p>Ruby是一门面向对象的编程语言。这意味着我们可以在Ruby语言中使用对象。对于语言程序员来说Ruby程序就是一些字符流。这些符号就是Ruby的关键字、操作符、变量符号和字面量。从语言的角度来看Ruby程序是由对象组成的。这些对象在Ruby脚本程序执行进程来创建和修改。</p>


<p>有两种类型的对象：内置对象和自定义对象。内置对象是所有程序员都可以使用的预定义对象。它们由Ruby语言的内核或者变量库提示。自定义对象是由应用程序开发者在他们的应用程序域中创建的。</p>


<p>所有的对象都必须在使用之前创建。我们把创建对象叫做对象实例化。对象是由数据和方法组成，数据是对象静态的部分，方法是动态的形式。对象的修改以及与其他对象通信都是通过方法进行的。</p>


<pre><code>#!/usr/bin/ruby
puts "Ruby language"
</code></pre>


<p>以上是一个简单的Ruby脚本。如果我们熟悉Pascal或者C之类的程序语言，我们可以看到一个名为<em>puts</em>的关键字或者是一个函数和一个字符串参数<em>&#8220;Ruby language&#8221;</em>。</p>


<p>看起来有点不同，Ruby是一门纯面向对象语言。<em>&#8220;Ruby language&#8221;</em>确实是一个字符串，常见的一种数据类型。但是它也是一个对象。与所有的对象一样，我们可以调用它们的方法。这与其他的语言有点不同。<em>puts</em>是一个方法。方法是定义在一个对象中的函数。方法是不能独自存在的。实际上<em>puts</em>方法是<em>Kernel</em>模块的一部分。</p>


<pre><code>#!/usr/bin/ruby
Kernel.puts "Ruby language"
Kernel.puts "Ruby language".size
</code></pre>


<p>在以上的脚本中我们写了两行代码。</p>


<pre><code>Kernel.puts "Ruby language"
</code></pre>


<p><em>Kernel</em>是可以省略的，在第一个例子中我们调用<em>puts</em>方法就没有使用<em>Kernel</em>。这样可以少打些字节约时间。实际上它是对于<em>Kernel.puts</em>这个正式调用的简写。正如在C#中的Console.writeln和Java中的System.println。因此方法必须与一个对象相关联，或者如果是类方法就必须与类相关联。</p>


<pre><code>Kernel.puts "Ruby language".size
</code></pre>


<p>在这行代码中我们在终端上打印了<em>&#8220;Ruby language&#8221;</em>这个字符串的长度。对于有其他编程语言经验的程序员来说可能会困惑。在其他语言中字符串是一个原始数据类型，不能修改，并且没有自己的方法。在Ruby中字符串是一个完整的对象，有自己的方法。<em>size</em>方法其中一个，用于返回这个字符串的长度。</p>


<p>$ ./simple2.rb<br>
Ruby language<br>
13  </p>


<p>以上是这个例子的输出。</p>


<hr>


<p>接下来的例子我们看看整数。与字符串相似一个数字也是一个对象。</p>


<pre><code>#!/usr/bin/ruby
puts 6.object_id
puts 6.even?
puts 6.zero?
puts 6.class
</code></pre>


<p>这个例子中我们定义了一个数字<em>6</em>。然后调用了一些这个数字的方法。</p>


<pre><code>puts 6.object_id
</code></pre>


<p>这里<em>6</em>是一个对象，<em>object_id</em>是一个方法。这个方法返回了与这个对象相关联的id号。每个对象都拥有一个id号。如果我们要在对象上调用一个方法，就必须在他们之间加点号。</p>


<pre><code>puts 6.even?
puts 6.zero?
</code></pre>


<p>这里我们对<em>6</em>这个对象调用了两个方法。如果一个数是偶数，那么<em>even?</em>返回<em>true</em>；如果一个数等于0,那么<em>zero?</em>返回<em>true</em>。注意这两个方法都是以问号能结尾的。在Ruby中约定了如果一个方法返回值是布尔类型，那么方法名以问号结尾。</p>


<pre><code>puts 6.class
</code></pre>


<p><em>class</em>方法告诉我们当前正在处理的这个对象是什么类型的。在这里<em>6</em>是一个<em>Fixnum</em>类型。</p>


<p>$ ./objectnumber.rb<br>
13<br>
true<br>
false<br>
Fixnum  </p>


<p>以上是这个例子的输出结果。</p>


<h2>创建对象</h2>


<p>我们之前提到了在Ruby是对象使用之前必须先创建。对象可以被隐式创建或者显式创建。使用字面量符号创建对象是隐式创建；使用<em>new</em>关键字创建对象是显式创建。自定义对象都是显式创建的。自定义对象必须是从某个特定的类创建的。类是对象的模块，一个类可以创建多个对象。</p>


<pre><code>#!/usr/bin/ruby
class Being
end

puts 67
puts "ZetCode"

s = String.new "ZetCode"
puts s

# n1 = Fixnum.new 67
# puts n1

b = Being.new
puts b
</code></pre>


<p>这个例子演示了Ruby中的对象创建。</p>


<pre><code>class Being
end
</code></pre>


<p>这里是一个名为<em>Being</em>的对象模块。对象模块使用<em>class</em>关键字创建。自定义对象模块通常放在代码文件的顶部，或者分开放在另外的文件中。</p>


<pre><code>puts 67
puts "ZetCode"
</code></pre>


<p>这两行代码我们用到了两个对象。<em>Fixnum</em>类型的<em>67</em>和<em>String</em>类型的<em>&#8220;ZetCode&#8221;</em>。<em>67</em>和<em>&#8220;ZetCode&#8221;</em>是使用字面符号创建了。字面符号是一个文本，表示了一个类型的特定值。这两个对象是Ruby解释器幕后创建的。在源代码中Ruby的一些对象是使用他们特定的字面符号创建的。</p>


<pre><code>s = String.new "ZetCode"
puts s
</code></pre>


<p>这是正式的方法创建字符串对象。它与之前的隐式创建是等价的。</p>


<pre><code># n1 = Fixnum.new 67
# puts n1
</code></pre>


<p>不是所有的内置对象都可以使用<em>new</em>方法来创建。以上代码就不能编译通过。<em>Fixnum</em>对象只能通过字面符号来创建。</p>


<pre><code>b = Being.new
puts b
</code></pre>


<p>这里我们创建了自定义对象的一个实例。<em>puts</em>方法输出了这个对象的简短描述。</p>


<p>$ ./ocreation.rb<br>
67<br>
ZetCode<br>
ZetCode<br>
#&lt;Being:0x9944d9c>  </p>


<p>以上是输出结果。</p>


<hr>


<p>继续介绍一些正式的对象创建。  </p>


<pre><code>#!/usr/bin/ruby

s1 = String.new "Ruby"
puts s1.size
puts s1.downcase

a1 = Array.new 
a1.push 1, 2, 3
puts a1.include? 3
puts a1.empty?

r1 = Range.new 1, 6
puts r1.class
puts r1.include? 4
</code></pre>


<p>在这个例子中，我们创建三个内建对象并且调用了几个它们的方法。</p>


<pre><code>s1 = String.new "Ruby"
puts s1.size
puts s1.downcase
</code></pre>


<p>创建一个字符串对象，并且调用了它的两个方法。<em>size</em>方法返回这个字符串的长度。<em>downcase</em>方法将这个字符串转为小写。</p>


<pre><code>a1 = Array.new 
a1.push 1, 2, 3
puts a1.include? 3
puts a1.empty?
</code></pre>


<p>这里创建了一个数组，并往其中添加了三个数字。然后调用了两个数组的方法。<em>include?</em>方法用于检查一个特定的值（在这个例子中是3）是否在数组内。<em>empty?</em>方法返回一个布尔类型的值表明这个数组是否为空。</p>


<pre><code>r1 = Range.new 1, 6
puts r1.class
puts r1.include? 4
</code></pre>


<p>创建了一个<em>Range</em>类型的实例对象。它包含了1到6的数字。<em>class</em>方法返回这个对象的类型名称。在这个例子中<em>include?</em>方法检查数字<em>4</em>是否在这个范围内。</p>


<p>$ ./formal.rb<br>
4<br>
ruby<br>
true<br>
false<br>
Range<br>
true  </p>


<p>这个例子的运行输出结果。</p>


<h2>对象字面符</h2>


<p>前面提到了一些内建对象可以使用对象字面符创建。接下来的例子展示了一些对象字面符。</p>


<pre><code>#!/usr/bin/ruby

4.times { puts "Ruby" }

puts "Ruby".size
puts "Ruby".downcase

puts [1, 2, 3].include? 3
puts [1, 2, 3].empty?

puts :name.class
puts :name.frozen?

puts (1..6).class
puts (1..6).include? 4
</code></pre>


<p>在这个例子中我们使用字面符创建了<em>Fixnum</em>、<em>Strings</em>、<em>Arrays</em>、 <em>Symbols</em>和<em>Ranges</em>对象。</p>


<pre><code>4.times { puts "Ruby" }
</code></pre>


<p>我们可以直接对一个整数字面符号调用方法。这行代码将在终端上打印4次&#8221;Ruby&#8221;字符串。</p>


<pre><code>puts "Ruby".size
puts "Ruby".downcase
</code></pre>


<p>我们对使用字面符号创建的字符串调用了两个方法。</p>


<pre><code>puts [1, 2, 3].include? 3
puts [1, 2, 3].empty?
</code></pre>


<p>这里我们使用字面符号创建了两个数组。然后使用<em>include?</em>方法检查一个特定的数字是否是这个数组里；使用<em>empty?</em>方法检查这个数组是否为空。</p>


<pre><code>puts :name.class
puts :name.frozen?
</code></pre>


<p>使用以冒号开头的字面符号创建了符号对象，并且调用的它的两个方法。</p>


<pre><code>puts (1..6).class
puts (1..6).include? 4
</code></pre>


<p>使用字面符号创建了两个范围对象，并且调用了他们的两个方法。<em>class</em>方法返回这个类的名称，<em>include?</em>方法检查给定的数字是否是这个范围内。</p>


<p>$ ./literals.rb<br>
Ruby<br>
Ruby<br>
Ruby<br>
Ruby<br>
4<br>
ruby<br>
true<br>
false<br>
Symbol<br>
false<br>
Range<br>
true  </p>


<p>以上是例子的输出结果。</p>


<h2>对象层级</h2>


<p>在许多面向对象语言中对象是层级形式的。Ruby中也有对象层级。与树形层级相似，我们也有父对象和子对象。对象从它的父对象中继承数据和行为。层级的顶级是根对象，称为<em>Object</em>。在Ruby中每个对象都至少有一个父对象。也就是就每个对象都继承至<em>Object</em>对象的基类。</p>


<p>根据Ruby的官方文档，<em>Object</em>是Ruby的类层级的根。它的所有方法在所有的类中都是一样的，除非显示的覆盖了。</p>


<pre><code>#!/usr/bin/ruby

puts 4.is_a? Object
puts "Ruby".is_a? Object
puts [2, 3].is_a? Object
puts :name.is_a? Object
puts (1..2).is_a? Object
</code></pre>


<p>以上例子的代码展示了所有对象都是继承至根对象<em>Object</em>。</p>


<pre><code>puts 4.is_a? Object
</code></pre>


<p>使用<em>is_a?</em>方法检查一个数字是否为特定的类型，也就是说它是否继承至给定的对象类型。</p>


<p>$ ./mother.rb <br>
true<br>
true<br>
true<br>
true<br>
true  </p>


<p>所有方法都返回<em>true</em>，意味着所有的对象都继承至母类。</p>


<hr>


<p>即使是基本的Ruby对象，它们的继承层级也可能是很复杂的。</p>


<pre><code>#!/usr/bin/ruby

puts 6.class

puts 6.is_a? BasicObject
puts 6.is_a? Object
puts 6.is_a? Numeric
puts 6.is_a? Integer
puts 6.is_a? Fixnum

puts 6.is_a? Bignum
puts 6.is_a? String
</code></pre>


<p>这个例子展示了小数字的继承层级。</p>


<pre><code>puts 6.class
</code></pre>


<p>我们发现数字6的类型是<em>Fixnum</em>。</p>


<pre><code>puts 6.is_a? BasicObject
puts 6.is_a? Object
puts 6.is_a? Numeric
puts 6.is_a? Integer
puts 6.is_a? Fixnum
</code></pre>


<p>以上这些代码全都返回<em>true</em>。数字6是<em>Fixnum</em>类型。从Ruby文档中我们发现另外四个对象是<em>Fuxnum</em>对象的父类。</p>


<pre><code>puts 6.is_a? Bignum
puts 6.is_a? String
</code></pre>


<p>$ ./inheritance.rb<br>
Fixnum<br>
true<br>
true<br>
true<br>
true<br>
true<br>
false<br>
false  </p>


<p>以上是输出结果。</p>


<hr>


<p>这节的最后再举个例子展示下自定义对象的继承。</p>


<pre><code>#!/usr/bin/ruby

class Being

    def to_s
        "This is Being"
    end

    def get_id
        9
    end
end

class Living &lt; Being

    def to_s
        "This is Living"
    end
end

l = Living.new

puts l
puts l.get_id
puts l.is_a? Being
puts l.is_a? Object
puts l.is_a? BasicObject
</code></pre>


<p>在这个例子中我们创建了两个对象。<em>Being</em>和<em>Living</em>。<em>Living</em>对象继承至<em>Being</em>。第一个是父对象，第二介是子对象。</p>


<pre><code>class Being

    def to_s
        "This is Being"
    end

    def get_id
        9
    end
end
</code></pre>


<p>这里定义了一个Ruby的自定义对象。定义内容是<em>class</em>和<em>end</em>关键字之间。在定义里我们创建了两个方法。当<em>puts</em>方法接了一个对象作为参数时，会调用它的<em>to_s</em>方法。它通常返回这个对象的字符串描述。</p>


<pre><code>class Living &lt; Being

    def to_s
        "This is Living"
    end
end
</code></pre>


<p>定义了一个<em>Living</em>对象，这个对象继承至<em>Being</em>对象。<em>&lt;</em>操作符用于创建继承关系。<em>to_s</em>方法被覆盖了。</p>


<pre><code>l = Living.new
</code></pre>


<p>我们创建了一个Living实例对象。自定义对象使用<em>new</em>关键字创建。</p>


<pre><code>puts l
</code></pre>


<p><em>puts</em>方法调用<em>Living</em>对象的<em>to_s</em>方法。只有当<em>Living</em>类没有定义<em>to_s</em>方法时，<em>Being</em>类的<em>to_s</em>方法才会被调用。</p>


<pre><code>puts l.get_id
</code></pre>


<p><em>Living</em>对象没有定义<em>get_id</em>方法。在这种情况下就检查它的父类是否有此方法。在这里<em>Being</em>有这个方法，并且被调用。</p>


<pre><code>puts l.is_a? Being
</code></pre>


<p>这行将返回<em>true</em>。<em>Living</em>对象是<em>Being</em>类型的，因为它继承至<em>Being</em>类。</p>


<pre><code>puts l.is_a? Object
puts l.is_a? BasicObject
</code></pre>


<p>我们的<em>Living</em>自定义对象中，没有特别显示的指定与<em>Object</em>或者<em>BasicObject</em>的关系。然而这两行也返回<em>true</em>。这是因为在Ruby中所有对象都是自动设置为这两个对象的后代。这是Ruby解释器在幕后完成的。</p>


<p>$ ./custominher.rb<br>
This is Living<br>
9<br>
true<br>
true<br>
true  </p>


<p>以上是输出结果。</p>


<h2>Ruby的顶级环境</h2>


<p>Ruby中有一个特殊的对象引用到Ruby的顶级环境，这是定义在其他上下文之外的默认执行环境。顶级环境名字是<em>main</em>。它是一个<em>Object</em>类型的实例对象。以下<em>main</em>分配了一个局部空间，所有的局部变量有属于它。</p>


<pre><code>#!/usr/bin/ruby

n1 = 3
n2 = 5

puts local_variables

Kernel.puts self
puts self.class
</code></pre>


<p>这是描述Ruby顶级环境的第一个例子。</p>


<pre><code>n1 = 3
n2 = 5
</code></pre>


<p>我们定义了两个数字类型的变量，这些变量是顶级环境的局部变量。</p>


<pre><code>puts local_variables
</code></pre>


<p>这里我们输出所有的局部变量。<em>local_variables</em>是<em>Kernel</em>模块的一个方法，它包含了每个顶级环境的对象。</p>


<pre><code>Kernel.puts self
</code></pre>


<p><em>self</em>是Ruby的伪变量。它返回当前对象的接收者。这行将在终端打印<em>&#8220;main&#8221;</em>。这是顶级环境的名字。<em>Kernel.puts</em>代码部分的<em>Kernel</em>可以省略。完整的名字表示的<em>puts</em>方法属于<em>Kernel</em>模块。</p>


<pre><code>puts self.class
</code></pre>


<p>这行打印了顶级环境的类型。我们得到顶级环境的对象类型。它是<em>Object</em>类型，Ruby类层级的根。</p>


<p>$ ./toplevel.rb<br>
n1<br>
n2 <br>
main <br>
Object  </p>


<p>这是这个例子的输出结果。<em>n1</em>、<em>n2</em>是顶级环境所分配的局部变量。<em>main</em>是Ruby顶级执行环境的名字。最后<em>Object</em>是顶级环境的类型。</p>


<hr>


<p>我们再展示另一个关于Ruby顶级环境的例子。</p>


<pre><code>#!/usr/bin/ruby

@name = "Jane"
@age = 17

def info
   "#{@name} is #{@age} years old" 
end

puts self.instance_variables
puts self.private_methods.include? :info

puts info
</code></pre>


<p>我们展示的属于顶级环境的实例变量和方法。</p>


<pre><code>@name = "Jane"
@age = 17
</code></pre>


<p>我们定义了两个实例变量。在Ruby中实例变量以<em>@</em>符号开头。实例变量属于指定的对象实例。在这里是属于Ruby的顶级环境。</p>


<pre><code>def info
   "#{@name} is #{@age} years old" 
end
</code></pre>


<p>这里定义了一个方法。每个方法都必须属于一个对象。这个方法是属于顶级环境的。所有顶级环境的方法都是私有的。私有方法的访问是受制的。</p>


<pre><code>puts self.instance_variables
</code></pre>


<p><em>instance_variables</em>方法打印<em>self</em>的所有实例变量。</p>


<pre><code>puts self.private_methods.include? :info
</code></pre>


<p>所有的顶级环境的方法都自动设为私有。<em>private_methods</em>返回该对象所有的私有方法。由于内容太多，我们就调用<em>include?</em>方法来检查<em>info</em>方法是否是其中一个。注意我们是通过符号名来引用<em>info</em>的。</p>


<p>$ ./toplevel2.rb<br>
@name<br>
@age<br>
true<br>
Jane is 17 years old  </p>


<p>以上是例子的输出结果。</p>


<p>这章包含了Ruby对象的基本内容。</p>


<hr>


<p>原文地址： <a href="http://zetcode.com/lang/rubytutorial/objects/">http://zetcode.com/lang/rubytutorial/objects/</a><br>
翻译：龙昌  admin@longchangjin.cn<br>
完整教程：<a href="https://github.com/wusuopu/Ruby-tutorial">https://github.com/wusuopu/Ruby-tutorial</a>  </p>

</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
    <h1 class="entry-title"><a href="http://www.xefan.com/archives/83905.html">[翻译]Ruby教程4——变量</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2013-11-05T00:00:00+08:00'><span class='date'><span class='date-month'>Nov</span> <span class='date-day'>5</span><span class='date-suffix'>th</span>, <span class='date-year'>2013</span></span> <span class='time'>12:00 am</span></time>
        
           | <a href="http://www.xefan.com/archives/83905.html#disqus_thread"
             data-disqus-identifier="http://www.xefan.com/archives/83905.html">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><h1>变量</h1>


<p>在这章的教程中我们将详细介绍变量。  </p>


<p>变量是保存数据的地址。每个变量都有唯一的一个名字，变量命名存在着一些约定。变量保存着数据对象，更确切的说变量是对数据所在的计算机内存地址的引用。每一个对象都具有一定的数据类型，内置的类型或者自定义的类型。Ruby属于动态语言，与Java、C或者Pascal之类的强类型语言不同，动态语言不用为变量定义确切数据类型，而是解释器在分配变量时决定它的类型。在Ruby中程序运行过程变量可以包含不同类型的不同值。</p>


<blockquote>
<p>#!/usr/bin/ruby  </p>
<p>i = 5<br>
 puts i<br>
 i = 7<br>
 puts i  </p>
</blockquote>


<p>变量是可变的，与常量不同，在程序运行过程中它们可以保存不同的值。在上面这个例子中有一个名为<em>i</em>的变量，首先赋值为5,然后又改为7。</p>


<h2>命名约定</h2>


<p>与其他语言一样，Ruby对变量标识符也有些命名约定。<br>
Ruby是区分大小写的，这意味着<em>age</em>和<em>Age</em>是两个变量名。许多语言都是区分大小写的，但是BASIC例外。我们改变字符的大小写可以创建不同的变量，但是不推荐这种做法。</p>


<blockquote>
<p>#!/usr/bin/ruby  </p>
<p>i = 5<br>
 p i<br>
 I = 7<br>
 p I  </p>
</blockquote>


<p>这个例子定义了两个变量<em>I</em>和<em>i</em>，它们保存了不同的值。</p>


<p>./case.rb<br>
5<br>
7  </p>


<p>以上是<em>case.rb</em>脚本的输出结果。</p>


<hr>


<p>在Ruby中变量名可由字母数字和下划线组成。为了使解释器能简单的从字面上区分数字和变量，变量名不能以数字开头。变量名同样也不能以大写字母开头，在Ruby中以大写字母开头会被认为是常量。</p>


<blockquote>
<p>#!/usr/bin/ruby  </p>
<p>name = &#8220;Jane&#8221;<br>
 placeOfBirth = &#8220;Bratislava&#8221;<br>
 placeOfBirth = &#8220;Kosice&#8221;<br>
 favorite_season = &#8220;autumn&#8221;  </p>
<p>n1 = 2<br>
 n2 = 4<br>
 n3 = 7  </p>
<p>p name, placeOfBirth, favorite_season<br>
 p n1, n2, n3  </p>
</blockquote>


<p>在这个脚本中我们展示一些变量的命名。</p>


<hr>


<p>变量名应该是有意义的。好的编程习惯是给变量取个具有描述性的名字，使得程序更加可读。</p>


<pre><code>#!/usr/bin/ruby

name = "Jane"
place_of_birth = "Bratislava"
occupation = "student"

i = 5
while i &gt; 0 do
    puts name
    i -= 1
end
</code></pre>


<p>这个脚本展示三个具有描述性的变量名。对于程序员来说<em>place_of_birth</em>比其他的名字如<em>pob</em>更具有描述性。在循环的时候通常选择一个比较简单的变量名。</p>


<h2>印章(Sigils)</h2>


<p>变量标识符可以以一些特殊的印章（Sigils）符号开头。印章（Sigils）是附加在标识符上的符号。在Ruby中变量印章（Sigils）表示了变量的作用域范围。在Perl中它是表示数据的类型。Ruby的变量印章（Sigils）符号有<em>$</em>和<em>@</em>。  </p>


<blockquote>
<p>#!/usr/bin/ruby  </p>
<p>tree_name = &#8220;pine&#8221;<br>
 $car_name = &#8220;Peugeot&#8221;<br>
 @sea_name = &#8220;Black sea&#8221;<br>
 @@species = &#8220;Cat&#8221;  </p>
<p>p local_variables<br>
 p global_variables.include? :$car_name<br>
 p self.instance_variables<br>
 p Object.class_variables  </p>
</blockquote>


<p>我们定义了四个不同作用域范围的变量。作用域表示了该变量可以被引用到的范围。我们使用了内置的方法来决定变量的作用域。</p>


<blockquote>
<p>tree_name = &#8220;pine&#8221;  </p>
</blockquote>


<p>不包含印章（Sigils）符号的变量是一个局部变量。局部变量只在局部有效，如在方法、代码块、模块内。</p>


<blockquote>
<p>$car_name = &#8220;Peugeot&#8221;  </p>
</blockquote>


<p>全局变量以<em>$</em>符号开头。它们在所有地方都是有效的。在程序中不要滥用全局变量。</p>


<blockquote>
<p>@sea_name = &#8220;Black sea&#8221;  </p>
</blockquote>


<p>实例变量是以<em>@</em>符号开头。它只有在实例对象中才有效。</p>


<blockquote>
<p>@@species = &#8220;Cat&#8221;  </p>
</blockquote>


<p>最后我们定义了一个类变量。它在所有属于这个类的实例中都有效。</p>


<blockquote>
<p>p local_variables  </p>
</blockquote>


<p><em>local_variables</em>是保存了当前环境下所有定义的局部变量的数组。</p>


<blockquote>
<p>p global_variables.include? :$car_name  </p>
</blockquote>


<p>类似的，<em>global_variables</em>是保存的全部全局变量的数组。由于全局变量很多，我们就不将它们全部在终端上打印了。每次Ruby脚本启动时都会预定义一些变量。我们使用数组的<em>include?</em>方法来检查我们全局变量是否定义了。同时请注意我们引用变量是用的符号。（符号是以一个冒号开头）</p>


<blockquote>
<p>p self.instance_variables  </p>
</blockquote>


<p><em>self</em>伪变量指向了<em>instance_variables</em>方法的接收对象。这个例子中的接收对象是<em>main</em>，Ruby的顶级执行区域。</p>


<blockquote>
<p>p Object.class_variables </p>
</blockquote>


<p>最后我们获取所有的类变量数组。<em>main</em>是一个Object类的实例。</p>


<p>$ ./sigils.rb<br>
[:tree_name]<br>
true<br>
[:@sea_name]<br>
[:@@species]  </p>


<p>以上是这个例子的输出结果，我们看到了变量的符号名。</p>


<h2>局部变量</h2>


<p>局部变量是只在Ruby源代码的局部区域有效。这个区域也称为局部作用域。局部变量是在Ruby的模块、方法、类中定义。</p>


<pre><code>#!/usr/bin/ruby

def method1
   x = 5
   p x    
end

method1

p x
</code></pre>


<p>我们定义了一个名为<em>method1</em>的方法，它有一个变量。这个变量是局部变量。这意味着这个变量只在这个方法内有效。我们只能在这个方法名到<em>end</em>关键字之间访问<em>x</em>变量。</p>


<pre><code>def method1
   x = 5
   p x    
end
</code></pre>


<p>以上定义了一个<em>method1</em>方法。在方法内部创建了一个局部变量<em>x</em>，然后将它的值打印到终端。</p>


<blockquote>
<p>method1  </p>
</blockquote>


<p>方法被调用。</p>


<blockquote>
<p>p x  </p>
</blockquote>


<p>我们试图在方法外部访问这个局部变量。这将导致<em>NameError</em>错误，Ruby解释器找不到这个标识符。</p>


<p>$ ./locals.rb<br>
5<br>
./locals.rb:11:in <code>&lt;main&gt;': undefined local variable   
or method</code>x&#8217; for main:Object (NameError)  </p>


<p>以上是这个例子的输出结果。</p>


<hr>


<p>以下例子是对前一个例子的简单修改。</p>


<pre><code>#!/usr/bin/ruby

x = 5

def method1
    x = 10
    p x
end

method1

p x
</code></pre>


<p>我们定义了两个<em>x</em>变量。一个是在<em>method1</em>内部定义的，另一个是在外部定义的。他们是两个不同的局部变量，并不会相互冲突。</p>


<pre><code>x = 5
</code></pre>


<p>我们创建了一个局部变量，它的值为5。这个变量的局部作用范围是<em>main</em>区域。它在<em>method1</em>内部是无效的。  </p>


<pre><code>def method1  
    x = 10  
    p x  
end
</code></pre>


<p>在<em>method1</em>内部创建了一个新的<em>x</em>局部变量，它的值是10.它存在于<em>method1</em>方法内部，在<em>end</em>关键字之后就会失效。</p>


<p>$ ./locals2.rb<br>
10<br>
5  </p>


<p>以上是输出结果。</p>


<hr>


<p>如果一个方法接收了参数，那么就会创建与这些参数相对应的局部变量。  </p>


<pre><code>#!/usr/bin/ruby


def rectangle_area a, b
    puts local_variables
    return a * b
end

puts rectangle_area 5, 6
</code></pre>


<p>我们定义了一个方法，它接收两个值，然后返回这个矩形的面积。</p>


<pre><code>def rectangle_area a, b
    puts local_variables
    return a * b
end
</code></pre>


<p><em>rectangle_area</em>方法接收两个参数。它们是矩形的边长，然后我们计算它的面积。对应于标识符<em>a</em>、<em>b</em>的两个局部变量将自动创建了。我们调用<em>local_variables</em>方法查看方法内部的所有局部变量。</p>


<pre><code>puts rectangle_area 5, 6
</code></pre>


<p>这里我们给<em>rectangle_area</em>方法传了两个值。这两个值将会分配给在方法内部创建的两个局部变量。  </p>


<p>$ ./parameters.rb<br>
a<br>
b<br>
30  </p>


<p>输出了三个结果。前两个是<em>rectangle_area</em>方法内部的局部变量名。第三个是面积的计算结果。</p>


<hr>


<p>一个方法可以定义在另一个方法的内部。内嵌方法有它自己的局部变量。</p>


<pre><code>#!/usr/bin/ruby

def method1

    def method2

        def method3
            m5, m6 = 3
            puts "Level 3"
            puts local_variables
        end

        m3, m4 = 3
        puts "Level 2"
        puts local_variables
        method3    
    end

    m1, m2 = 3
    puts "Level 1"
    puts local_variables
    method2

end

method1
</code></pre>


<p>在这个Ruby脚本中我们创建了三个方法。<em>method2</em>和<em>method3</em>是内嵌方法。<em>method2</em>定义在<em>method1</em>内部，<em>method3</em>又定义在<em>method2</em>内部。每一个方法的局部变量仅在这个方法内是可访问的。</p>


<p>$ ./lms.rb<br>
Level 1<br>
m1<br>
m2<br>
Level 2<br>
m3<br>
m4<br>
Level 3<br>
m5<br>
m6  </p>


<p>从输出结果我们可以知道<em>method1</em>有两个局部变量<em>m1</em>和<em>m2</em>。内嵌方法<em>method2</em>的局部变量有<em>m3</em>、<em>m4</em>。最内部的方法<em>method3</em>的局部变量是<em>m5</em>、<em>m6</em>。  </p>


<hr>


<p>这一节的最后一个例子将展示一些局部作用域的示范。</p>


<pre><code>module ModuleM
    m1, m2 = 4

    puts "Inside module"
    puts local_variables        
end


def method1
    v, w = 3
    puts "Inside method"
    puts local_variables
end


class Some
    x, y = 2
    puts "Inside class"
    puts local_variables
end

method1

t1, t2 = 7

puts "Inside toplevel"
puts local_variables
</code></pre>


<p>在这个例子我们分别在模块、方法、类和顶级环境中创建局部变量。<em>local_variables</em>是内核模块的一个方法，用于获取当前的所有局部变量。</p>


<pre><code>module ModuleM
    m1, m2 = 4

    puts "Inside module"
    puts local_variables        
end
</code></pre>


<p>模块是一个方法和常量的集合。我们创建了两个局部变量<em>m1</em>和<em>m2</em>。</p>


<pre><code>def method1
    v, w = 3
    puts "Inside method"
    puts local_variables
end
</code></pre>


<p>在<em>method1</em>方法中创建了两个局部变量<em>v</em>、<em>w</em>。</p>


<pre><code>class Some
    x, y = 2
    puts "Inside class"
    puts local_variables
end
</code></pre>


<p>在<em>Some</em>类中创建了两个局部变量<em>x</em>、<em>y</em>。</p>


<pre><code>t1, t2 = 7
</code></pre>


<p>最后我们为Ruby顶级环境创建两个局部变量。</p>


<p>$ ./locals3.rb <br>
Inside module<br>
m1<br>
m2<br>
Inside class<br>
x<br>
y<br>
Inside method<br>
v<br>
w<br>
Inside toplevel<br>
t1<br>
t2  </p>


<p>输出结果展示了各个作用域的局部变量。</p>


<h2>全局变量</h2>


<p>全局变量可以在脚本的任何地方访问到。它们以<em>$</em>符号开头。<br>
全局变量可能会引起很多程序错误，因此不鼓励使用全局变量。除非有原因要使用，否则建议使用局部变量。</p>


<pre><code>#!/usr/bin/ruby

$gb = 6


module ModuleM        
    puts "Inside module"
    puts $gb
end


def method1
    puts "Inside method"
    puts $gb
end


class Some
    puts "Inside class"
    puts $gb
end

method1

puts "Inside toplevel"
puts $gb
puts global_variables.include? :$gb
</code></pre>


<p>在这个例子中我们创建了一个全局变量<em>$gb</em>。这个变量在模块、方法、类和顶级环境都可以访问。全部变量<em>$gb</em>是所有的实体中都是有效的。</p>


<pre><code>$gb = 6
</code></pre>


<p>创建全局变量<em>$gb</em>，它的值为6。</p>


<pre><code>module ModuleM        
    puts "Inside module"
    puts $gb
end
</code></pre>


<p>在一个模块定义中我们打印全局变量的值。</p>


<pre><code>def method1
    puts "Inside method"
    puts $gb
end
</code></pre>


<p>在一个方法定义中我们打印全局变量的值。</p>


<pre><code>class Some
    puts "Inside class"
    puts $gb
end
</code></pre>


<p>在一个类定义中我们打印全局变量的值。</p>


<pre><code>puts $gb
puts global_variables.include? :$gb
</code></pre>


<p>在顶级环境下打印全局变量的值，并检查这个变量是否为全局变量。</p>


<p>$ ./globals.rb<br>
Inside module<br>
6<br>
Inside class<br>
6<br>
Inside method<br>
6<br>
Inside toplevel<br>
6<br>
true  </p>


<p>这个例子的输出结果确认了全局变量可以任何地方访问到。  </p>


<hr>


<p>当一个Ruby脚本启动时，它会访问多个预定义的全局变量。这些全局变量不认为有害并且能帮助完成一些常见的任务。</p>


<pre><code>#!/usr/bin/ruby

p $LOAD_PATH
p $:
</code></pre>


<p>这个脚本显示了<em>$LOAD_PATH</em>这个全局变量。这个变量列出了<em>require</em>方法会搜索的所有目录。<em>$:</em>是<em>$LOAD_PATH</em>的缩写。<br>
更多的全局变量会在本章的变量预定义这节中介绍。</p>


<h2>实例变量、类变量</h2>


<p>在这节将简要的介绍下实例变量和类变量。它们将会在面向对象那一章详细介绍。<br>
实例变量是属于具体某个对象实例的变量。每个对象都有它自己的变量。实例变量以<em>@</em>符号开头。类变量属于特定某个类的。这个类所创建的对象实例共享这个类的类变量。类变量以<em>@@</em>符号开头。</p>


<pre><code>#!/usr/bin/ruby

class Being

    @@is = true

    def initialize nm
        @name = nm
    end

    def to_s
        "This is #{@name}"
    end

    def does_exist?
        @@is
    end
end

b1 = Being.new "Being 1"
b2 = Being.new "Being 2"
b3 = Being.new "Being 3"

p b1, b2, b3

p b1.does_exist?
p b2.does_exist?
p b3.does_exist?
</code></pre>


<p>我们创建一个自定义<em>Being</em>类。这个<em>Being</em>类有一个类变量和一个实例变量。</p>


<pre><code>class Being        
    @@is = true
</code></pre>


<p><em>@@is</em>是一个类变量。这个类变量被所有<em>Being</em>类的实例所共享。这个例子的逻辑是判断是不是<em>Being</em>。</p>


<pre><code>def initialize nm
    @name = nm
end
</code></pre>


<p><em>initialize</em>方法是构造函数。这个方法在对象被创建时调用。用于创建<em>@name</em>实例变量。  </p>


<pre><code>def to_s
    "This is #{@name}"
end
</code></pre>


<p>当这个对象作为打印方法如p或者puts的参数时<em>to_s method</em>方法会被调用。这个方法返回这个对象便于人类阅读的描述内容。  </p>


<pre><code>def does_exist?
    @@is
end
</code></pre>


<p><em>does_exist?</em>返回类变量。</p>


<pre><code>b1 = Being.new "Being 1"
b2 = Being.new "Being 2"
b3 = Being.new "Being 3"
</code></pre>


<p>创建Being类的三个实例对象。每个对象拥有不同的名字。这个名字存储在实例变量中，对于每个对象它是唯一的。名字将会在<em>to_s</em>方法中使用，用于返回一个对该对象的简短描述。</p>


<pre><code>p b1, b2, b3
</code></pre>


<p>这个方法将刚创建的三个对象作为参数，它将调用每个对象的<em>to_s</em>方法。  </p>


<pre><code>p b1.does_exist?
p b2.does_exist?
p b3.does_exist?
</code></pre>


<p>最后我们调用每个实例对象的<em>does_exist?</em>方法。这三个方法会输出相同的结果，因为这个方法返回的是类变量。</p>


<pre><code>$ ./icvars.rb
This is Being 1
This is Being 2
This is Being 3
true
true
true
</code></pre>


<p>以上是这个例子的输出结果。前三条信息是唯一的，因为这个字符串是存储在实例变量中的。<em>true</em>值是类变量，它被调用的三次。  </p>


<h2>环境&amp;命令行变量</h2>


<p>可以用<em>ENV</em>常量来访问环境变量。它是一个Ruby的hash对象。每个环境变量都是<em>ENV</em>这个hash对象的键值。  </p>


<p><em>ARGV</em>常量存储了命令行的参数值。它们是在脚本启动时传递的。<em>ARGV</em>是一个数组，参数以字符串存储。<em>S*</em>是<em>ARGV</em>的别名。</p>


<p><em>ENV</em>和<em>ARGV</em>都是全局常量。</p>


<pre><code>#!/usr/bin/ruby

ARGV.each do |a|
  puts "Argument: #{a}"
end
</code></pre>


<p>这个脚本我们通过循环遍历打印了<em>ARGV</em>的每个值。</p>


<p>$ ./commandline.rb 1 2 3<br>
Argument: 1<br>
Argument: 2<br>
Argument: 3  </p>


<p>我们给了三个命令行参数。它们在终端上各打印了一行。</p>


<hr>


<p>接下来的例子介绍了处理环境变量。</p>


<pre><code>#!/usr/bin/ruby

puts ENV['SHELL']
puts ENV['LANG']
puts ENV['TERM']
</code></pre>


<p>这个脚本在终端上打印了三个环境变量的值。这些变量值的内容依赖于我们操作系统的系统设置。 </p>


<p>$ ./environment.rb<br>
/bin/bash<br>
en_US.utf8<br>
xterm  </p>


<p>以上是一个输出例子。</p>


<h2>伪变量</h2>


<p>在Ruby中有一些变量被称作伪变量。它们不同于常规的变量，不能给它们设置值。<br>
<em>self</em>是当前方法的接收者。<em>nil</em>是<em>NilClass</em>的唯一实例，它代表值不存在。<em>true</em>是<em>TrueClass</em>的唯一实例，它代表布尔真。<em>flase</em>是<em>FalseClass</em>是唯一实例，它代表布尔假。<br>
<em>true</em>和<em>false</em>是布尔数据类型。从另一个角度来看他们是特殊的类实例，这是因为在Ruby中一切皆对象。</p>


<pre><code>#!/usr/bin/ruby

p self
p nil
p true
p false

p self.class
p nil.class
p true.class
p false.class
</code></pre>


<p>这是一个伪变量的例子。我们打印所有的伪变量，然后再看它们的类名。  </p>


<pre><code>p self
</code></pre>


<p>在当前上下文<em>self</em>伪变量返回的是<em>main</em>执行的上下文。  </p>


<p>$ ./pseudo.rb<br>
main<br>
nil<br>
true<br>
false<br>
Object<br>
NilClass<br>
TrueClass<br>
FalseClass  </p>


<p>以上是例子的输出结果。</p>


<hr>


<p>在本节的第二个例子，我们将进一步分析<em>self</em>。</p>


<pre><code>#!/usr/bin/ruby

class Some
    puts self
end

class Other
    puts self
end

puts self
</code></pre>


<p>之前我们说过，<em>self</em>是对当前方法接收者的引用。以上例子展示了三个不同的接收者。 </p>


<pre><code>class Some
    puts self
end
</code></pre>


<p>这个接收者名为<em>Some</em>。</p>


<pre><code>class Other
    puts self
end
</code></pre>


<p>这是另一个接收者，名为：<em>Other</em>。</p>


<pre><code>puts self
</code></pre>


<p>第三个接收者是Ruby顶级环境。</p>


<p>$ ./pseudoself.rb <br>
Some <br>
Other <br>
main   </p>


<p>以上是例子的输出结果。</p>


<hr>


<p>本节的最后一个例子展示了另外三个伪变量。</p>


<pre><code>#!/usr/bin/ruby

if true
    puts "This message is shown"
end

if false
    puts "This message is not shown"
end

p $name
p $age
</code></pre>


<p>上面的例子展示了<em>true</em>、<em>false</em>和<em>nil</em>伪变量。 </p>


<pre><code>if true
    puts "This message is shown"
end
</code></pre>


<p><em>true</em>用于布尔表达式中。这条消息总是会打印的。  </p>


<pre><code>if false
    puts "This message is not shown"
end
</code></pre>


<p>这条消息永远不会打印。这个条件不成立。这个布尔表达式总是会返回一个负值。  </p>


<pre><code>p $name
p $age
</code></pre>


<p>如果全局变量没有初始化就引用，那么它们就会包含一个<em>nil</em>伪变量。这代表值不存在。  </p>


<p>$ ./pseudo2.rb<br>
This message is shown<br>
nil<br>
nil  </p>


<p>以上是<em>pseudo2.rb</em>脚本的输出结果。</p>


<h2>预定义变量</h2>


<p>Ruby中有很多预定义的全局变量。这是继承到Perl，Ruby受Perl的影响很大。Ruby脚本启动之后就可以访问这些变量了。接下来有些例子展示预定义变量。</p>


<pre><code>#!/usr/bin/ruby

print "Script name: ", $0, "\n"
print "Command line arguments: ", $*, "\n"

puts "Process number of this script: #{$$}"
</code></pre>


<p>以上使用了三个预定义变量。<em>$0</em>、<em>$*</em>和<em>$$</em>。<em>$0</em>存储了当前脚本的名字。<em>$*</em>存储了命令行参数。 <em>$$</em>存储了当前脚本程序的PID。  </p>


<p>$ ./predefined.rb 1 2 3 <br>
Script name: ./predefined.rb<br>
Command line arguments: [&#8220;1&#8221;, &#8220;2&#8221;, &#8220;3&#8221;]<br>
Process number of this script: 3122  </p>


<p>以上是一个输出例子。</p>


<hr>


<p><em>$?</em>全局变量存储了最后一个子进程的退出状态。  </p>


<pre><code>#!/usr/bin/ruby

system 'echo "Ruby"'
puts $?

%x[exit '1']
puts $?
</code></pre>


<p>我们执行两个子进程，然后使用<em>$?</em>查看它们的退出状态。</p>


<pre><code>system 'echo "Ruby"'
puts $?
</code></pre>


<p>使用<em>system</em>方法启动一个子进程。它是一个bash的echo命令，用于在终端输出消息。  </p>


<pre><code>%x[exit '1']
puts $?
</code></pre>


<p>第二个情况是使用状态1执行bash的exit命令。这次我们使用<em>%x</em> 操作符，用于执行一条被分隔符所选择的命令。</p>


<p>$ ./predefined2.rb<br>
Ruby<br>
pid 3131 exit 0<br>
pid 3133 exit 1  </p>


<p>第一个子进程退出状态为0,第二为1。 </p>


<hr>


<p><em>$;</em>变量存储了字符串<em>split</em>方法的默认分隔符。  </p>


<pre><code>#!/usr/bin/ruby

str = "1,2,3,4,5,6,7"
p str.split

$; = ","
p str.split
</code></pre>


<p>我们使用<em>$;</em>变量来控制字符串的<em>split</em>方法是如何分隔的。这个方法接收一个参数，用于确定字符串应该何处分隔。 如果这个参数省略了，那么将会使用<em>$;</em>的值。  </p>


<pre><code>$; = ","
p str.split
</code></pre>


<p>我们为<em>$;</em>分隔符指定个值。当<em>split</em>方法没有传递参数时，<em>$;</em>的值将会被使用。  </p>


<p>$ ./predefined3.rb<br>
[&#8220;1,2,3,4,5,6,7&#8221;]<br>
[&#8220;1&#8221;, &#8220;2&#8221;, &#8220;3&#8221;, &#8220;4&#8221;, &#8220;5&#8221;, &#8220;6&#8221;, &#8220;7&#8221;]  </p>


<p>在第一种情况下字符串没有被分割，第二种情况下字符串正确的被分割了。  </p>


<hr>


<p>最后我们展示三个用于正则表达式的全局预定义变量。  </p>


<pre><code>#!/usr/bin/ruby

"Her name is Jane" =~ /name/

p $`
p $&amp;
p $'
</code></pre>


<p>当我们对字符串使用<em>=~</em>保用符时，Ruby设置了一些变量。<em>$&amp;</em>变量设为最后一个匹配该正则式的内容。<em>$`</em>设为<em>$&amp;</em>之前的内容.<em>$’</em>为<em>$&amp;</em>之后的内容。</p>


<p>$ ./predefined4.rb<br>
&#8220;Her &#8221;<br>
&#8220;name&#8221;<br>
&#8221; is Jane&#8221;  </p>


<p>以上是这个例子的输出结果。</p>


<p>在这一章的教程中我们深入的学习了Ruby的变量。</p>


<hr>


<p>原文地址： <a href="http://zetcode.com/lang/rubytutorial/variables/">http://zetcode.com/lang/rubytutorial/variables/</a><br>
翻译：龙昌  admin@longchangjin.cn<br>
完整教程：<a href="https://github.com/wusuopu/Ruby-tutorial">https://github.com/wusuopu/Ruby-tutorial</a>  </p>

</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
    <h1 class="entry-title"><a href="http://www.xefan.com/archives/83902.html">[翻译]Ruby教程3——基础</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2013-11-04T00:00:00+08:00'><span class='date'><span class='date-month'>Nov</span> <span class='date-day'>4</span><span class='date-suffix'>th</span>, <span class='date-year'>2013</span></span> <span class='time'>12:00 am</span></time>
        
           | <a href="http://www.xefan.com/archives/83902.html#disqus_thread"
             data-disqus-identifier="http://www.xefan.com/archives/83902.html">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><h1>基础</h1>


<p>在这一章我们将覆盖Ruby语言的基本程序概念。我们展示一些非常基础的程序，使用到了变量、常量和基本的数据类型。从终端读取、写入内容；我们将会介绍变量的插值（interpolation）。</p>


<p>我们从一个非常简单的代码例子开始。  </p>


<blockquote>
<p>#!/usr/bin/ruby<br>
  puts &#8220;This is Ruby&#8221;</p>
</blockquote>


<p>这个简单的脚本会在终端打印<em>&#8220;This is Ruby&#8221;</em>信息。  </p>


<blockquote>
<p>#!/usr/bin/ruby</p>
</blockquote>


<p>这用于执行这个脚本的Ruby解释器的路径。</p>


<blockquote>
<p>puts &#8220;This is Ruby&#8221;</p>
</blockquote>


<p><em>puts</em>是Ruby的关键字，用于将它的参数打印到终端上。在这个例子中它的参数是一个被双引号分隔的字符串。</p>


<p>$ ./first.rb <br>
This is Ruby</p>


<p>以上是这个例子的输出结果。</p>


<hr>


<p>我们可以从终端读取值。</p>


<blockquote>
<p>#!/usr/bin/ruby<br>
   print &#8220;What is your name? &#8221;<br>
   name = gets
   puts &#8220;Hello #{name}&#8221;</p>
</blockquote>


<p>第二个程序将会从终端读取一个值并输出。  </p>


<blockquote>
<p>print &#8220;What is your name? &#8221;</p>
</blockquote>


<p><em>print</em>关键字是将参数打印到终端上。<em>print</em>与<em>puts</em>的不同在于<em>print</em>不同自动换行，而<em>puts</em>会自动换行。</p>


<blockquote>
<p>name = gets</p>
</blockquote>


<p>这里我们将从用户输入中读取值并将其保存在<em>name</em>变量中。<em>gets</em>是一个方法用于从终端读取一行内容。它是一个内置的方法。</p>


<blockquote>
<p>puts &#8220;Hello #{name}&#8221;</p>
</blockquote>


<p>在这行代码我们展示变量的插值。变量插值（Variable interpolation）是将字符串字面量中的变量替换成它真实的值。变量插值（interpolation）的其他说法是：变量置换和变量扩展。  </p>


<blockquote>
<p>$ ./name.rb <br>
 What is your name? Jan<br>
 Hello Jan  </p>
</blockquote>


<p>以上是第二个程序的输出结果。</p>


<hr>


<p>Ruby代码可以从命令行运行。这个是借鉴至Perl的单行方式，小块代码执行小任务。</p>


<blockquote>
<p>$ ruby -e &#8220;puts RUBY_VERSION&#8221;<br>
 2.0.0</p>
</blockquote>


<p><em>-e</em>参数告诉Ruby要执行的代码从命令行中给定，而不是Ruby代码文件。我们例子将在终端输出Ruby解释器的版本号。<br>
译注：原文的作者使用的是ruby 1.9.3，而如今ruby最新版已经是2.0.0了。</p>


<hr>


<p>Ruby解释器有一个<em>-c</em>选项用于检查代码的语法。如果启用了的话，代码将不会被执行。如果代码没有语法错误，那么将会打印<em>&#8220;Syntax OK&#8221;</em>。</p>


<blockquote>
<p>#!/usr/bin/ruby<br>
 class Being end <br>
 m = Test.new<br>
 p m  </p>
</blockquote>


<p>以上例子中有一个语法错误。如果我们将<em>class</em>和<em>end</em>关键字放在同一行，那么我们就必须还要使用分号字符(;)。</p>


<p>$ ruby -c syntax_check.rb <br>
syntax_check.rb:3: syntax error, unexpected keyword_end, expecting &#8216;&lt;&#8217; or &#8216;;&#8217; or &#8216;\n&#8217;<br>
syntax_check.rb:6: syntax error, unexpected $end, expecting keyword_end  </p>


<p>发现了语法错误。如果我们在<em>Being</em>的后面加上分号，错误提示消息就会消失。  </p>


<h2>命令行参数</h2>


<p>Ruby程序可以从命令行接收参数。当我们执行程序时参数接在程序名的后面。</p>


<blockquote>
<p>#!/usr/bin/ruby<br>
 puts ARGV  </p>
</blockquote>


<p>接在文件名后面的有效命令行参数被Ruby程序保存在全局数组ARGV中。</p>


<p>这里我们将所有的命令行参数打印到终端上。  </p>


<p>$ ./args.rb 1 2 3<br>
1<br>
2<br>
3  </p>


<p>我们提供了三个数字作为命令行参数，并且它们都打印到终端上了。</p>


<hr>


<p>在下面的例子中我们将打印所有的参数还有脚本名。</p>


<blockquote>
<p>#!/usr/bin/ruby<br>
 puts $0<br>
 puts $*  </p>
</blockquote>


<p><em>$0</em>是全局变量，包含被执行的脚本的名称。在Ruby中全局变量是以<em>$</em>字符开头。<em>$*</em>是另一个全局变量。它与ARGV是相等的，包含了命令行的所有参数。</p>


<p>$ ./args2.rb Ruby Python Perl<br>
./args2.rb<br>
Ruby<br>
Python<br>
Perl  </p>


<p><em>args2.rb</em>脚本接收了三个参数。脚本名和这三个参数都打印到终端上了。  </p>


<h2>变量和常量</h2>


<p>变量是保存数据的地址。变量包括名称和数据类型。数据类型表示了数据的不同类型。整数、字符串和浮点数都是数据类型。Ruby是一门动态语言，这意味着我们不需要（也不能）定义一个变量的确定类型。而是Ruby解释器在分配变量时决定它的数据类型。此外，在程序运行时一个变量还可以包含不同类型的不同值。这与Java、C或者Pascal之类的强类型语言不同。与变量不同，常量（应该）保持它的值。一旦初始化了就不能修改。然后在Ruby中是有可能修改常量的值，这种情况下会出现一个警告。</p>


<blockquote>
<p>#!/usr/bin/ruby<br>
 city = &#8220;New York&#8221;<br>
 name = &#8220;Paul&#8221;; age = 35<br>
 nationality = &#8220;American&#8221;  </p>
<p>puts city<br>
 puts name<br>
 puts age<br>
 puts nationality  </p>
<p>city = &#8220;London&#8221;  </p>
<p>puts city  </p>
</blockquote>


<p>在上面的例子中我们使用了四个变量。</p>


<blockquote>
<p>city = &#8220;New York&#8221;</p>
</blockquote>


<p>我们给<em>city</em>变量分配了一个字符串。这个变量是动态创建的。 </p>


<blockquote>
<p>name = &#8220;Paul&#8221;; age = 35</p>
</blockquote>


<p>创建两个变量。我们可以将两条语句放在一行里。然后为了提高可读性应该每行一条语句。</p>


<blockquote>
<p>puts city<br>
 puts name<br>
 puts age<br>
 puts nationality  </p>
</blockquote>


<p>将变量的值打印到终端。</p>


<blockquote>
<p>city = &#8220;London&#8221;  </p>
</blockquote>


<p>给<em>city</em>变量分配新的值。  </p>


<p>$ ./variables.rb <br>
New York<br>
Paul<br>
35<br>
American<br>
London  </p>


<p>这是以上例子的输出。</p>


<hr>


<p>之前我们已经介绍过常量了，它一直都保存着一个值。但是不同于其他语言，Ruby没有对这个进行强制限制。</p>


<blockquote>
<p>#!/usr/bin/ruby  </p>
<p>WIDTH = 100<br>
 HEIGHT = 150   </p>
<p>var = 40<br>
 puts var  </p>
<p>var = 50<br>
 puts var  </p>
<p>puts WIDTH<br>
 WIDTH = 110<br>
 puts WIDTH  </p>
</blockquote>


<p>在这个例子中定义了两个常量和一个变量。</p>


<blockquote>
<p>WIDTH = 100<br>
 HEIGHT = 150   </p>
</blockquote>


<p>在Ruby中常量是以大写字母开头的。通常是将所有字母都大写。</p>


<blockquote>
<p>var = 40<br>
 puts var  </p>
<p>var = 50  </p>
</blockquote>


<p>定义并初始化一个变量。随后又给它分配了一个新的值，这是合法的。</p>


<blockquote>
<p>WIDTH = 100  </p>
</blockquote>


<p>我们给常量分配了一个新的值。常量一旦创建就不应该改变，否则它就不意味着是一个常量。Ruby解释器将会给出一条警告。</p>


<p>$ ./constants.rb <br>
40<br>
50<br>
100<br>
./constants.rb:13: warning: already initialized constant WIDTH<br>
110  </p>


<p>以上是脚本的输出。</p>


<h2>变量插值</h2>


<p>变量插值（interpolation）是将字符串中的变量替换成它的值。变量插值的其他说法是：变量置换和变量扩展。</p>


<blockquote>
<p>#!/usr/bin/ruby  </p>
<p>age = 34<br>
 name = &#8220;William&#8221;  </p>
<p>puts &#8220;#{name} is #{age} years old&#8221;   </p>
</blockquote>


<p>在Ruby中字符串是不可变的。我们不能修改一个已存在的字符串。变量插值是字符创建时进行的。  </p>


<blockquote>
<p>age = 34<br>
 name = &#8220;William&#8221;  </p>
</blockquote>


<p>定义两个变量。</p>


<blockquote>
<p>puts &#8220;#{name} is #{age} years old&#8221; </p>
</blockquote>


<p>字符串是被双引号所引起来。当我们将变量名放在<em>#{</em>和<em>}</em>字符之间时,这个变量会被它的值所篡改。</p>


<p>$ ./interpolation.rb <br>
William is 34 years old  </p>


<p>以上是这个例子的输出。</p>


<p>这一章覆盖了Ruby语言的一些基础。 </p>


<hr>


<p>原文地址： <a href="http://zetcode.com/lang/rubytutorial/basics/">http://zetcode.com/lang/rubytutorial/basics/</a><br>
翻译：龙昌  admin@longchangjin.cn<br>
完整教程：<a href="https://github.com/wusuopu/Ruby-tutorial">https://github.com/wusuopu/Ruby-tutorial</a>  </p>

</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
    <h1 class="entry-title"><a href="http://www.xefan.com/archives/83899.html">[翻译]Ruby教程2——词法结构</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2013-11-02T00:00:00+08:00'><span class='date'><span class='date-month'>Nov</span> <span class='date-day'>2</span><span class='date-suffix'>nd</span>, <span class='date-year'>2013</span></span> <span class='time'>12:00 am</span></time>
        
           | <a href="http://www.xefan.com/archives/83899.html#disqus_thread"
             data-disqus-identifier="http://www.xefan.com/archives/83899.html">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><h1>Ruby 词法结构</h1>


<p>计算机语言跟人类语言类似也有词法结构。一个Ruby程序的源代码由符号构成。符号标志是最基本的代码元素。在Ruby语言中我们有多种词法结构，如：注释、变量、字面量、空白符号、操作符、分隔符和关键字。</p>


<h2>注释</h2>


<p>注释是用于向人们阐明源代码。在Ruby中有两种注释的方法，单行注释和多行注释。单行注释以#字符开始；多行注释是放置在<em>=bgin</em>和<em>=end</em> 等号标志之间。</p>


<blockquote>
<p>#!/usr/bin/ruby  </p>
<p>=begin  </p>
<blockquote>
<p>comments.rb<br>
      author Jan Bodnar<br>
      ZetCode 2011    </p>
</blockquote>
<p>=end  </p>
<p># prints message to the terminal<br>
 puts &#8220;Comments example&#8221;  </p>
</blockquote>


<p>这个例子同时展示的两种方法的注释。注释的内容将会被Ruby解释器忽略掉。</p>


<blockquote>
<pre><code>=begin  
    comments.rb  
    author Jan Bodnar  
    ZetCode 2011  
=end
</code></pre>
</blockquote>


<p>这是一个多行注释的例子，两个符号标志必须在行首。</p>


<h2>空白符号</h2>


<p>在源文件中Ruby的空白符号被用于分隔符号标志和结束语句。它也用于增强代码的可读性。  </p>


<p>if true then<br>
&nbsp;&nbsp;puts &#8220;A message&#8221;<br>
end  </p>


<p>空白字符在一些时候是必须的。例如在<em>if</em>关键字和<em>true</em>关键字之间；或者在<em>puts</em>方法和实际的字符串之间。而有时它又是被禁止的，如它不能包含在变量标识符或者语言关键字中。  </p>


<p>a=1<br>
b&nbsp;=&nbsp;2<br>
c&nbsp;&nbsp;=&nbsp;&nbsp;3  </p>


<p>这些在符号标志之间的空白字符对于Ruby解释器是无关紧要的。但是它于整个项目的风格统一非常重要。</p>


<hr>


<blockquote>
<p>#!/usr/bin/ruby  </p>
<p>x = 5 + 3<br>
 puts x  </p>
<p>x = 5 <br>
   &nbsp;&nbsp;&nbsp;&nbsp;+ 3<br>
 puts x      </p>
<p>x = 5 + <br>
   &nbsp;&nbsp;&nbsp;&nbsp;3<br>
 puts x</p>
</blockquote>


<p>换行是一种用于结束语句的空白字符形式。  </p>


<p>x = 5 + 3  </p>


<p>在第一种情况，我们有一条语句。它将相加求和的值赋给x变量。这个变量的值为8。  </p>


<p>x = 5<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;+3</p>


<p>现在第二种情况。第1条语句被换行符终止了，x变量的值是5。另一条语句<em>+3</em>，没有任何影响。  </p>


<p>x = 5 +<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3  </p>


<p>最后，第1条语句的换行符之前有一个+二元操作符，因此解释器期望另一个值，它将检查第二行。在这种情况它将这两种作为一条语句，因此x这是的值为8。  </p>


<p>$ ./whitespace.rb<br>
8<br>
5<br>
8  </p>


<p>以上为输出结果。  </p>


<h2>变量</h2>


<p>变量是一个保存了值的标识符。在编程时我们说我们给一个变量分配一个值。专业一点的说法是一个变量是对计算机中存储了值的内存的引用。在Ruby中一个变量可以保存字符串、数字或者多种对象。不同时间变量可以被分配不同的值。<br>
在Ruby中变量名由字母数字和下划线组成，但是不能以数字开头。Ruby解释器可以很容易地区分原始的数字跟变量。变量名不能以大写字母开头，在Ruby中以大写字母开头的标识符会被认为是一个常量。</p>


<blockquote>
<p>Value<br>
   value2<br>
   company_name  </p>
</blockquote>


<p>以上这些都是合法的变量名。</p>


<blockquote>
<p>12Val<br>
   exx$<br>
   first-name  </p>
</blockquote>


<p>以上这些都不是合法的变量名。  </p>


<p>变量名前可以加<em>$</em>和<em>@</em>这两个特殊的字符，它们用于创建特殊作用域的变量。  </p>


<p>变量名是大小写敏感的，这意味着<em>price</em>和<em>pRice</em>是两个不同的标识符。  </p>


<blockquote>
<p>#!/usr/bin/ruby<br>
 number = 10<br>
 numBER = 11  </p>
<p>puts number, numBER  </p>
</blockquote>


<p>在这个脚本中我们给两个标识符分配了两个数字。<em>number</em>和<em>numBER</em>是两个不同的变量。</p>


<blockquote>
<p>$ ./case.rb<br>
   10<br>
   11  </p>
</blockquote>


<p>以上是这个脚本运行的输出结果。</p>


<h2>常量</h2>


<p>常量的值在程序运行过程中是不变的。在Ruby中一个标识符的首字母大写即为一个常量。编程时对于常量约定是所有字母全都大写。<br>
与其他语言不同，Ruby不会强制要求常量的值始终不变。当我们给一个常量分配新的值时解释器只会提示一个警告。  </p>


<blockquote>
<p>#!/usr/bin/ruby<br>
 Name = &#8220;Robert&#8221;<br>
 AGE = 23<br>
 Name = &#8220;Juliet&#8221;  </p>
</blockquote>


<p>在上面的例子中我们创建了两个常量，其中一个被重新定义了。  </p>


<blockquote>
<p>Name = &#8220;Robert&#8221;<br>
 AGE = 23  </p>
</blockquote>


<p>创建两个常量。在Ruby中标识符的首字母大写即定义为常量。作为约定常量通常是所有字母都大写的。  </p>


<blockquote>
<p>Name = &#8220;Juliet&#8221;  </p>
</blockquote>


<p>我们重新定义了一个常量，这会引起一个警告。</p>


<blockquote>
<p>$ ./constants.rb<br>
   ./constants.rb:6: warning: already initialized constant Name  </p>
</blockquote>


<p>以上是这个例子运行的输出。</p>


<h2>字面量</h2>


<p>字面量（literal）是按原文本内容所表示的特殊类型的值。字面量类型包括布尔型、整型、浮点型、字符串、字符和日期。专业的说一个字面量在编译时会分配一个值，该值在运行时会分配给对应的变量。</p>


<blockquote>
<p>age = 29<br>
 nationality = &#8220;Hungarian&#8221;  </p>
</blockquote>


<p>这里我们分配了两个字面量变量。数字<em>29</em>和字符串<em>&#8220;Hungarian&#8221;</em>都是字面量。  </p>


<pre><code>#!/usr/bin/ruby

require 'date'

sng = true  
name = "James"  
job = nil  
weight = 68.5  
born = Date.parse("November 12, 1986")

puts "His name is #{name}"

if sng == true  
    puts "He is single"  
else  
    puts "He is in a relationship"  
end

puts "His job is #{job}"  
puts "He weighs #{weight} kilograms"  
puts "He was born in #{born}"
</code></pre>


<p>在上面这个例子中，我们使用了多个字面量。布尔字面量的值可能为<em>true</em>或者<em>false</em>，<em>James</em>是一个字符串字面量，<em>nil</em>表示一个不存在的值，<em>68.5</em>是一个浮点数，最后<em>November 12,1986</em>是一个日期。</p>


<blockquote>
<p>$ ./literals.rb<br>
   His name is James<br>
   He is single<br>
   His job is <br>
   He weighs 68.5 kilograms<br>
   He was born in 1986-11-12  </p>
</blockquote>


<p>以上为<em>literals.rb</em>脚本的输出结果。 </p>


<h2>代码块</h2>


<p>Ruby语句通常是放在代码块中。一个代码块可以被<em>{}</em>符号或者<em>do</em>、<em>end</em>关键字分隔。  </p>


<pre><code>#!/usr/bin/ruby

puts [2, -1, -4, 0].delete_if { |x| x &lt; 0 }

[1, 2, 3].each do |e|
    puts e
end
</code></pre>


<p>这个例子中我们展示了两个代码块。  </p>


<p>Ruby代码的控制流通常是使用<em>if</em>关键字。这个关键字k跟随着一个代码块，在这种情况下代码块被<em>then</em>、<em>end</em>关键字分隔，<em>then</em>关键字是可选的。</p>


<pre><code>#!/usr/bin/ruby

if true then
    puts "Ruby language"
    puts "Ruby script"
end
</code></pre>


<p>在上面这个例子中，我们展示了一个简单的代码块。它有两条语句。这个代码块被<em>then</em>、<em>end</em>关键字分隔。<em>then</em>关键字可以省略。</p>


<h2>符号</h2>


<p>符号<em>$</em>、<em>@</em>是特殊字符用于表示变量的作用域，<em>$</em>表示全局变量，<em>@</em>表示实例变量，<em>@@</em>表示类变量。  </p>


<blockquote>
<p>$car_name = &#8220;Peugeot&#8221;<br>
  @sea_name = &#8220;Black sea&#8221;<br>
  @@species = &#8220;Cat&#8221;  </p>
</blockquote>


<p>这些符号总是位于变量标识符的开头。</p>


<h2>操作符</h2>


<p>操作符是一个用于对值执行一个动作的符号。  </p>


<pre><code>!    +    -    ~    *    **    /    %
&lt;&lt;    &gt;&gt;    &amp;    |    ^
==    ===    !=    &lt;=&gt;    &gt;=    &gt;
&lt;    &lt;=    =    %=    /=    -=
+=    *=    **=    ..    ...    not
and    or    ?:    &amp;&amp;    ||
</code></pre>


<p>以上是在Ruby中所有有效的操作符，我们将在之后的教程中介绍它们。  </p>


<h2>分隔符</h2>


<p>分隔符是一个或多个用于在纯文本或者其他数据流中指定分隔独立区域范围的字符序列。  </p>


<pre><code>(       )       [       ]       {       }      
,       ;       '       "       |       |

#!/usr/bin/ruby

name = "Jane"
occupation = 'Student'
numbers = [ 2, 3, 5, 3, 6, 2 ]

puts name; puts occupation
puts numbers[2]
numbers.each { |i| puts i }
puts ( 2 + 3 ) * 5
</code></pre>


<p>在上面这个例子中我们展示多种Ruby分隔符的用法。  </p>


<blockquote>
<p>name = &#8220;Jane&#8221;<br>
 occupation = &#8216;Student&#8217;  </p>
</blockquote>


<p>在Ruby中单引号和双引号被用于分隔字符串。</p>


<blockquote>
<p>numbers = [ 2, 3, 5, 3, 6, 2 ]  </p>
</blockquote>


<p>中括号用于指定数组的范围。逗号用于分隔数组项。  </p>


<blockquote>
<p>puts name; puts occupation  </p>
</blockquote>


<p>在Ruby中分号用于分隔两条语句。</p>


<blockquote>
<p>puts numbers[2]  </p>
</blockquote>


<p>分隔符可用于不同的环境中，这里中括号用于访问数组。</p>


<blockquote>
<p>numbers.each { |i| puts i }  </p>
</blockquote>


<p>大括号用于定义代码块。管道用于定义在每次循环中被当前数组项所填充的元素。</p>


<blockquote>
<p>puts ( 2 + 3 ) * 5</p>
</blockquote>


<p>括号用于改变一个表达式的求值。</p>


<h2>关键字</h2>


<p>关键字是在Ruby语言中被保留的字。关键字用于在计算机程序中展示特定的任务。例如：在终端中打印一个值，执行重复的任务或者展示逻辑操作。程序员不能使用关键字作为普通的变量。  </p>


<pre><code>alias    and      BEGIN      begin    break    case  
class    def      defined?   do       else     elsif  
END      end      ensure     false    for      if  
in       module   next       nil      not      or  
redo     rescue   retry      return   self     super  
then     true     undef      unless   until    when   
while    yield
</code></pre>


<p>这些是Ruby的关键列表。</p>


<p>以上就是Ruby的词法结构了。</p>


<hr>


<p>原文地址： <a href="http://zetcode.com/lang/rubytutorial/lexis/">http://zetcode.com/lang/rubytutorial/lexis/</a><br>
翻译：龙昌  admin@longchangjin.cn<br>
完整教程：<a href="https://github.com/wusuopu/Ruby-tutorial">https://github.com/wusuopu/Ruby-tutorial</a>  </p>

</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
    <h1 class="entry-title"><a href="http://www.xefan.com/archives/83895.html">[翻译]Ruby教程1——Ruby语言介绍</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2013-11-02T00:00:00+08:00'><span class='date'><span class='date-month'>Nov</span> <span class='date-day'>2</span><span class='date-suffix'>nd</span>, <span class='date-year'>2013</span></span> <span class='time'>12:00 am</span></time>
        
           | <a href="http://www.xefan.com/archives/83895.html#disqus_thread"
             data-disqus-identifier="http://www.xefan.com/archives/83895.html">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><h1>Ruby</h1>


<p>在这部分Ruby教程中，我们将介绍Ruby编程语言。</p>


<h2>目标</h2>


<p>这个教程的目标是让你入门Ruby。这个教程覆盖了Ruby的主要内容，包括变量、表达式、集合、流程控制结构以及其他的一些主要特性。同样也会描述一些高级的概念，例如面向对象和正则表达式。这不会完全地覆盖这个语言。</p>


<h2>Ruby</h2>


<p>Ruby是一门动态的、反射的、通用的面向对象编程语言。它的源作者是一个日本程序员——松本行弘 (まつもとゆきひろ)。Ruby第一次发表是在1995年。</p>


<p>Ruby支持多种程序范式。包括面向对象、反射、命令式的和反射的编程。Ruby语言主要是受到Perl、Smalltalk、Eiffel和Lisp的影响。不同于java、C#以及C，Ruby没有官方的规范。取而代之的是用原始的C实现的Ruby语言作为实际参考。同时也还存在一些用其他方法实现的Ruby语言，如：JRuby、IronRuby或者MacRuby。</p>


<p>Ruby的官方网站是: <a href="htp://ruby-lang.org">ruby-lang.org</a></p>


<h2>人气</h2>


<p>如今有上百种编程语言，而Ruby属于最流行的一个。在<a href="http://langpop.com">langpop.com</a>和<a href="http://www.tiobe.com/index.php/content/paperinfo/tpci/index.html">tiobe</a>网站Ruby都排在第10名左右。Ruby on Rails——一个非常流行的web应用框架是使用Ruby开发第一个杀手级的应用。</p>


<h2>交互式的解释器</h2>


<p>我们可以通过脚本或者交互式的解释器来运行Ruby语句。在这个教程中我们将使用交互式的Ruby会话来展示一些小的代码片段。大的代码例子将放在Ruby脚本中。</p>


<blockquote>
<p>$ irb<br>
  irb(main):001:0&gt; puts RUBY_VERSION<br>
  2.0.0<br>
  =&gt; nil  </p>
</blockquote>


<p>这是一个Ruby交互会式会话的例子。我们在终端中打印了一个特别的常量RUBY_VERSION，它被设置为当前使用的Ruby的版本。<br>
译注：原文的作者使用的是ruby 1.8.7，而如今ruby最新版已经是2.0.0了，因此我在翻译的时候也结合了当前新的内容。</p>


<h2>Ruby脚本</h2>


<p>我们开始我们的第一个简单的Ruby脚本例子。  </p>


<blockquote>
<p>#!/usr/bin/ruby<br>
 # first.rb<br>
 puts &#8220;This is Ruby&#8221;  </p>
</blockquote>


<p>这个脚本我们将在终端上打印一条消息。</p>


<blockquote>
<p>#!/usr/bin/ruby</p>
</blockquote>


<p>UNIX下的每一个脚本都是以shebang符号开始的。shebang是脚本中开始的前两个字符：<strong>#!</strong>。shebang后面是执行我们脚本的解释器的路径。/usr/bin是Ruby解释器最常用的位置。它也可以定位在/usr/local/bin或者其他什么地方。</p>


<blockquote>
<p># first.rb  </p>
</blockquote>


<p>在Ruby中注释是以#开始。</p>


<blockquote>
<p>puts &#8220;This is Ruby&#8221; </p>
</blockquote>


<p>puts方法是将字符串打印到终端。</p>


<blockquote>
<p>$ which ruby<br>
 /usr/bin/ruby  </p>
</blockquote>


<p>Ruby解释器的路径可以使用which命令找到。</p>


<blockquote>
<p>$ chmod +x first.rb<br>
 $ ./first.rb<br>
 This is Ruby  </p>
</blockquote>


<p>通过chmod命令，我们给脚本增加可执行的权限。</p>


<h2>资源</h2>


<p>以下资源在编写该教程时会使用到：<br>
<em> <a href="http://www.ruby-lang.org/">ruby-lang.org</a><br>
</em> <a href="http://ruby-doc.org/">ruby-doc.org</a><br>
<em> <a href="http://en.wikipedia.org/wiki/Ruby_(programming_language)">Ruby article on wikipedia.org</a><br>
</em> <a href="http://ruby.runpaint.org/">ruby.runpaint.org</a></p>


<p>在这章的教程中我们介绍了Ruby语言。  </p>


<hr>


<p>原文地址： <a href="http://zetcode.com/lang/rubytutorial/ruby/">http://zetcode.com/lang/rubytutorial/ruby/</a><br>
翻译：龙昌  admin@longchangjin.cn<br>
完整教程：<a href="https://github.com/wusuopu/Ruby-tutorial">https://github.com/wusuopu/Ruby-tutorial</a>  </p>

</div>
  
  


    </article>
  
  <div class="pagination">
    
      <a class="prev" href="/page/11">&larr; Older</a>
    
    <a href="/blog/archives">Blog Archives</a>
    
    <a class="next" href="/page/9">Newer &rarr;</a>
    
  </div>
</div>
<aside class="sidebar">
  
    <section>
  <h1>Subscription</h1>
  <!--以下是QQ邮件列表订阅嵌入代码--><script >var nId = "e7ee5da6d322dc7157c25cfd8a7700bb23a056dd1fb18cb4",nWidth="auto",sColor="light",sText="请输入邮件地址：" ;</script><script src="http://list.qq.com/zh_CN/htmledition/js/qf/page/qfcode.js" charset="gb18030"></script>
</section>
<section>
  <h1>Recent Posts</h1>
  <ul id="recent_posts">
    
      <li class="post">
        <a href="http://www.xefan.com/archives/84165.html">使用CodePush对ReactNative进行热更新</a>
      </li>
    
      <li class="post">
        <a href="http://www.xefan.com/archives/84164.html">ReactNative获取设备屏幕尺寸</a>
      </li>
    
      <li class="post">
        <a href="http://www.xefan.com/archives/84163.html">ReactNative Jsbundle管理</a>
      </li>
    
      <li class="post">
        <a href="http://www.xefan.com/archives/84162.html">ReactNative自动设置开发服务器IP</a>
      </li>
    
      <li class="post">
        <a href="http://www.xefan.com/archives/84161.html">Mac OS中VirtualBox的Android蓝牙设置</a>
      </li>
    
  </ul>
</section>
<section>
  <h1>Categories</h1>
    <ul id="category-list"><li><a href='/categories/linux栏目/index.html'>linux栏目 (48)</a></li><li><a href='/categories/python栏目/index.html'>python栏目 (34)</a></li><li><a href='/categories/ruby栏目/index.html'>ruby栏目 (32)</a></li><li><a href='/categories/web开发/index.html'>web开发 (20)</a></li><li><a href='/categories/前端相关/index.html'>前端相关 (10)</a></li><li><a href='/categories/嵌入式栏目/index.html'>嵌入式栏目 (11)</a></li><li><a href='/categories/开源软件/index.html'>开源软件 (20)</a></li><li><a href='/categories/教程/index.html'>教程 (16)</a></li><li><a href='/categories/数据库/index.html'>数据库 (10)</a></li><li><a href='/categories/数据结构和算法/index.html'>数据结构和算法 (16)</a></li><li><a href='/categories/编程开发/index.html'>编程开发 (43)</a></li><li><a href='/categories/网络日志/index.html'>网络日志 (11)</a></li><li><a href='/categories/资源分享/index.html'>资源分享 (24)</a></li></ul>
</section>
<section>
  <h1>Tag Cloud</h1>
    <span id="tag-cloud"><a href='/tags/access/index.html' style='font-size: 105.3731343283582%'>access(6)</a> <a href='/tags/adobe/index.html' style='font-size: 100.8955223880597%'>adobe(1)</a> <a href='/tags/ajax/index.html' style='font-size: 102.68656716417911%'>ajax(3)</a> <a href='/tags/android/index.html' style='font-size: 100.8955223880597%'>Android(1)</a> <a href='/tags/angular/index.html' style='font-size: 106.26865671641791%'>angular(7)</a> <a href='/tags/apache/index.html' style='font-size: 100.8955223880597%'>apache(1)</a> <a href='/tags/arch/index.html' style='font-size: 106.26865671641791%'>Arch(7)</a> <a href='/tags/arm/index.html' style='font-size: 107.16417910447761%'>ARM(8)</a> <a href='/tags/asp/index.html' style='font-size: 106.26865671641791%'>asp(7)</a> <a href='/tags/c/index.html' style='font-size: 111.64179104477611%'>C(13)</a> <a href='/tags/css/index.html' style='font-size: 101.7910447761194%'>css(2)</a> <a href='/tags/django/index.html' style='font-size: 102.68656716417911%'>Django(3)</a> <a href='/tags/dreamweaver/index.html' style='font-size: 100.8955223880597%'>Dreamweaver(1)</a> <a href='/tags/fedora/index.html' style='font-size: 101.7910447761194%'>Fedora(2)</a> <a href='/tags/firefox/index.html' style='font-size: 102.68656716417911%'>firefox(3)</a> <a href='/tags/flash/index.html' style='font-size: 100.8955223880597%'>Flash(1)</a> <a href='/tags/ftp/index.html' style='font-size: 100.8955223880597%'>ftp(1)</a> <a href='/tags/gcc/index.html' style='font-size: 105.3731343283582%'>gcc(6)</a> <a href='/tags/gentoo/index.html' style='font-size: 101.7910447761194%'>Gentoo(2)</a> <a href='/tags/git/index.html' style='font-size: 103.58208955223881%'>git(4)</a> <a href='/tags/gobject/index.html' style='font-size: 105.3731343283582%'>GObject(6)</a> <a href='/tags/grub/index.html' style='font-size: 100.8955223880597%'>grub(1)</a> <a href='/tags/gtk/index.html' style='font-size: 115.22388059701493%'>gtk(17)</a> <a href='/tags/gulp/index.html' style='font-size: 100.8955223880597%'>gulp(1)</a> <a href='/tags/hash/index.html' style='font-size: 100.8955223880597%'>Hash(1)</a> <a href='/tags/ibus/index.html' style='font-size: 100.8955223880597%'>ibus(1)</a> <a href='/tags/js/index.html' style='font-size: 109.85074626865672%'>js(11)</a> <a href='/tags/linux/index.html' style='font-size: 160.0%'>Linux(67)</a> <a href='/tags/mac/index.html' style='font-size: 100.8955223880597%'>Mac(1)</a> <a href='/tags/mongodb/index.html' style='font-size: 110.74626865671642%'>mongodb(12)</a> <a href='/tags/mysql/index.html' style='font-size: 103.58208955223881%'>mysql(4)</a> <a href='/tags/nginx/index.html' style='font-size: 100.8955223880597%'>nginx(1)</a> <a href='/tags/node/index.html' style='font-size: 100.8955223880597%'>node(1)</a> <a href='/tags/php/index.html' style='font-size: 108.95522388059702%'>php(10)</a> <a href='/tags/ps/index.html' style='font-size: 105.3731343283582%'>PS(6)</a> <a href='/tags/pygame/index.html' style='font-size: 110.74626865671642%'>pygame(12)</a> <a href='/tags/python/index.html' style='font-size: 145.67164179104478%'>python(51)</a> <a href='/tags/qt/index.html' style='font-size: 101.7910447761194%'>Qt(2)</a> <a href='/tags/react/index.html' style='font-size: 103.58208955223881%'>react(4)</a> <a href='/tags/redis/index.html' style='font-size: 100.8955223880597%'>Redis(1)</a> <a href='/tags/redis/index.html' style='font-size: 100.8955223880597%'>redis(1)</a> <a href='/tags/ruby/index.html' style='font-size: 129.55223880597015%'>Ruby(33)</a> <a href='/tags/scrapy/index.html' style='font-size: 102.68656716417911%'>Scrapy(3)</a> <a href='/tags/shell/index.html' style='font-size: 100.8955223880597%'>shell(1)</a> <a href='/tags/tq2440/index.html' style='font-size: 104.4776119402985%'>TQ2440(5)</a> <a href='/tags/ubuntu/index.html' style='font-size: 106.26865671641791%'>ubuntu(7)</a> <a href='/tags/usb/index.html' style='font-size: 102.68656716417911%'>USB(3)</a> <a href='/tags/vim/index.html' style='font-size: 123.28358208955224%'>vim(26)</a> <a href='/tags/virtualbox/index.html' style='font-size: 102.68656716417911%'>VirtualBox(3)</a> <a href='/tags/vmware/index.html' style='font-size: 100.8955223880597%'>vmware(1)</a> <a href='/tags/w3m/index.html' style='font-size: 100.8955223880597%'>w3m(1)</a> <a href='/tags/web开发/index.html' style='font-size: 113.43283582089552%'>Web开发(15)</a> <a href='/tags/windows/index.html' style='font-size: 106.26865671641791%'>windows(7)</a> <a href='/tags/wordpress/index.html' style='font-size: 100.8955223880597%'>WordPress(1)</a> <a href='/tags/xcode/index.html' style='font-size: 100.8955223880597%'>Xcode(1)</a> <a href='/tags/xml/index.html' style='font-size: 100.8955223880597%'>xml(1)</a> <a href='/tags/免费/index.html' style='font-size: 100.8955223880597%'>免费(1)</a> <a href='/tags/内核/index.html' style='font-size: 100.8955223880597%'>内核(1)</a> <a href='/tags/匹配算法/index.html' style='font-size: 105.3731343283582%'>匹配算法(6)</a> <a href='/tags/单片机/index.html' style='font-size: 101.7910447761194%'>单片机(2)</a> <a href='/tags/嵌入式/index.html' style='font-size: 100.8955223880597%'>嵌入式(1)</a> <a href='/tags/开源软件/index.html' style='font-size: 108.05970149253731%'>开源软件(9)</a> <a href='/tags/排序算法/index.html' style='font-size: 108.05970149253731%'>排序算法(9)</a> <a href='/tags/文件空间/index.html' style='font-size: 100.8955223880597%'>文件空间(1)</a> <a href='/tags/无线网/index.html' style='font-size: 100.8955223880597%'>无线网(1)</a> <a href='/tags/正则式/index.html' style='font-size: 100.8955223880597%'>正则式(1)</a> <a href='/tags/注册机/index.html' style='font-size: 101.7910447761194%'>注册机(2)</a> <a href='/tags/游戏/index.html' style='font-size: 108.95522388059702%'>游戏(10)</a> <a href='/tags/电脑技巧/index.html' style='font-size: 108.05970149253731%'>电脑技巧(9)</a> <a href='/tags/空间/index.html' style='font-size: 100.8955223880597%'>空间(1)</a> <a href='/tags/算法/index.html' style='font-size: 114.32835820895522%'>算法(16)</a> <a href='/tags/红旗/index.html' style='font-size: 100.8955223880597%'>红旗(1)</a> <a href='/tags/经典语录/index.html' style='font-size: 100.8955223880597%'>经典语录(1)</a> <a href='/tags/网络日志/index.html' style='font-size: 105.3731343283582%'>网络日志(6)</a> <a href='/tags/翻译/index.html' style='font-size: 123.28358208955224%'>翻译(26)</a> <a href='/tags/视频教程/index.html' style='font-size: 108.95522388059702%'>视频教程(10)</a> <a href='/tags/资源分享/index.html' style='font-size: 110.74626865671642%'>资源分享(12)</a> <a href='/tags/转载/index.html' style='font-size: 101.7910447761194%'>转载(2)</a> <a href='/tags/随笔/index.html' style='font-size: 100.8955223880597%'>随笔(1)</a> </span>
</section>
<section>
  <h1>Link</h1>
    <ul id="category-list">
      <li><a target="_blank" title="我的Github" href="https://github.com/wusuopu">@Github</a></li>
      <li><a target="_blank" title="我的微博" href="http://www.weibo.com/u/1768691343">@Weibo</a></li>
      <li><a target="_blank" title="我的Twitter" href="https://twitter.com/longchangjin">@Twitter</a></li>
      <li><a target="_blank" title="我的豆瓣" href="http://www.douban.com/people/lchj/">@Douban</a></li>

      <li><a target="_blank" title="" href="http://www.vimer.cn/">Vimer的程序世界</a></li>
      <li><a target="_blank" title="" href="http://pythoner.net/">python开发者社区</a></li>
      <li><a target="_blank" title="" href="http://simple-is-better.com/">python.cn(news, jobs)</a></li>
      <li><a target="_blank" title="" href="http://gtk.awaysoft.com/">GTK+ 中文社区</a></li>
    </ul>
</section>

  
</aside>

    </div>
  </div>
  <footer role="contentinfo"><p>
  Copyright &copy; 2016 - 龍昌 -
  <span class="credit">Powered by <a href="http://octopress.org">Octopress</a></span>
</p>
<div style="display:none;"><script src="http://s94.cnzz.com/stat.php?id=1259846&web_id=1259846&show=pic" language="JavaScript"></script></div>

</footer>
  

<script type="text/javascript">
      var disqus_shortname = 'longchang';
      
        
        var disqus_script = 'count.js';
      
    (function () {
      var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
      dsq.src = '//' + disqus_shortname + '.disqus.com/' + disqus_script;
      //dsq.src = '/javascripts/disqus/' + disqus_script;
      (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    }());
</script>











</body>
</html>
