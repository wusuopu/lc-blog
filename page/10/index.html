<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>龍昌博客</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="关注Linux及开源信息">
<meta property="og:type" content="website">
<meta property="og:title" content="龍昌博客">
<meta property="og:url" content="http://www.xefan.com/page/10/index.html">
<meta property="og:site_name" content="龍昌博客">
<meta property="og:description" content="关注Linux及开源信息">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="龍昌博客">
<meta name="twitter:description" content="关注Linux及开源信息">
  
    <link rel="alternate" href="/atom.xml" title="龍昌博客" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  <link rel="stylesheet" href="/css/style.css">
  

</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">龍昌博客</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">从Pythoneer转向Rubist</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
          <a class="main-nav-link" href="/about">About</a>
        
          <a class="main-nav-link" href="/gbook">留言板</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://www.xefan.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-/archives/83945.html" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/archives/83945.html" class="article-date">
  <time datetime="2013-11-17T00:00:00.000Z" itemprop="datePublished">2013-11-17</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Ruby栏目/">Ruby栏目</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/archives/83945.html">[翻译]Ruby教程14——正则表达式</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p></p><h1>Ruby的正则表达式</h1><p></p>
<p>在这部分和教程中我们将讨论正则表达式。</p><br><p>正则表达式用于文本搜索和更高级的文本操作。内建正则表达式的工具如grep、sed；文本编辑器如vi、emacs；编程语言如Tcl、Perl、Python。Ruby也内建支持正则表达式。</p><br><p>从另一方面来看正则表达式语法构成了一个文本匹配的领域专用语言。</p><br><p><em>pattern</em>（模式）是一个正则表达式，它定义了我们要搜索或者操作的文本。它由文本字面和元字符构成。模式位于两个分隔符内。在Ruby中是<em>//</em>字符。它们通知正则表达式函数的开始和结束。</p><br><p>这里是元字符的部分列表。</p><br><table><br>    <tr><br>        <td>.</td><br>        <td>匹配任意一个字符</td><br>    </tr><br>    <tr><br>        <td><em></em></td><br>        <td>匹配前一个元素0次或多次</td><br>    </tr><br>    <tr><br>        <td>[]</td><br>        <td>括号表达式。匹配括号内的一个字符</td><br>    </tr><br>    <tr><br>        <td>[^]</td><br>        <td>匹配不在括号内的一个字符</td><br>    </tr><br>    <tr><br>        <td>^</td><br>        <td>匹配字符串的开始位置</td><br>    </tr><br>    <tr><br>        <td>$</td><br>        <td>匹配字符串的结束位置</td><br>    </tr><br>    <tr><br>        <td>|</td><br>        <td>交替操作</td><br>    </tr><br></table><br><br><p>=~操作符对字符串匹配正则表达式，如果匹配则返回匹配字符串的偏移量否则为nil。 <em>RegExp</em>类是用来开发正则表达式。还有两个速记的方式来创建正则表达式。下面的例子将显示它们。</p><br><pre><code>#!/usr/bin/ruby<br><br>re = Regexp.new ‘Jane’<br>p “Jane is hot”.match re<br><br>p “Jane is hot” =~ /Jane/<br>p “Jane is hot”.match %r{Jane}<br></code></pre><br><p>第一个例子我们显示了对字符串应用正则表达式的三种方式。</p><br><pre><code>re = Regexp.new ‘Jane’<br>p “Jane is hot”.match re<br></code></pre><br><p>上面两行我们创建了一个简单的包含正则表达式文本的<em>Regexp</em>对象。使用<em>match</em>方法我们对<em>“Jane is hot”</em>句子应用这个正则表达式。检查’Jance’是否在这个句子中。</p><br><pre><code>p “Jane is hot” =~ /Jane/<br>p “Jane is hot”.match %r{Jane}<br></code></pre><br><p>这两行完成相同的工作。两个斜杠//和%R{}字符是第一种方式的简写。在这个教程中，我们将使用斜杠。这是在许多语言中是事实上的标准。</p><br><pre><code>$ ./regex.rb<br>#&lt;MatchData “Jane”&gt;<br>0<br>#&lt;MatchData “Jane”&gt;<br></code></pre><br><p>这三种情况都匹配的。<em>match</em>方法返回匹配的数据，如果没有则返回nil。=~操作符返回第一个匹配的字符的位置，或者nil。</p><br><h2>点字符</h2><br><p>点字符是一个可以匹配任意单字符的正则表达式字符。注意必须要有些字符，它不能被忽略。</p><br><pre><code>#!/usr/bin/ruby<br><br>p “Seven”.match /.even/<br>p “even”.match /.even/<br>p “eleven”.match /.even/<br>p “proven”.match /.even/<br></code></pre><br><p>第一个例子，我们对字符串使用<em>match</em>方法应用正则表达式。<em>match</em>方法成功则返回匹配到的数据，否则返回nil。</p><br><pre><code>p “Seven”.match /.even/<br></code></pre><br><p>“Seven”是一个字符串，可以调用<em>match</em>方法。这个方法的参数是一个模式。/.even/正则表达式模式是查找以任意字符开头接着是<em>‘even’</em>的字符串。</p><br><pre><code>$ ./dot.rb<br>#&lt;MatchData “Seven”&gt;<br>nil<br>#&lt;MatchData “leven”&gt;<br>nil<br></code></pre><br><p>从输出结果中我们看到哪些是匹配的哪些是没有匹配的。</p><br><hr><br><p>正如前面所说的，如果有点字符，那么就必须要有一个任意的字符。它不能被忽略。如果我们想到查找一个文本，其中有字符能被忽略的。换言之，我们想要一个模式可以同时匹配’seven’和’even’。对于这个我们可以使用一个<em>?</em>重复字符。<em>?</em>重复字符表示前一个字符可能出现0或者1次。</p><br><pre><code>#!/usr/bin/ruby<br><br>p “seven”.match /.even/<br>p “even”.match /.even/<br>p “even”.match /.?even/<br></code></pre><br><p>这个脚本使用<em>?</em>重复字符。</p><br><pre><code>p “even”.match /.even/<br></code></pre><br><p>这行打印nil，因为正则表达式在’even’之前要接受一个字符。</p><br><pre><code>p “even”.match /.?even/<br></code></pre><br><p>我们稍微修改一下正则表达式。<em>‘.?’</em>代表没有字符或者有一个字符。这次匹配成功。</p><br><pre><code>$ ./dot2.rb<br>#&lt;MatchData “seven”&gt;<br>nil<br>#&lt;MatchData “even”&gt;<br></code></pre><br><p>输出结果。</p><br><h2>正则表达式方法</h2><br><p>前面的两个例子我们对正则表达式使用了<em>match</em>方法。除了<em>match</em>之外还有其他的方法也接受正则表达式参数。</p><br><pre><code>#!/usr/bin/ruby<br><br>puts “motherboard” =~ /board/<br>puts “12, 911, 12, 111”[/\d{3}/]<br><br>puts “motherboard”.gsub /board/, “land”<br><br>p “meet big deep nil need”.scan /.[e][e]./<br>p “This is Sparta!”.split(/\s/)<br></code></pre><br><p>这个例子显示了正则表达式的一些方法。</p><br><pre><code>puts “motherboard” =~ /board/<br></code></pre><br><p>=~操作符将正则表达式放在右边，字符串放在左边。</p><br><pre><code>puts “12, 911, 12, 111”[/\d{3}/]<br></code></pre><br><p>正则表达式可以位于字符串后面的中括号内。这行打印第一个3个数字。</p><br><pre><code>puts “motherboard”.gsub /board/, “land”<br></code></pre><br><p>使用<em>gsub</em>方法我们将’board’字符串替换成’land’。</p><br><pre><code>p “meet big deep nil need”.scan /.[e][e]./<br></code></pre><br><p><em>scan</em>方法查找字符串匹配。它会查找所有出现的匹配，而不仅是第一个。这行打印所有与模式匹配的字符串。</p><br><pre><code>p “This is Sparta!”.split(/\s/)<br></code></pre><br><p><em>split</em>方法使用给定的正则式来分隔字符串。<em>\s</em>字符代表了任何空白字符。</p><br><pre><code>$ ./apply.rb<br>6<br>911<br>motherland<br>[“meet”, “deep”, “need”]<br>[“This”, “is”, “Sparta!”]<br></code></pre><br><p>apply.rb脚本的输出结果。</p><br><h2>特殊变量</h2><br><p>一些使用正则式的方法会激活一些特殊的变量。包括上次匹配的字符串、上次匹配结果的前面部分和上次匹配结果的后面部分。这些变量方便了程序员。</p><br><pre><code>#!/usr/bin/ruby<br><br>puts “Her name is Jane” =~ /name/<br><br>p $<code>p $&amp;amp;
p $&#39;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这个例子显示了三个特殊的变量。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;puts &quot;Her name is Jane&quot; =~ /name/
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这行代码是一个简单的正则式匹配。我们在&#39;Her name is Jane&#39;句子中查找&#39;name&#39;。我们使用=~操作符。这个操作符也会设置三个特殊的变量。这行返回数字4。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;p $</code><br></code></pre><br><p><em>$<code>&lt;/em&gt;特殊变量包含了上次匹配结果之前的文本。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;p $&amp;amp;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;em&gt;$&amp;amp;&lt;/em&gt;为匹配的文本。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;p $&#39;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;em&gt;$&#39;&lt;/em&gt;变量包含上次匹配结果之后的文本。&lt;/p&gt;
&lt;p&gt;$ ./svars.rb&lt;br&gt;
4&lt;br&gt;
&quot;Her &quot;&lt;br&gt;
&quot;name&quot;&lt;br&gt;
&quot; is Jane&quot;  &lt;/p&gt;
&lt;p&gt;例子的输出结果。&lt;/p&gt;
&lt;h2&gt;锚点&lt;/h2&gt;
&lt;p&gt;锚点是在文本中匹配位置的字符。我们展示三个锚点字符。^字符匹配了行的开头；$字符匹配了行的结尾；\b字符匹配词的边界。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#!/usr/bin/ruby

sen1 = &quot;Everywhere I look I see Jane&quot;
sen2 = &quot;Jane is the best thing that happened to me&quot;

p sen1.match /^Jane/ 
p sen2.match /^Jane/

p sen1.match /Jane$/ 
p sen2.match /Jane$/
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;第一个例子我们使用了^和$。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;sen1 = &quot;Everywhere I look I see Jane&quot;
sen2 = &quot;Jane is the best thing that happened to me&quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;有两个句子。&#39;Jane&#39;位于第一个的结尾第二个的开头。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;p sen1.match /^Jane/ 
p sen2.match /^Jane/
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这里我们查找这两个句子是否以&#39;Jane&#39;开头。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;p sen1.match /Jane$/ 
p sen2.match /Jane$/
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这里我们在句子结尾查找匹配。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ ./anchors.rb
nil
#&amp;lt;MatchData &quot;Jane&quot;&amp;gt;
#&amp;lt;MatchData &quot;Jane&quot;&amp;gt;
nil
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;运行结果。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;通常一个请求仅包含一个匹配全部的词。我们会默认计算所有匹配，包括更大的或者复合词。让我们通过一个例子来阐述。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#!/usr/bin/ruby

text = &quot;The cat also known as the domestic cat is a small, 
usually furry, domesticated, carnivorous mammal.&quot;

p text.scan /cat/

p $</code><br>p $&amp;<br>p $’<br><br><p>有一个句子。我们使用<em>scan</em>在这个句子中查找所有的’cat’字符串。</p><br><pre><code>text = “The cat also known as the domestic cat is a small,<br>usually furry, domesticated, carnivorous mammal.”<br></code></pre><br><p>问题是这个文本中有三个’cat’字符串。要匹配的’cat’表示一个哺乳动物,/cat/却匹配了’domesticated’词的8-10的字母。这不是我们想要的。</p><br><pre><code>$ ./boudaries.rb<br>[“cat”, “cat”, “cat”]<br>“The cat also known as the domestic cat is a small, \nusually furry, domesti”<br>“cat”<br>“ed, carnivorous mammal.”<br></code></pre><br><p>最后一次匹配的’domesticated’在下一个例子中将被使用\b锚点字符排除。</p><br><hr><br><p>\b字符用于设置要查找的词的边界。</p><br><pre><code>#!/usr/bin/ruby<br><br>text = “The cat also known as the domestic cat is a small,<br>usually furry, domesticated, carnivorous mammal.”<br><br>p text.scan /\bcat\b/<br><br>p $`<br>p $&amp;<br>p $’<br></code></pre><br><p>这个例子使用\b元字符进行了改善。</p><br><pre><code>p text.scan /\bcat\b/<br></code></pre><br><p>使用上面的正则式我们将查找’cat’整个词，不计算子词。</p><br><h2>字符类</h2><br><p>我们可以结合方括号将字符转换成字符类。字符类可以匹配在方括号内的任意字符。/[ab]/模式意味a或者b，相反的/ab/意味着a接着b。</p><br><pre><code>#!/usr/bin/ruby<br><br>words = %w/ sit MIT fit fat lot pad /<br><br>pattern = /[fs]it/<br><br>words.each do |word|<br>   if word.match pattern<br>       puts “#{word} matches the pattern”<br>   else<br>       puts “#{word} does not match the pattern”<br>   end<br>end<br></code></pre><br><p>有一系列的6个3字母的单词。我们对数组的每个字符串采用特定字符集的正则式。</p><br><pre><code>pattern = /[fs]it/<br></code></pre><br><p>这个式模式在这个数组中查找到了’fit’、’sit’。我们从字符集使用’f’或者’s’。</p><br><p>$ ./classes.rb<br><br>sit matches the pattern<br><br>MIT does not match the pattern<br><br>fit matches the pattern<br><br>fat does not match the pattern<br><br>lot does not match the pattern<br><br>pad does not match the pattern  </p><br><p>有两个匹配的。</p><br><hr><br><p>一个例子我们将进一步探讨字符类。</p><br><pre><code>#!/usr/bin/ruby<br><br>p “car”.match %r{[abc][a][rs]}<br>p “car”.match /[a-r]+/<br>p “23af 433a 4ga”.scan /\b[a-f0-9]+\b/<br></code></pre><br><p>例子中有三个字符类正则式。</p><br><pre><code>p “car”.match %r{[abc][a][rs]}<br></code></pre><br><p>这行的正则式由三个字符类构成。每个都对应一个字符。[abc]是a、b或者c。[a]就是a。第三个[rs]是r或者s。这里匹配’car’字符串。</p><br><pre><code>p “car”.match /[a-r]+/<br></code></pre><br><p>我们在字符类中使用了一个连接符<em>-</em>。连接符是一个元字符表示一个范围：这里是a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, 或r。由于字符类仅对应一个字符。我们也可以使用+重复字符。这表示前一个字符集的字符可以重复一次或者多次。’car’字符串被匹配了。</p><br><pre><code>p “23af 433a 4ga”.scan /\b[a-f0-9]+\b/<br></code></pre><br><p>这行有一个由三个子字符串构成的字符串。使用<em>scan</em>方法检查十六进制整数。我们有两个范围。第一个[a-f]代表a到f的字符。第二个[0-9]代表字数0到9。+表示这些字符可以重复多次。最后\b创建一个边界，表示仅接受由这些字符构成的字符串。</p><br><pre><code>$ ./classes2.rb<br>#&lt;MatchData “car”&gt;<br>#&lt;MatchData “car”&gt;<br>[“23af”, “433a”]<br></code></pre><br><p>输出结果。 </p><br><hr><br><p>如果字符类的第一个字符是脱字符（^），则对该类反转。它会匹配除了这些之外的任何字符。</p><br><pre><code>#!/usr/bin/ruby<br><br>p “ABC”.match /[^a-z]{3}/<br>p “abc”.match /[^a-z]{3}/<br></code></pre><br><p>这个例子我们在字符类中使用脱字符。</p><br><pre><code>p “ABC”.match /[^a-z]{3}/<br></code></pre><br><p>我们查找一个有3个字母的字符串。这些字母不能在a到z之间。”ABC”字符串匹配这个正则式，因为所有的三个字符都是大写字母。</p><br><pre><code>p “abc”.match /[^a-z]{3}/<br></code></pre><br><p>“abc”字符串没有匹配。</p><br><pre><code>$ ./caret.rb<br>#&lt;MatchData “ABC”&gt;<br>nil<br></code></pre><br><p>输出结果。</p><br><h2>量词</h2><br><p>标记或者组后面的量词表示前面的元素允许出现多少次。</p><br><pre><code> ?     - 0 or 1 match
 </code></pre></em>     - 0 or more<br> +     - 1 or more<br> {n}   - exactly n<br> {n,}  - n or more<br> {,n}  - n or less (??)<br> {n,m} - range n to m<br><br></p><p>上面是通常的量词列表。</p><br><pre><code>#!/usr/bin/ruby<br><br>p “seven dig moon car lot fire”.scan /\w{3}/<br>p “seven dig moon car lot fire”.scan /\b\w{3}\b/<br></code></pre><br><p>例子中我们想要选择这些有3个字符的单词。\w字符是一个词字符。\w{3}意味着前面的词字符出现3次。</p><br><pre><code>p “seven dig moon car lot fire”.scan /\w{3}/<br></code></pre><br><p>第一只是对每个字符串截取前三个字符。这不是我们想要的。</p><br><pre><code>p “seven dig moon car lot fire”.scan /\b\w{3}\b/<br></code></pre><br><p>这是改进的搜索。我们将之前的模式放在边界符\b之间。现在仅查找有三个字符的单词。</p><br><pre><code>$ ./nchars.rb<br>[“sev”, “dig”, “moo”, “car”, “lot”, “fir”]<br>[“dig”, “car”, “lot”]<br></code></pre><br><p>输出结果。</p><br><hr><br><p>{n,m}是一个重复结构对于有n到m个字符的字符串。</p><br><pre><code>#!/usr/bin/ruby<br><br>p “I dig moon lottery it fire”.scan /\b\w{2,4}\b/<br></code></pre><br><p>上面的例子我们选择有2、3、4个字符的单词。我们再次使用了边界符\b。</p><br><pre><code>$ ./rchars.rb<br>[“dig”, “moon”, “it”, “fire”]<br></code></pre><br><p>这个例子打印了一个有2-4个字符的单词数组。</p><br><hr><br><p>下一个例子我们展示<em>?</em>元字符。接着<em>?</em>的字符是可选的。<em>?</em>之前的字符可以出现一次或者0次。</p><br><pre><code>#!/usr/bin/ruby<br><br>p “color colour colors colours”.scan /colou?rs/<br>p “color colour colors colours”.scan /colou?rs?/<br><br>p “color colour colors colours”.scan /\bcolor\b|\bcolors\b|\bcolour\b|\bcolours\b/<br></code></pre><br><p>我们想要在一个文本中查找<em>colour</em>单词。这个单词有两种拼写方式，美式的’colour’和英式的’color’。我们想要两种都查找，此外我们还想查找复数形式。</p><br><pre><code>p “color colour colors colours”.scan /colou?rs/<br></code></pre><br><p>colou?rs模式查找’colours’和’colors’。u字符在?字符之前表示是可选的。</p><br><pre><code>p “color colour colors colours”.scan /colou?rs?/<br></code></pre><br><p>colou?rs?模式使u和s字符是可选的。因此我们会查找到这四个组合。</p><br><pre><code>p “color colour colors colours”.scan /\bcolor\b|\bcolors\b|\bcolour\b|\bcolours\b/<br></code></pre><br><p>相同的请求可以间隔的写。</p><br><pre><code>$ ./qmark.rb<br>[“colors”, “colours”]<br>[“color”, “colour”, “colors”, “colours”]<br>[“color”, “colour”, “colors”, “colours”]<br></code></pre><br><p>输出结果。</p><br><hr><br><p>这节的最后一个例子我们展示+字符。它允许前面的字符重复1次或多次。</p><br><pre><code>#!/usr/bin/ruby<br><br>nums = %w/ 234 1 23 53434 234532453464 23455636<br>    324f 34532452343452 343 2324 24221 34$34232/<br><br>nums.each do |num|<br>    m = num.match /[0-9]+/<br><br>    if m.to_s.eql? num<br>        puts num<br>    end<br>end<br></code></pre><br><p>这个例子我们有一个数字数组。数字可以有一个或者多个数字字符。</p><br><pre><code>nums = %w/ 234 1 23 53434 234532453464 23455636<br>    324f 34532452343452 343 2324 24221 34$34232/<br></code></pre><br><p>这是一个字符串数组。其中有两个不是数字，因为它们包含了非数字字符。</p><br><pre><code>nums.each do |num|<br>    m = num.match /[0-9]+/<br><br>    if m.to<em>s.eql? num<br>        puts num<br>    end<br>end<br></em></code></pre><br><p>我们遍历数组并对每个字符串应用正则式。表达式[0-9]+代表了0到9的任意字符重复0次或者多次。默认的这个表达式也会查找子字符串。<br>在34$34232中引擎认为34是一个数字。\b边界符在这里是无效的，因为我们没有具体的字符，引擎不知道该在哪里停止查找。这就是为什么我们在代码块中包含一个if条件式。仅当匹配结果等于原字符串才认为它是一个数字。</p><br><p>$ ./numbers.rb<br><br>234<br><br>1<br><br>23<br><br>53434<br><br>234532453464<br><br>23455636<br><br>34532452343452<br><br>343<br><br>2324<br><br>24221  </p><br><p>这些的值是数字。</p><br><h2>忽略大小写搜索</h2><br><p>我们可以执行忽略大小写的搜索。正则表达式可以接一个选项。它是一个单一的字符，以某种方式修改模式。这里不区分大小写的搜索我们使用i选项。</p><br><pre><code>#!/usr/bin/ruby<br><br>p “Jane”.match /Jane/<br>p “Jane”.match /jane/<br>p “Jane”.match /JANE/<br><br>p “Jane”.match /jane/i<br>p “Jane”.match /Jane/i<br>p “Jane”.match /JANE/i<br></code></pre><br><p>这个例子显示了区分大小写和不区分大小写的搜索。</p><br><pre><code>p “Jane”.match /Jane/<br>p “Jane”.match /jane/<br>p “Jane”.match /JANE/<br></code></pre><br><p>这三行的字符必须完全匹配模式。仅有第一行是匹配的。</p><br><pre><code>p “Jane”.match /jane/i<br>p “Jane”.match /Jane/i<br>p “Jane”.match /JANE/i<br></code></pre><br><p>这里我们使用i选项，接在第二个/字符后面。我们进行不区分大小写的搜索。这三行者匹配了。</p><br><pre><code>$ ./icase.rb<br>#&lt;MatchData “Jane”&gt;<br>nil<br>nil<br>#&lt;MatchData “Jane”&gt;<br>#&lt;MatchData “Jane”&gt;<br>#&lt;MatchData “Jane”&gt;<br></code></pre><br><p>例子的输出结果。</p><br><h2>交替</h2><br><p>一个例子解释交替操作符（|）。这个操作符可以创建一个有多个选择的正则式。</p><br><pre><code>#!/usr/bin/ruby<br><br>names = %w/Jane Thomas Robert Lucy Beky<br>    John Peter Andy/<br><br>pattern = /Jane|Beky|Robert/<br><br>names.each do |name|<br><br>    if name =~ pattern<br>        puts “#{name} is my friend”<br>    else<br>        puts “#{name} is not my friend”<br>    end<br>end<br></code></pre><br><p><em>names</em>数组中有8个名字。我们将在数组中查找多虑字符串的组合。</p><br><pre><code>pattern = /Jane|Beky|Robert/<br></code></pre><br><p>这是搜索模式。它表示Jane, Beky和Robert是我的朋友。如果你查找他们就会找到我的朋友。</p><br><p>$ ./alternation.rb<br><br>Jane is my friend<br><br>Thomas is not my friend<br><br>Robert is my friend<br><br>Lucy is not my friend<br><br>Beky is my friend<br><br>John is not my friend<br><br>Peter is not my friend<br><br>Andy is not my friend  </p><br><p>这是脚本的输出结果。</p><br><h2>子模式</h2><br><p>我们可以使用括号()创建子模式。</p><br><pre><code>#!/usr/bin/ruby<br><br>p “bookworm” =~ /book(worm)?$/<br>p “book” =~ /book(worm)?$/<br>p “worm” =~ /book(worm)?$/<br>p “bookstore” =~ /book(worm)?$/<br></code></pre><br><p>我们有如下正则式模式：book(worm)?$。(worm)是一个子模式。仅有两个字符串可以匹配：’book’或者’bookworm’。接在子模式后面的?字符意味着这个子模式出现0或者1次。这里$字符确切的匹配字符串的结尾。没有它单词bookstore和bookmania也会被匹配。</p><br><pre><code>#!/usr/bin/ruby<br><br>p “book” =~ /book(shelf|worm)?$/<br>p “bookshelf” =~ /book(shelf|worm)?$/<br>p “bookworm” =~ /book(shelf|worm)?$/<br>p “bookstore” =~ /book(shelf|worm)?$/<br></code></pre><br><p>子模式经常是多个单词组合交替结合的。例如，book(shelf|worm)匹配’bookshelf’和’bookworm’，book(shelf|worm)?匹配’bookshelf’，’bookworm’和’book’。</p><br><p>$ ./subpatterns2.rb<br><br>0<br><br>0<br><br>0<br><br>nil  </p><br><p>最后一个子模式没有匹配。记住0不意味着没有匹配。对于=~操作符，它是第一个匹配到的字符的索引。</p><br><h2>邮箱例子</h2><br><p>最后一个例子，我们创建一个正则式模式检查邮箱地址。</p><br><pre><code>#!/usr/bin/ruby<br><br>emails = %w/ luke@gmail.com andy@yahoo.com 23214sdj^as<br>    f3444@gmail.com /<br><br>pattern = /^[a-zA-Z0-9.-]+@[a-zA-Z0-9-]+.[a-zA-Z.]{2,5}$/<br><br>emails.each do |email|<br><br>    if email.match pattern<br>        puts “#{email} matches”<br>    else<br>        puts “#{email} does not match”<br>    end<br><br>end<br></code></pre><br><p>注意这个例子提供了仅一种解决方案。它不需要是最好的。</p><br><pre><code>emails = %w/ luke@gmail.com andy@yahoocom 23214sdj^as<br>    f3444@gmail.com /<br></code></pre><br><p>这是一个邮箱数组，仅有两个是有效的。</p><br><pre><code>pattern = /^[a-zA-Z0-9.<em>-]+@[a-zA-Z0-9-]+.[a-zA-Z.]{2,5}$/<br></em></code></pre><br><p>这是一个模式，第一个^和最后一个$是获取完整匹配。在模式之前和之后都不允许有字符。邮箱分为5部分。第一部分是本地部分，它通常是公司、个体或者昵称的名字。[a-zA-Z0-9.-]+列出了所有可能用于本地部分的字符，它们可以使用一次或者多次。第二部分是字面符@，第三部分是域名部分。它通常是邮箱的提供商，如 yahoo或者gmail。字符集[a-zA-Z0-9-]+指明了所有的可以用于域名的字符。+量词将这些字符使用一次或者多次。第四部分是点字符。它的前面接一个转义符。(.)因为点字符是一个元字符具有特殊意义。转义之后得到一个字面上的点。最后一部分是顶级域名。这个模式是[a-zA-Z.]{2,5}。顶级域名有2到5个字符，如sk, net, info, travel。这同样也有点字符，这是因此一些顶级域名有两部分如co.uk。</p><br><p>$ ./email.rb<br><br>luke@gmail.com matches<br><br>andy@yahoocom does not match<br><br>23214sdj^as does not match<br><br>f3444@gmail.com matches  </p><br><p>这个正则式标记了两个有效的邮箱地址。</p><br><p>在这章，我们学习了Ruby的正则表达式。</p><br><hr><br><p>原文地址： <a href="http://zetcode.com/lang/rubytutorial/regex/" target="_blank" rel="external">http://zetcode.com/lang/rubytutorial/regex/</a><br><br>翻译：龙昌  admin@longchangjin.cn<br><br>完整教程：<a href="https://github.com/wusuopu/Ruby-tutorial" target="_blank" rel="external">https://github.com/wusuopu/Ruby-tutorial</a> </p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://www.xefan.com/archives/83945.html" data-id="cjc95ct5w00j0n4q322emiaaa" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Ruby/">Ruby</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/翻译/">翻译</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-/archives/83942.html" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/archives/83942.html" class="article-date">
  <time datetime="2013-11-17T00:00:00.000Z" itemprop="datePublished">2013-11-17</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Ruby栏目/">Ruby栏目</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/archives/83942.html">[翻译]Ruby教程13——面向对象2</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p></p><h1>Ruby的面向对象编程2</h1><p></p>
<p>在这章的教程我们继续讨论Ruby的面向对象编程。</p><br><p>我们以属性修饰符开始。将会包涵类常量、类方法和操作符重载。我们将定义多态，并展示在Ruby中如何使用它。我们也会提及模块和异常。</p><br><h2>属性修饰符</h2><br><p>Ruby的所有变量都是私有的。它只能通过方法来访问。这些方法通常称为设值函数(setters)和获得者(getters)。创建一个setter和getter方法是很平常的事情。加些Ruby有便利的方法来创建这两种方法。它们是<em>attr_reader</em>、<em>attr_writer</em>和<em>attr_accessor</em>。</p><br><p><em>attr_reader</em>用于创建getter方法。<em>attr_writer</em>用于setter方法。<em>attr_accessor</em>用于创建两种方法。</p><br><pre><code>#!/usr/bin/ruby<br><br>class Car<br><br>    attr_reader :name, :price<br>    attr_writer :name, :price<br><br>    def to_s<br>        “#{@name}: #{@price}”<br>    end<br><br>end<br><br><br>c1 = Car.new<br>c2 = Car.new<br><br>c1.name = “Porsche”<br>c1.price = 23500<br><br>c2.name = “Volkswagen”<br>c2.price = 9500<br><br>puts “The #{c1.name} costs #{c1.price}”<br><br>p c1<br>p c2<br></code></pre><br><p>定义了一个<em>Car</em>类，在类内部我们使用了<em>attr_reader</em>和<em>attr_writer</em>创建了两个<em>getter</em>和<em>setter</em>方法。</p><br><pre><code>attr_reader :name, :price<br></code></pre><br><p>这里我们创建了两个实例方法名为：<em>name</em>和<em>price</em>。注意<em>attr_reader</em>将方法名符号作为参数。</p><br><pre><code>attr_writer :name, :price<br></code></pre><br><p><em>attr_writer</em>创建了两个<em>setter</em>方法<em>name</em>、<em>price</em>和两个实例变量<em>@name</em>、 <em>@price</em>。</p><br><pre><code>c1.name = “Porsche”<br>c1.price = 23500<br></code></pre><br><p>这里的上下文中调用了两个<em>setter</em>方法，为实例变量填充数据。</p><br><pre><code>puts “The #{c1.name} costs #{c1.price}”<br></code></pre><br><p>这里调用了两个<em>getter</em>方法获取数据。</p><br><p>$ ./arw.rb <br><br>The Porsche costs 23500<br><br>Porsche: 23500<br><br>Volkswagen: 9500  </p><br><p>例子的输出结果。</p><br><hr><br><p>正如上面阐述的，<em>attr_accessor</em>方法会创建<em>getter</em>、<em>setter</em>方法和它们的实例变量。</p><br><pre><code>#!/usr/bin/ruby<br><br>class Book<br>   attr_accessor :title, :pages<br>end<br><br>b1 = Book.new<br>b1.title = “Hidden motives”<br>b1.pages = 255<br><br>p “The book #{b1.title} has #{b1.pages} pages”<br></code></pre><br><p>定义了一个<em>Book</em>类，它使用<em>attr_accessor</em>创建了两对方法和两个实例变量。</p><br><pre><code>class Book<br>   attr_accessor :title, :pages<br>end<br></code></pre><br><p><em>attr_accessor</em>方法设置了<em>title</em>、<em>pages</em> 方法以及<em>@title</em>、<em>@pages</em>实例变量。</p><br><pre><code>b1 = Book.new<br>b1.title = “Hidden motives”<br>b1.pages = 255<br></code></pre><br><p>创建了一个<em>Book</em>对象。调用两个setter方法为对象的实例变量填充数据。</p><br><pre><code>p “The book #{b1.title} has #{b1.pages} pages”<br></code></pre><br><p>这行的代码我们调用getter方法读取实例变量的值。</p><br><p>$ ./accessor.rb<br><br>“The book Hidden motives has 255 pages”  </p><br><p>例子的输出结果。</p><br><h2>类的常量</h2><br><p>Ruby允许创建类常量。这些常量不属于特定的对象，它们是属于类的。作为约定，常量以大写字母开头。</p><br><pre><code>#!/usr/bin/ruby<br><br>class MMath<br><br>    PI = 3.141592<br>end<br><br><br>puts MMath::PI<br></code></pre><br><p>创建一个<em>MMath</em>类，包含了一个<em>PI</em>常量。</p><br><pre><code>PI = 3.141592<br></code></pre><br><p>我们创建了一个<em>PI</em>常量。记住在Ruby中常量不是强制的。</p><br><pre><code>puts MMath::PI<br></code></pre><br><p>使用<em>::</em>操作符访问<em>PI</em>常量。</p><br><p>$ ./classconstant.rb <br><br>3.141592  </p><br><p>例子输出结果。</p><br><h2>to_s方法</h2><br><p>每个对象都有一个<em>to_s</em>方法，它返回该对象的一个字符串描述。注意<em>puts</em>方法将一个对象作为参数时，该对象的<em>to_s</em>方法将被调用。</p><br><pre><code>#!/usr/bin/ruby<br><br>class Being<br><br>    def to_s<br>        “This is Being class”<br>    end<br>end<br><br>b = Being.new<br>puts b.to_s<br>puts b<br></code></pre><br><p>定义一个<em>Being</em>类并重载了<em>to_s</em>方法。</p><br><pre><code>def to_s<br>    “This is Being class”<br>end<br></code></pre><br><p>每个创建的类都继承自基类<em>Object</em>。<em>to_s</em>方法属于这个类。我们重载了<em>to_s</em>方法，使得描述信息更加可读。</p><br><pre><code>b = Being.new<br>puts b.to_s<br>puts b<br></code></pre><br><p>创建一个<em>Being</em>的对象，调用两次<em>to_s</em>方法。第一次是显式调用，第二次是隐式调用。</p><br><p>$ ./tostring.rb <br><br>This is Being class<br><br>This is Being class  </p><br><p>例子的运行结果。</p><br><h2>操作符重载</h2><br><p>操作符重载是基本参数的不同进行的操作也不同。</p><br><p>Ruby中操作符和方法仅有一点区别。</p><br><pre><code>#!/usr/bin/ruby<br><br>class Circle<br><br>    attr_accessor :radius<br><br>    def initialize r<br>        @radius = r<br>    end<br><br>    def +(other)<br>        Circle.new @radius + other.radius<br>    end<br><br>    def to_s<br>        “Circle with radius: #{@radius}”<br>    end<br>end<br><br><br>c1 = Circle.new 5<br>c2 = Circle.new 6<br>c3 = c1 + c2<br><br>p c3<br></code></pre><br><p>这个例子中，我们创建了一个<em>Circle</em>类，并重载了+操作符，用于将两个<em>circle</em>对象相加。</p><br><pre><code>def +(other)<br>    Circle.new @radius + other.radius<br>end<br></code></pre><br><p>我们定义了一个名为<em>+</em>的方法，这个方法将两个<em>circle</em>对象的半径相加。</p><br><pre><code>c1 = Circle.new 5<br>c2 = Circle.new 6<br>c3 = c1 + c2<br></code></pre><br><p>创建两个<em>circle</em>对象。在第三行我们将这两个对象相加生成一个新的对象。</p><br><p>$ ./operatoroverloading.rb<br><br>Circle with radius: 11  </p><br><p>这两个对象相加生成的第三个对象半径为11。</p><br><h2>类方法</h2><br><p>Ruby方法分为类方法和实例方法。类方法只能被类调用，不能被实例调用。</p><br><p>类方法不能访问实例变量。</p><br><pre><code>#!/usr/bin/ruby<br><br>class Circle<br><br>    def initialize x<br>        @r = x<br>    end<br><br>    def self.info<br>       “This is a Circle class”<br>    end<br><br>    def area<br>        @r <em> @r </em> 3.141592<br>    end<br><br>end<br><br><br>p Circle.info<br>c = Circle.new 3<br>p c.area<br></code></pre><br><p>上面的例子展示了一个<em>Circle</em>类。除了构造函数之外，还有一个类方法和一个实例方法。</p><br><pre><code>def self.info<br>    “This is a Circle class”<br>end<br></code></pre><br><p>以<em>self</em>关键字开头的是类方法。</p><br><pre><code>def area<br>    “Circle, radius: #{@r}”<br>end<br></code></pre><br><p>实例方法不以<em>self</em>关键字开头。</p><br><pre><code>p Circle.info<br></code></pre><br><p>调用类方法。注意我们是通过类来调用这个方法。</p><br><pre><code>c = Circle.new 3<br>p c.area<br></code></pre><br><p>为了调用实例方法我们必须得先创建一个对象。实例方法总是被对象调用。这里<em>c</em>变量保存了该对象，我们利用点操作符调用<em>area</em>方法。</p><br><p>$ ./classmethods.rb<br><br>“This is a Circle class”<br><br>28.274328  </p><br><p>例子的输出描述了Ruby的类方法。</p><br><hr><br><p>在Ruby中有三种方式创建类方法。</p><br><pre><code>#!/usr/bin/ruby<br><br>class Wood<br><br>    def self.info<br>       “This is a Wood class”<br>    end<br>end<br><br>class Brick<br><br>    class &lt;&lt; self<br>        def info<br>           “This is a Brick class”<br>        end<br>    end<br>end<br><br>class Rock<br><br>end<br><br>def Rock.info<br>   “This is a Rock class”<br>end<br><br><br>p Wood.info<br>p Brick.info<br>p Rock.info<br></code></pre><br><p>这个例子创建了三个类，每个都有一个类方法。</p><br><pre><code>def self.info<br>    “This is a Wood class”<br>end<br></code></pre><br><p>类方法可以以<em>self</em>关键字开头。</p><br><pre><code>class &lt;&lt; self<br>    def info<br>        “This is a Brick class”<br>    end<br>end<br></code></pre><br><p>另一个方式是将方法定义放在<em>class &lt;&lt; self</em>结构之后。</p><br><pre><code>def Rock.info<br>   “This is a Rock class”<br>end<br></code></pre><br><p>这是第三种定义类方法的方式。</p><br><p>$ ./classmethods2.rb<br><br>“This is a Wood class”<br><br>“This is a Brick class”<br><br>“This is a Rock class”  </p><br><p>调用<em>Wood</em>、<em>Brick</em>和<em>Rock</em>这三个类的类方法的输出结果。</p><br><h2>创建实例方法的三种方式</h2><br><p>Ruby有三种基本的方式创建实例方法。实例方法是属于实例对象的。它们是通过对象使用点操作符调用。</p><br><pre><code>#!/usr/bin/ruby<br><br>class Wood<br><br>    def info<br>       “This is a wood object”<br>    end<br>end<br><br>wood = Wood.new<br>p wood.info<br><br>class Brick<br><br>    attr_accessor :info<br>end<br><br>brick = Brick.new<br>brick.info = “This is a brick object”<br>p brick.info<br><br>class Rock<br><br>end<br><br>rock = Rock.new<br><br>def rock.info<br>    “This is a rock object”<br>end<br><br>p rock.info<br></code></pre><br><p>这个例子我们创建了三个实例对象<em>Wood</em>、<em>Brick</em>和<em>Rock</em>。每个对象都有一介上实例方法。</p><br><pre><code>class Wood<br><br>    def info<br>       “This is a wood object”<br>    end<br>end<br><br>wood = Wood.new<br>p wood.info<br></code></pre><br><p>这可能是最常用的一种方式。<em>info</em>方法定义在<em>Wood</em>类的内部。稍后创建一个对象并调用它的<em>info</em>方法。</p><br><pre><code>class Brick<br><br>    attr_accessor :info<br>end<br><br>brick = Brick.new<br>brick.info = “This is a brick object”<br>p brick.info<br></code></pre><br><p>另一种创建实例方法的方式是使用属性修饰符。这是一种方便的方式可以减少程序员的按键输入。<em>attr_accessor</em>创建两个方法getter和setter，同样也创建一个实例变量用于存储数据。创建一个<em>brick</em>对象，数据使用setter方法保存在<em>@info</em>变量中。最后使用getter方法读取消息。</p><br><pre><code>class Rock<br><br>end<br><br>rock = Rock.new<br><br>def rock.info<br>    “This is a rock object”<br>end<br><br>p rock.info<br></code></pre><br><p>第三种方法我们创建了一个空的<em>Rock</em>类。稍后实例化一个对象，动态的为这个对外创建一个方法。</p><br><p>$ ./threeways.rb<br><br>“This is a wood object”<br><br>“This is a brick object”<br><br>“This is a rock object”  </p><br><p>例子的输出结果。</p><br><h2>多态性</h2><br><p>多态是使用一个操作符或者函数对不同的数据进行不同的处理。实践中多态意味着如果类B继承自类A，它没有必要将类A的所有都继承；它可以做一些与类A不同的事情。</p><br><p>注意静态语言如C++、Java、或者C#和动态语言如Python、Ruby的多态有些不同。在静态语言中编译器决定了方法的定义。在动态语言中我们专注了同名方法的不同操作。</p><br><pre><code>#!/usr/bin/ruby<br><br>class Animal<br><br>    def make_noise<br>        “Some noise”<br>    end<br><br>    def sleep<br>        puts “#{self.class.name} is sleeping.”<br>    end<br><br>end<br><br>class Dog &lt; Animal<br><br>    def make_noise<br>        ‘Woof!’<br>    end<br><br>end<br><br>class Cat &lt; Animal<br><br>    def make_noise<br>        ‘Meow!’<br>    end<br>end<br><br>[Animal.new, Dog.new, Cat.new].each do |animal|<br>  puts animal.make_noise<br>  animal.sleep<br>end<br></code></pre><br><p>我们创建了一个简单的继承结构。有一个<em>Animal</em>基类和两个后代<em>Cat</em>和<em>Dog</em>。这三个类都有它自己的<em>make_noise</em>方法实现。后代的实现方法会替换掉<em>Animal</em>类的。</p><br><pre><code>class Dog &lt; Animal<br><br>    def make_noise<br>        ‘Woof!’<br>    end<br><br>end<br></code></pre><br><p><em>Dog</em>类的<em>make_noise</em>实现替换掉了<em>Animal</em>类的实现。</p><br><pre><code>[Animal.new, Dog.new, Cat.new].each do |animal|<br>  puts animal.make_noise<br>  animal.sleep<br>end<br></code></pre><br><p>为每个类的创建了一个实例对象，并对该对象调用了<em>make_noise</em>方法和<em>sleep</em>方法。</p><br><p>$ ./polymorhism.rb<br><br>Some noise<br><br>Animal is sleeping.<br><br>Woof!<br><br>Dog is sleeping.<br><br>Meow!<br><br>Cat is sleeping.  </p><br><p>polymorhism.rb脚本的输出结果。</p><br><h2>模块</h2><br><p>一个Ruby模块是方法、类和常量的集合。模块与类相似也有些不同。模块不能创建实例，没有子类。</p><br><p>模块用于将相关的类、方法和常量聚集单独放在一个模块中。这样也避免了命名的冲突，因为模块将它包含的对象进行了封装。从这方面来看Ruby的模块与C#的命名空间和Java的包相似。</p><br><p>在Ruby中模块也支持混合类（mixins）。混入类（mixin）是一个创建多继承的工厂。如果一个类继承自多个类，则称为多继承。</p><br><pre><code>#!/usr/bin/ruby<br><br>puts Math::PI<br>puts Math.sin 2<br></code></pre><br><p>Ruby有一个内建的<em>Math</em>模块。它有许多方法和常量。我们使用<em>::</em>操作符访问PI常量。与类相同使用点操作符访问方法。</p><br><pre><code>#!/usr/bin/ruby<br><br>include Math<br><br>puts PI<br>puts sin 2<br></code></pre><br><p>如果我包含了一个模块，我们就可以直接引用Math的对象了。模块导入使用<em>include</em>关键字。</p><br><p>$ ./modules.rb<br><br>3.141592653589793<br><br>0.9092974268256817  </p><br><p>程序的输出结果。</p><br><hr><br><p>下面的例子我们展示了如何使用模块来组织代码。</p><br><pre><code>#!/usr/bin/ruby<br><br>module Forest<br><br>    class Rock ; end<br>    class Tree ; end<br>    class Animal ; end<br><br>end<br><br>module Town<br><br>   class Pool ; end<br>   class Cinema ; end<br>   class Square ; end<br>   class Animal ; end<br><br>end<br><br><br>p Forest::Tree.new<br>p Forest::Rock.new<br>p Town::Cinema.new<br><br>p Forest::Animal.new<br>p Town::Animal.new<br></code></pre><br><p>Ruby代码可以主义分组。<em>Rocks</em>和<em>Tree</em>属于<em>Forest</em>。<em>Pools</em>、<em>Cinema</em>、<em>Squares</em>属于<em>Town</em>。使用模块让我们的代码更加有条理。<em>Animals</em>可以在<em>Forest</em>里也可以有<em>Town</em>里。对于一个脚本我们不能定义两个<em>Animal</em>类，它们会冲突。将它们放在不同的模块即可解决这个问题。</p><br><pre><code>p Forest::Tree.new<br>p Forest::Rock.new<br>p Town::Cinema.new<br></code></pre><br><p>创建属于<em>Forest</em>和<em>Town</em>的对象。我们使用<em>::</em>操作符访问模块里的对象。</p><br><pre><code>p Forest::Animal.new<br>p Town::Animal.new<br></code></pre><br><p>创建两个Animal对象。Ruby解释器会将它们标识为它们的模块名。</p><br><pre><code>$ ./modules3.rb<br>#&lt;Forest::Tree:0x97f35ec&gt;<br>#&lt;Forest::Rock:0x97f35b0&gt;<br>#&lt;Town::Cinema:0x97f3588&gt;<br>#&lt;Forest::Animal:0x97f3560&gt;<br>#&lt;Town::Animal:0x97f3538&gt;<br></code></pre><br><p>modules3.rb程序的输出。</p><br><hr><br><p>这节的最后一个例子我们将展示使用模块进行多继承。在这里的上下文中模块称为混合类（mixins）。</p><br><pre><code>#!/usr/bin/ruby<br><br>module Device<br>    def switch_on ; puts “on” end<br>    def switch_off ; puts “off” end<br>end<br><br>module Volume<br>    def volume_up ; puts “volume up” end<br>    def vodule_down ; puts “volume down” end<br>end<br><br>module Pluggable<br>    def plug_in ; puts “plug in” end<br>    def plug_out ; puts “plug out” end<br>end<br><br>class CellPhone<br>    include Device, Volume, Pluggable<br><br>    def ring<br>        puts “ringing”<br>    end<br>end<br><br>cph = CellPhone.new<br>cph.switch_on<br>cph.volume_up<br>cph.ring<br></code></pre><br><p>我们定义了三个模块和一个类。模块代表了一些功能。一个设备可以调节开头。许多对象都可以分享这个功能，包含电视、手机、电脑和冰箱。相对于为每个对象创建这个功能，我们是将它分隔在一个模块里，它可以被每个对象包含。这样代码将更加有条理更紧凑。</p><br><pre><code>module Volume<br>    def volume_up ; puts “volume up” end<br>    def vodule_down ; puts “volume down” end<br>end<br></code></pre><br><p><em>Volume</em>模块组织了负责控制音量等级的方法。如果一个设备需要这些方法，它只需要简单的在自己的类中包含这个模块即可。</p><br><pre><code>class CellPhone<br>    include Device, Volume, Pluggable<br><br>    def ring<br>        puts “ringing”<br>    end<br>end<br></code></pre><br><p><em>CellPhone</em>添加了这三个模块。这些模块的方法混合在<em>CellPhone</em>类中。对于这个类的实例对象同样有效。<em>CellPhone</em>类也有一个自己的<em>ring</em>方法。</p><br><pre><code>cph = CellPhone.new<br>cph.switch_on<br>cph.volume_up<br>cph.ring<br></code></pre><br><p>创建了一个<em>CellPhone</em>对象并调用了三个方法。</p><br><p>$ ./mixins.rb<br><br>on<br><br>volume up<br><br>ringing  </p><br><p>例子的运行结果。</p><br><h2>异常</h2><br><p>异常是对象偏离了正常的程序执行流的信号。<br><br>异常出现、抛出或者开始。</p><br><p>在应用程序执行期间，许多事情可能引起错误。磁盘满了我们不能保存文件。网络断了但应用程序试图连接某个网站。所有的这些可能引起应用程序崩溃。为了避免这个的发生，我们应当在程序异常时预先处理错误。对于这个我们可以使用异常处理。</p><br><p>异常是对象，它们是内建<em>Exception</em>类的后代。<em>Exception</em>对象携带了关于异常的信息。它的类型（异常的类名），可选的描述字符串，和一个可选的跟踪信息。为了获取关于程序运行异常的额外信息，程序可以子类化<em>Exception</em>或者更多是<em>StandardError</em>。</p><br><pre><code>#!/usr/bin/ruby<br><br>x = 35<br>y = 0<br><br>begin<br>    z = x / y<br>    puts z<br>rescue =&gt; e<br>    puts e<br>    p e<br>end<br></code></pre><br><p>上面的程序我们故意的除以0,这个导致一个错误。</p><br><pre><code>begin<br>    z = x / y<br>    puts z<br></code></pre><br><p>出错的语句位置<em>begin</em>关键字之后。</p><br><pre><code>rescue =&gt; e<br>    puts e<br>    p e<br>end<br></code></pre><br><p><em>rescue</em>关键字之后的代码我们处理一个异常。这里我们在终端上打印错误信息。<em>e</em>是一个异常对象，在错误发生时创建的。</p><br><pre><code>$ ./zerodivision.rb<br>divided by 0<br>#&lt;ZeroDivisionError: divided by 0&gt;<br></code></pre><br><p>输出结果我们看到了异常信息。最后一行显示了异常对象名为<em>ZeroDivisionError</em>。</p><br><hr><br><p>程序员可以使用<em>raise</em>关键字发起自己的异常。</p><br><pre><code>#!/usr/bin/ruby<br><br>age = 17<br><br>begin<br>    if age &lt; 18<br>        raise “Person is a minor”<br>    end<br><br>    puts “Entry allowed”<br>rescue =&gt; e<br>    puts e<br>    p e<br>    exit 1<br>end<br></code></pre><br><p>俱乐部不允许不满18岁的青年进入。我们使用Ruby脚本模拟这个情况。</p><br><pre><code>begin<br>    if age &lt; 18<br>        raise “Person is a minor”<br>    end<br><br>    puts “Entry allowed”<br></code></pre><br><p>如果是未成年人，将出现一个异常。如果<em>raise</em>关键字没有指明异常参数，则<em>RuntimeError</em>异常将引发。这个代码不会到达<em>puts “Entry allowed”</em>这行。代码执行中断并继续<em>rescue</em>的代码块。</p><br><pre><code>rescue =&gt; e<br>    puts e<br>    p e<br>    exit 1<br>end<br></code></pre><br><p>在<em>rescue</em>代码块中我们打印错误信息，<em>RuntimeError</em>对象的一个字符串描述。我们也调用了<em>exit</em>方法通知环境该脚本错误退出。</p><br><pre><code>$ ./raise_exception.rb<br>Person is a minor<br>#&lt;RuntimeError: Person is a minor&gt;<br>$ echo $?<br>1<br></code></pre><br><p>未成年人不允许进行俱乐部。bash的$?变量设置了这个脚本错误退出。</p><br><hr><br><p>Ruby的<em>ensure</em>从名创建的代码块总是会被执行，不管是否有异常。</p><br><pre><code>#!/usr/bin/ruby<br><br>begin<br>    f = File.open(“stones”, “r”)<br><br>    while line = f.gets do<br>        puts line<br>    end<br><br>rescue =&gt; e<br>    puts e<br>    p e<br>ensure<br>    f.close if f<br>end<br></code></pre><br><p>这个例子我们尝试打开并读取stones文件。I/O操作容易出现错误。</p><br><pre><code>ensure<br>    f.close if f<br>end<br></code></pre><br><p>在<em>ensure</em>的代码块中我们关闭文件处理对象。我们查检处理对象是否存在，因为它可能没有被创建。分配的资源通常位于<em>ensure</em>代码块里。</p><br><hr><br><p>如果想到，我们可以创建自定义的异常。Ruby中自定义异常继承自<em>StandardError</em>类。</p><br><pre><code>#!/usr/bin/ruby<br><br>class BigValueError &lt; StandardError ; end<br><br>LIMIT = 333<br>x = 3_432_453<br><br>begin<br><br>    if x &gt; LIMIT<br>        raise BigValueError, “Exceeded the maximum value”<br>    end<br><br>    puts “Script continues”<br><br>rescue =&gt; e<br>    puts e<br>    p e<br>    exit 1<br>end<br></code></pre><br><p>我们有一个情况不能处理大的数字。</p><br><pre><code>class BigValueError &lt; StandardError ; end<br></code></pre><br><p>我们定义一个<em>BigValueError</em>类。这个类继承自<em>StandardError</em>类。</p><br><pre><code>LIMIT = 333<br></code></pre><br><p>数字超过这个常量就被认为是大的。</p><br><pre><code>if x &gt; LIMIT<br>    raise BigValueError, “Exceeded the maximum value”<br>end<br></code></pre><br><p>如果值比<em>LIMIT</em>在，则抛出一个自定义异常。异常信息为<em>“Exceeded the maximum value”</em>。</p><br><pre><code>$ ./custom_exception.rb<br>Exceeded the maximum value<br>#&lt;BigValueError: Exceeded the maximum value&gt;<br></code></pre><br><p>执行程序。</p><br><p>在这一章我们完成了Ruby语言的面向对象编程。</p><br><hr><br><p>原文地址： <a href="http://zetcode.com/lang/rubytutorial/oop2/" target="_blank" rel="external">http://zetcode.com/lang/rubytutorial/oop2/</a><br><br>翻译：龙昌  admin@longchangjin.cn<br><br>完整教程：<a href="https://github.com/wusuopu/Ruby-tutorial" target="_blank" rel="external">https://github.com/wusuopu/Ruby-tutorial</a> </p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://www.xefan.com/archives/83942.html" data-id="cjc95ct5v00iyn4q3oacsspvv" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Ruby/">Ruby</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/翻译/">翻译</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-/archives/83939.html" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/archives/83939.html" class="article-date">
  <time datetime="2013-11-16T00:00:00.000Z" itemprop="datePublished">2013-11-16</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Ruby栏目/">Ruby栏目</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/archives/83939.html">[翻译]Ruby教程12——面向对象</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p></p><h1>Ruby的面向对象编程</h1><p></p>
<p>在这部分的Ruby教程我们将讨论面向对象编程。</p><br><p>编程语言有过程式编程、函数式编程和面向对象编程范式。Ruby中面向对象语言并包含了一些函数式和过程式。</p><br><p>面向对象(OOP)是一种使用对象及其接口来设计应用程序和计算机程序的编程范式。</p><br><p>面向对象的基本概念如下：</p><br><ul><br><li>抽象（Abstraction）  </li><br><li>多态（Polymorphism）  </li><br><li>封装（Encapsulation）  </li><br><li>继承（Inheritance）  </li><br></ul><br><p>抽象是对于现实中复杂的问题通过适当的建模将其简化。多态是使用相同的操作符或者函数对不同的输入数据进行不同处理。封装是将一个类的具体实现对其他对象进行隐藏。继承是一种使用已经定义的类来创建新的类的方式。</p><br><h2>对象</h2><br><p>对象是Ruby面向对象程序的基本组成。一个对象包含了数据和方法。对象之间通过方法进行交流。每个对象可以接收消息、发送消息和处理数据。</p><br><p>创建一个对象需要两步。首先定义一个类。类是对象的模板。它是一张蓝图，用来描述这个类的所有对象的状态和行为。一个类可以创建多个对象。运行时创建的对象称为这个类的实例。</p><br><pre><code>#!/usr/bin/ruby<br><br>class Being<br><br>end<br><br>b = Being.new<br>puts b<br></code></pre><br><p>第一个例子我们创建了一个简单的对象。</p><br><pre><code>class Being<br><br>end<br></code></pre><br><p>定义一个简单的类，内容为空。表示它没有任何数据和方法。</p><br><pre><code>b = Being.new<br></code></pre><br><p>创建一个<em>Being</em>类的新实例。这里我们使用<em>new</em>方法，新创建的对象保存在变量b中。</p><br><pre><code>puts b<br></code></pre><br><p>在终端上打印对象的基本描述。当我们打印一个对象时，实际上是调用的<em>to_s</em>方法。但是我们没有任何的定义，因为每个创建的对象都是继承自<em>Object</em>。它有一些基本的函数，<em>to_s</em>是其中一个。</p><br><pre><code>$ ./simple.rb<br>#&lt;Being:0x9f3c290&gt;<br></code></pre><br><p>我们得到这个对象的类名。</p><br><h2>构造函数</h2><br><p>构造函数是一个特殊的方法。它在对象创建时自动执行。它没有返回值。构造函数的目的是初始化对象的状态。在Ruby中构造函数名为<em>intialize</em>。</p><br><p>构造函数不能被继承。父对象的构造函数是通过<em>super</em>方法来调用。它们的调用顺序与继承顺序一致。</p><br><pre><code>#!/usr/bin/ruby<br><br>class Being<br><br>    def initialize<br>        puts “Being is created”<br>    end<br><br>end<br><br>Being.new<br></code></pre><br><p>定义一个<em>Being</em>类。</p><br><pre><code>class Being<br><br>    def initialize<br>        puts “Being is created”<br>    end<br><br>end<br></code></pre><br><p>类<em>Being</em>定义了一个构造函数名为<em>initialize</em>。它在终端上打印一条信息。Ruby中方法定义位置<em>def</em>和<em>end</em>关键字之间。</p><br><pre><code>Being.new<br></code></pre><br><p>创建一个<em>Being</em>类的实例对象。在对象初创时构造函数将被调用。</p><br><p>$ ./constructor.rb<br><br>Being is created  </p><br><p>程序的输出。</p><br><hr><br><p>对象的属性是绑定在对象里的数据项。这些数据项也称为实例变量（instance variables）或者成员字段（member fields）。实例变量在类中定义但是各个对象都有单独的复本。</p><br><p>下面的例子我们初始化类的成员数据。变量初始化是构造函数的典型工作。</p><br><pre><code>#!/usr/bin/ruby<br><br>class Person<br><br>    def initialize name<br>        @name = name<br>    end<br><br>    def get_name<br>        @name<br>    end<br><br>end<br><br>p1 = Person.new “Jane”<br>p2 = Person.new “Beky”<br><br>puts p1.get_name<br>puts p2.get_name<br></code></pre><br><p>上面的例子定义了一个<em>Person</em>类，并且有一个实例变量。</p><br><pre><code>class Person<br><br>    def initialize name<br>        @name = name<br>    end<br></code></pre><br><p><em>Person</em>的构造函数设置了一个实例变量<em>name</em>。构造函数的<em>name</em>参数是在创建时传递的。构造函数是在实例对象创建时调用。<em>@name</em>是一个实例变量。在Ruby中实例变量以@字符开头。</p><br><pre><code>def get_name<br>    @name<br>end<br></code></pre><br><p><em>get_name</em>方法返回成员字段。在Ruby蝇成员字段只能通过方法来访问。</p><br><pre><code>p1 = Person.new “Jane”<br>p2 = Person.new “Beky”<br></code></pre><br><p>我们创建了<em>Person</em>类的两个对象。每个对象的构造函数都传递了一个字符串参数。</p><br><pre><code>puts p1.get_name<br>puts p2.get_name<br></code></pre><br><p>通过调用每个对象的<em>get_name</em>方法来打印成员字段。</p><br><p>$ ./person.rb<br><br>Jane<br><br>Beky  </p><br><p>从程序的输出看到每个实例都有自己的<em>name</em>成员字段。</p><br><hr><br><p>我们可以创建一个对象而不调用构造函数。Ruby有一个特殊的<em>allocate</em>方法。<em>allocate</em>方法为新的对象分配空间而不调用<em>initialize</em>。</p><br><pre><code>#!/usr/bin/ruby<br><br>class Being<br><br>   def initialize<br>       puts “Being created”<br>   end<br>end<br><br><br>b1 = Being.new<br>b2 = Being.allocate<br>puts b2<br></code></pre><br><p>这个例子我们创建了两个对象。第一介对象使用<em>new</em>方法，第二个对象使用<em>allocate</em>方法。</p><br><pre><code>b1 = Being.new<br></code></pre><br><p>这里我们通过<em>new</em>关键字创建一个实例对象。构造函数<em>initialize</em>将会调用，并且在终端上打印消息。</p><br><pre><code>b2 = Being.allocate<br>puts b2<br></code></pre><br><p>这里使用<em>allocate</em>方法，没有调用构造函数。使用<em>puts</em>关键字调用对象的<em>to_s</em>方法将其显示。</p><br><pre><code>$ ./allocate.rb<br>Being created<br>#&lt;Being:0x8ea0044&gt;<br></code></pre><br><p>程序的输出。</p><br><h2>构造函数重载</h2><br><p>重载构造函数可以使用类有多种类型的构造函数。这样我们可以使用不同数量或者不同类型的参数来创建对象。</p><br><p>Ruby没有我们所知的其他语言那样的构造函数重载。在Ruby中这种行为可以通过一些有默认值的扩展参数来模拟。</p><br><pre><code>#!/usr/bin/ruby<br><br><br>class Person<br><br>    def initialize name=”unknown”, age=0<br>        @name = name<br>        @age = age<br>    end<br><br>    def to_s<br>        “Name: #{@name}, Age: #{@age}”<br>    end<br><br>end<br><br>p1 = Person.new<br>p2 = Person.new “unknown”, 17<br>p3 = Person.new “Becky”, 19<br>p4 = Person.new “Robert”<br><br>p p1, p2, p3, p4<br></code></pre><br><p>这个例子展示了模拟构造函数的重载。当<em>name</em>参数没有指定时使用<em>“unknow”</em>代替，对于<em>age</em>使用0。</p><br><pre><code>def initialize name=”unknown”, age=0<br>    @name = name<br>    @age = age<br>end<br></code></pre><br><p>这个构造传入两个参数。它们都有默认值。当我们创建对象没有指定值时就使用默认值。注意参数顺序必须一致。第一个是<em>name</em>，第二介是<em>age</em>。</p><br><pre><code>p1 = Person.new<br>p2 = Person.new “unknown”, 17<br>p3 = Person.new “Becky”, 19<br>p4 = Person.new “Robert”<br><br>p p1, p2, p3, p4<br></code></pre><br><p>我们创建了四个对象。构造函数传入了不同个数的参数。</p><br><p>$ ./consover.rb<br><br>Name: unknown, Age: 0<br><br>Name: unknown, Age: 17<br><br>Name: Becky, Age: 19<br><br>Name: Robert, Age: 0  </p><br><p>例子的输出结果。</p><br><h2>方法</h2><br><p>方法是定义在类里面的函数。它们用于对对象的属性执行一些操作。方法在面向对象范式的封装性中必不可少。例如我们<em>AccessDatabase</em>类中有一个<em>connect</em>方法，我们不需要关心这个方法到底是如何连接数据库的。我们仅需要知道使用这个方法连接数据库。这对程序功能的划分必不可少，尤其是大的应用程序。</p><br><p>在Ruby中数据仅能够通过方法访问。</p><br><pre><code>#!/usr/bin/ruby<br><br>class Person<br><br>    def initialize name<br>        @name = name<br>    end<br><br>    def get_name<br>        @name<br>    end<br><br>end<br><br>per = Person.new “Jane”<br><br>puts per.get_name<br>puts per.send :get_name<br></code></pre><br><p>这个例子展示了调用方法的两个基本方式。</p><br><pre><code>puts per.get_name<br></code></pre><br><p>通常的方式是在对象后面使用点操作符。</p><br><pre><code>puts per.send :get_name<br></code></pre><br><p>另种方式是使用内建的<em>send</em>方法。它将方法名符号作为参数传入。</p><br><hr><br><p>方法通常对对象的数据进行一些操作。</p><br><pre><code>#!/usr/bin/ruby<br><br>class Circle<br><br>    @@PI = 3.141592<br><br>    def initialize<br>        @radius = 0<br>    end<br><br>    def set_radius radius<br>        @radius = radius<br>    end<br><br>    def area<br>        @radius <em> @radius </em> @@PI<br>    end<br><br>end<br><br><br>c = Circle.new<br>c.set_radius 5<br>puts c.area<br></code></pre><br><p>这个例子的代码我们定义了一个<em>Circle</em>类两个方法。</p><br><pre><code>@@PI = 3.141592<br></code></pre><br><p>我们在<em>Circle</em>类中定义了一个<em>@@PI</em>变量。类变量以<em>@@</em>开头。类变量是属于类的，每个对象都可以访问它们的类变量。我们<em>@@PI</em>来计算圆的面积。</p><br><p>def initialize<br>    @radius = 0<br>end</p><br><p>定义了一个成员字段。它是圆的半径。如果我们想在外部修改这个变量，我们必须使用公开的<em>set_radius</em>方法。这个数据是受保护的。</p><br><pre><code>def set_radius radius<br>    @radius = radius<br>end<br></code></pre><br><p>这是<em>set_radius</em>方法。它为<em>@radius</em>实例变量设置一个新的值。</p><br><pre><code>def area<br>    @radius <em> @radius </em> @@PI<br>end<br></code></pre><br><p><em>area</em>方法返回圆的面积。</p><br><pre><code>c = Circle.new<br>c.set_radius 5<br>puts c.area<br></code></pre><br><p>我们创建一个<em>Circle</em>类的实例对象，并且通过<em>set_radius</em>方法设置它的半径。</p><br><p>$ ./circle.rb<br><br>78.5398  </p><br><p>例子的输出结果。</p><br><h2>访问修饰符</h2><br><p>访问修饰符设置成员和方法的可见性。Ruby有三种访问修饰符：<em>public</em>、<em>protected</em>和<em>private</em>。在Ruby中所有的数据都是私有的。访问修饰符可以仅对方法使用。Ruby中的方法是公开的，除非使用了其他修饰符。</p><br><p>公开的方法在类的内部和外部都可以访问。保护和私有的方法略微不同。都不能在类外部访问，仅能在这个类和它的子类或者父类内部访问。</p><br><p>注意与其他面向对象编程语言不同，继承不会充当访问修饰符。仅有两件事很重要。第一，我们是否可以在类的内部或者外部访问方法。第二，是否我们要使用或者不使用<em>self</em>关键字。</p><br><p>访问修饰符保护数据避免受到意外的修改。使用程序更健壮。实现一些主要用于修改数据的方法。这些方法最好是私有的。只有真正需要修改才将接口公开给用户。多年来用户习惯使用特殊方法并对打破向后兼容普遍不满。</p><br><pre><code>#!/usr/bin/ruby<br><br>class Some<br><br>     def method1<br>         puts “public method1 called”<br>     end<br><br>    public<br><br>     def method2<br>         puts “public method2 called”<br>     end<br><br>     def method3<br>         puts “public method3 called”<br>         method1<br>         self.method1<br>     end<br>end<br><br>s = Some.new<br>s.method1<br>s.method2<br>s.method3<br></code></pre><br><p>这个例子解释了Ruby公有方法的用法。</p><br><pre><code>def method1<br>    puts “public method1 called”<br>end<br></code></pre><br><p><em>method1</em>是公有的，尽管我们没有使用<em>public</em>修饰符。因为方法默认都是公有的，除非指明为其他。</p><br><pre><code>public<br><br>  def method2<br>      puts “public method2 called”<br>  end<br><br>  …<br></code></pre><br><p><em>public</em>关键字之后的方法是公有的。</p><br><pre><code>def method3<br>    puts “public method3 called”<br>    method1<br>    self.method1<br>end<br></code></pre><br><p>在公有方法<em>method3</em>中我们通过使用和没有使用<em>self</em>关键字调用了另一个公有方法。</p><br><pre><code>s = Some.new<br>s.method1<br>s.method2<br>s.method3<br></code></pre><br><p>公有方法是仅能够在类外部调用的方法。</p><br><p>$ ./public_methods.rb<br>public method1 called<br>public method2 called<br>public method3 called<br>public method1 called<br>public method1 called</p><br><p>例子运行结果。</p><br><hr><br><p>下一个例子看私有方法。</p><br><pre><code>#!/usr/bin/ruby<br><br><br>class Some<br><br>    def initialize<br>        method1<br>        # self.method1<br>    end<br><br>    private<br><br>     def method1<br>         puts “private method1 called”<br>     end<br><br>end<br><br><br>s = Some.new<br># s.method1<br></code></pre><br><p>私有方法是Ruby中严厉的方法。它们只能够在类内部调用并且不能使用<em>self</em>关键字。</p><br><pre><code>def initialize<br>    method1<br>    # self.method1<br>end<br></code></pre><br><p>在构造函数方法中我们调用了私有方法<em>method1</em>。使用<em>self</em>调用的被注释了。私有方法不能指定接收者。</p><br><pre><code>private<br><br>  def method1<br>      puts “private method1 called”<br>  end<br></code></pre><br><p><em>private</em>关键字之后的是私有方法。</p><br><pre><code>s = Some.new<br># s.method1<br></code></pre><br><p>创建了一个<em>Some</em>类的实例对象。在外部调用这个方法是禁止的，如果将这行取消注释Ruby解释器会报错。</p><br><p>$ ./private_methods.rb<br><br>private method called  </p><br><p>输出结果。</p><br><hr><br><p>最后我们使用保护方法。保护方法和私有方法的区别很小。保护方法与私有方法相似，不过它们可以通过<em>self</em>关键字调用。</p><br><pre><code>#!/usr/bin/ruby<br><br>class Some<br><br>    def initialize<br>        method1<br>        self.method1<br>    end<br><br>    protected<br><br>     def method1<br>         puts “protected method1 called”<br>     end<br><br>end<br><br><br>s = Some.new<br># s.method1<br></code></pre><br><p>上面的例子展示了保护方法的用法。</p><br><pre><code>def initialize<br>    method1<br>    self.method1<br>end<br></code></pre><br><p>保护方法可以使用和不使用<em>self</em>关键字。</p><br><pre><code>protected<br><br>  def method1<br>      puts “protected method1 called”<br>  end<br></code></pre><br><p>保护方法以<em>protected</em>关键字开头。</p><br><pre><code>s = Some.new<br># s.method1<br></code></pre><br><p>保护方法不能在类外部调用。取消注释会报错。</p><br><h2>继承</h2><br><p>继承是使用已经定义的类来构造新的类的方式。新构建的类称为派生类。派生自的类称为基类。继承的好处是代码利用，减少程序的复杂性。派生类（后代）覆盖或者扩展基类（祖先）的函数。</p><br><pre><code>#!/usr/bin/ruby<br><br>class Being<br><br>    def initialize<br>        puts “Being class created”<br>    end<br>end<br><br>class Human &lt; Being<br><br>   def initialize<br>       super<br>       puts “Human class created”<br>   end<br>end<br><br>Being.new<br>Human.new<br></code></pre><br><p>这个程序我们定义了两个类：一个基类<em>Being</em>和一个派生类<em>Human</em>。</p><br><pre><code>class Human &lt; Being<br></code></pre><br><p>Ruby中使用<em>&lt;</em>操作符创建继承关系。<em>Human</em>类继承自<em>Being</em>类。</p><br><pre><code>def initialize<br>    super<br>    puts “Human class created”<br>end<br></code></pre><br><p><em>super</em>方法调用父类的构造函数。</p><br><pre><code>Being.new<br>Human.new<br></code></pre><br><p>实例化了<em>Being</em>类和<em>Human</em>类。</p><br><p>$ ./inheritance.rb <br><br>Being class created<br><br>Being class created<br><br>Human class created  </p><br><p>首先创建<em>Being</em>类。基类<em>Human</em>同样也调用了父类的构造函数。</p><br><hr><br><p>一个对象的关系可能很复杂。一个对象可以有多个祖先。Ruby有<em>ancestors</em>方法获取一个类的祖先列表。</p><br><p>每个Ruby对象都是<em>Object</em>、<em>BaseObject</em>和<em>Kernel</em>的后代。它们内建于Ruby语言的内核中。</p><br><pre><code>#!/usr/bin/ruby<br><br><br>class Being<br>end<br><br>class Living &lt; Being<br>end<br><br>class Mammal &lt; Living<br>end<br><br>class Human &lt; Mammal<br>end<br><br><br>p Human.ancestors<br></code></pre><br><p>这个例子中定义了四个类。<em>Human</em>、<em>Mammal</em>、<em>Living</em>和<em>Being</em>。</p><br><pre><code>p Human.ancestors<br></code></pre><br><p>打印Human类的祖先。</p><br><p>$ ./ancestors.rb <br><br>[Human, Mammal, Living, Being, Object, Kernel, BasicObject]  </p><br><p><em>Human</em>类有三个自定义的和三个内建的祖先。</p><br><hr><br><p>一个更复杂的例子。</p><br><pre><code>#!/usr/bin/ruby<br><br>class Being<br><br>    @@count = 0<br><br>    def initialize<br>        @@count += 1<br>        puts “Being class created”<br>    end<br><br>    def show_count<br>        “There are #{@@count} beings”<br>    end<br><br>end<br><br>class Human &lt; Being<br><br>   def initialize<br>       super<br>       puts “Human is created”<br>   end<br>end<br><br>class Animal &lt; Being<br><br>   def initialize<br>       super<br>       puts “Animal is created”<br>   end<br>end<br><br>class Dog &lt; Animal<br><br>   def initialize<br>       super<br>       puts “Dog is created”<br>   end<br>end<br><br>Human.new<br>d = Dog.new<br>puts d.show_count<br></code></pre><br><p>我们定义了四个类。继承的层级有点复杂。<em>Human</em>和<em>Animal</em>继承自<em>Being</em>。<em>Dog</em>继承自<em>Animal</em>。我们还使用了类变量来统计beings的创建个数。</p><br><pre><code>@@count = 0<br></code></pre><br><p>我们定义一个类变量。它用于统计beings的创建个数。</p><br><pre><code>def initialize<br>    @@count += 1<br>    puts “Being class created”<br>end<br></code></pre><br><p>每次<em>Being</em>类实例化时我们将<em>@@count</em>变量加1。这使用我们可以跟踪实例创建的个数。</p><br><pre><code>class Animal &lt; Being<br>…<br><br>class Dog &lt; Animal<br>…<br></code></pre><br><p><em>Animal</em>继承自<em>Being</em>，<em>Dog</em>继承自<em>Animal</em>。进一步的<em>Dog</em>也继承自<em>Being</em>。</p><br><pre><code>Human.new<br>d = Dog.new<br>puts d.show_count<br></code></pre><br><p>我们通过<em>Human</em>和<em>Dog</em>创建实例。然后调用<em>Dog</em>对象的<em>show_count</em>方法。<em>Dog</em>类没有该方法，将调用<em>Being</em>类的。</p><br><p>$ ./inheritance2.rb<br>Being class created<br><br>Human is created<br><br>Being class created<br><br>Animal is created<br><br>Dog is created<br><br>There are 2 beings  </p><br><p><em>Human</em>对象调用了两个构造函数。<em>Dog</em>对象调用了三个构造函数。创建了两个<em>Being</em>实例。</p><br><hr><br><p>方法和数据成员可见性在继承中不起作用。这与其他通常的面向对象编程语言是显著的不同。</p><br><p>在C#或者Java中公有的和保护的数据成员和方法可以被继承，私有的不能。与这相比，在Ruby中私有的数据成员和方法也可以被继承。数据成员和方法的可见性不会受继承的影响。</p><br><pre><code>#!/usr/bin/ruby<br><br>class Base<br><br>    def initialize<br>        @name = “Base”<br>    end<br><br>    private<br><br>     def private_method<br>         puts “private method called”<br>     end<br><br>    protected<br><br>     def protected_method<br>         puts “protected_method called”<br>     end<br><br>    public<br><br>     def get_name<br>         return @name<br>     end<br>end<br><br><br>class Derived &lt; Base<br><br>    def public_method<br>        private_method<br>        protected_method<br>    end<br>end<br><br>d = Derived.new<br>d.public_method<br>puts d.get_name<br></code></pre><br><p>这个例子中有两个类。<em>Derived</em>继承乍<em>Base</em>。它继承了三个方法和一个数据字段。</p><br><pre><code>def public_method<br>    private_method<br>    protected_method<br>end<br></code></pre><br><p><em>Derived</em>类的<em>public_method</em>调用了一个私有方法和一个保护方法。它们定义在父类中。</p><br><pre><code>d = Derived.new<br>d.public_method<br>puts d.get_name<br></code></pre><br><p>创建一个<em>Derived</em>类的实例。调用<em>public_method</em>方法和<em>get_name</em>方法，它返回私有的实例变量<em>@name</em>。记住Ruby中所有的实例变量都是私有的。<em>get_name</em>方法返回这个变量不管<em>@name</em>是私有的还是在父类中定义的。</p><br><p>$ ./inheritance3.rb<br><br>private method called<br><br>protected_method called<br><br>Base  </p><br><p>输出结果证实了在Ruby中公有的、保护的、私有的方法和私有的成员字段都能被继承。</p><br><h2>super方法</h2><br><p><em>super</em>方法调用父类的同名方法。如果没有传递参数它将自动的把当前的所有参数传入。如果写为<em>super()</em>则没有参数传入。</p><br><pre><code>#!/usr/bin/ruby<br><br>class Base<br><br>    def show x=0, y=0<br>        p “Base class, x: #{x}, y: #{y}”<br>    end<br>end<br><br>class Derived &lt; Base<br><br>    def show x, y<br>        super<br>        super x<br>        super x, y<br>        super()<br>    end<br>end<br><br><br>d = Derived.new<br>d.show 3, 3<br></code></pre><br><p>这个例子有两个类一个继承。它们都定义了<em>show</em>方法。这个方法在<em>Derived</em>类中使用super调用了父类的方法。</p><br><pre><code>def show x, y<br>    super<br>    super x<br>    super x, y<br>    super()<br>end<br></code></pre><br><p><em>super</em>不带参数则会传递将当前传入的参数，这里是x=3、y=3。<em>super()</em>方法不传递参数。</p><br><p>$ ./super.rb<br><br>“Base class, x: 3, y: 3”<br><br>“Base class, x: 3, y: 0”<br><br>“Base class, x: 3, y: 3”<br><br>“Base class, x: 0, y: 0”  </p><br><p>输出结果。</p><br><p>这是Ruby的面向对象的第一部分。</p><br><hr><br><p>原文地址： <a href="http://zetcode.com/lang/rubytutorial/oop/" target="_blank" rel="external">http://zetcode.com/lang/rubytutorial/oop/</a><br><br>翻译：龙昌  admin@longchangjin.cn<br><br>完整教程：<a href="https://github.com/wusuopu/Ruby-tutorial" target="_blank" rel="external">https://github.com/wusuopu/Ruby-tutorial</a> </p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://www.xefan.com/archives/83939.html" data-id="cjc95ct5s00irn4q3gkz3xm2j" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Ruby/">Ruby</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/翻译/">翻译</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-/archives/83935.html" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/archives/83935.html" class="article-date">
  <time datetime="2013-11-15T00:00:00.000Z" itemprop="datePublished">2013-11-15</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Ruby栏目/">Ruby栏目</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/archives/83935.html">[翻译]Ruby教程11——哈希表</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p></p><h1>哈希表</h1><p></p>
<p>这部分的教程我们将提到哈希表。哈希表是一个键-值对的集合。与数组相似，不同与数组的是哈希表的索引是确定的，数组的只能是整数。哈希表有时称为相关联的数组。</p><br><p>哈希表是非常有用的集合。它有许多方法供程序员使用。</p><br><h2>创建哈希表</h2><br><p>有两种创建哈希表的方式：使用<em>new</em>关键字或者哈希表的字面量。</p><br><pre><code>#!/usr/bin/ruby<br><br>names = Hash.new<br>names[1] = “Jane”<br>names[2] = “Thomas”<br><br>puts names<br></code></pre><br><p>第一个脚本创建了一个哈希表并添加了两个键-值对。</p><br><pre><code>names = Hash.new<br></code></pre><br><p>创建一个哈希对象。</p><br><pre><code>names[1] = “Jane”<br>names[2] = “Thomas”<br></code></pre><br><p>添加两对值。数字1、2是哈希表的键。键放在中括号里。<em>names</em>是属于键的值。</p><br><pre><code>puts names<br></code></pre><br><p>打印哈希表。</p><br><pre><code>$ ./create.rb<br>{1=&gt;”Jane”, 2=&gt;”Thomas”}<br></code></pre><br><p>从输出结果我们看到一个哈希表是用花括号括起来的。键和值是使用<em>=&gt;</em>符号成对搭配。</p><br><hr><br><p><em>store</em>方法可以用于给哈希表设置一些初始值。它可以代替花括号。</p><br><pre><code>#!/usr/bin/ruby<br><br>names = Hash.new<br>names.store(1, “Jane”)<br>names.store(2, “Thomas”)<br>names.store(3, “Rebecca”)<br><br>puts names<br></code></pre><br><p>创建了一个相似的脚本，这次我们使用<em>store</em>方法。</p><br><pre><code>names.store(1, “Jane”)<br></code></pre><br><p><em>store</em>方法的第一个参数是键，第二个参数是值。</p><br><hr><br><p>第三个脚本我们使用字面符来创建哈希表。它的值是用花括号括起来的。并且键和值是用<em>=&gt;</em>符号成对分配。</p><br><pre><code>#!/usr/bin/ruby<br><br>domains = { “de” =&gt; “Germany”,<br>            “sk” =&gt; “Slovakia”,<br>            “hu” =&gt; “Hungary”,<br>            “us” =&gt; “United States”,<br>            “no” =&gt; “Norway”<br>          }<br><br>puts domains[“de”]<br>puts domains[“sk”]<br></code></pre><br><p>创建哈希表<em>domains</em>包含5对内容。这里键和值都是字符串。</p><br><p>$ ./create3.rb <br><br>Germany<br><br>Slovakia  </p><br><p>例子的输出结果。</p><br><h2>基本用法</h2><br><p>这一节我们展示Ruby哈希表的一些很基础的方法。</p><br><pre><code>#!/usr/bin/ruby<br><br>names = Hash.new<br><br>names[1] = “Jane”<br>names[2] = “Thomas”<br>names[3] = “Robert”<br>names[4] = “Julia”<br>names[5] = “Rebecca”<br><br>puts “The size of the hash is #{names.size}”<br><br>puts names.keys.inspect<br>puts names.values.inspect<br></code></pre><br><p>上面的脚本中创建了一个有5个值的哈希表，介绍了哈希表的三个方法。</p><br><pre><code>puts “The size of the hash is #{names.size}”<br></code></pre><br><p><em>size</em>方法返回哈希表的大小。与<em>length</em>方法相同。</p><br><pre><code>puts names.keys.inspect<br>puts names.values.inspect<br></code></pre><br><p><em>keys</em>方法返回哈希表的所有键。以此类推，<em>values</em>方法返回哈希表的所有值。返回的数据是一个数组形式的。为了使输出更加可读我们使用了<em>inspect</em>方法。</p><br><p>$ ./basic.rb<br><br>The size of the hash is 5<br><br>[1, 2, 3, 4, 5]<br><br>[“Jane”, “Thomas”, “Robert”, “Julia”, “Rebecca”]  </p><br><p>例子的输出结果。注意最后两个方法是两个数组。</p><br><hr><br><p>这节的第二个例子展示了哈希表实例的三个方法。</p><br><pre><code>#!/usr/bin/ruby<br><br>names1 = Hash.new<br><br>names1[1] = “Jane”<br>names1[2] = “Thomas”<br>names1[3] = “Robert”<br>names1[4] = “Julia”<br>names1[5] = “Rebecca”<br><br>names2 = names1.dup<br><br>puts names1.eql? names2<br><br>puts names1.empty?<br>names1.clear<br>puts names1.empty?<br></code></pre><br><p>创建了一个<em>names</em>哈希表，对该对象调用了三个方法。</p><br><pre><code>names2 = names1.dup<br></code></pre><br><p>通过<em>dup</em>方法创建了一个副本。</p><br><pre><code>puts names1.eql? names2<br></code></pre><br><p><em>eql?</em>方法比较两个哈希表对象是否相等。这里是相同的，打印true。</p><br><pre><code>puts names1.empty?<br></code></pre><br><p><em>empty?</em>方法检查哈希表是否为空。这行打印false，因为<em>names1</em>有5项数据。</p><br><pre><code>names1.clear<br>puts names1.empty?<br></code></pre><br><p><em>clear</em>方法删除哈希表的所有内容。接着调用<em>empty?</em>方法返回true。</p><br><p>$ ./basic2.rb<br><br>true<br><br>false<br><br>true  </p><br><p>输出结果。</p><br><hr><br><p>有一个方法可以判断一个键或者值是否在这个哈希表中。</p><br><pre><code>#!/usr/bin/ruby<br><br>domains = { :de =&gt; “Germany”, :sk =&gt; “Slovakia”,<br>            :no =&gt; “Norway”, :us =&gt; “United States”<br>          }<br><br>puts domains.has_key? :de<br>puts domains.include? :no<br>puts domains.key? :me<br>puts domains.member? :sk<br><br>puts domains.has_value? “Slovakia”<br>puts domains.value? “Germany”<br></code></pre><br><p>创建了一个有4对数据的哈希表<em>domains</em>。键是用的符号，因为它更有效。</p><br><pre><code>puts domains.has_key? :de<br>puts domains.include? :no<br>puts domains.key? :me<br>puts domains.member? :sk<br></code></pre><br><p>这里我们用了四个方法来判断哈希表是否包含该键。它们的功能都是相同的。</p><br><pre><code>puts domains.has_value? “Slovakia”<br>puts domains.value? “Germany”<br></code></pre><br><p>这里用了两个方法检查这两个字符串是否在哈希表中。</p><br><p>$ ./has.rb<br><br>true<br><br>true<br><br>false<br><br>true<br><br>true<br><br>true  </p><br><p>输出结果。</p><br><hr><br><p>这节的最后一个例子，我们将从哈希表中读取内容。</p><br><pre><code>#!/usr/bin/ruby<br><br>stones = { 1 =&gt; “garnet”, 2 =&gt; “topaz”,<br>           3 =&gt; “opal”, 4 =&gt; “amethyst”<br>         }<br><br>puts stones.fetch 1<br>puts stones[2]<br>puts stones.values_at 1, 2, 3<br></code></pre><br><p>这个脚本展示了三个读取值的方法。</p><br><pre><code>puts stones.fetch 1<br></code></pre><br><p><em>fetch</em>方法通过给定的键读取值。</p><br><pre><code>puts stones[2]<br></code></pre><br><p>也可以使用中括号来获取一个值，这行会打印<em>“topaz”</em>。</p><br><pre><code>puts stones.values_at 1, 2, 3<br></code></pre><br><p><em>values_at</em>方法可以一次获取多个值。这个方法通过给定的键返回一个数组包含了对应的值。</p><br><p>$ ./read.rb<br><br>garnet<br><br>topaz<br><br>garnet<br><br>topaz<br><br>opal  </p><br><p>例子的输出结果。</p><br><h2>循环遍历哈希表</h2><br><p>有一些方法可以用于循环遍历哈希表。</p><br><pre><code>#!/usr/bin/ruby<br><br>stones = { 1 =&gt; “garnet”, 2 =&gt; “topaz”,<br>           3 =&gt; “opal”, 4 =&gt; “amethyst”<br>         }<br><br>stones.each { |k, v| puts “Key: #{k}, Value: #{v}” }<br>stones.each_key { |key| puts “#{key}” }<br>stones.each_value { |val| puts “#{val}” }<br>stones.each_pair { |k, v| puts “Key: #{k}, Value: #{v}” }<br></code></pre><br><p>上面的例子我们展示的四个方法。用这些方法显示了所有的键、值。</p><br><pre><code>stones.each { |k, v| puts “Key: #{k}, Value: #{v}” }<br></code></pre><br><p><em>each</em>方法对每个键都调用了给定的代码块，键-值对作为参数传递。</p><br><pre><code>stones.each_key { |key| puts “#{key}” }<br></code></pre><br><p>我们使用<em>each_key</em>方法循环遍历了哈希表所有的键。将它们打印在终端上。</p><br><pre><code>stones.each_value { |val| puts “#{val}” }<br></code></pre><br><p><em>each_value</em>用于循环遍历哈希表所有的值。</p><br><pre><code>stones.each_pair { |k, v| puts “Key: #{k}, Value: #{v}” }<br></code></pre><br><p><em>each_pair</em>方法与<em>each</em>方法相同。</p><br><p>$ ./loop.rb<br><br>Key: 1, Value: garnet<br><br>Key: 2, Value: topaz<br><br>Key: 3, Value: opal<br><br>Key: 4, Value: amethyst<br><br>1<br><br>2<br><br>3<br><br>4<br><br>garnet<br><br>topaz<br><br>opal<br><br>amethyst<br><br>Key: 1, Value: garnet<br><br>Key: 2, Value: topaz<br><br>Key: 3, Value: opal<br><br>Key: 4, Value: amethyst  </p><br><p>输出结果。</p><br><h2>删除键值对</h2><br><p>接下来的例子关注哈希表的删除。</p><br><pre><code>#!/usr/bin/ruby<br><br>names = Hash.new<br><br>names[1] = “Jane”<br>names[2] = “Thomas”<br>names[3] = “Robert”<br>names[4] = “Julia”<br>names[5] = “Rebecca”<br><br>names.delete 4<br>names.shift<br><br>puts names<br></code></pre><br><p>这个脚本我们使用了两个方法：<em>delete</em>和<em>shift</em>。<em>delete</em>方法是删除指定的键的值，并将其返回。<em>shift</em>方法删除哈希表的第一对键值，并将其作为数组返回。</p><br><pre><code>names.delete 4<br></code></pre><br><p>删除<em>4 =&gt; “Julia”</em>这对值。</p><br><pre><code>names.shift<br></code></pre><br><p>这行代码删除<em>1 =&gt; “Jane”</em>这对值。</p><br><pre><code>$ ./deleteitem.rb<br>{2=&gt;”Thomas”, 3=&gt;”Robert”, 5=&gt;”Rebecca”}<br></code></pre><br><p>输出结果显示还剩的内容。</p><br><hr><br><p><em>reject</em>和<em>delete_if</em>方法可以从哈希表中移除多项内容。如果这些方法所给定的代码块中的条件式返回true，则删除对应的键值对。这两个方法有个重要区别。<em>reject</em>方法作用于复本，<em>delete_if</em>作用于原对象。</p><br><pre><code>#!/usr/local/bin/ruby<br><br>names1 = Hash.new<br><br>names1[1] = “Jane”<br>names1[2] = “Thomas”<br>names1[3] = “Robert”<br>names1[4] = “Julia”<br>names1[5] = “Rebecca”<br><br>puts names1.reject { |k, v| v =~ /R.<em>/ }<br>puts names1<br>puts names1.delete_if { |k, v| k&lt;=3 }<br>puts names1<br></em></code></pre><br><p>这个例子使用上面的方法删除多项键值对。</p><br><pre><code>puts names1.reject { |k, v| v =~ /R./ }<br></code></pre><br><p><em>reject</em>方法移除所有满足代码块中正则式的值，并返回修改后的哈希表，原哈希表不变。</p><br><pre><code>puts names1<br></code></pre><br><p>这行的输出证实了原哈希表没有改变。</p><br><pre><code>puts names1.delete_if { |k, v| k&lt;=3 }<br></code></pre><br><p>这里我们删除键小于等于3的键值对。这个方法修改了原对象。</p><br><pre><code>$ ./massdelete.rb<br>{1=&gt;”Jane”, 2=&gt;”Thomas”, 4=&gt;”Julia”}<br>{1=&gt;”Jane”, 2=&gt;”Thomas”, 3=&gt;”Robert”, 4=&gt;”Julia”, 5=&gt;”Rebecca”}<br>{4=&gt;”Julia”, 5=&gt;”Rebecca”}<br>{4=&gt;”Julia”, 5=&gt;”Rebecca”}<br></code></pre><br><p>输出结果。</p><br><h2>添加内容</h2><br><p><em>merge</em>和<em>update</em>方法可以给哈希表添加键值对。</p><br><pre><code>#!/usr/bin/ruby<br><br>names1 = Hash.new<br><br>names1[1] = “Jane”<br>names1[2] = “Thomas”<br><br>names2 = Hash.new<br><br>names2[3] = “Robert”<br>names2[4] = “Julia”<br><br>names = names1.merge names2<br>puts names<br><br>names = names1.update names2<br>puts names<br></code></pre><br><p>这个脚本中我们创建了两个哈希表，然后对它们调用了<em>merge</em>和<em>update</em>方法。</p><br><pre><code>names = names1.merge names2<br>puts names<br></code></pre><br><p>合并<em>names1</em>和<em>names2</em>，结果分配给<em>names</em>。</p><br><pre><code>$ ./merge.rb<br>{1=&gt;”Jane”, 2=&gt;”Thomas”, 3=&gt;”Robert”, 4=&gt;”Julia”}<br>{1=&gt;”Jane”, 2=&gt;”Thomas”, 3=&gt;”Robert”, 4=&gt;”Julia”}<br></code></pre><br><p>最后的哈希表包含了<em>names1</em>和<em>names2</em>的内容。</p><br><h2>merge与merge!</h2><br><p>最后一节，我们重述一下Ruby的习俗。一些Ruby的方法以感叹号结尾。这个标志在语法上没有意义，它只是表明调用这个方法会修改对象的内容。</p><br><pre><code>#!/usr/bin/ruby<br><br>names1 = Hash.new<br><br>names1[1] = “Jane”<br>names1[2] = “Thomas”<br><br>names2 = Hash.new<br><br>names2[3] = “Robert”<br>names2[4] = “Julia”<br><br>names = names1.merge names2<br>puts names<br>puts names1<br><br>names = names1.merge! names2<br>puts names<br>puts names1<br></code></pre><br><p>我们展示了<em>merge</em>和<em>merge!</em>方法的不同。</p><br><pre><code>names = names1.merge names2<br></code></pre><br><p><em>merge</em>不会修改<em>names1</em>，它作用于一个新的复本。</p><br><pre><code>names = names1.merge! names2<br></code></pre><br><p><em>merge!</em>方法作用于原对象。<em>names1</em>被修改了。</p><br><pre><code>$ ./merge2.rb<br>{1=&gt;”Jane”, 2=&gt;”Thomas”, 3=&gt;”Robert”, 4=&gt;”Julia”}<br>{1=&gt;”Jane”, 2=&gt;”Thomas”}<br>{1=&gt;”Jane”, 2=&gt;”Thomas”, 3=&gt;”Robert”, 4=&gt;”Julia”}<br>{1=&gt;”Jane”, 2=&gt;”Thomas”, 3=&gt;”Robert”, 4=&gt;”Julia”}<br></code></pre><br><p><em>merge2.rb</em>程序的输出。</p><br><p>在这章我们学习了Ruby的哈希表。</p><br><hr><br><p>原文地址： <a href="http://zetcode.com/lang/rubytutorial/hashes/" target="_blank" rel="external">http://zetcode.com/lang/rubytutorial/hashes/</a><br><br>翻译：龙昌  admin@longchangjin.cn<br><br>完整教程：<a href="https://github.com/wusuopu/Ruby-tutorial" target="_blank" rel="external">https://github.com/wusuopu/Ruby-tutorial</a> </p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://www.xefan.com/archives/83935.html" data-id="cjc95ct5q00ikn4q3ycbs5kvq" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Ruby/">Ruby</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/翻译/">翻译</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-/archives/83932.html" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/archives/83932.html" class="article-date">
  <time datetime="2013-11-14T00:00:00.000Z" itemprop="datePublished">2013-11-14</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Ruby栏目/">Ruby栏目</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/archives/83932.html">[翻译]Ruby教程10——数组</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p></p><h1>数组</h1><p></p>
<p>这一部分的教程将介绍数组。数组是有序对象的集合。</p><br><p>一个这是在某个时刻只能保存一项数值。不过数组可以保存多项。这些数据项被称为数组的元素。数组可以保存任何类型的数据。每个元素可以使用索引来引用。第一个元素的索引值为0。</p><br><p>注意Ruby的数组与C、C++或者Java中的数组有很大的不同。</p><br><pre><code>#!/usr/bin/ruby<br><br>nums = [1, 2, 3, 4, 5]<br><br>nums.each do |num|<br>    puts num<br>end<br></code></pre><br><p>我们的第一个例子创建了一个包含5个整数的数组，然后在终端上打印这些元素。</p><br><pre><code>nums = [1, 2, 3, 4, 5]<br></code></pre><br><p>这行创建了一个包含5个整数的数组，每个元素使用逗号分隔开来。</p><br><pre><code>nums.each do |num|<br>    puts num<br>end<br></code></pre><br><p>我们使用<em>each</em>方法遍历数组并在终端上打印每个元素。</p><br><p>$ ./array.rb<br><br>1<br><br>2<br><br>3<br><br>4<br><br>5  </p><br><p>程序的输出结果。</p><br><h2>创建数组</h2><br><p>Ruby中数组是一个对象，可以使用<em>new</em>方法进行实例化。</p><br><pre><code>#!/usr/bin/ruby<br><br>nums = Array.new<br><br>nums.push 1<br>nums.push 2<br>nums.push 3<br>nums.push 4<br>nums.push 5<br><br>puts nums<br></code></pre><br><p>这个脚本中我们创建了一个数组<em>nums</em>，然后往里面添加了5个整数。</p><br><pre><code>nums = Array.new<br></code></pre><br><p>创建数组对象。</p><br><pre><code>nums.push 1<br></code></pre><br><p><em>push</em>方法是往数组尾部添加一项数据。</p><br><hr><br><p>我们继续使用<em>new</em>方法创建数组。</p><br><pre><code>#!/usr/bin/ruby<br><br>a1 = Array.new<br>a2 = Array.new 3<br>a3 = Array.new 6, “coin”<br>a4 = Array.new [11]<br>a5 = Array.new (15) {|e| e<em>e}<br><br>puts [a1, a2, a3, a4, a5].inspect<br></em></code></pre><br><p><em>Array</em>类的<em>new</em>方法有一些选项。</p><br><pre><code>a1 = Array.new<br></code></pre><br><p>创建一个空的数组，支持稍后再往其中填充数据。</p><br><pre><code>a2 = Array.new 3<br></code></pre><br><p>创建一个数组包含3个<em>nil</em>对象。</p><br><pre><code>a3 = Array.new 6, “coin”<br></code></pre><br><p>创建一个数组包含6个<em>“coin”</em>字符串。第一个选项是数组的大小；第二个选项是填充的对象。</p><br><pre><code>a4 = Array.new [11]<br></code></pre><br><p>第四个数组只有一项数据。</p><br><pre><code>a5 = Array.new (15) {|e| ee}<br></code></pre><br><p>创建一个有15个元素的数组，第个元素都是在代码块中创建。这里计算了序号数的平方。</p><br><pre><code>puts [a1, a2, a3, a4, a5].inspect<br></code></pre><br><p>将所有的数组放在一个数组中。数组是可以放入另一个数组里的。然后调用数组的<em>inspect</em>方法，它将对其所有的元素都调用该方法。<em>inspect</em>方法将返回代表这个数组的字符串。当我们需要快速检查数组内容时它非常有用。</p><br><p>$ ./arraynew.rb<br><br>[[], [nil, nil, nil], [“coin”, “coin”, “coin”, “coin”, “coin”, “coin”], <br><br>[11], [0, 1, 4, 9, 16, 25, 36, 49, 64, 81, 100, 121, 144, 169, 196]]  </p><br><p>我们可以所有创建的数组。</p><br><hr><br><p>接下来的脚本展示了多种创建数组的方法。</p><br><pre><code>#!/usr/bin/ruby<br><br>integers = [1, 2, 3, 4, 5]<br>animals = %w( donkey dog cat dolphin eagle )<br>weights = Array.new<br>weights &lt;&lt; 4.55 &lt;&lt; 3.22 &lt;&lt; 3.55 &lt;&lt; 8.55 &lt;&lt; 3.23<br><br>puts integers.inspect<br>puts animals.inspect<br>puts weights.inspect<br></code></pre><br><p>我们创建了三个数组分别包含了整数、字符串和小数。</p><br><pre><code>integers = [1, 2, 3, 4, 5]<br></code></pre><br><p>这行创建了一个包含5个整数的数组。这是最经典的方法。数组的每个元素放在中括号中用逗号隔开。</p><br><pre><code>animals = %w( donkey dog cat dolphin eagle )<br></code></pre><br><p>这行代码创建了一个有5个元素的字符串数组。这种方式我们不需要逗号和双引号，减少了按键次数。</p><br><pre><code>weights = Array.new<br>weights &lt;&lt; 4.55 &lt;&lt; 3.22 &lt;&lt; 3.55 &lt;&lt; 8.55 &lt;&lt; 3.23<br></code></pre><br><p>第三种方法有两步。首先创建一个数组对象，然后用数据将其初始化。这是正式的数组创建方法。上面方法实际上是这个的简写。</p><br><pre><code>puts integers.inspect<br></code></pre><br><p>The inspect method prints the string representation of the array to the terminal.</p><br><p>$ ./creation.rb<br><br>[1, 2, 3, 4, 5]<br><br>[“donkey”, “dog”, “cat”, “dolphin”, “eagle”]<br><br>[4.55, 3.22, 3.55, 8.55, 3.23]  </p><br><p>例子的输出结果。</p><br><hr><br><p>数组的数据项没限制必须是数字和字符串。数组可以包含Ruby中的所有类型的数据。</p><br><pre><code>#!/usr/bin/ruby<br><br>class Empty<br><br>end<br><br>nums = [1, 2, 3, 4, 5]<br><br>various = [1, -1, “big”, 3.4, Empty.new, nums, :two]<br><br>puts various.inspect<br></code></pre><br><p>我们在数组中放了多种Ruby对象。</p><br><pre><code>various = [1, -1, “big”, 3.4, Empty.new, nums, :two]<br></code></pre><br><p>这个数组包含了数字、字符串、自定义对象、另一个数组和一个符号。</p><br><pre><code>$ ./arrayobjects.rb<br>[1, -1, “big”, 3.4, #&lt;Empty:0x987f704&gt;, [1, 2, 3, 4, 5], :two]<br></code></pre><br><p><em>arrayobjects.rb</em>脚本的运行结果。</p><br><hr><br><p>下一个例子展示嵌套数组；即一个数组包含另一个数组。Ruby中可以在数组中嵌套数组。</p><br><pre><code>#!/usr/bin/ruby<br><br>numbers = [1, 2, 3, [2, 4, 6, [11, 12]]]<br><br>puts numbers.length<br>puts numbers[0], numbers[1]<br><br>puts numbers[3][0]<br>puts numbers[3][1]<br><br>puts numbers[3][3][0]<br>puts numbers[3][3][1]<br><br>puts numbers.flatten!.inspect<br></code></pre><br><p>数组<em>[11, 12]</em>被嵌套在<em>[2, 4, 6, …]</em>里，这个数组又被嵌套在<em>[1, 2, 3, …]</em>数组里。</p><br><pre><code>puts numbers.length<br></code></pre><br><p><em>length</em>方法返回4。内嵌数组只算一个元素。</p><br><pre><code>puts numbers[0], numbers[1]<br></code></pre><br><p>这里<em>[]</em>字符用于访问数组的元素。上面这行代码返回第一个和第二个元素。</p><br><pre><code>puts numbers[3][0]<br>puts numbers[3][1]<br></code></pre><br><p>这里我们访问内嵌数组的元素。<em>[3][0]</em>返回内嵌数组的第一个元素，在这里是2。同样的<em>[3][1]</em>返回内嵌数组的第二个元素，这里是4。</p><br><pre><code>puts numbers[3][3][0]<br>puts numbers[3][3][1]<br></code></pre><br><p>现在我们进入更深一层。我们访问更深一层数组的元素。<em>[3][3]</em>返回<em>[11, 12]</em>数组。然后从这个数组获取第一个和第二个元素。</p><br><pre><code>puts numbers.flatten!.inspect<br></code></pre><br><p><em>flatten!</em>方法将数组变为平坦。它将所有的内嵌数组元素创建成一个新的数组。</p><br><p>$ ./arrayofarrays.rb<br><br>4<br><br>1<br><br>2<br><br>2<br><br>4<br><br>11<br><br>12<br><br>[1, 2, 3, 2, 4, 6, 11, 12]  </p><br><p>输出结果。 </p><br><h2>打印数组内容</h2><br><p>要在终端上打印数组的元素有多种方法可以完成。</p><br><pre><code>#!/usr/bin/ruby<br><br>integers = [1, 2, 3, 4, 5]<br><br>puts integers<br>puts integers.inspect<br><br>integers.each do |e|<br>    puts e<br>end<br></code></pre><br><p>这个脚本我们将数组的元素打印了三次。</p><br><pre><code>puts integers<br></code></pre><br><p>数组作为puts/print方法的参数是最简单的方式。每行将打印一个元素。</p><br><pre><code>puts integers.inspect<br></code></pre><br><p>使用<em>inspect</em>方法输出结果的可读性更好。</p><br><pre><code>integers.each do |e|<br>    puts e<br>end<br></code></pre><br><p><em>each</em>方法为每个元素都调用一次一个代码块，元素作为参数传递。我们简单的参元素使用<em>puts</em>方法。</p><br><p>$ ./printarray1.rb<br><br>1<br><br>2<br><br>3<br><br>4<br><br>5<br><br>[1, 2, 3, 4, 5]<br><br>1<br><br>2<br><br>3<br><br>4<br><br>5  </p><br><p>数组在终端上打印了三次。</p><br><hr><br><p>第二个例子我们提供了两个额外的方法打印数组。</p><br><pre><code>#!/usr/bin/ruby<br><br>integers = [1, 2, 3, 4, 5]<br><br>integers.length.times do |idx|<br>    puts integers[idx]<br>end<br><br>integers.each_with_index do |num, idx|<br>    puts “value #{num} has index #{idx}”<br>end<br></code></pre><br><p>第一种情况我们组合使用了<em>length</em>和<em>times</em>方法。第二种情况我们使用了<em>each_with_index</em>方法。</p><br><pre><code>integers.length.times do |idx|<br>    puts integers[idx]<br>end<br></code></pre><br><p><em>length</em>方法返回数组的长度。<em>times</em>方法将接下来的代码块迭代<em>length</em>次，传递的值从0到length-1。这些数字作为数组的索引使用。</p><br><pre><code>integers.each_with_index do |num, idx|<br>    puts “value #{num} has index #{idx}”<br>end<br></code></pre><br><p><em>each_with_index</em>方法迭代数组并将元素及其索引传递给代码块。用这种方法我们可以简单的打印元素和它的索引。</p><br><p>$ ./printarray2.rb<br><br>1<br><br>2<br><br>3<br><br>4<br><br>5<br><br>value 1 has index 0<br><br>value 2 has index 1<br><br>value 3 has index 2<br><br>value 4 has index 3<br><br>value 5 has index 4  </p><br><p>输出结果。</p><br><h2>读取数组元素</h2><br><p>这节我们将从数组读取数据。</p><br><pre><code>#!/usr/bin/ruby<br><br>lts = %w{ a b c d e f g h}<br><br>puts lts.first<br>puts lts.last<br>puts lts.at(3)<br></code></pre><br><p>第一个例子我们展示了三个简单的方法进行数据检索。</p><br><pre><code>puts lts.first<br>puts lts.last<br></code></pre><br><p><em>first</em>方法读取数组的第一个元素；<em>last</em>方法读取数组的最后一个元素。</p><br><pre><code>puts lts.at(3)<br></code></pre><br><p><em>at</em>方法返回指定索引的元素。</p><br><p>$ ./retrieval.rb<br><br>a<br><br>h<br><br>d  </p><br><p><em>retrieval.rb</em>程序的输出结果。</p><br><hr><br><p><em>[]</em>符号可以用于访问数据。这是传统访问数据的方法，许多语言都使用这种方法。</p><br><pre><code>#!/usr/bin/ruby<br><br>lts = %w{ a b c d e f g h }<br><br>puts lts[0]<br>puts lts[-1]<br>puts lts[0, 3].inspect<br>puts lts[2..6].inspect<br>puts lts[2…6].inspect<br></code></pre><br><p>我们展示了5个使用[]符号的例子。</p><br><pre><code>puts lts[0]<br>puts lts[-1]<br></code></pre><br><p>我们获取数组的第一个和最后一个元素。第一项的索引为0,最后一项的索引为-1。</p><br><pre><code>puts lts[0, 3].inspect<br></code></pre><br><p>当中括号里有两个数时，第一个是开始的索引，第二个是长度。这行代码返回从0开始的3个元素。注意<em>inspect</em>方法仅是为了让输出可读而已。</p><br><pre><code>puts lts[2..6].inspect<br>puts lts[2…6].inspect<br></code></pre><br><p>我们可以在中括号使用范围操作符。第一行读取第2个到第6个元素，第二行读取第2个到第5个元素。</p><br><hr><br><p>接下来展示<em>values_at</em>方法。这个方法的优势是可以选择多个位置的元素。</p><br><pre><code>#!/usr/bin/ruby<br><br>lts = %w{ a b c d e f g h}<br><br>puts lts.values_at(1..5).inspect<br>puts lts.values_at(1, 3, 5).inspect<br>puts lts.values_at(1, 3, 5, 6, 8).inspect<br>puts lts.values_at(-1, -3).inspect<br></code></pre><br><p><em>values_at method</em>方法返回一个数组包含选中的元素。<em>inspect</em>方法仅是为了让输出可读而已。</p><br><pre><code>puts lts.values_at(1..5).inspect<br></code></pre><br><p>这行代码返回索引为1到5的元素。</p><br><pre><code>puts lts.values_at(1, 3, 5).inspect<br></code></pre><br><p>这里我们读取索引为1、3、5的元素。</p><br><pre><code>puts lts.values_at(1, 3, 5, 6, 8).inspect<br></code></pre><br><p>我们可以指定多个索引，如果指定的索引没有元素则返回<em>nil</em>。</p><br><pre><code>puts lts.values_at(-1, -3).inspect<br></code></pre><br><p>负数的索引表示从数组尾部开始。</p><br><p>$ ./retrieval3.rb<br><br>[“b”, “c”, “d”, “e”, “f”]<br><br>[“b”, “d”, “f”]<br><br>[“b”, “d”, “f”, “g”, nil]<br><br>[“h”, “f”]  </p><br><p>脚本的输出结果。</p><br><hr><br><p>我们使用<em>fetch</em>方法从数组读取数据。</p><br><pre><code>#!/usr/bin/ruby<br><br>lts = [0, 1, 2, 3, 4, 5, 6]<br><br>puts lts.fetch(0)<br>puts lts.fetch(-2)<br>puts lts.fetch(8, ‘undefined’)<br>puts lts.fetch(8) { |e| -2<em>e }<br></em></code></pre><br><p>我们展示了<em>fetch</em>方法的一些形式的用法。</p><br><pre><code>puts lts.fetch(0)<br>puts lts.fetch(-2)<br></code></pre><br><p>第一行打印了数组的第一个元素。第二行打印了倒数第二个元素。</p><br><pre><code>puts lts.fetch(8, ‘undefined’)<br></code></pre><br><p>第三种形式是返回指定索引的元素，如果索引超出范围则返回默认值，这里是<em>‘undefined’</em>。没有第二个参数则会抛出IndexError错误。</p><br><pre><code>puts lts.fetch(8) { |e| -2e}<br></code></pre><br><p>最后一种形式我们定义了一个代码块，传递了索引对应的值，这个方法返回了代码块调用的结果。</p><br><p>$ ./retrieval4.rb<br><br>0<br><br>5<br><br>undefined<br><br>-16  </p><br><p>脚本的输出结果。</p><br><hr><br><p>我们将展示<em>take</em>和<em>take_while</em>方法的用法。</p><br><pre><code>#!/usr/bin/ruby<br><br>lts = %w{ a b c d e f g h}<br><br><br>puts lts.take(4).inspect<br><br>lts2 = lts.take_while { |e| e &lt; ‘f’ }<br>puts lts2.inspect<br></code></pre><br><p><em>take</em> n方法返回开头的n个元素。<em>take_while</em>方法将元素传递给一个代码块，直到代码块返回<em>nil</em>或者<em>false</em>才停止迭代，并返回之前的元素。</p><br><pre><code>puts lts.take(4).inspect<br></code></pre><br><p>这里我们返回开头的4个元素。</p><br><pre><code>lts2 = lts.take_while { |e| e &lt; ‘f’ }<br>puts lts2.inspect<br></code></pre><br><p>这里我们从源数组创建了一个新的数组，这个新数组包含了所有小于’f’的字符。</p><br><p>$ ./retrieval5.rb<br><br>[“a”, “b”, “c”, “d”]<br><br>[“a”, “b”, “c”, “d”, “e”]  </p><br><p><em>retrieval5.rb</em>程序的输出结果。</p><br><hr><br><p><em>slice</em>方法与[]符号相同。返回一个或者多个元素。</p><br><pre><code>#!/usr/bin/ruby<br><br>lts = %w{ a b c d e f g h}<br><br>puts lts.slice(0)<br>puts lts.slice(-1)<br>puts lts.slice(0, 3).inspect<br>puts lts.slice(2..6).inspect<br>puts lts.slice(2…6).inspect<br></code></pre><br><p>展示了5个<em>slice</em> 方法的例子。</p><br><pre><code>puts lts.slice(0)<br>puts lts.slice(-1)<br></code></pre><br><p>这些形式的<em>slice</em>方法返回一个数组元素。第行代码返回第一个元素，第二行代码返回最后一个元素。</p><br><pre><code>puts lts.slice(0, 3).inspect<br></code></pre><br><p>第一个参数是起始索引，第二个参数是长度。这一行代码返回从0开始的3个元素。</p><br><pre><code>puts lts.slice(2..6).inspect<br>puts lts.slice(2…6).inspect<br></code></pre><br><p>我们可以在<em>slice</em>方法中使用范围操作符。第一行读取第2到6的元素，第二行读取第2到5的元素。</p><br><p>$ ./retrieval6.rb<br><br>a<br><br>h<br><br>[“a”, “b”, “c”]<br><br>[“c”, “d”, “e”, “f”, “g”]<br><br>[“c”, “d”, “e”, “f”]  </p><br><p><em>slice</em>方法返回数组的一部分，一个或者多个元素。</p><br><hr><br><p>可以随机选择数组的一个元素。Ruby中的<em>sample</em>方法可以实现。</p><br><pre><code>#!/usr/bin/ruby<br><br>lts = %w{ a b c d e f g h}<br><br>puts lts.sample<br>puts lts.sample(3).inspect<br></code></pre><br><p><em>sample</em>方法有两种形式。第一种我们选择一个随机元素。第二种我们选择n个随机元素。</p><br><p>$ ./random.rb<br><br>b<br><br>[“c”, “f”, “d”]<br><br>$ ./random.rb<br><br>d<br><br>[“c”, “d”, “e”]  </p><br><p>执行两次结果不同。</p><br><h2>使用数组</h2><br><p>接下来的例子介绍一些Ruby数组的方法。</p><br><pre><code>#!/usr/bin/ruby<br><br>num1 = [1, 2, 3, 4, 5]<br>num2 = [6, 7, 8, 9, 10]<br><br>puts num1 + num2<br>puts num1.concat num2<br></code></pre><br><p>我们定义了两个数组，将它们相加。</p><br><pre><code>puts num1 + num2<br>puts num1.concat num2<br></code></pre><br><p>有两个数组相加的方法。使用+操作符或者<em>concat</em>方法。</p><br><hr><br><p>Ruby中数组有丰富的方法。例如<em>length</em>方法返回数组的元素个数。</p><br><pre><code>#!/usr/bin/ruby<br><br>lts = %w{ a b c d e f}<br><br>puts lts.inspect<br>puts “Array has #{lts.length} elements”<br>puts “The first element is #{lts.first}”<br>puts “The last element is #{lts.last}”<br><br>puts lts.eql? lts.dup<br>puts lts.eql? lts.dup.delete_at(0)<br><br>lts.clear<br>puts lts.inspect<br>puts lts.empty?<br></code></pre><br><p>上面的脚本我们介绍了7个新方法。</p><br><pre><code>puts “Array has #{lts.length} elements”<br></code></pre><br><p><em>length</em>方法决定数组的大小。</p><br><pre><code>puts “The first element is #{lts.first}”<br>puts “The last element is #{lts.last}”<br></code></pre><br><p>这里我们获取第一个和最后一个元素。</p><br><pre><code>puts lts.eql? lts.dup<br></code></pre><br><p><em>eql?</em>方法指出两个数组是否相等。这里是返回<em>true</em>。<em>dup</em>方法创建一个浅复制对象。</p><br><pre><code>puts lts.eql? lts.dup.delete_at(0)<br></code></pre><br><p><em>delete_at</em>方法从数组的开头删除元素。现在两个数组不相同了。</p><br><pre><code>lts.clear<br></code></pre><br><p><em>clear</em>方法删除数组的所有元素。</p><br><pre><code>puts lts.empty?<br></code></pre><br><p><em>empty?</em>方法检查数组是否为空。这里返回<em>true</em>，因为我们已经将所有元素都删除了。</p><br><p>$ ./basics.rb<br><br>[“a”, “b”, “c”, “d”, “e”, “f”]<br><br>Array has 6 elements<br><br>The first element is a<br><br>The last element is f<br><br>true<br><br>false<br><br>[]<br><br>true  </p><br><p>输出结果。</p><br><hr><br><p>一些Ruby的数组方法以感叹号结尾。这是Ruby的习惯。感叹号告诉程序员这个方法会修改数据。感叹号本身没有什么作用，它只是名字的约定。</p><br><pre><code>#!/usr/bin/ruby<br><br>chars = %w{a b c d e}<br><br>reversed_chars = chars.reverse<br>puts reversed_chars.inspect<br>puts chars.inspect<br><br>reversed_chars = chars.reverse!<br>puts reversed_chars.inspect<br>puts chars.inspect<br></code></pre><br><p>Ruby中有一些比较相似的方法。<em>reverse</em>和<em>reverse!</em>方法都是改为数组元素的顺序，将它们反转。不同在于<em>reverse</em>方法返回反转后的数组，原数组不变。<em>reverse!</em>方法会同时修改原数组。</p><br><p>$ ./twotypes.rb<br><br>[“e”, “d”, “c”, “b”, “a”]<br><br>[“a”, “b”, “c”, “d”, “e”]<br><br>[“e”, “d”, “c”, “b”, “a”]<br><br>[“e”, “d”, “c”, “b”, “a”]  </p><br><p>我们清晰的看到前两个数组不同，第三和第四个数组是相同的。</p><br><hr><br><p>一些其他的方法展示。</p><br><pre><code>#!/usr/bin/ruby<br><br>numbers = [1, 2, 2, 2, 3, 4, 5, 8, 11]<br><br>puts numbers.index 2<br>puts numbers.index 11<br>puts numbers.rindex 2<br><br>puts numbers.include? 3<br>puts numbers.include? 10<br><br>puts numbers.join ‘-‘<br>puts numbers.uniq!.inspect<br></code></pre><br><p>介绍5个额外的方法。</p><br><pre><code>puts numbers.index 2<br>puts numbers.index 11<br></code></pre><br><p><em>index</em>方法返回数组中元素对应的索引。索引是从左算起。第一行返回1,它是第一个2的索引。数组中仅有一个11,它的索引是8。</p><br><pre><code>puts numbers.rindex 2<br></code></pre><br><p><em>rindex</em>方法返回从右边开始的索引。这里2的最右索引为3。</p><br><pre><code>puts numbers.include? 3<br>puts numbers.include? 10<br></code></pre><br><p><em>include?</em>方法检查一个元素是否在数组中。第一行返回<em>true</em>，3在数组中。第二行返回<em>false</em>，数组中没有10。作为约定Ruby中以问号结尾的方法返回一个布尔值，并且对数组没有影响。</p><br><pre><code>puts numbers.join ‘-‘<br></code></pre><br><p><em>join</em>方法返回一个字符串，它是将数组的元素用指定的符号分隔开来。</p><br><pre><code>puts numbers.uniq!.inspect<br></code></pre><br><p><em>uniq!</em>方法移除重复的元素。在数组中有3个2,调用方法之后就只剩一个2了。</p><br><p>$ ./methods2.rb <br><br>1<br><br>8<br><br>3<br><br>true<br><br>false<br><br>1-2-2-2-3-4-5-8-11<br><br>[1, 2, 3, 4, 5, 8, 11]  </p><br><p>注意<em>join</em>方法产生的是一个字符串，它是数组的数字用<em>-</em>符号分隔。</p><br><h2>修改数组</h2><br><p>这一节我们介绍与数组修改相关的方法。基本的我们做一些插入和删除操作。</p><br><pre><code>#!/usr/bin/ruby<br><br>lts = []<br><br>lts.insert 0, ‘E’, ‘F’, ‘G’<br>lts.push ‘H’<br>lts.push ‘I’, ‘J’, ‘K’<br>lts &lt;&lt; ‘L’ &lt;&lt; ‘M’<br>lts.unshift ‘A’, ‘B’, ‘C’<br>lts.insert(3, ‘D’)<br><br>puts lts.inspect<br></code></pre><br><p>从一个空数组开始，我们使用不同的插入方法。</p><br><pre><code>lts.insert 0, ‘E’, ‘F’, ‘G’<br></code></pre><br><p><em>insert</em>方法往<em>lts</em>数组插入了3个元素。</p><br><pre><code>lts.push ‘H’<br>lts.push ‘I’, ‘J’, ‘K’<br></code></pre><br><p><em>push</em>方法往数组添加元素，我们可以添加一个或多个元素。</p><br><pre><code>lts &lt;&lt; ‘L’ &lt;&lt; ‘M’<br></code></pre><br><p><em>&lt;&lt;</em>与<em>push</em>方法相同。这个操作可以链式调用。</p><br><pre><code>lts.unshift ‘A’, ‘B’, ‘C’<br></code></pre><br><p><em>unshift</em>方法将元素插入在数组前端。</p><br><pre><code>lts.insert(3, ‘D’)<br></code></pre><br><p>这里<em>insert</em>方法在指定的位置插入’D’字符。</p><br><p>$ ./insertion.rb<br><br>[“A”, “B”, “C”, “D”, “E”, “F”, “G”, “H”, “I”, “J”, “K”, “L”, “M”]  </p><br><p>使用上面的方法，我们创建了一个包含大写字母的数组。</p><br><hr><br><p>一些删除数组元素的方法。</p><br><pre><code>#!/usr/bin/ruby<br><br>lts = %w{ a b c d e f g h}<br><br>lts.pop<br>lts.pop<br><br>puts lts.inspect<br><br>lts.shift<br>lts.shift<br><br>puts lts.inspect<br><br>lts.delete_at(0)<br>lts.delete(‘d’)<br><br>puts lts.inspect<br><br>puts lts.clear<br>puts lts.inspect<br></code></pre><br><p>这个脚本展示了5个用于删除数组元素的方法。</p><br><pre><code>lts = %w{ a b c d e f g h}<br></code></pre><br><p>创建一个有8个元素的数组。</p><br><pre><code>lts.pop<br></code></pre><br><p><em>pop</em>方法移除最后一个元素。</p><br><pre><code>lts.shift<br></code></pre><br><p><em>shift</em>方法移除数组的第一个元素。</p><br><pre><code>lts.delete_at(0)<br></code></pre><br><p><em>delete_at</em>方法删除指定位置的元素。我们删除剩余元素的第一个元素。</p><br><pre><code>puts lts.clear<br></code></pre><br><p><em>clear</em>方法清除所有元素。</p><br><pre><code>lts.delete(‘d’)<br></code></pre><br><p><em>delete</em>方法删除指定的一项数据。</p><br><p>$ ./deletion.rb<br><br>[“a”, “b”, “c”, “d”, “e”, “f”]<br><br>[“c”, “d”, “e”, “f”]<br><br>[“e”, “f”]<br><br>[]  </p><br><p>输出结果。</p><br><hr><br><p>目前为止我们使用的方法同时只修改一个数组项。Ruby中有一些方法可以一次修改多个数组项的。</p><br><pre><code>#!/usr/bin/ruby<br><br>nms = [2, -1, -4, 0, 4, 3, -2, 3, 5]<br><br>nms.delete_if { |x| x &lt; 0 }<br><br>puts nms.inspect<br></code></pre><br><p>例子介绍了<em>delete_if</em>方法用于删除所有符合条件式的数据项。</p><br><pre><code>nms.delete_if { |x| x &lt; 0 }<br></code></pre><br><p>这行删除所有的负数。</p><br><p>$ ./delete_if.rb<br><br>[2, 0, 4, 3, 3, 5]  </p><br><p>我们从<em>nms</em>数组中删除了所有的负数。</p><br><hr><br><p>我们展示两个其他的方法处理多数据项。</p><br><pre><code>#!/usr/bin/ruby<br><br>lts = %w{ a b c d e f g}<br><br>puts lts.inspect<br><br>lts.reject! do |e|<br>    e =~ /[c language=”-y”][/c]/<br>end<br><br>puts lts.inspect<br><br>lts.replace([“x”, “y”, “z”])<br>puts lts.inspect<br></code></pre><br><p>我们使用了两个方法，<em>reject!</em>和<em>replace</em>。</p><br><pre><code>lts.reject! do |e|<br>    e =~ /[c language=”-y”][/c]/<br>end<br></code></pre><br><p><em>reject!</em>方法移除了所有项满足条件式的数据。这里我们删除所有符合正则式的字母。</p><br><pre><code>lts.replace([“x”, “y”, “z”])<br></code></pre><br><p><em>replace</em>方法将使用给定的数据替换数组项。如果可能它会截断或者扩展数组。</p><br><p>$ ./modify.rb <br><br>[“a”, “b”, “c”, “d”, “e”, “f”, “g”]<br><br>[“a”, “b”]<br><br>[“x”, “y”, “z”]  </p><br><p><em>modify.rb</em>例子的输出结果。</p><br><h2>集合操作</h2><br><p>这一节中我们展示Ruby数组的集合操作。数学中集合是独立对象的收集。</p><br><pre><code>#!/usr/bin/ruby<br><br>A = [1, 2, 3, 4, 5]<br>B = [4, 5, 6, 7, 8]<br><br>union = A | B<br>isect = A &amp; B<br>diff1  = A - B<br>diff2  = B - A<br>sdiff = (A - B) | (B - A)<br><br>puts “Union of arrays: #{union}”<br>puts “Intersection of arrays: #{isect}”<br>puts “Difference of arrays A - B: #{diff1}”<br>puts “Difference of arrays B - A: #{diff2}”<br>puts “Symmetric difference of arrays: #{sdiff}”<br></code></pre><br><p>上面的脚本我们展示了一些集合操作，并集、交集、差集和对称差集。</p><br><pre><code>nums1 = [1, 2, 3, 4, 5]<br>nums2 = [4, 5, 6, 7, 8]<br></code></pre><br><p>字义了两个整数数组。都是集合，因此每个元素都只出现了一次。两个数组有两个相同的数，4和5。</p><br><pre><code>union = nums1 | nums2<br></code></pre><br><p>数组的并集。两个数组相加，每个元素最终也只出现一次。</p><br><pre><code>isect = A &amp; B<br></code></pre><br><p>数组交集。输出两个数组都存在的元素。这里是4和5。</p><br><pre><code>diff1  = A - B<br>diff2  = B - A<br></code></pre><br><p>两个差集，也称补集。第一行我们得到了所有在A中出现B中没有出现的元素。第二行我们得到B中出现A中没有出现的元素。</p><br><pre><code>sdiff = (A - B) | (B - A)<br></code></pre><br><p>对称差集。A或B中存在，但不同时存在于A和B。</p><br><p>$ ./setoperations.rb<br><br>Union of arrays: [1, 2, 3, 4, 5, 6, 7, 8]<br><br>Intersection of arrays: [4, 5]<br><br>Difference of arrays A - B: [1, 2, 3]<br><br>Difference of arrays B - A: [6, 7, 8]<br><br>Symmetric difference of arrays: [1, 2, 3, 6, 7, 8]  </p><br><p>输出结果。</p><br><h2>select、collect、map方法</h2><br><p>下面的例子我们展示三个方法：<em>select</em>、<em>collect</em>和<em>map</em>。</p><br><pre><code>#!/usr/bin/ruby<br><br>nums = [1, 3, 2, 6, 7, 12, 8, 15]<br><br>selected = nums.select do |e|<br>    e &gt; 10<br>end<br><br>puts selected.inspect<br><br>collected = nums.collect do |e|<br>    e &lt; 10<br>end<br><br>puts collected.inspect<br><br>mapped = nums.map do |e|<br>    e<em>2<br>end<br><br>puts mapped.inspect<br></em></code></pre><br><p>所有这些方法都对数组的元素执行许多操作。</p><br><pre><code>selected = nums.select do |e|<br>    e &gt; 10<br>end<br></code></pre><br><p>上面的代码使用<em>collect</em>方法创建了一个新数组。我们只选择了满足条件式的元素。这里我们选择了所有大于10的元素。</p><br><pre><code>collected = nums.collect do |e|<br>    e &lt; 10<br>end<br></code></pre><br><p><em>collect</em>方法稍微不同。它只收集代码块的返回值。新的数组只包含true和false。</p><br><pre><code>mapped = nums.map do |e|<br>    e2<br>end<br></code></pre><br><p><em>map</em>方法与<em>collect</em>方法相同。上面的代码根据已存在的数组创建了一个新的数组。每个元素都乘以2.</p><br><p>$ ./mass.rb<br><br>[12, 15]<br><br>[true, true, true, true, true, false, true, false]<br><br>[2, 6, 4, 12, 14, 24, 16, 30]  </p><br><p>创建了新数组。</p><br><h2>元素排序</h2><br><p>最后我们对数组元素进行排序。</p><br><pre><code>#!/usr/bin/ruby<br><br>planets = %w{ Mercury Venus Earth Mars Jupiter<br>                Saturn Uranus Neptune Pluto }<br><br>puts “#{planets.sort}”<br>puts “#{planets.reverse}”<br>puts “#{planets.shuffle}”<br></code></pre><br><p>例子中使用了三个Ruby数组的方法对数组元素进行重组。</p><br><pre><code>puts “#{planets.sort}”<br></code></pre><br><p><em>sort</em>方法按字母顺序进行排序。</p><br><pre><code>puts “#{planets.reverse}”<br></code></pre><br><p><em>reverse</em>方法反转元素并返回新的数组。</p><br><pre><code>puts “#{planets.shuffle}”<br></code></pre><br><p><em>shuffle</em>方法将数组元素随机重组。</p><br><p>$ ./ordering.rb<br><br>[“Earth”, “Jupiter”, “Mars”, “Mercury”, “Neptune”, “Pluto”, “Saturn”, …]<br><br>[“Pluto”, “Neptune”, “Uranus”, “Saturn”, “Jupiter”, “Mars”, “Earth”, …]<br><br>[“Earth”, “Jupiter”, “Mercury”, “Saturn”, “Mars”, “Venus”, “Uranus”, …]  </p><br><p>例子的输出结果。</p><br><p>在这章我们学习了Ruby的数组。</p><br><hr><br><p>原文地址： <a href="http://zetcode.com/lang/rubytutorial/arrays/" target="_blank" rel="external">http://zetcode.com/lang/rubytutorial/arrays/</a><br><br>翻译：龙昌  admin@longchangjin.cn<br><br>完整教程：<a href="https://github.com/wusuopu/Ruby-tutorial" target="_blank" rel="external">https://github.com/wusuopu/Ruby-tutorial</a> </p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://www.xefan.com/archives/83932.html" data-id="cjc95ct5r00inn4q3lpv2c9as" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Ruby/">Ruby</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/翻译/">翻译</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-/archives/83929.html" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/archives/83929.html" class="article-date">
  <time datetime="2013-11-12T00:00:00.000Z" itemprop="datePublished">2013-11-12</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Ruby栏目/">Ruby栏目</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/archives/83929.html">[翻译]Ruby教程9——控制流</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p></p><h1>控制流</h1><p></p>
<p>这章的教程我们将讨论控制流。</p><br><p>条件和循环改变了Ruby程序的流程。条件式是执行条件语句下面的特定语句。循环是执行多次的代码块。程序开始后，语句从源文件顶部到底部一行一行的执行。</p><br><h2>if语句</h2><br><p>if关键字用于检查一个表达式是否为真。如果为真则执行语句。这个语句可以是单一的语句，也可以是复合语句。复合语句是由多条语句构成的闭合代码块。代码块用<em>end</em>关键字闭合，<em>then</em>关键字是可选的。</p><br><pre><code>#!/usr/bin/ruby<br><br>num = gets.to_i<br><br>if num &gt; 0 then<br><br>    puts “num variable is positive”<br>    puts “num variable equals to #{num}”<br>end<br></code></pre><br><p>输入一个数字，如果这个数字大于0则打印两条消息，否则什么也不做。</p><br><p>$ ./simpleif.rb <br><br>4<br><br>num variable is positive<br><br>num variable equals to 4  </p><br><p>条件为真并且消息在终端上打印了。</p><br><hr><br><p>我们可以使用<em>else</em>关键字不创建一个简单的分支。如果<em>if</em>关键字后的表达式求值为假，那么<em>else</em>后面的语句将自动执行。这些代码使用<em>end</em>关键字闭合起来。</p><br><pre><code>#!/usr/bin/ruby<br><br>age = 17<br><br>if age &gt; 18<br><br>    puts “Driving licence issued”<br>else<br><br>    puts “Driving licence not permitted”<br>end<br></code></pre><br><p>这里创建了一个<em>age</em>变量，布尔表达式求值为假，因此在终端上打印”Driving licence not permitted”。</p><br><p>$ ./licence.rb <br><br>Driving licence not permitted  </p><br><p>我们可以使用<em>elsif</em>关键字创建多个分支。仅当前一个条件不为真时<em>elsif</em>关键字才会测试另一个条件。注意我们可以使用多个<em>elsif</em>关键字。</p><br><pre><code>#!/usr/bin/ruby<br><br>print “Enter a number: “<br><br>num = gets.to_i<br><br>if num &lt; 0<br><br>    puts “#{num} is negative”<br>elsif num == 0<br><br>   puts “#{num} is zero”<br>elsif num &gt; 0<br><br>   puts “#{num} is positive”<br>end<br></code></pre><br><p>创建一个数字变量判断它是正数、负数还是0。根据输入值的不同将打印不同的消息。</p><br><h2>case语句</h2><br><p><em>case</em>语句是一个程序控制流语句。它允许一个变量或者表达式的值控制程序的执行流程。相比<em>if</em>、<em>elsif</em>它创建多分支更简单。</p><br><p>我们创建一个变量或者表达式。<em>case</em>关键字用于针对一个列表的值测试这个变量或者表达式的值。这个列表的值是使用<em>when</em>关键字呈现出来。如果值匹配，那么<em>when</em>关键字后面的语句将执行。有一个可选的<em>else</em>语句，如果没有匹配的它将执行。</p><br><pre><code>#!/usr/bin/ruby<br><br>print “Enter top level domain: “<br><br>domain = gets.chomp<br><br>case domain<br>    when “us”<br>        puts “United States”<br>    when “de”<br>        puts “Germany”<br>    when “sk”<br>        puts “Slovakia”<br>    when “hu”<br>        puts “Hungary”<br>    else<br>        puts “Unknown”<br>end<br></code></pre><br><p>这个程序中我们创建了一个<em>domain</em>变量，它的值从命令行读取。使用<em>when</em>语句测试这个变量的值。这有些选项。如果值等于”us”则打印”United States”字符串。</p><br><pre><code>domain = gets.chomp<br></code></pre><br><p>我们使用<em>gets</em>方法获取一个输入值。使用<em>chomp</em>方法去掉换行符。</p><br><p>$ ./domains.rb <br><br>Enter top level domain: hu<br><br>Hungary  </p><br><p>我们输入”hu”，程序返回”Hungary”。</p><br><h2>while、until语句</h2><br><p><em>while</em>语句是一个控制流语句允许代码多次执行。当的条件为真时代码将执行。</p><br><p><em>while</em>关键字执行使用<em>end</em>闭合的代码块语句。每次表达式为真时这些语句将执行。</p><br><pre><code>#!/usr/bin/ruby<br><br>i = 0<br>sum = 0<br><br>while i &lt; 10  do<br>   i = i + 1<br>   sum = sum + i<br>end<br><br>puts “The sum of 0..9 values is #{sum}”<br></code></pre><br><p>这个例子计算了一个范围数的和。</p><br><p>while循环有三部分：初始化、测试和更新。每次执行语句称为周期。</p><br><pre><code>i = 0<br>sum = 0<br></code></pre><br><p>初始化变量<em>i</em>和<em>sum</em>。<em>i</em>用于计数。</p><br><pre><code>while i &lt; 10  do<br>   …<br>end<br></code></pre><br><p><em>while</em>和<em>do</em>之间的表达式是第二阶段，测试。注意<em>do</em>关键字是可选的。，内部的语句将会执行直到表达式的值为假。</p><br><pre><code>i = i + 1<br></code></pre><br><p>这是循环的第三阶段——更新。我们增加计数值。注意不当的处理会导致死循环。</p><br><p>$ ./while.rb <br><br>The sum of 0..9 values is 55  </p><br><p>This is the output of the example. </p><br><hr><br><p>当条件为假时<em>until</em>控制流语句将执行。当条件为真时循环停止。</p><br><pre><code>#!/usr/bin/ruby<br><br>hours_left = 12<br><br>until hours_left == 0<br><br>    if hours_left == 1<br>        puts “There is #{hours_left} hour left”<br>    else<br>        puts “There are #{hours_left} hours left”<br>    end<br><br>    hours_left -= 1<br>end<br></code></pre><br><p>这个例子中创建了一个变量<em>hours_left</em>。我们开始计数，每次循环打印还有几个小时。当变量值等于0时循环停止。</p><br><p>$ ./until.rb <br><br>There are 12 hours left<br><br>There are 11 hours left<br><br>There are 10 hours left<br><br>There are 9 hours left<br><br>There are 8 hours left<br><br>There are 7 hours left<br><br>There are 6 hours left<br><br>There are 5 hours left<br><br>There are 4 hours left<br><br>There are 3 hours left<br><br>There are 2 hours left<br><br>There is 1 hour left  </p><br><p>程序运行的结果。</p><br><h2>for语句</h2><br><p>当循环次数是已知时，我们可以使用<em>for</em>语句。<em>for</em>循环使用<em>in</em>接着一个范围。对这个范围的每个元素都执行代码块的语句。这些语句使用<em>end</em>关键字闭合。<em>do</em>关键字是可选的。</p><br><pre><code>#!/usr/bin/ruby<br><br>for i in 0..9 do<br><br>    puts “#{i}”<br>end<br></code></pre><br><p>这个例子中我们打印了0到9的数。每次循环<em>i</em>变量保存了这个范围的一个数，这个数将在终端上打印。</p><br><p>$ ./forloop.rb <br><br>0<br><br>1<br><br>2<br><br>3<br><br>4<br><br>5<br><br>6<br><br>7<br><br>8<br><br>9  </p><br><p>例子运行结果。</p><br><hr><br><p>要遍历一个数组的元素可以使用数组的<em>length</em>方法。</p><br><pre><code>#!/usr/bin/ruby<br><br>planets = [“Mercury”, “Venus”, “Earth”, “Mars”, “Jupiter”,<br>    “Saturn”, “Uranus”, “Neptune”]<br><br>for i in 0…planets.length<br><br>    puts planets[i]<br>end<br></code></pre><br><p>这个例子中我们创建了一个数组<em>planets</em>，我们遍历这个数组打印这个数组的每个元素。</p><br><pre><code>planets = [“Mercury”, “Venus”, “Earth”, “Mars”, “Jupiter”,<br>    “Saturn”, “Uranus”, “Neptune”]<br></code></pre><br><p><em>planets</em>数组。</p><br><pre><code>for i in 0…planets.length<br></code></pre><br><p><em>length</em>方法返回数组的长度。数组从0开始，最后一个索引是n-1。</p><br><pre><code>puts planets[i]<br></code></pre><br><p>打印数组指定的一个元素。</p><br><p>$ ./planets2.rb <br><br>Mercury<br><br>Venus<br><br>Earth<br><br>Mars<br><br>Jupiter<br><br>Saturn<br><br>Uranus<br><br>Neptune  </p><br><p>程序的运行结果。</p><br><h2>each方法</h2><br><p>在Ruby中我们可以使用<em>each</em>方法遍历数组的每个元素。它接受两个参数。一个元素和一个代码块。元素放在管道之间，它保存了当前循环的数据项。代码块是每次要执行的内容。</p><br><pre><code>#!/usr/bin/ruby<br><br>planets = [“Mercury”, “Venus”, “Earth”, “Mars”, “Jupiter”,<br>    “Saturn”, “Uranus”, “Neptune”]<br><br>planets.each do |planet|<br><br>    puts planet<br>end<br></code></pre><br><p>这个例子我们使用<em>each</em>迭代器遍历<em>planets</em>数组。</p><br><pre><code>planets.each do |planet|<br><br>    puts planet<br>end<br></code></pre><br><p><em>each</em>迭代器是<em>planets</em>数组的一个方法。<em>planet</em>保存了此次迭代的数据项。我们可以使用任何我们想使用的字符。我们可以使用{}代替<em>do</em>和<em>end</em>关键字。</p><br><h2>break、next语句</h2><br><p><em>break</em>语句用于终止<em>while</em>、<em>for</em>或者<em>case</em>的代码块语句。</p><br><pre><code>#!/usr/bin/ruby<br><br>while true<br><br>    r = 1 + rand(30)<br>    print “#{r} “<br><br>    if r == 22<br>        break<br>    end<br>end<br><br>puts<br></code></pre><br><p>我们定义了一个无限循环，使用<em>break</em>语句退出这个循环。我们选择1到30的数，打印它。如果等于22则结束<em>while</em>循环。</p><br><pre><code>while true<br>   …<br>end<br></code></pre><br><p>这是一个无限循环，<em>while</em>的条件总是为真。退出无限循环的唯一方法是使用<em>break</em>。</p><br><pre><code>r = 1 + rand(30)<br>print “#{r} “<br></code></pre><br><p>计算从1到30的随机数，并将其打印。</p><br><pre><code>if r == 22<br>    break<br>end<br></code></pre><br><p>如果数等于22,结束循环。</p><br><p>$ ./break.rb <br><br>20 14 6 26 30 12 2 10 18 29 28 11 30 26 20 22   </p><br><p>可能的输出结果。</p><br><hr><br><p><em>next</em>语句用于跳过此次循环，继续下次循环。它可与<em>for</em>和<em>while</em>联合使用。</p><br><p>接下来的例子我们打印不能被2整除的数一列表。</p><br><pre><code>#!/usr/bin/ruby<br><br>num = 0<br><br>while num &lt; 100<br><br>    num += 1<br><br>    if (num % 2 == 0)<br>        next<br>    end<br><br>    print “#{num} “<br>end<br><br>puts<br></code></pre><br><p>我们使用<em>while</em>循环迭代1到99的数。</p><br><pre><code>if (num % 2 == 0)<br>    next<br>end<br></code></pre><br><p>如果这个数可以被2整除，<em>next</em>语句将执行，循环的其余将跳过。</p><br><p>$ ./next.rb <br><br>1 3 5 7 9 11 13 15 17 19 21 23 25 27 29 31 33 35 37 39 <br><br>41 43 45 47 49 51 53 55 57 59 61 63 65 67 69 71 73 75 77 <br><br>79 81 83 85 87 89 91 93 95 97 99   </p><br><p>程序的输出结果。</p><br><h2>redo语句</h2><br><p><em>redo</em>语句重新开始循环而不检查循环的条件式。下面的例子有点复杂，它展示了<em>redo</em>语句和其它的一些特性。</p><br><pre><code>#!/usr/bin/ruby<br><br>options = [“rock”, “scissors”, “paper”]<br><br>while true<br><br>    print &lt;&lt;TEXT<br>1 - rock<br>2 - scissors<br>3 - paper<br>9 - end game<br>TEXT<br><br>    val = gets.to_i<br><br>    r = rand(3) + 1<br><br>    if val == 9<br>        puts “End”<br>        exit<br>    end<br><br>    if ![1, 2, 3, 9].include?(val)<br>        puts “Invalid option”<br>        redo<br>    end<br><br>    computer = options[r-1]<br>    human = options[val-1]<br><br>    puts “I have #{computer}, you have #{human}”<br><br>    if val == r<br>        puts “Tie, next throw”<br>        redo<br>    end<br><br><br>    if val == 1 and r == 2<br>        puts “Rock blunts scissors, you win”<br><br>    elsif val == 2 and r == 1<br>        puts “Rock blunts scissors, you loose”<br><br>    elsif val == 2 and r == 3<br>        puts “Scissors cut paper, you win”<br><br>    elsif val == 3 and r == 2<br>        puts “Scissors cut paper, you loose”<br><br>    elsif val == 3 and r == 1<br>        puts “Paper covers rock, you win”<br><br>    elsif val == 1 and r == 3<br>        puts “Paper covers rock, you loose”<br><br>    end<br>end<br></code></pre><br><p>这是一个简单的Rock-paper-scissors游戏。这个例子中我们用到了<em>redo</em>语句、条件式、随机数、数组和输入。</p><br><pre><code>options = [“rock”, “scissors”, “paper”]<br></code></pre><br><p>定义了游戏可能用到的选项数组。这三个词在打印消息时会用到。</p><br><pre><code>    print &lt;&lt;TEXT<br>1 - rock<br>2 - scissors<br>3 - paper<br>9 - end game<br>TEXT<br></code></pre><br><p>使用定界符在终端上打印一个菜单。菜单在每次游戏循环时都打印。</p><br><pre><code>val = gets.to_i<br><br>r = rand(3) + 1<br></code></pre><br><p>这几行代码从终端输入一个值，然后选择一个1、2、3的随机数。</p><br><pre><code>if val == 9<br>    puts “End”<br>    exit<br>end<br></code></pre><br><p>如果输入为9，打印’End’并退出程序。</p><br><pre><code>if ![1, 2, 3, 9].include?(val)<br>    puts “Invalid option”<br>    redo<br>end<br></code></pre><br><p>如果用户选择了一个不是菜单的值，我们提示无效选项并重新循环。</p><br><pre><code>computer = options[r-1]<br>human = options[val-1]<br><br>puts “I have #{computer}, you have #{human}”<br></code></pre><br><p>将数字转化为字符串，并同时打印用户的选择和计算机的选择。</p><br><pre><code>if val == r<br>    puts “Tie, next throw”<br>    redo<br>end<br></code></pre><br><p>如果选择相同则是平局，开始新的游戏循环。</p><br><pre><code>if val == 1 and r == 2<br>    puts “Rock blunts scissors, you win”<br><br>elsif val == 2 and r == 1<br>    puts “Rock blunts scissors, you loose”<br>…<br></code></pre><br><p>使用多个<em>if</em>、<em>elsif</em>分支，比较用户和计算机的选择以决定谁是赢家。</p><br><p>$ ./redo.rb <br><br>1 - rock<br><br>2 - scissors<br><br>3 - paper<br><br>9 - end game<br><br>3<br><br>I have paper, you have paper<br><br>Tie, next throw<br><br>1 - rock<br><br>2 - scissors<br><br>3 - paper<br><br>9 - end game<br><br>2<br><br>I have rock, you have scissors<br><br>Rock blunts scissors, you loose<br><br>1 - rock<br><br>2 - scissors<br><br>3 - paper<br><br>9 - end game<br><br>1<br><br>I have scissors, you have rock<br><br>Rock blunts scissors, you win<br><br>1 - rock<br><br>2 - scissors<br><br>3 - paper<br><br>9 - end game<br><br>9<br><br>End  </p><br><p>程序输出结果。</p><br><p>这部分的Ruby教程我们谈论了结构控制流。</p><br><hr><br><p>原文地址： <a href="http://zetcode.com/lang/rubytutorial/flowcontrol/" target="_blank" rel="external">http://zetcode.com/lang/rubytutorial/flowcontrol/</a><br><br>翻译：龙昌  admin@longchangjin.cn<br><br>完整教程：<a href="https://github.com/wusuopu/Ruby-tutorial" target="_blank" rel="external">https://github.com/wusuopu/Ruby-tutorial</a> </p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://www.xefan.com/archives/83929.html" data-id="cjc95ct5o00ign4q36bhw5kyy" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Ruby/">Ruby</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/翻译/">翻译</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-/archives/83926.html" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/archives/83926.html" class="article-date">
  <time datetime="2013-11-10T00:00:00.000Z" itemprop="datePublished">2013-11-10</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Ruby栏目/">Ruby栏目</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/archives/83926.html">[翻译]Ruby教程8——表达式</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p></p><h1>表达式</h1><p></p>
<p>在这章的教程将介绍Ruby的表达式。</p><br><p>表达式是由操作数和操作符构成的。表达式的操作符表明了对操作数应用什么操作。表达式中操作符的求值顺序由操作符的优先级和结合律决定的。</p><br><p>操作符是一个特殊的符号表明了要执行的确切操作。编程语言中的操作符取自数学运算。程序员使用数据，操作符用于处理数据。操作数是操作符的参数。</p><br><p>以下表格中按优先级展示Ruby的操作符（高优先级在前）：</p><br><table><br>    <thead><br>        <tr><br>            <td>分类</td><br>            <td>符号</td><br>        </tr><br>    </thead><br>    <tbody><br>        <tr><br>            <td>解析，访问操作符</td><br>            <td>:: .</td><br>        </tr><br>        <tr><br>            <td>数组操作符</td><br>            <td>[] []=</td><br>        </tr><br>        <tr><br>            <td>求幂</td><br>            <td><strong></strong></td><br>        </tr><br>        <tr><br>            <td>非，反，一元加、减</td><br>            <td>! ~ + -</td><br>        </tr><br>        <tr><br>            <td>乘、除、模</td><br>            <td><em> / %</em></td><br>        </tr><br>        <tr><br>            <td>加、减</td><br>            <td>+ -</td><br>        </tr><br>        <tr><br>            <td>移位</td><br>            <td>&lt;&lt; &gt;&gt;</td><br>        </tr><br>        <tr><br>            <td>位与</td><br>            <td>&amp;</td><br>        </tr><br>        <tr><br>            <td>位或、逻辑或</td><br>            <td>^ |</td><br>        </tr><br>        <tr><br>            <td>关系运算</td><br>            <td>&gt; &gt;= &lt; &lt;=</td><br>        </tr><br>        <tr><br>            <td>相等、模式匹配</td><br>            <td>&lt;=&gt; == === != =~ !~</td><br>        </tr><br>        <tr><br>            <td>逻辑与</td><br>            <td>&amp;&amp;</td><br>        </tr><br>        <tr><br>            <td>逻辑或</td><br>            <td>||</td><br>        </tr><br>        <tr><br>            <td>范围操作符</td><br>            <td>.. …</td><br>        </tr><br>        <tr><br>            <td>三目运算</td><br>            <td>?:</td><br>        </tr><br>        <tr><br>            <td>分配操作</td><br>            <td>= += -= = = /= %= &amp;= |= ^= &lt;&lt;= &gt;&gt;= ||= &amp;&amp;=</td><br>        </tr><br>        <tr><br>            <td>否定</td><br>            <td>not</td><br>        </tr><br>        <tr><br>            <td>逻辑或、与</td><br>            <td>or and</td><br>        </tr><br>    </tbody><br></table><br><br><p>同一行的操作符具有相同的优先级。</p><br><p>一个操作符通常有两个操作数。那些只有一个操作数的操作符称为一元操作符。有两个操作数的称为二元操作符。有一个三元操作符(?:)有三个操作数。</p><br><p>操作符可能用于不同的上下文。例如+操作符，从上面的表格可知它能用于不同情况。数字求和、连接字符串、作为数字的符号。我们称这个操作符被重载了。</p><br><h2>正负号操作符</h2><br><p>有两个正负号操作符，+和-，用于指定或者修改值的符号。</p><br><pre><code>#!/usr/bin/ruby<br><br>puts +2<br>puts -2<br></code></pre><br><p>+和-指明了值的符号。加号表明是正数，通常可省略。</p><br><hr><br><p>接下来的例子我们使用减号。</p><br><pre><code>#!/usr/bin/ruby<br><br>a = 1<br><br>puts a<br>puts -(a)<br>puts -(-(a))<br></code></pre><br><p>减号改变了值的符号。</p><br><p>$ ./sign.rb<br><br>1<br><br>-1<br><br>1  </p><br><p>输出结果。</p><br><h2>分配操作符</h2><br><p>分配操作符<em>=</em>将一个值分配给一个变量。变量是这个值的点位符。数学运算中<em>=</em>操作符有不同的意义。在方程式中<em>=</em>是相等操作，左边的值等于右边的值。</p><br><pre><code>x = 1<br>puts x # prints 1<br></code></pre><br><p>这里分配的一个数字给<em>x</em>变量。</p><br><pre><code>x = x + 1<br>puts x # prints 2<br></code></pre><br><p>前一个表达式中数学运算中是行不通的。但是在程序中是合法的。这个表达式是将<em>x</em>变量加1，右边等于2,并把2赋值给x。</p><br><pre><code>3 = x;<br></code></pre><br><p>这个语法是错误的，我们不能组值分配字面符。</p><br><h2>解析，成员访问操作符</h2><br><p>有两个操作符具有最高的优先级，这意味着它们总是先求解。</p><br><pre><code>#!/usr/bin/ruby<br><br>class MyMath<br>    Pi = 3.1415926535<br>end<br><br>module People<br>    Name = “People”<br>end<br><br>puts MyMath::Pi<br>puts People::Name<br></code></pre><br><p>第一个例子展示了<em>::</em>命名空间解析操作符。它可以访问一个定义在其它类或模块里的常量、模块或者类。它用于提供命名空间，这样方法和类的名字就不会与其他作者的类冲突了。</p><br><pre><code>class MyMath<br>    Pi = 3.1415926535<br>end<br><br>module People<br>    Name = “People”<br>end<br></code></pre><br><p>这里创建了一个模块的一个类，分别定义了一个常量。</p><br><pre><code>puts MyMath::Pi<br>puts People::Name<br></code></pre><br><p>我们使用<em>::</em>操作符访问它们的常量。</p><br><p>$ ./resolution.rb<br><br>3.1415926535<br><br>People  </p><br><p><em>resolution.rb</em>脚本的输出结果。</p><br><hr><br><p>点(.)操作符是成员访问，用于调用对象的方法。</p><br><pre><code>#!/usr/bin/ruby<br><br>class Person<br><br>   def initialize name, age<br>       @name = name<br>       @age = age<br>   end<br><br>   def info<br>       “#{@name} is #{@age} years old”<br>   end<br><br>end<br><br>p = Person.new “Jane”, 17<br>puts p.info<br><br>puts “ZetCode”.reverse<br></code></pre><br><p>这个例子中我们创建了两个对象，一个是用户定义的，一个是预定义的。我们对这些对象使用点操作符。</p><br><pre><code>p = Person.new “Jane”, 17<br>puts p.info<br></code></pre><br><p>在这行使用点操作符调用了两个方法：new和info。</p><br><pre><code>puts “ZetCode”.reverse<br></code></pre><br><p>字符串是内建对象，具有一个<em>reverse</em>方法。</p><br><p>$ ./memberaccess.rb<br><br>Jane is 17 years old<br><br>edoCteZ  </p><br><p>输出结果。</p><br><h2>字符串连接</h2><br><p>Ruby中<em>+</em>操作符同样可以用于字符串连接。在不同上下文中操作符作用不同，我们称这个为重载。</p><br><pre><code>#!/usr/bin/ruby<br><br>puts “Return “ + “of “ + “the “ + “King”<br>puts “Return “.+”of “.+ “the “.+”King”<br></code></pre><br><p>我们将三个字符串连接在一起。</p><br><pre><code>puts “Return “ + “of “ + “the “ + “King”<br></code></pre><br><p>我们使用<em>+</em>操作符连接字符串。</p><br><pre><code>puts “Return “.+”of “.+ “the “.+”King”<br></code></pre><br><p><em>+</em>操作符也是Ruby的一个方法。我们可以使用访问操作符(.)来调用它。</p><br><p>$ ./catstrings.rb <br><br>Return of the King<br><br>Return of the King  </p><br><p><em>catstrings.rb</em>程序的运行结果。</p><br><h2>增、减操作符</h2><br><p>Ruby中没有如下操作。<br><br>x++;<br><br>…<br><br>y–;  </p><br><p>这些是C语言的增、减操作。</p><br><p>如果你熟悉Java、C、C++，你可能了解这些操作符。但是这些在Ruby中无效的。同样在Python中也没有。</p><br><h2>算术操作符</h2><br><p>下面的表格是Ruby中的算术操作符。  </p><br><table><br><thead><br><tr><br><th align="left">符号</th><br><th align="left">名字</th><br></tr><br></thead><br><tbody><br><tr><br><td align="left">+</td><br><td align="left">加</td><br></tr><br><tr><br><td align="left">-</td><br><td align="left">减</td><br></tr><br><tr><br><td align="left"><em></em></td><br><td align="left">乘</td><br></tr><br><tr><br><td align="left">/</td><br><td align="left">除</td><br></tr><br><tr><br><td align="left">%</td><br><td align="left">模</td><br></tr><br><tr><br><td align="left">**</td><br><td align="left">幂</td><br></tr><br></tbody><br></table><br><p>下面的例子中我们使用了算术操作符。</p><br><pre><code>#!/usr/bin/ruby<br><br>a = 10<br>b = 11<br>c = 12<br><br>puts a + b + c<br>puts c - a<br>puts a  b<br>puts c / 3<br>puts c % a<br>puts c <strong> a<br></strong></code></pre><br><p>在前面的例子我们使用了加、减、乘、除和取余操作。这些与数学上的是相同的。</p><br><pre><code>puts c % a<br></code></pre><br><p><em>%</em>操作符是取余或者求模。</p><br><p>$ ./arithmetic.rb<br><br>33<br><br>2<br><br>110<br><br>4<br><br>2<br><br>61917364224  </p><br><p>输出结果。</p><br><hr><br><p>接下来展示整数和浮点数除法的区别。</p><br><pre><code>#!/usr/bin/ruby<br><br>puts 5 / 2<br><br>puts 5 / 2.0<br>puts 5.0 / 2<br>puts 5.to_f / 2<br></code></pre><br><p>上面的例子我们将两个数相除。</p><br><pre><code>puts 5 / 2<br></code></pre><br><p>这个表达式中的操作数都是整数，我们进行的是整数相除。结果返回的也是整数。</p><br><pre><code>puts 5 / 2.0<br>puts 5.0 / 2<br>puts 5.to_f / 2<br></code></pre><br><p>如果其中一个或两个是浮点数，我们进行的是浮点数相除。</p><br><p>$ ./division.rb<br><br>2<br><br>2.5<br><br>2.5<br><br>2.5  </p><br><p><em>division.rb</em>程序的运行结果。</p><br><hr><br><p>Ruby有其他方式进行除运算。这些都是有效的方法调用。</p><br><pre><code>#!/usr/bin/ruby<br><br>puts 5.div 2.0<br>puts 5.fdiv 2<br>puts 5.quo 2<br>puts 5.0.quo 2.0<br></code></pre><br><p>上面例子中我们使用了<em>div</em>、<em>fdiv</em>和<em>quo</em>方法。</p><br><pre><code>puts 5.div 2.0<br></code></pre><br><p><em>div</em>总是进行整数除，即使操作数是浮点数。</p><br><pre><code>puts 5.fdiv 2<br></code></pre><br><p><em>fdiv</em>总是进行浮点数除法。</p><br><pre><code>puts 5.quo 2<br>puts 5.0.quo 2.0<br></code></pre><br><p><em>quo</em>方法进行精确的除法。如果操作数是浮点数则返回浮点数，否则是有理数。</p><br><p>$ ./otherdivision.rb<br><br>2<br><br>2.5<br><br>5/2<br><br>2.5  </p><br><h2>布尔操作符</h2><br><p>Ruby中有以下布尔操作符。</p><br><table><br>    <thead><br>        <tr><br>            <td>符号</td><br>            <td>名字</td><br>        </tr><br>    </thead><br>    <tbody><br>        <tr><br>            <td>&amp;&amp;</td><br>            <td>逻辑与</td><br>        </tr><br>        <tr><br>            <td>||</td><br>            <td>逻辑或</td><br>        </tr><br>        <tr><br>            <td>!</td><br>            <td>否</td><br>        </tr><br>    </tbody><br></table><br><br><p>布尔操作符处理真假值。Ruby中有额外的布尔操作符，<em>and</em>、<em>or</em>、<em>&amp;</em>、<em>not</em>。它们操作是相同的，只是优先级低一些。与Perl语言不同，这需要一个低优先级的布尔操作符。</p><br><pre><code>#!/usr/bin/ruby<br><br>x = 3<br>y = 8<br><br>puts x == y<br>puts y &gt; x<br><br>if y &gt; x then<br>    puts “y is greater than x”<br>end<br></code></pre><br><p>许多表达式的结果都是一个布尔值。布尔值用于条件语句。</p><br><pre><code>puts x == y<br>puts y &gt; x<br></code></pre><br><p>返回布尔值的相关操作符。这两行打印为false和true。</p><br><pre><code>if y &gt; x then<br>    puts “y is greater than x”<br>end<br></code></pre><br><p>仅当月<em>if</em>条件为真时<em>if</em>里的语句才会执行。x &gt; y返回true，因此”y is greater than x”会在终端上打印。</p><br><hr><br><p>下面的例子展示逻辑与操作符。</p><br><pre><code>#!/usr/bin/ruby<br><br>puts true &amp;&amp; true<br>puts true &amp;&amp; false<br>puts false &amp;&amp; true<br>puts false &amp;&amp; false<br></code></pre><br><p>与操作只有在操作数都为true才返回true。</p><br><p>$ ./andoperator.rb<br><br>true<br><br>false<br><br>false<br><br>false  </p><br><p>只有一个表达式的结果为true。</p><br><hr><br><p>逻辑或操作符当有一个操作数为true则返回true。</p><br><pre><code>#!/usr/bin/ruby<br><br>puts true || true<br>puts true || false<br>puts false || true<br>puts false || false<br></code></pre><br><p>如果有一边是true，操作的结果就是true。</p><br><p>$ ./oroperator.rb<br><br>true<br><br>true<br><br>true<br><br>false  </p><br><p>三个表达式结果为true。</p><br><hr><br><p>非操作进行真假反转。</p><br><pre><code>#!/usr/bin/ruby<br><br>puts !0<br>puts !1<br>puts !true<br>puts !false<br><br>puts ! (4&lt;3)<br>puts ! “Ruby”.include?(“a”)<br></code></pre><br><p>这个例子展示了非操作符的用法。</p><br><p>$ ./not.rb<br><br>false<br><br>false<br><br>false<br><br>true<br><br>true<br><br>true  </p><br><p>输出结果。</p><br><hr><br><p><em>||</em>和<em>&amp;&amp;</em>操作符是短路求值（short circuit evaluated）。短路求值意味着只有在第一个参数不足以确定表达式的值时第二个参数才会进行求值。短求值主要用于提高执行效率。</p><br><p>用一个例子解释。</p><br><pre><code>#!/usr/bin/ruby<br><br>def one<br>    puts “Inside one”<br>    false<br>end<br><br>def two<br>    puts “Inside two”<br>    true<br>end<br><br>puts “Short circuit”<br><br>if one &amp;&amp; two<br>    puts “Pass”<br>end<br><br>puts “##############################”<br><br>if two || one<br>    puts “Pass”<br>end<br></code></pre><br><p>在例子中定义了两个方法，用于在布尔操作中作为操作数。我们将看到它们是否被调用了。</p><br><pre><code>if one &amp;&amp; two<br>    puts “Pass”<br>end<br></code></pre><br><p>第一个方法返回false，短路求值不会计算第二个方法。一旦一个操作数是false，那么这个逻辑的结果总是false。</p><br><pre><code>puts “##############################”<br><br>if two || one<br>    puts “Pass”<br>end<br></code></pre><br><p>第二种情况我们使用<em>||</em>操作符，并且第一个操作数为<em>tow</em>方法。这里同样没有必要对第二个操作数求值，只要第一个操作数为true，那么逻辑或总是为true。</p><br><pre><code>$ ./shortcircuit.rb<br>Short circuit<br>Inside one<br>##############################<br>Inside two<br>Pass<br></code></pre><br><p><em>shortcircuit.rb</em>程序的运行结果。</p><br><h2>关系操作符</h2><br><p>关系操作符用于值的比较，其总是返回布尔值。</p><br><table><br><thead><br><tr><br><th align="left">符号</th><br><th align="left">含义</th><br></tr><br></thead><br><tbody><br><tr><br><td align="left">&lt;</td><br><td align="left">小于</td><br></tr><br><tr><br><td align="left">&lt;=</td><br><td align="left">小于等于</td><br></tr><br><tr><br><td align="left">&gt;</td><br><td align="left">大于</td><br></tr><br><tr><br><td align="left">&gt;=</td><br><td align="left">大于等于</td><br></tr><br></tbody><br></table><br><p>关系操作符又称为比较操作符。</p><br><pre><code>#!/usr/bin/ruby<br><br>p 3 &lt; 4<br>p 3 &gt; 5<br>p 3 &gt;= 3<br></code></pre><br><p>表达式<em>3 &lt; 4</em>返回true，因为3小于4。表达式<em>3 &gt; 5</em>返回false，因为3不大于5。</p><br><h2>位操作符</h2><br><p>人类用的是十进制数字，计算机原生的是二进制数。二进制、八进制、十进制和十六进制只是数字的符号。位操作符针对的是二进制数。</p><br><table><br>    <thead><br>        <tr><br>            <td>符号</td><br>            <td>含义</td><br>        </tr><br>    </thead><br>    <tbody><br>        <tr><br>            <td>~</td><br>            <td>按位取反</td><br>        </tr><br>        <tr><br>            <td>^</td><br>            <td>按位异或</td><br>        </tr><br>        <tr><br>            <td>&amp;</td><br>            <td>按位与</td><br>        </tr><br>        <tr><br>            <td>|</td><br>            <td>按位与或</td><br>        </tr><br>        <tr><br>            <td>&lt;&lt;</td><br>            <td>左移位</td><br>        </tr><br>        <tr><br>            <td>&gt;&gt;</td><br>            <td>右移位</td><br>        </tr><br>    </tbody><br></table><br><br><p>位操作在高级语言中很少使用。</p><br><pre><code>#!/usr/bin/ruby<br><br>puts ~ 7   # prints -8<br>puts ~ -8  # prints 7<br><br>puts 6 &amp; 3  # prints 2<br>puts 3 &amp; 6  # prints 2<br><br>puts 6 ^ 3  # prints 5<br>puts 3 ^ 6  # prints 5<br><br>puts 6 | 3  # prints 7<br>puts 3 | 6  # prints 7<br><br>puts 6 &lt;&lt; 1  # prints 12<br>puts 1 &lt;&lt; 6  # prints 64<br><br>puts 6 &gt;&gt; 1  # prints 3<br>puts 1 &gt;&gt; 6  # prints 0<br></code></pre><br><p>上面的例子中展示了这6个位操作符。</p><br><pre><code>puts ~ 7   # prints -8<br>puts ~ -8  # prints 7<br></code></pre><br><p>按位取反是将1变为0，0变为1。将操作会将数字7所有的位都反转，同样包括符号位。如果再次反转所有的位即会得到数字7。</p><br><pre><code>puts 6 &amp; 3  # prints 2<br>puts 3 &amp; 6  # prints 2<br></code></pre><br><p>按位与是将两个数进行逐位与操作，只有两个数对应位的都为1结果才为1。</p><br><pre><code>puts 6 ^ 3  # prints 5<br>puts 3 ^ 6  # prints 5<br></code></pre><br><p>按位异或是将两个数进行逐位异或操作，只要其中一个数（但不是全部）对应位的为1结果就为1。</p><br><pre><code>puts 6 | 3  # prints 7<br>puts 3 | 6  # prints 7<br></code></pre><br><p>按位或是将两个数进行逐位或操作，只要其中一个数对应位的为1结果就为1。</p><br><pre><code>puts 6 &lt;&lt; 1  # prints 12<br>puts 1 &lt;&lt; 6  # prints 64<br><br>puts 6 &gt;&gt; 1  # prints 3<br>puts 1 &gt;&gt; 6  # prints 0<br></code></pre><br><p>移位操作符是按位进行右移或左移，也称为算术移位。</p><br><h2>复合分配操作符</h2><br><p>复合分配操作符是由两个操作符构成。它们是简写操作符。</p><br><pre><code>#!/usr/bin/ruby<br><br>a = 0<br><br>a = a + 1<br>a += 1<br>puts a<br><br><br>b = 0<br><br>b = b - 8<br>b -= 8<br>puts b<br></code></pre><br><p><em>+=</em>和<em>-=</em>操作符是一个简写的操作符。它们的可读性没有全写的好，但是有经验的程序员经常使用它们。</p><br><pre><code>a = a + 1<br>a += 1<br></code></pre><br><p>这两行的操作是一样的，都是将变量<em>a</em>加1。</p><br><p>其他的一些复合操作符。</p><br><pre><code>-=   *=  =  /=   %=   &amp;=   |=   &lt;&lt;=   &gt;&gt;=<br></code></pre><br><h2>操作符优先级</h2><br><p>操作符的优先级表明了先对哪个操作符进行求值。优先级避免了表达式的二义性。</p><br><p>这个表达式的结果是多少？28还是40？</p><br><p>3 + 5 <em> 5  </em></p><br><p>跟数学相同，乘法优先级高于加法，加些结果为28。</p><br><p>(3 + 5)  5  </p><br><p>我们可以使用括号来改变优先级。括号里的表达式总是最先求值。</p><br><pre><code>#!/usr/bin/ruby<br><br>puts 3 + 5 <em> 5<br>puts (3 + 5) </em> 5<br><br>puts ! true | true<br>puts ! (true | true)<br></code></pre><br><p>这个例子展示了一些表达式，其结果依赖于操作符优先级。</p><br><pre><code>puts 3 + 5 <em> 5<br></em></code></pre><br><p>这行打印28，因为乘法操作优先级高于加法。</p><br><pre><code>puts ! true | true<br></code></pre><br><p>这里非操作优先级更高。最后返回为true。</p><br><p>$ ./precedence.rb<br><br>28<br><br>40<br><br>true<br><br>false  </p><br><h2>结合律</h2><br><p>有时优先级不能决定表达式的结果。还有另一条规则称为结合律。它决定相同优先级的求值顺序。</p><br><p>9 / 3  3  </p><br><p>这个的结果是多少？9还是1？乘、除和取模操作是从左到右结合的。因此结果为9。</p><br><p>数学运算、布尔、关系和位操作都是从左向右结合的。</p><br><p>另外赋值操作是右结合。</p><br><pre><code>a = b = c = d = 0<br>print a, b, c, d # prints 0000<br></code></pre><br><p>复合分配操作是从右向左结合的。</p><br><pre><code>j = 0<br>j *= 3 + 1<br>puts j<br></code></pre><br><p>你可能期望结果为1,但是实际上结果为0。由于结合律，右边表达式先求值再应用复合分配操作。</p><br><h2>范围操作符</h2><br><p>Ruby有两个范围操作符，用于创建一个范围对象。通常是数字或者字母的范围。</p><br><p><em>..</em>范围操作符（两个点）创建一个包含的范围。<em>…</em>操作符（三个点）创建一个非包含的范围，较大的值不包含在其中。</p><br><pre><code>#!/usr/bin/ruby<br><br>p (1..3).to_a<br>p (1…3).to_a<br><br>p (‘a’ .. ‘l’).to_a<br></code></pre><br><p>这个例子中我们使用范围操作符创建了数字范围和字母范围。</p><br><pre><code>p (1..3).to_a<br>p (1…3).to_a<br></code></pre><br><p>这两行都是使用范围操作符创建了两个范围，然后转换为数据。第一个范围的值为1,2,3；第二个为1和2.</p><br><pre><code>p (‘a’ .. ‘l’).to_a<br></code></pre><br><p>这里使用<em>..</em>操作符创建一个’a’到’l’的数组。</p><br><p>$ ./range.rb<br><br>[1, 2, 3]<br><br>[1, 2]<br><br>[“a”, “b”, “c”, “d”, “e”, “f”, “g”, “h”, “i”, “j”, “k”, “l”]  </p><br><p>输出结果。</p><br><h2>三元运算术</h2><br><p>三元运算术是一个条件操作。如果我们需要根据条件表达式从两个值选择一个时这是一个方便的操作。</p><br><p>cond-exp ? exp1 : exp2  </p><br><p>如果<em>cond-exp</em>为真则返回<em>exp1</em>，否则返回<em>exp2</em>。</p><br><pre><code>#!/usr/bin/ruby<br><br>age = 32<br><br>adult = age &gt;= 18 ? true : false<br><br>if adult then<br>    puts “Adult”<br>else<br>    puts “Not adult”<br>end<br></code></pre><br><p>许多国家成年是基于你的年龄。是否成年即为是否超过了一定年龄。这种情况适合于三元操作。</p><br><pre><code>adult = age &gt;= 18 ? true : false<br></code></pre><br><p>首先对赋值符右转进行求值，它的值将赋给<em>adult</em>变量。</p><br><p>$ ./ternary.rb<br><br>Adult  </p><br><p>32年已经成年了。</p><br><h2>计算素数</h2><br><p>我们将计算素数。</p><br><pre><code>#!/usr/bin/ruby<br><br>nums = (4..50).to_a<br><br>puts “Prime numbers:”<br><br>print “2 3 “<br><br>nums.each do |i|<br><br>    not_prime = false<br><br>    (2..Math.sqrt(i).ceil).each do |j|<br>        not_prime = true if i % j == 0<br>    end<br><br>    print i, “ “ unless not_prime<br><br>end<br><br>puts<br></code></pre><br><p>上面的例子中我们用到了一些操作符。</p><br><pre><code>nums = (4..50).to_a<br></code></pre><br><p>我们将从这些数中计算哪些是素数。</p><br><pre><code>print “2 3 “<br></code></pre><br><p>我们路过2和3,因为它们都是素数。</p><br><pre><code>not_prime = false<br></code></pre><br><p><em>not_prime</em>标志表明选择的数不是素数。我们假设选择的数是素数，直到被证明不是为止。</p><br><pre><code>(2..Math.sqrt(i).ceil).each do |j|<br>    not_prime = true if i % j == 0<br>end<br></code></pre><br><p>当取模的结果为0表示这个数不是素数。</p><br><pre><code>print i, “ “ unless not_prime<br></code></pre><br><p>如果<em>not_prime</em>标志没有设置则打印这个数。</p><br><hr><br><p>上面例子展示了一些操作符。实际上有更简单方法计算素数。Ruby中有一个计算素数的模块。</p><br><pre><code>#!/usr/bin/ruby<br><br>require ‘prime’<br><br>Prime.each(50) do |i|<br>    print i, “ “<br>end<br><br>puts<br></code></pre><br><p>使用Ruby的<em>prime</em>模块计算素数。</p><br><pre><code>require ‘prime’<br></code></pre><br><p>导入<em>prime</em>模块。</p><br><pre><code>Prime.each(50) do |i|<br>    print i, “ “<br>end<br></code></pre><br><p>计算到50的素数。</p><br><p>$ ./primes.rb<br><br>2 3 5 7 11 13 17 19 23 29 31 37 41 43 47   </p><br><p>结果输出了2到50之间的素数。</p><br><p>这章的教程介绍了表达式。</p><br><hr><br><p>原文地址： <a href="http://zetcode.com/lang/rubytutorial/expressions/" target="_blank" rel="external">http://zetcode.com/lang/rubytutorial/expressions/</a><br><br>翻译：龙昌  admin@longchangjin.cn<br><br>完整教程：<a href="https://github.com/wusuopu/Ruby-tutorial" target="_blank" rel="external">https://github.com/wusuopu/Ruby-tutorial</a>  </p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://www.xefan.com/archives/83926.html" data-id="cjc95ct5n00ien4q3skqn7bj9" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Ruby/">Ruby</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/翻译/">翻译</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-/archives/83921.html" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/archives/83921.html" class="article-date">
  <time datetime="2013-11-08T00:00:00.000Z" itemprop="datePublished">2013-11-08</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Ruby栏目/">Ruby栏目</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/archives/83921.html">[翻译]Ruby教程7——字符串</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p></p><h1>字符串</h1><p></p>
<p>在这部分的教程将详细的介绍字符串。</p><br><p>字符串是计算机语言中最重要的数据类型之一，这就是为什么我们决定要用一整章来介绍字符串。</p><br><p>字符串是序列化的unicode字符。它是一种数据类型存储了序列化的值，它的元素通常代表的是根据字符编码的字符。当一个字符串在代码中以字面量出现，它也称为字符串文本。</p><br><h2>第一个例子</h2><br><p>在Ruby中字符串文本是以单引号或者双引号引起来的。</p><br><pre><code>#!/usr/bin/ruby<br><br># first.rb<br><br>puts ‘Python language’<br>puts “Ruby language”<br></code></pre><br><p>这个例子有两个字符串，第一个是用单引号，另一个是用双引号。</p><br><p>$ ./first.rb <br><br>Python language<br><br>Ruby language  </p><br><p>程序输出。</p><br><h2>使用引号</h2><br><p>如果我们想要显示引号该怎么做，直接引用？这有两种方法实现。</p><br><pre><code>#!/usr/bin/ruby<br><br>puts “There are many stars”<br>puts “He said, \”Which one is your favourite?\””<br><br>puts ‘There are many stars’<br>puts ‘He said, “Which one is your favourite?”‘<br></code></pre><br><p>我们使用()字符将引号转义。通常双引号是用于划定字符串的范围，然后被转义之后它原始的意义就没有了。它在字符串中被作为一个正常的字符。第二种方法是混合使用单引号和双引号。</p><br><p>$ ./quotes.exe <br><br>There are many stars.<br><br>He said, “Which one is your favourite?”  </p><br><p>输出结果。</p><br><h2>转义序列</h2><br><p>转义符是特殊的字符，在字符串中有特殊的含意。</p><br><pre><code>#!/usr/bin/ruby<br><br>puts “one two three four”<br>puts “one\ntwo\nthree\nfour”<br></code></pre><br><p>最常用一个的转义符是换行符\n。它在许多编程语言中都有效。换行符之后的字符将出现在新的一行。</p><br><p>$ ./newline.rb<br><br>one two three four<br><br>one<br><br>two<br><br>three<br><br>four  </p><br><p>以上脚本的输出结果中换行符之后的字符在新的一行。</p><br><hr><br><p><em>r</em>、<em>b</em>和<em>t</em>是正常的字符，当前面加上\字符后就具有特殊意义了。</p><br><pre><code>#!/usr/bin/ruby<br><br>puts “   bbb\raaa”<br>puts “Joan\b\b\bane”<br>puts “Towering\tinferno”<br></code></pre><br><p>这个例子中我们用到了三个不同的转义字符。</p><br><pre><code>puts “   bbb\raaa”<br></code></pre><br><p>回车符<em>\r</em>控制之后的字符回到行首。之前打印到终端上的字符串会被处理。这个转义字符会将<em>aaa</em>字符位于<em>bbb</em>之前，输出为<em>aaabbb</em>。</p><br><pre><code>puts “Joan\b\b\bane”<br></code></pre><br><p><em>\b</em>是退格控制符，它会删掉前一个字符。这个字符串将在终端上打印<em>‘Jane’</em>而不是<em>‘Joan’</em>。</p><br><pre><code>puts “Towering\tinferno”<br></code></pre><br><p>最后<em>\t</em>转义符是用于两个词之间制表空格的。</p><br><p>$ ./escapes.rb <br><br>aaabbb<br><br>Jane<br><br>Towering        inferno  </p><br><p>例子的输出结果。</p><br><hr><br><p>反斜杠<em>\</em>是用于创建转义符的特殊字符。当需要打印反斜杠时，则在它前面加上另一个反斜杠。这意味着转义过了可以打印。在Ruby中单引号和双引号用于划定字符串范围的，想要打印它们同样也需要在前面加上<em>\</em>。</p><br><pre><code>#!/usr/bin/ruby<br><br>puts “The special character \“<br>puts “The special character \’”<br>puts “The special character \””<br></code></pre><br><p>这个例子中我们在终端上打印了这三个字符。</p><br><p>$ ./specials.rb<br><br>The special character \ <br><br>The special character ‘<br><br>The special character “  </p><br><p>输出结果。</p><br><h2>访问字符串的元素</h2><br><p>在Ruby中我们可以使用方括号<em>[]</em>来访问字符串的元素。在括号内可以使用字符串、范围索引。</p><br><pre><code>#!/usr/bin/ruby<br><br>msg = “Ruby language”<br><br>puts msg[“Ruby”]<br>puts msg[“Python”]<br><br>puts msg[0]<br>puts msg[-1]<br><br>puts msg[0, 3]<br>puts msg[0..9]<br>puts msg[0, msg.length]<br></code></pre><br><p>这个例子的代码展示了我们可以访问字符串的一部分。</p><br><pre><code>msg = “Ruby language”<br></code></pre><br><p>这里是我们将要访问的字符串。</p><br><pre><code>puts msg[“Ruby”]<br></code></pre><br><p>这行代码我们测试字符串<em>‘Ruby’</em>是否是<em>msg</em>的子串。如果是将返回该字符串。</p><br><pre><code>puts msg[0]<br></code></pre><br><p>可以通过索引来访问这个字符串的字符。编号是从0开始的，也就是说0号索引是第1个字符。<em>msg[0]</em>返回字符串的第一个字符<em>R</em>。</p><br><pre><code>puts msg[-1]<br></code></pre><br><p>这里我们访问最后一个字符。-1代表了最后一个索引。</p><br><pre><code>puts msg[0, 3]<br></code></pre><br><p>两个用逗号分隔的索引返回了从第1个索引开始到第2个索引的字符，不包括第2个索引。</p><br><pre><code>puts msg[0..9]<br></code></pre><br><p>范围操作符也可以完成同样操作。这里我们打印前10个字符。</p><br><pre><code>puts msg[0, msg.length]<br></code></pre><br><p>这行返回全部的字符。<em>msg.length</em>返回字符串的长度。</p><br><p>$ ./access.rb<br><br>Ruby  </p><br><p>R<br><br>e<br><br>Rub<br><br>Ruby langu<br><br>Ruby language  </p><br><p>输出结果。</p><br><h2>多行字符串</h2><br><p>许多编程语言要创建多行字符串需要额外的努力，在Visual Basic中尤其如此。但是在Ruby中却是很容易。</p><br><pre><code>#!/usr/bin/ruby<br><br>puts “I hear Mariachi static on my radio<br>And the tubes they glow in the dark<br>And I’m there with her in Ensenada<br>And I’m here in Echo Park<br>“<br><br>puts %/<br>Carmelita hold me tighter<br>I think I’m sinking down<br>And I’m all strung out on heroin<br>On the outskirts of town/<br><br>puts &lt;&lt;STRING<br><br>Well, I’m sittin’ here playing solitaire<br>With my pearl-handled deck<br>The county won’t give me no more methadone<br>And they cut off your welfare check<br>STRING<br></code></pre><br><p>这个例子中我们使用了Carmelita歌曲的歌词。我们展示了使用三种方法打印多行字符串。可以使用双引号；可以使用%字符创建多行字符串，用%后面的字符将字符串包围住；最后我们使用定界符，这和语法是使用<em>&lt;&lt;</em>接着一些字符串，用这个字符串包围住多行字符。它必须左对齐。</p><br><h2>变量替换</h2><br><p>变量替换是将字符串的变量替换成它们的值。为了将变量替换成值，这个变量在字符串需要放在<em>#{</em>和<em>}</em>之间。</p><br><pre><code>#!/usr/bin/ruby<br><br>name = “Jane”<br>age = 17<br><br>puts “#{name} is #{age} years old”<br></code></pre><br><p>这个例子中我们替换了字符串中的两个变量：<em>name</em>和<em>age</em>。</p><br><p>$ ./interpolation.rb <br><br>Jane is 17 years old  </p><br><hr><br><p>也可以替换表达式。</p><br><pre><code>#!/usr/bin/ruby<br><br>x = 5<br>y = 6<br><br>puts “The product of #{x} and #{y} is #{x<em>y}”<br></em></code></pre><br><p>这是一个表达式替换的例子。</p><br><p>$ ./interpolation2.rb<br><br>The product of 5 and 6 is 30  </p><br><p>运行例子脚本。</p><br><hr><br><p>这是另一种替换变量的方法。类似于Python 2.x所支持的替换。</p><br><pre><code>#!/usr/bin/ruby<br><br>name = “Jane”<br>age = 17<br><br>message = “%s is %d years old” % [name, age]<br>puts message<br></code></pre><br><p>以上是一个例子。</p><br><pre><code>message = “%s is %d years old” % [name, age]<br></code></pre><br><p>使用之前先创建一个字符串。<em>%s</em>和<em>%d</em>是格式化字符，分别表示字符串和数字。值由%字符后面的方括号提供。</p><br><h2>字符串连接</h2><br><p>字符串连接是从多个字符串创建一个字符串。</p><br><pre><code>#!/usr/bin/ruby<br><br>lang = “Ruby” + “ programming” + “ languge”<br>puts lang<br><br>lang = “Python” “ programming” “ language”<br>puts lang<br><br>lang = “Perl” &lt;&lt; “ programming” &lt;&lt; “ language”<br>puts lang<br><br>lang = “Java”.concat(“ programming”).concat(“ language”)<br>puts lang<br></code></pre><br><p>Ruby提供多种方法连接字符串。</p><br><pre><code>lang = “Ruby” + “ programming” + “ languge”<br></code></pre><br><p>在计算机语言中加法操作符是最常用的一种。Perl和PHP是用的点操作符(.)。</p><br><pre><code>lang = “Python” “ programming” “ language”<br></code></pre><br><p>Ruby自动连接多个后续的字符串。</p><br><pre><code>lang = “Perl” &lt;&lt; “ programming” &lt;&lt; “ language”<br></code></pre><br><p>另一种方法是使用<em>&lt;&lt;</em>操作符。</p><br><pre><code>lang = “Java”.concat(“ programming”).concat(“ language”)<br></code></pre><br><p>每个字符串字面符实际上都是一个对象。我们可以对Ruby对象调用很多方法。对于字符串对象可以调用<em>concat</em>方法连接两个字符串。它返回最后的结果对象，再对其调用另一个方法。这样我们就将这些方法链接起来了。</p><br><p>$ ./concatenate.rb<br><br>Ruby programming languge<br><br>Python programming language<br><br>Perl programming language<br><br>Java programming language  </p><br><p>输出结果。</p><br><h2>冻结字符串</h2><br><p>在Java或者C#中字符串是不可变的，这意味着不能修改已存在的字符串。只能通过已存在的字符串创建一个新的。在Ruby中字符串同样也是不可修改的。</p><br><p>Ruby中字符串对象有一个<em>freeze</em>方法，可以使它们不可变。</p><br><pre><code>#!/usr/bin/ruby<br><br>msg = “Jane”<br>msg &lt;&lt; “ is “<br>msg &lt;&lt; “17 years old”<br><br>puts msg<br><br>msg.freeze<br><br>#msg &lt;&lt; “and she is pretty”<br></code></pre><br><p>这个例子我们演示了字符串是可变的。然后在调用<em>freeze</em>方法之后我们就不能再作修改了。如果我们取消掉注释将会得到’can’t modify frozen string’错误信息。</p><br><h2>字符串比较</h2><br><p>在编程中字符串比较是件平常的事情。我们可以使用<em>==</em>操作符或者<em>eql?</em>方法来比较两个字符串，如果相等返回<em>true</em>，否则<em>false</em>。</p><br><pre><code>#!/usr/bin/ruby<br><br>puts “12” == “12”<br>puts “17” == “9”<br>puts “aa” == “ab”<br><br>puts “Jane”.eql? “Jan”<br>puts “Jane”.eql? “Jane”<br></code></pre><br><p>这个例子的代码我们比较了一些字符串。</p><br><pre><code>puts “12” == “12”<br></code></pre><br><p>这两个是相等的，这行返回true。</p><br><pre><code>puts “aa” == “ab”<br></code></pre><br><p>第一个字符是相等，然后比较下一个字符。它们不同，因此返回false。</p><br><pre><code>puts “Jane”.eql? “Jan”<br></code></pre><br><p><em>eql?</em>方法用于比较两个字符串。所有对象都内建了<em>eql?</em>方法。这个方法将另一个要比较的字符串作为参数传入。</p><br><p>$ ./comparing.rb<br><br>true<br><br>false<br><br>false<br><br>false<br><br>true  </p><br><p>程序输出结果。</p><br><hr><br><p>Ruby中有一个“飞船(spaceship)”操作符<em>&lt;==&gt;</em>。这个操作符来自Perl，与以上两个比较方法不同，它不是返回<em>true</em>和<em>false</em>，而是返回1、0或者-1。取决于左参数和右参数的关系。如果左参数大于右参数则返回1；如果左参数小于右参数则返回-1；如果相等返回0。什么才是一个字符大于另一个字符呢？字符在表中是有序的，在表中每个字符有一位位置。当比较字符时实际比较它们在表中的位置。例如ASCII表，字符<em>a</em>在<em>b</em>的前面，因此<em>a&lt;==&gt;b</em>返回-1，因为左参数的位置小于右参数<em>b</em>。</p><br><pre><code>#!/usr/bin/ruby<br><br>puts “a” &lt;==&gt; “b”<br>puts “b” &lt;==&gt; “a”<br>puts “a” &lt;==&gt; “a”<br></code></pre><br><p>使用“飞船”操作符比较字符串。</p><br><p>$ ./spaceship.rb<br><br>-1<br><br>1<br><br>0  </p><br><p>输出结果。</p><br><hr><br><p>有可能比较字符串不管大小写。在Ruby中有<em>casecmp</em>方法。这个方法与飞船操作符相同。</p><br><pre><code>#!/usr/bin/ruby<br><br>puts “Jane”.casecmp “Jane”<br>puts “Jane”.casecmp “jane”<br>puts “Jane”.casecmp “Jan”<br></code></pre><br><p>以上是一个例子。</p><br><pre><code>puts “Jane”.casecmp “Jane”<br>puts “Jane”.casecmp “jane”<br></code></pre><br><p>这两行返回结果都是0.因为我们不考虑字符的大小写。</p><br><p>$ ./case.rb<br><br>0<br><br>0<br><br>1  </p><br><p>输出结果。</p><br><h2>字符串对象</h2><br><p>Ruby是面向对象语言。对象是面向对象程序的基本代码块。字符串也是对象。对象由数据和方法组成。在面向对象程序中，创建对象并且相互通信。</p><br><pre><code>#!/usr/bin/ruby<br><br>website = “google.com”<br>puts website<br><br>website = String.new “zetcode.com”<br>puts website<br></code></pre><br><p>以上例子我们展示了两个创建字符串的基本方法。</p><br><pre><code>website = “google.com”<br></code></pre><br><p>这里是使用字符串字面量创建了一个<em>website</em>字符串变量。</p><br><pre><code>website = String.new “zetcode.com”<br></code></pre><br><p>这是标准创建字符串对象的方法。然而第一和更常用，因为它更简洁，并且在计算机语言中更普遍。</p><br><hr><br><pre><code>#!/usr/bin/ruby<br><br>puts “zetcode”.upcase<br>puts “zetcode”.size<br>puts “zetcode”.reverse<br></code></pre><br><p>这个例子中我们对字符串字面量调用了三个方法。如果是熟悉Java或者C的人可能会困惑。在Ruby中调用方法时字符串字面量会转化为一个字符串对象。</p><br><p>$ ./stringobject2.rb<br><br>ZETCODE<br><br>7<br><br>edoctez  </p><br><p>输出结果。</p><br><h2>字符串方法</h2><br><p>Ruby字符串对象有一些有用的方法。如我们见到过的<em>concat</em>或者<em>eql?</em>。</p><br><pre><code>#!/usr/bin/ruby<br><br>word = “Determination”<br><br>puts “The word #{word} has #{word.size} characters”<br><br>puts word.include? “tion”<br>puts word.include? “tic”<br><br>puts<br><br>puts word.empty?<br>word.clear<br>puts word.empty?<br></code></pre><br><p>创建一个字符串变量，展示了四个字符串的方法。</p><br><pre><code>puts “The word #{word} has #{word.size} characters”<br></code></pre><br><p><em>size</em>方法返回字符串的长度。</p><br><pre><code>puts word.include? “tion”<br></code></pre><br><p><em>include?</em>方法判断一个字符串是否为子串。这里返回的是true。</p><br><pre><code>puts word.empty?<br>word.clear<br></code></pre><br><p><em>empty?</em>方法检查字符串是否为空。返回一个布尔值。<em>clear</em>方法清空字符串。</p><br><p>$ ./basicmethods.rb<br><br>The word Determination has 13 characters<br><br>true<br><br>false  </p><br><p>false<br><br>true  </p><br><p>输出结果。</p><br><hr><br><p>接下来的例子介绍字符串大小写的方法。</p><br><pre><code>#!/usr/bin/ruby<br><br>ruby = “Ruby programming language”<br><br>puts ruby.upcase<br>puts ruby.downcase<br>puts ruby.capitalize<br>puts ruby.swapcase<br></code></pre><br><p>Ruby中有四个与大小写相关的方法。<em>upcase</em>方法将字符串全转为大写并返回一个新对象；<em>downcase</em>方法是将字符串全转为小写并返回一个新对象；<em>capitalize</em>方法是将字符串的首字母大写并返回一个新的对象。最后<em>swapcase</em>方法是将大小写反转并返回一个新对象。</p><br><p>$ ./rubylang.rb<br><br>RUBY PROGRAMMING LANGUAGE<br><br>ruby programming language<br><br>Ruby programming language<br><br>rUBY PROGRAMMING LANGUAGE  </p><br><p>输出结果。</p><br><hr><br><p>接下来展示两个Ruby字符串的方法：<em>start_with?</em> 和<em>end_with?</em>。这两个方法都是返回布尔值。它们判断一个字符串是否分别以另一个字符串开头或结尾。</p><br><pre><code>#!/usr/bin/ruby<br><br>ws1 = “zetcode.com”<br>ws2 = “www.gnome.org”<br><br>puts ws1.start_with? “www.”<br>puts ws2.start_with? “www.”<br><br>puts<br><br>puts ws1.end_with? “.com”<br>puts ws2.end_with? “.com”<br></code></pre><br><p>这是一个上述方法的例子。</p><br><pre><code>puts ws1.start_with? “www.”<br></code></pre><br><p>这里检查一个字符串是否以“www.”开头。如果不是则在终端打印false。</p><br><pre><code>puts ws1.end_with? “.com”<br></code></pre><br><p>检查字符串<em>ws1</em>是否以”.com”结尾。如果是则在终端打印true。</p><br><p>$ ./startend.rb<br><br>false<br><br>true  </p><br><p>true<br><br>false  </p><br><p>输出结果。</p><br><hr><br><p>接下来我们介绍<em>inspect</em>方法。这个方法返回被引号包围原始的字符串，对于特殊字符不处理。对于想要检查字符串由哪些字符组成的比较有用。</p><br><pre><code>#!/usr/bin/ruby<br><br>msg = “Jane\t17\nThomas\t23”<br><br>puts msg<br>puts msg.inspect<br></code></pre><br><p><em>inspect</em>方法的一个例子。</p><br><pre><code>msg = “Jane\t17\nThomas\t23”<br></code></pre><br><p>这个字符串有一些特殊的字符。</p><br><pre><code>puts msg<br>puts msg.inspect<br></code></pre><br><p>第一种情况，字符串中的制表符和换行符被解释了。第二种情况我们得到了一个原始格式的字符串。</p><br><pre><code>$ ./inspectmethod.rb<br>Jane    17<br>Thomas  23<br>“Jane\t17\nThomas\t23”<br></code></pre><br><p>输出结果。</p><br><hr><br><p><em>chomp</em>方法是将字符串尾部的分隔符去掉并返回一个新对象。默认的分隔符是换行符(\n)。</p><br><pre><code>#!/usr/bin/ruby<br><br>print “Are you sure to download? (Yes/No) “<br><br>response = gets<br><br>if (response.downcase == “yes”)<br>    puts “Downloaded”<br>else<br>    puts “Download cancelled”<br>end<br><br>puts response.inspect<br></code></pre><br><p>上面的脚本我们从用户输入一些内容，然后再返回给用户。</p><br><p>$ ./chomp.rb<br><br>Are you sure to download? (Yes/No) Yes<br><br>Download cancelled<br><br>“Yes\n”  </p><br><p>这个脚本没有正确的工作。原因很清晰，由<em>inspect</em>返回了。用户输入的内容以回车键结尾，因此换行符也被包含其中了。”Yes”与”Yes\n”不相等。要使用脚本正确运行，我们使用<em>chomp</em>方法移除掉换行符。</p><br><pre><code>#!/usr/bin/ruby<br><br>print “Are you sure to download? (Yes/No) “<br><br>response = gets<br><br>if (response.downcase.chomp == “yes”)<br>    puts “Downloaded”<br>else<br>    puts “Download cancelled”<br>end<br><br>puts response.inspect<br></code></pre><br><p>这个是正确的脚本。</p><br><pre><code>if (response.downcase.chomp == “yes”)<br></code></pre><br><p>这里我们在比”Yes”比较之前对输入内容进行了处理。</p><br><p>$ ./chomp.rb<br><br>Are you sure to download? (Yes/No) Yes<br><br>Downloaded<br><br>“Yes\n”  </p><br><p>现在脚本正确工作了。</p><br><h2>格式化字符串</h2><br><p>Ruby中有格式化说明符。格式化说明符决定了如何显示一个字符串。它以<em>%</em>字符开始。格式化说明符放在单引号或者双引号内。</p><br><p>格式化说明符有以下字段。</p><br><p>%[flags][field width][precision]conversion specifier</p><br><p>方括号内的字段是可选的。</p><br><p>转换说明符表明数据将如何进行转换。</p><br><pre><code>#!/usr/bin/ruby<br><br>puts “There are %d oranges in the basket.” % 12<br>puts “There are %d oranges and %d apples in the basket.” % [12, 10]<br></code></pre><br><p>这是一个格式化说明符的例子。</p><br><pre><code>puts “There are %d oranges in the basket” % 12<br></code></pre><br><p>当我们在字符串中使用%d，我们在这个位置将期望一个数字。<em>d</em>是十进制数的转换说明符。这个数据在<em>%</em>字符后面给出。</p><br><pre><code>puts “There are %d oranges and %d apples in the basket” % [12, 10]<br></code></pre><br><p>当我们在一个字符串中使用多个格式化说明符时，每个都以<em>%</em>开始。多个值放在[]之间并以逗号分隔。</p><br><p>$ ./formatspecifiers.rb<br><br>There are 12 oranges in the basket.<br><br>There are 12 oranges and 10 apples in the basket.  </p><br><p>输出结果。</p><br><hr><br><p>接下来的例子我们介绍一些基本的转换符。</p><br><pre><code>#!/usr/bin/ruby<br><br>puts “There are %d apples.” % 5<br>puts “I can see %i oranges.” % 3<br>puts “The width of iPhone 3G is %f mm.” % 62.1<br>puts “This animal is called a %s” % “rhinoceros.”<br></code></pre><br><p>我们使用了整数、浮点数和字符串的转换符。</p><br><pre><code>puts “There are %d apples.” % 5<br>puts “I can see %i oranges.” % 3<br></code></pre><br><p><em>d</em>和<em>i</em>都是用于整数。</p><br><pre><code>puts “The width of iPhone 3G is %f mm.” % 62.1<br></code></pre><br><p><em>f</em>用于浮点数。默认浮点数有6个小数。</p><br><pre><code>puts “This animal is called a %s” % “rhinoceros.”<br></code></pre><br><p><em>s</em>用于字符串。</p><br><p>$ ./basicspecifiers.rb<br><br>There are 5 apples.<br><br>I can see 3 oranges.<br><br>The width of iPhone 3G is 62.100000 mm.<br><br>This animal is called a rhinoceros.  </p><br><p>输出结果。</p><br><hr><br><p>接下来是一个实践的例子。</p><br><pre><code>#!/usr/bin/ruby<br><br>website = “zetcode.com”<br><br>website.each_char do |c|<br>    print “#{c} has ASCII code %d\n” % c.ord<br>end<br></code></pre><br><p>这个例子我们记遍历字符串的所有字符并在终端上打印它的ASCII值。</p><br><pre><code>website.each_char do |c|<br>    print “#{c} has ASCII code %d\n” % c.ord<br>end<br></code></pre><br><p><em>each_char</em>方法将<em>website</em>字符串中的每个字符传给代码块，一个字符是一次循环。当前的字符保存在这是<em>c</em>中。我们使用<em>ord</em>方法获取字符的ASCII值。</p><br><p>$ ./character.rb<br><br>z has ASCII code 122<br><br>e has ASCII code 101<br><br>t has ASCII code 116<br><br>c has ASCII code 99<br><br>o has ASCII code 111<br><br>d has ASCII code 100<br><br>e has ASCII code 101<br><br>. has ASCII code 46<br><br>c has ASCII code 99<br><br>o has ASCII code 111<br><br>m has ASCII code 109  </p><br><p>输出结果。 </p><br><hr><br><p>数字有多种显示形式。</p><br><pre><code>#!/usr/bin/ruby<br><br># decimal<br>puts “%d” % 300<br><br># hexadecimal<br>puts “%x” % 300<br><br># octal<br>puts “%o” % 300<br><br># binary<br>puts “%b” % 300<br><br># scientific<br>puts “%e” % (5/3.0)<br></code></pre><br><p>上面的例子中我们打印数字的十进制、十六进制、八进制、二进制和科学记数的形式。</p><br><pre><code># hexadecimal<br>puts “%x” % 300<br></code></pre><br><p><em>x</em>转换符用于将数字转为十六进制格式。</p><br><pre><code># binary<br>puts “%b” % 300<br></code></pre><br><p><em>b</em>转换符用于将数字转为二进制格式。</p><br><p>$ ./various.rb<br><br>300<br><br>12c<br><br>454<br><br>100101100<br><br>1.666667e+00  </p><br><p>输出结果。</p><br><hr><br><p>精度是格式化说明符的一个字段。它指明了后面小数点的位数。它对于整数、小数和字符串有不同的意义。当用于整数时表明了最少打印多少个数字。如果数字个数少于精度则前面用0补全。对于整数精度默认为1,表示前面没有0.当用于浮点数时表示小数点后显示多少个数字。最后，用于字符串时精度表示多少个字符会打印。</p><br><pre><code>#!/usr/bin/ruby<br><br>puts ‘Height: %f %s’ % [172.3, ‘cm’]<br>puts ‘Height: %.1f %s’ % [172.3, ‘cm’]<br><br>puts “%d” % 16<br>puts “%.5d” % 16<br><br>puts “%s” % “zetcode”<br>puts “%.5s” % “zetcode”<br></code></pre><br><p>这个例子中我们使用了精度字段。</p><br><pre><code>puts ‘Height: %f %s’ % [172.3, ‘cm’]<br>puts ‘Height: %.1f %s’ % [172.3, ‘cm’]<br></code></pre><br><p>172.3是一个浮点数。如果没有指定精度则会显示6个小数。这里将会显示5个0.第二行的<em>.1</em>是精度，它将小数个数减为1。的</p><br><pre><code>puts “%d” % 16<br>puts “%.5d” % 16<br></code></pre><br><p>对于整数默认精度为1。第二行中我们指明了精度为.5，这将会在16前面加上3个0。</p><br><pre><code>puts “%s” % “zetcode”<br>puts “%.5s” % “zetcode”<br></code></pre><br><p>第一行会打印所有的字符串。第二行仅打印5个，有两个字符将抛弃。</p><br><p>$ ./precision.rb<br><br>Height: 172.300000 cm<br><br>Height: 172.3 cm<br><br>16<br><br>00016<br><br>zetcode<br><br>zetco  </p><br><p>输出结果。</p><br><hr><br><p>宽度字段表示数据最小要显示的宽度。它是一个数字，并且在小数点之前。如果输出比较短，则会被用空格填充，且右对齐。如果宽度前面有减号则会左对齐。如果输出比宽度长则会完整输出。</p><br><pre><code>#!/usr/bin/ruby<br><br>puts “%d” % 1<br>puts “%d” % 16<br>puts “%d” % 165<br>puts “%d” % 1656<br>puts “%d” % 16567<br><br>puts “%10d” % 1<br>puts “%10d” % 16<br>puts “%10d” % 165<br>puts “%10d” % 1656<br>puts “%10d” % 16567<br></code></pre><br><p>第一种情况打印5个数字没有指明宽度。输出的宽度即为数字的位数。第二种情况指明宽度为10。则每个都最少输出10字符的长度，数字右对齐。</p><br><pre><code>puts “%d” % 1<br>puts “%d” % 16<br></code></pre><br><p>打印两个数字，输出的宽度分别为1、2个字符。</p><br><pre><code>puts “%10d” % 1<br>puts “%10d” % 16<br></code></pre><br><p>这里宽度都为10个字符。这两个数被填充了8、9个空格。</p><br><pre><code>$ ./fieldwidth.rb<br>1<br>16<br>165<br>1656<br>16567<br>         1<br>        16<br>       165<br>      1656<br>     16567<br></code></pre><br><p>我们发现第二种情况数字是右对齐的。</p><br><hr><br><p>标志修饰符修改了模式的行为。</p><br><p><em>#</em>标志分别在二进制、八进制各十六进制前加上0b、0和0x。它会给小数加上小数点，即使这个小数人被精度限制了。</p><br><pre><code>#!/usr/bin/ruby<br><br>puts “%#b” % 231<br>puts “%#x” % 231<br>puts “%#o” % 231<br><br>puts “%.0e” % 231<br>puts “%#.0e” % 231<br><br>puts “%.0f” % 231<br>puts “%#.0f” % 231<br></code></pre><br><p>这个例子我们使用了<em>#</em>标志。</p><br><pre><code>puts “%#b” % 231<br>puts “%#x” % 231<br>puts “%#o” % 231<br></code></pre><br><p>十进制数231分别以二进制、八进制和十六进制打印。<em>#</em>标志会给它们加上前缀。</p><br><pre><code>puts “%.0e” % 231<br>puts “%#.0e” % 231<br></code></pre><br><p>这个<em>.0</em>限制了小数个数。然后使用<em>#</em>标志后小数点会显示，即使没有小数值。</p><br><p>$ ./flags1.rb<br><br>0xe7<br><br>0b11100111<br><br>0347<br><br>2e+02<br><br>2.e+02<br><br>231<br><br>231.  </p><br><p>输出结果。</p><br><hr><br><p><em>+</em>标志会给正数加上正号。对于二进制、十六进制和八进制的负数会加上负号并使用它的绝对值。</p><br><pre><code>#!/usr/bin/ruby<br><br>puts “%d” % 231<br>puts “%+d” % 231<br>puts “%d” % -231<br>puts “%+d” % -231<br><br>puts “%b” % -231<br>puts “%o” % -231<br>puts “%x” % -231<br><br>puts “%+b” % -231<br>puts “%+o” % -231<br>puts “%+x” % -231<br></code></pre><br><p>一个演示<em>+</em>标志符的例子。</p><br><pre><code>puts “%d” % 231<br>puts “%+d” % 231<br></code></pre><br><p>通常正数的符号会被忽略掉。如果想要显示正数的符号可以使用<em>+</em>标志符。</p><br><pre><code>puts “%d” % -231<br>puts “%+d” % -231<br></code></pre><br><p><em>+</em>标志符对负数没有影响，输出结果还是一样的。</p><br><pre><code>puts “%b” % -231<br>puts “%o” % -231<br>puts “%x” % -231<br></code></pre><br><p>二进制、八进制和十六进制的数有它们自己生成负数的方法。</p><br><pre><code>puts “%+b” % -231<br>puts “%+o” % -231<br>puts “%+x” % -231<br></code></pre><br><p>如果我们对负数指定了<em>+</em>标志，我们将数字转为不同的格式并加上负号。没有专门的方式表示负数。</p><br><p>$ ./flags2.rb<br><br>231<br><br>+231<br><br>-231<br><br>-231<br><br>..100011001<br><br>..7431<br><br>..f19<br><br>-11100111<br><br>-347<br><br>-e7  </p><br><p>输出结果。</p><br><hr><br><p>这里介绍<em>0</em>标志和<em>-</em>标志。<em>0</em>标志会用0代替空格来填充数字。<em>-</em>标志会将输出左对齐。</p><br><pre><code>#!/usr/bin/ruby<br><br>puts “%010d” % 1<br>puts “%010d” % 16<br>puts “%010d” % 165<br>puts “%010d” % 1656<br>puts “%010d” % 16567<br><br>puts “%-10d” % 1<br>puts “%-10d” % 16<br>puts “%-10d” % 165<br>puts “%-10d” % 1656<br>puts “%-10d” % 16567<br></code></pre><br><p>以上是一个例子。</p><br><pre><code>puts “%010d” % 1<br>puts “%010d” % 16<br></code></pre><br><p>数字会用0填充。</p><br><pre><code>puts “%-10d” % 1<br>puts “%-10d” % 16<br></code></pre><br><p>数字个数比宽度短，且会左对齐。</p><br><p>$ ./fieldwidth2.rb<br><br>0000000001<br><br>0000000016<br><br>0000000165<br><br>0000001656<br><br>0000016567<br><br>1        <br><br>16        <br><br>165       <br><br>1656     <br><br>16567  </p><br><p>输出结果。</p><br><hr><br><p>标志符用于精度和宽度。当我们使用<em>符号时精度和宽度将作为一个参数。</em></p><br><pre><code>#!/usr/bin/ruby<br><br>puts “%.f” % [3, 1.1111111]<br>puts “%0<em>d” % [10, 2]<br>puts “%0</em>.<em>f” % [10, 3, 1.1111]<br></em></code></pre><br><p>使用了标志的的例子。</p><br><pre><code>puts “%.<em>f” % [3, 1.1111111]<br></em></code></pre><br><p>这里使用<em>作为精度，则第一个数字3是精度的参数。它只为显示</em>1.1111111的3个小数。</p><br><pre><code>puts “%0<em>d” % [10, 2]<br></em></code></pre><br><p>这行的代码我们使用标志作为宽度。我们必须在[]之间加上宽度。第一个数字是宽度，第十个数字是要转换的值。</p><br><pre><code>puts “%0<em>.</em>f” % [10, 3, 1.1111]<br></code></pre><br><p>*标志可以同时用于宽度和精度。这样我们就必须都在[]中指明。</p><br><p>$ ./flags3.rb<br><br>1.111<br><br>0000000002<br><br>000001.111  </p><br><p>输出结果。</p><br><p>这章的教程介绍的Ruby的字符串。</p><br><hr><br><p>原文地址： <a href="http://zetcode.com/lang/rubytutorial/strings/" target="_blank" rel="external">http://zetcode.com/lang/rubytutorial/strings/</a><br><br>翻译：龙昌  admin@longchangjin.cn<br><br>完整教程：<a href="https://github.com/wusuopu/Ruby-tutorial" target="_blank" rel="external">https://github.com/wusuopu/Ruby-tutorial</a>  </p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://www.xefan.com/archives/83921.html" data-id="cjc95ct5l00ian4q31c2vojtu" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Ruby/">Ruby</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/翻译/">翻译</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-/archives/83913.html" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/archives/83913.html" class="article-date">
  <time datetime="2013-11-07T00:00:00.000Z" itemprop="datePublished">2013-11-07</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Ruby栏目/">Ruby栏目</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/archives/83913.html">[翻译]Ruby教程6——数据类型</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p></p><h1>数据类型</h1><p></p>
<p>在这一章的教程中我们开始讨论数据类型。</p><br><p>所有类别的计算机程序，包括电子表格、文本编辑器、计算器和聊天软件都使用数据。现代计算机语言中各种数据类型是必不可少的。一种数据类型是一些可操作的值的集合。</p><br><p>Ruby中有一些数据类型，这些类型都是基于类的。以下是Ruby中公认的数据类型：  </p><br><ul><br><li>布尔(Booleans)  </li><br><li>符号(Symbols)  </li><br><li>数字(Numbers)  </li><br><li>字符串(Strings)</li><br><li>数组(Arrays)  </li><br><li>哈希(Hashes)</li><br></ul><br><p>下面的例子中我们展示Ruby中所有重要的数据类型。</p><br><pre><code>#!/usr/bin/ruby<br><br>h = { :name =&gt; “Jane”, :age =&gt; 17 }<br><br>p true.class, false.class<br>p “Ruby”.class<br>p 1.class<br>p 4.5.class<br>p 3_463_456_457.class<br>p :age.class<br>p [1, 2, 3].class<br>p h.class<br></code></pre><br><p>我们将它们的类型名打印出来，类型是用于创建对象的模块。  </p><br><pre><code>p true.class, false.class<br></code></pre><br><p><em>true</em>和<em>false</em>对象展示的布尔类型。</p><br><pre><code>p “Ruby”.class<br></code></pre><br><p>这个是字符串。</p><br><pre><code>p 1.class<br>p 4.5.class<br>p 3_463_456_457.class<br></code></pre><br><p>这些是数字。</p><br><pre><code>p :age.class<br></code></pre><br><p>这个是符号标志，Ruby的一种特殊数据类型。</p><br><pre><code>p [1, 2, 3].class<br>p h.class<br></code></pre><br><p>这是两个容器，数组和哈希表。</p><br><p>$ ./types.rb<br><br>TrueClass<br><br>FalseClass<br><br>String<br><br>Fixnum<br><br>Float<br><br>Bignum<br><br>Symbol<br><br>Array<br><br>Hash  </p><br><p>这个程序列出了属于Ruby的类型。</p><br><h2>布尔值</h2><br><p>在我们的世界里存在着对偶关系。天与地、水与火、男与女、爱与恨。这些就是我们自然中的“布尔”。在Ruby里，布尔类型只有一种，具有两个值：<em>true</em>(真)与<em>false</em>(假)。布尔是一种基本的数据类型，它在计算机程序中非常普遍。</p><br><p>高兴的父母等待着孩子的诞生。他们可能会给孩子取个名字。如果是男孩就叫John，如果是女孩就叫Victoria。</p><br><pre><code>#!/usr/bin/ruby<br><br># kid.rb<br><br>bool = [true, false]<br><br>male = bool[rand(2)]<br><br><br>if male<br>    puts “We will use name John”<br>else<br>    puts “We will use name Victoria”<br>end<br></code></pre><br><p>在这个程序中我们使用随机数来模拟这种情况。</p><br><pre><code>bool = [true, false]<br></code></pre><br><p>我们创建一个名为<em>bool</em>的变量，它是一个数组包含了两个布尔值。这个数组是使用方括号创建的。</p><br><pre><code>male = bool[rand(2)]<br></code></pre><br><p>我们使用<em>rand()</em>方法生成一个随机数。这个方法返回0或1。返回的数用于数组的索引。</p><br><pre><code>if male<br>    puts “We will use name John”<br>else<br>    puts “We will use name Victoria”<br>end<br></code></pre><br><p>根据<em>male</em>变量我们打印一条信息。如果<em>male</em>是<em>true</em>则名字选择John，否则选择Vactoria。类似<em>is/else</em>的结构控制语句是根据布尔值来选择的。</p><br><p>$ ./kid.rb <br><br>We will use name Victoria <br><br>$ ./kid.rb <br><br>We will use name Victoria<br><br>$ ./kid.rb <br><br>We will use name John<br><br>$ ./kid.rb <br><br>We will use name John<br><br>$ ./kid.rb <br><br>We will use name John  </p><br><p>程序运行多次的结果如上。</p><br><h2>符号标志</h2><br><p>符号标志代表其他对象。使用符号标志而不是字符串，是因为可能保存一些资源。一个符号标志是<em>Symbol</em>类的一个实例对象。符号标志通常是在标识符的前面加上冒号，比如 :name。一些对象具有<em>to_sym</em>方法，用于将这些对象转化为符号标志。</p><br><p>Ruby的符号标志在程序运行时是不可改变的。它通常用于当作哈希表的键，因为一个键不需要完整的字符串功能。</p><br><pre><code>#!/usr/bin/ruby<br><br>p :name<br>p :name.class<br>p :name.methods.size<br>p “Jane”.methods.size<br><br>p :name.object_id<br>p :name.object_id<br>p “name”.object_id<br>p “name”.object_id<br></code></pre><br><p>第一个例子展示了符号标志的基本操作。</p><br><pre><code>p :name<br>p :name.class<br></code></pre><br><p>在终端上打印一个符号标志和它的类型。符号标志的类型是<em>Symbol</em>。</p><br><pre><code>p :name.methods.size<br>p “Jane”.methods.size<br></code></pre><br><p>比较字符串实例与符号标志实例分配的方法数量。字符串的方法数是符号标志的两位多。</p><br><pre><code>p :name.object_id<br>p :name.object_id<br>p “name”.object_id<br>p “name”.object_id<br></code></pre><br><p>相同的符号标志具有相同的id，相同的字符串的id却不同。</p><br><p>$ ./symbols.rb<br><br>:name<br><br>Symbol<br><br>79<br><br>162<br><br>10328<br><br>10328<br><br>77344750<br><br>77344730  </p><br><p>程序输出结果。</p><br><hr><br><p>符号标志也可以作为常量标志，类似于C/C++中的枚举类型。</p><br><pre><code>#!/usr/bin/ruby<br><br>light = :on<br><br>if light == :on<br>    puts “The light is on”<br>else<br>    puts “The light is off”<br>end<br><br>light = :off<br><br>if light == :on<br>    puts “The light is on”<br>else<br>    puts “The light is off”<br>end<br></code></pre><br><p>电灯不是开就是关。对于这两种情况定义了符号标志。</p><br><pre><code>light = :on<br></code></pre><br><p>灯是开的。</p><br><pre><code>if light == :on<br>    puts “The light is on”<br>else<br>    puts “The light is off”<br>end<br></code></pre><br><p>程序的逻辑依赖于<em>light</em>变量的状态。</p><br><hr><br><p>符号标志通常在哗然容器中作为键。这比字符串更加有效。</p><br><pre><code>#!/usr/bin/ruby<br><br>domains = {:sk =&gt; “Slovakia”, :no =&gt; “Norway”, :hu =&gt; “Hungary”}<br><br>puts domains[:sk]<br>puts domains[:no]<br>puts domains[:hu]<br></code></pre><br><p>在这个脚本中创建了一个名为<em>domains</em>的哈希表。它的键全是符号标志。</p><br><pre><code>puts domains[:sk]<br>puts domains[:no]<br>puts domains[:hu]<br></code></pre><br><p>在哈希表中键是用于访问值的。接下来我们打印出这个哈希表的值。</p><br><p>$ ./symbols3.rb<br><br>Slovakia<br><br>Norway<br><br>Hungary  </p><br><p>以上是例子的输出结果。</p><br><hr><br><p>Ruby解释器将内部引用存储为符号标志。</p><br><pre><code>#!/usr/bin/ruby<br><br>class Being<br><br>    def initialize<br>        @is = true<br>    end<br><br>    def say<br>        “I am being”<br>    end<br>end<br><br>b = Being.new<br><br>p b.method :say<br>p b.instance_variable_get :@is<br></code></pre><br><p>定义了一个<em>Being</em>类。该类有一个自定义实例变量<em>@is</em>和一个方法<em>say</em>。这两个实体在Ruby中保存为符号标志。</p><br><pre><code>p b.method :say<br></code></pre><br><p><em>method</em>方法用于在<em>b</em>对象在查找给定名字的方法。我们查找的是<em>:say</em>符号。</p><br><pre><code>p b.instance_variable_get :@is<br></code></pre><br><p>使用<em>instance_variable_get</em>检查<em>@is</em>是不是<em>b</em>对象的一个实例变量。在内部变量存储为<em>:@is</em>符号。</p><br><p>$ ./symbols4.rb   </p><br><h1><method: being#say=""></method:></h1><br><p>true  </p><br><p>输出结果。</p><br><hr><br><p>所有的符号都存储在符号表中。下一个例子我们来看看这个表。<em>Symbol</em>类的<em>all_symbols</em>方法返回了一个数组包含这个表的全部符号。</p><br><pre><code>#!/usr/bin/ruby<br><br>def info<br>  “info method”<br>end<br><br>@v = “Ruby”<br>@@n = “16”<br><br>p Symbol.all_symbols.include? :info<br>p Symbol.all_symbols.include? :@v<br>p Symbol.all_symbols.include? :@@n<br></code></pre><br><p>在这个Ruby脚本中创建了一个方法、一个实例变量和一个类变量。我们检查这些实体是否存储在符号表中。</p><br><pre><code>p Symbol.all_symbols.include? :info<br></code></pre><br><p>检查<em>:info</em>符号是否在符号表中。这行返回的是<em>true</em>。</p><br><p>$ ./symbols5.rb<br><br>true<br><br>true<br><br>true  </p><br><p>三个符号都在符号表中。</p><br><h2>整数</h2><br><p>整数是实数的一个子集。它没有分数或者小数。整数属于集合Z = {…, -2, -1, 0, 1, 2, …} 。这个集合是无限的。</p><br><p>在计算机语言中，整数是原始的数据类型。实际中计算机仅支持整数的一个子集，因为计算机的能力有限。整数用于统计离散的实体。我们有3、4、6个人，但是不能有3.33个人。我们有3.33千克。</p><br><p>在Ruby中整数是<em>Fixnum</em>或者<em>Bignum</em>类的实例对象。不同于其他语言，如Java或者C，在Ruby中整数是一个对象。这两种类型的大小不同。<em>Fixnum</em>类型的整数有一些限制，这些限制与机器有关。<em>Bignum</em>的值表示范围比<em>Fixnum</em>大。如果一些操作超出了<em>Fixnum</em>的范围，它会自动的转换成<em>Bignum</em>。程序员通常不需要关心整数的类型。</p><br><pre><code>#!/usr/bin/ruby<br><br>p -2<br>p 121<br>p 123265<br>p -34253464356<br>p 34867367893463476<br><br>p 1.class<br>p 23453246.class<br>p 234532423563456346.class<br>p 2345324235632363463456456346.class<br><br>p 5 / 2<br>p 5.div 2<br></code></pre><br><p>这个例子中我们处理的一些整数。</p><br><pre><code>p -2<br>p 121<br>p 123265<br>p -34253464356<br>p 34867367893463476<br></code></pre><br><p>这是一些不同大小的正数和负数。</p><br><pre><code>p 1.class<br>p 23453246.class<br>p 234532423563456346.class<br>p 2345324235632363463456456346.class<br></code></pre><br><p>打印出这些数的类型。前两个整数是<em>Fixnum</em>类型，其余两个是<em>Bignum</em>类型。</p><br><pre><code>p 5 / 2<br>p 5.div 2<br></code></pre><br><p>这两行展示的整数的相除。当两个数相除时我们使用了相除操作符/方法,结果也是一个整数。</p><br><p>$ ./integers.rb<br><br>-2<br><br>121<br><br>123265<br><br>-34253464356<br><br>34867367893463476<br><br>Fixnum<br><br>Fixnum<br><br>Bignum<br><br>Bignum<br><br>2<br><br>2  </p><br><p>例子的输出结果。</p><br><hr><br><p>在Ruby中整数可以有不同的表现符号。十进制、十六进制、八进制和二进制数都是可用的。十六进制数以0x字符开头，八进制以0字符开头，二进制以0b字符开头。</p><br><pre><code>#!/usr/bin/ruby<br><br>puts 122<br>puts 0x7a<br>puts 0172<br>puts 0b1111010<br></code></pre><br><p>这个例子中我们打印了十进制数<em>122</em>的所有表现形式。</p><br><p>$ ./inotations.rb<br><br>122<br><br>122<br><br>122<br><br>122  </p><br><p>以上是输出结果。</p><br><hr><br><p>我们使用整数的话，那么就是用于处理离散的实体。也许我们用于统计苹果的数量。</p><br><pre><code>#!/usr/bin/ruby<br><br>baskets = 16<br>apples_in_basket = 24<br><br>total = baskets <em> apples_in_basket<br><br>puts “There are total of #{total} apples”<br></em></code></pre><br><p>在这个程序中我们使用整数统计苹果的总数。</p><br><p>$ ./apples.rb<br><br>There are total of 384 apples  </p><br><p>以上是程序的输出。</p><br><hr><br><p>大数字读起来比较困难。如果我们有一个数245342395423452，我们发现很难快速的将它读出来。计算机之外大的数字是用空格或者逗号分隔开来。为了可读性，Ruby允许数字包含下划线。Ruby解释器会忽略整数中的下划线。</p><br><pre><code>#!/usr/bin/ruby<br><br>p 23482345629<br>p 23_482_345_629<br><br>p 23482345629 == 23_482_345_629<br></code></pre><br><p>这个例子演示了下划线的使用。</p><br><pre><code>p 23482345629 == 23_482_345_629<br></code></pre><br><p>这行展示了两个数据是相等的。</p><br><p>$ ./underscore.rb<br><br>23482345629<br><br>23482345629<br><br>true  </p><br><p>例子的输出结果。</p><br><h2>浮点数</h2><br><p>在计算中浮点数表示实数。实例意味着连续的数量，如：重量、高度和速度。Ruby中小数是<em>Float</em>或者<em>BigDecimal</em>类对象。<em>BigDecimal</em>类是Ruby的核心类，是Ruby标准库的一部分。此外我们还可以使用<em>Rational</em>对象。</p><br><p>我们需要理解数字是不业精确的。Ruby的官方文档清楚地说道浮点数对象表示的是不精确的实数。</p><br><pre><code>#!/usr/bin/ruby<br><br>p 15.4<br>p 0.3455<br>p -343.4563<br><br>p 12.5.class<br>p -12.5.class<br>p (5.0 / 2).class<br><br>p 5.fdiv 2<br>p 12.to_f<br></code></pre><br><p>上面的这个例子我们使用了浮点数。</p><br><pre><code>p 15.4<br>p 0.3455<br>p -343.4563<br></code></pre><br><p>这里我们打印三个小数的值。小数包含了小数点字符。</p><br><pre><code>p 12.5.class<br>p -12.5.class<br>p (5.0 / 2).class<br></code></pre><br><p>以上展示的数字的类型，全都是浮点数。最后一个整数与浮点数相除结果为浮点数。</p><br><pre><code>p 5.fdiv 2<br>p 12.to_f<br></code></pre><br><p>这里我们创建浮点数除法<em>fdiv</em>和转换方法<em>to_f</em>来创建浮点数。</p><br><p>$ ./decimals.rb<br><br>15.4<br><br>0.3455<br><br>-343.4563<br><br>Float<br><br>Float<br><br>Float<br><br>2.5<br><br>12.0  </p><br><p>以上为转出结果。</p><br><hr><br><p>一个小数默认最多只显示小数点后16个数字。我们可以使用<em>sprintf</em>或者<em>printf</em>方法来控制浮点数的格式。</p><br><pre><code>#!/usr/bin/ruby<br><br>p 1/3.0<br>p 1.fdiv 2<br><br>puts sprintf “%.4f” % (1/3.0)<br>puts sprintf “%.7f” % (5/3.0)<br></code></pre><br><p>格式化小数。</p><br><pre><code>p 1/3.0<br>p 13.fdiv 4<br>p 1.fdiv 2<br></code></pre><br><p>第一行打印的小数在小数点后有16个数字。第二行打印的有两个。第三行打印的有一个。</p><br><pre><code>puts sprintf “%.4f” % (1/3.0)<br>puts sprintf “%.7f” % (5/3.0)<br></code></pre><br><p>这里我们使用<em>sprintf</em>方法控制小数点后面的数字个数。<em>sprintf</em>方法的格式说明符是精确的。它是一个数字接着<em>%</em>符号。<em>f</em>是一个转换说明符，表示处理的是一个浮点数。</p><br><p>$ ./formatfloat.rb<br><br>0.3333333333333333<br><br>3.25<br><br>0.5<br><br>0.3333<br><br>1.6666667  </p><br><p>以上是输出结果。</p><br><hr><br><p>Ruby支持使用科学的记数法来表示一个浮点数。这也称为指数记数法，它是将非常大或者非常小的数转换成正常的小数形式。</p><br><pre><code>#!/usr/bin/ruby<br><br>p 1.2e-3<br>p 0.0012<br><br>p 1.5E-4<br>p 0.00015<br></code></pre><br><p>这个例子展示了两个使用科学记数表示的小数。</p><br><p>$ ./scientific.rb<br><br>0.0012<br><br>0.0012<br><br>0.00015<br><br>0.00015  </p><br><p>这是以上程序的输出。</p><br><hr><br><p>前面我们主说过浮点数的值稍微有些不精确。在很多计算中，普通的浮点小数已经足够精确了，如：我们的体重是60kg还是60.000024kg并不重要。对于其他计算，包括科学和工程应用，精确度是非常重要的。</p><br><p>Ruby有一个<em>BigDecimal</em>标准库。这个类对于非常大或者非常精准的浮点数提供了任意的精度。</p><br><pre><code>#!/usr/bin/ruby<br><br>require ‘bigdecimal’<br><br>sum = 0<br><br>1000.times do<br>    sum = sum + 0.0001<br>end<br><br>p sum<br><br><br>sum = BigDecimal.new(“0”)<br><br>1000.times do<br>    sum = sum + BigDecimal.new(“0.0001”)<br>end<br><br>puts sum.to_s(‘F’)<br>puts sum.to_s(‘E’)<br></code></pre><br><p>在这个例子中我们比较了<em>Float</em>与<em>BigDecimal</em>的精度。 </p><br><pre><code>require ‘bigdecimal’<br></code></pre><br><p><em>BigDecimal</em>类必须导入。</p><br><pre><code>sum = 0<br><br>1000.times do<br>    sum = sum + 0.0001<br>end<br><br>p sum<br></code></pre><br><p>通过循环对一个很小的浮点数求和。最后会出现一点误差。</p><br><pre><code>sum = BigDecimal.new(“0”)<br><br>1000.times do<br>    sum = sum + BigDecimal.new(“0.0001”)<br>end<br></code></pre><br><p>然后再对<em>BigDecimal</em>做同样的事情。</p><br><pre><code>puts sum.to_s(‘F’)<br>puts sum.to_s(‘E’)<br></code></pre><br><p>将<em>sum</em>浮点数打印为工程记数形式。</p><br><p>$ ./bigdecimal.rb<br><br>0.10000000000000184<br><br>0.1<br><br>0.1E0  </p><br><p>输出结果表示<em>BigDecimal</em>比<em>Float</em>更精确。</p><br><hr><br><p>如果一个短路运动员100m跑9.87s，那么他的时速是多少？</p><br><pre><code>#!/usr/bin/ruby<br><br>distance = 0.1<br>time = 9.87 / 3600<br><br>speed = distance / time<br><br>puts “The average speed of a sprinter is #{speed} km/h”<br></code></pre><br><p>这个例子必需使用浮点数。</p><br><pre><code>distance = 0.1<br></code></pre><br><p>100m等于0.1km。</p><br><pre><code>time = 9.87 / 3600<br></code></pre><br><p>9.87s等于9.87/6060 h。</p><br><pre><code>speed = distance / time<br></code></pre><br><p>要计算速度，我们用距离除以时间。</p><br><p>$ ./speed.rb<br><br>The average speed of a sprinter is 36.4741641337386 km/h  </p><br><p>以上是<em>speed.rb</em>脚本的输出。</p><br><h2>有理数</h2><br><p>Ruby支持有理数。有理数是一个确切的数。使用有理数可以避免舍入错误。Ruby中有理数是<em>Rational</em>类的对象。我们可以使用某些对象的<em>to_r</em>方法来创建有理数。</p><br><p>有理数可以用于表示两个整数相除的分数，a/b（b!=0）。如果b为1,每个整数都是一个有理数。</p><br><pre><code>#!/usr/bin/ruby<br><br>puts 2.to_r<br>puts “23”.to_r<br>puts 2.6.to_r<br><br>p Rational 0<br>p Rational 1/5.0<br>p Rational 0.5<br></code></pre><br><p>这个例子展示了一些有理数。</p><br><pre><code>puts 2.to_r<br></code></pre><br><p>变量我们使用<em>to_r</em>方法将整数2转化为有理数2/1。</p><br><pre><code>p Rational 0.5<br></code></pre><br><p>使用<em>Rational</em>方法创建一个有理数》</p><br><p>$ ./rational.rb<br><br>2/1<br><br>23/1<br><br>5854679515581645/2251799813685248<br><br>(0/1)<br><br>(3602879701896397/18014398509481984)<br><br>(1/2)  </p><br><p>例子的输出结果。</p><br><h2>空值</h2><br><p>Ruby有一个特殊的值<em>nil</em>。它表示空值。<em>nil</em>是<em>NilClass</em>类的单实例，仅有一个<em>nil</em>。</p><br><pre><code>#!/usr/bin/ruby<br><br>puts nil<br>p nil<br><br>p $val<br><br>p [1, 2, 3][4]<br><br>p $val1 == $val2<br></code></pre><br><p><em>nil</em>的一个例子。</p><br><pre><code>puts nil<br>p nil<br></code></pre><br><p>在终端上打印<em>nil</em>的值。<em>puts</em>方法打印空字符串，<em>p</em>方法打印<em>‘nil’</em>字符串。</p><br><pre><code>p $val<br></code></pre><br><p>当我们引用一个没有定义的全局变量时会返回<em>nil</em>值。</p><br><pre><code>p [1, 2, 3][3]<br></code></pre><br><p>这行代码我们引用了一个3元素数组的第4个元素，结果返回<em>nil</em>。Ruby中的许多方法对于无效的值都返回<em>nil</em>。</p><br><pre><code>p $val1 == $val2<br></code></pre><br><p>这行返回<em>true</em>，这实际上是因为<em>nil</em>是<em>NilClass</em>的单实例对象。</p><br><p>$ ./nilvalue.rb  </p><br><p>nil<br><br>nil<br><br>nil<br><br>true  </p><br><p>输出结果。</p><br><h2>字符串</h2><br><p>字符串在计算机程序代表文本数据。Ruby字符串是一个序列化的unicode字符。字符串是<em>String</em>的一个对象。字符串的字面量是字符加上双引号或者单引号。</p><br><p>字符串是一个非常重要的数据类型。它需要专门用一章来介绍。这里我们仅包含一个小例子。</p><br><pre><code>#!/usr/bin/ruby<br><br>p “Ruby”<br>p ‘Python’<br><br>p “Ruby”.size<br>p “Ruby”.upcase<br><br>p 23.to_s<br></code></pre><br><p>这个例子中我们使用了Ruby的字符串。我们使用<em>p</em>方法是为了在输出中看到数据类型。</p><br><pre><code>p “Ruby”<br>p ‘Python’<br></code></pre><br><p>在终端中打印两个字符串的字面值。第一个字面量是使用双引号，第二个是单引号。</p><br><pre><code>p “Ruby”.size<br>p “Ruby”.upcase<br></code></pre><br><p>这两行调用了两个字符串的方法。<em>size</em>方法返回字符串的长度，在这里是4个字符。<em>upcase</em>方法是将字符串转为大写。</p><br><pre><code>p 23.to_s<br></code></pre><br><p><em>to_s</em>方法是将整数转为字符串。</p><br><p>$ ./strings.rb<br><br>“Ruby”<br><br>“Python”<br><br>4<br><br>“RUBY”<br><br>“23”  </p><br><p>在输出中我们看到字符串是在引号内。这就是我们使用<em>p</em>方法的结果，<em>print</em>和<em>puts</em>方法都不会带上引号。</p><br><h2>数组和哈希表</h2><br><p>数组和哈希表是对象的集合。他们将对象集合在一起。</p><br><p>数组是对象的有序集合。哈希表是键-值对的集合。我们将会用单独的一章来介绍数组和哈希表。以下仅是一个预览的例子。</p><br><pre><code>#!/usr/bin/ruby<br><br>nums = [1, 2, 3, 4]<br><br>puts “There are #{nums.size} items in the array”<br><br>nums.each do |num|<br>    puts num<br>end<br><br><br>domains = { :de =&gt; “Germany”, :sk =&gt; “Slovakia”,<br>            :us =&gt; “United States”, :no =&gt; “Norway” }<br><br>puts domains.keys<br>puts domains.values<br></code></pre><br><p>这是一个Ruby数组和哈希表的例子。</p><br><pre><code>nums = [1, 2, 3, 4]<br><br>puts “There are #{nums.size} items in the array”<br><br>nums.each do |num|<br>    puts num<br>end<br></code></pre><br><p>这里创建一个有4项内容的数组。第二行统计了这个数组数据项的数量，并合并到了消息中。随后我们使用<em>each</em>方法将每个元素打印在终端上。</p><br><pre><code>domains = { :de =&gt; “Germany”, :sk =&gt; “Slovakia”,<br>            :us =&gt; “United States”, :no =&gt; “Norway” }<br><br>puts domains.keys<br>puts domains.values<br></code></pre><br><p>创建了Ruby的哈希表，然后打印它的键和值。</p><br><p>$ ./arrayshashes.rb<br><br>There are 4 items in the array<br><br>1<br><br>2<br><br>3<br><br>4<br><br>de<br><br>sk<br><br>us<br><br>no<br><br>Germany<br><br>Slovakia<br><br>United States<br><br>Norway  </p><br><p>例子的输出结果。</p><br><h2>类型转换</h2><br><p>我们经常是一次使用多种数据类型。在编程中从一种数据类型转换为其他类型是很平常的。类型转换或者类型的引用会将一个实体从一个类型转换成另一个类型。有两种类型转换的方式：隐式和显式。隐式类型转换又称为强制转换，是被编译器自动的转换。Ruby只有显式转换。</p><br><p>Ruby有内建的转换方法。如：<em>to_i</em>、<em>to_s</em>或者<em>to_f</em>。内核模块有一些公共的方法用来转换，如<em>Interger</em>、<em>String</em>或者<em>Float</em>。这些方法还要与Ruby的类混淆。</p><br><p>#!/usr/bin/ruby</p><br><pre><code>p Array(1..6)<br>p Complex 6<br>p Float 12<br>p Integer “34”<br>p Rational 6<br>p String 22<br></code></pre><br><p>这里我们展示了内核模块的转换方法。</p><br><p>$ ./convertmethods.rb<br><br>[1, 2, 3, 4, 5, 6]<br><br>(6+0i)<br><br>12.0<br><br>34<br><br>(6/1)<br><br>“22”  </p><br><p>例子的输出结果。</p><br><hr><br><pre><code>#!/usr/bin/ruby<br><br>p “12”.to_i<br>p 12.5.to_i<br>p nil.to_i<br><br>p 12.to_f<br>p “11”.to_f<br>p nil.to_f<br></code></pre><br><p>以上例子我们展示了数字的转换。一些对象具有<em>to_i</em>和<em>to_f</em>方法将对象转换成整数和浮点数。</p><br><pre><code>p “12”.to_i<br>p 12.5.to_i<br>p nil.to_i<br></code></pre><br><p>这里我们将字符串、小数和nil转换成整数。</p><br><pre><code>p 12.to_f<br>p “11”.to_f<br>p nil.to_f<br></code></pre><br><p>这三行将整数、字符串和nil转换成小数。</p><br><p>$ ./conversions.rb<br><br>12<br><br>12<br><br>0<br><br>12.0<br><br>11.0<br><br>0.0  </p><br><p>例子的输出结果。</p><br><hr><br><p>第二个例子展示了一些字符串的转换。</p><br><pre><code>#!/usr/bin/ruby<br><br>p “12”.to_i<br>p “13”.to_f<br>p “12”.to_r<br>p “13”.to_c<br><br>p “Jane”.to_sym<br><br>v = “Ruby Python Tcl PHP Perl”.split<br>p v.class<br></code></pre><br><p>上面的例子中我们将字符串转换为不同类型的对象。</p><br><pre><code>p “12”.to_i<br>p “13”.to_f<br>p “12”.to_r<br>p “13”.to_c<br></code></pre><br><p>这里将字符串转换成整数、小数、有理数和复数。</p><br><pre><code>p “Jane”.to_sym<br></code></pre><br><p>将字符串变为符号标志。</p><br><pre><code>v = “Ruby Python Tcl PHP Perl”.split<br>p v.class<br></code></pre><br><p>使用字符串的<em>split</em>方法将字符串转换成数组。</p><br><p>$ ./stringconv.rb<br><br>12<br><br>13.0<br><br>(12/1)<br><br>(13+0i)<br><br>:Jane<br><br>Array  </p><br><p>输出结果。</p><br><hr><br><p>下面的小例子展示了数组哈希表的转换。</p><br><pre><code>#!/usr/bin/ruby<br><br>h = {:de =&gt; “Germany”, :sk =&gt; “Slovakia”}<br>p h.to_a<br><br>a = [:de, “Germany”, :sk, “Slovakia”,<br>     :hu, “Hungary”, :no, “Norway”]<br>p Hash[<em>a]<br></em></code></pre><br><p>这个例子的代码我们创建了一个哈希表并转换成数组，创建一个数组并转换成哈希表。</p><br><pre><code>h = {:de =&gt; “Germany”, :sk =&gt; “Slovakia”}<br>p h.to_a<br></code></pre><br><p>哈希表转换为数组使用<em>to_a</em>方法。</p><br><pre><code>a = [:de, “Germany”, :sk, “Slovakia”,<br>     :hu, “Hungary”, :no, “Norway”]<br>p Hash[a]<br></code></pre><br><p>将数组转换成哈希表。在这里的上下文中使用了星号操作符。这个风格来自<em>Perl</em>。它将一个数组分割成多个变量。</p><br><p>$ ./h2a.rb<br><br>[[:de, “Germany”], [:sk, “Slovakia”]]<br><br>{:de=&gt;”Germany”, :sk=&gt;”Slovakia”, :hu=&gt;”Hungary”, :no=&gt;”Norway”}  </p><br><p>输出结果。</p><br><p>这章在教程覆盖了数据类型和它们的转换。</p><br><hr><br><p>原文地址： <a href="http://zetcode.com/lang/rubytutorial/datatypes/" target="_blank" rel="external">http://zetcode.com/lang/rubytutorial/datatypes/</a><br><br>翻译：龙昌  admin@longchangjin.cn<br><br>完整教程：<a href="https://github.com/wusuopu/Ruby-tutorial" target="_blank" rel="external">https://github.com/wusuopu/Ruby-tutorial</a>  </p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://www.xefan.com/archives/83913.html" data-id="cjc95ct5k00i8n4q37awe3x1p" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Ruby/">Ruby</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/翻译/">翻译</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-/archives/83909.html" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/archives/83909.html" class="article-date">
  <time datetime="2013-11-06T00:00:00.000Z" itemprop="datePublished">2013-11-06</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Ruby栏目/">Ruby栏目</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/archives/83909.html">[翻译]Ruby教程5——对象</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p></p><h1>Ruby中的对象</h1><p></p>
<p>在这章的教程中我们将简要的介绍下Ruby语言对象的概念。更多的内容将会在面向对象的章节中学习。由于Ruby的许多特性可以会使新手们迷惑，尤其是已经学习过其他编程语言的，因此才编写了这个关于对象的预备章节。</p><br><p>Ruby是一门面向对象的编程语言。这意味着我们可以在Ruby语言中使用对象。对于语言程序员来说Ruby程序就是一些字符流。这些符号就是Ruby的关键字、操作符、变量符号和字面量。从语言的角度来看Ruby程序是由对象组成的。这些对象在Ruby脚本程序执行进程来创建和修改。</p><br><p>有两种类型的对象：内置对象和自定义对象。内置对象是所有程序员都可以使用的预定义对象。它们由Ruby语言的内核或者变量库提示。自定义对象是由应用程序开发者在他们的应用程序域中创建的。</p><br><p>所有的对象都必须在使用之前创建。我们把创建对象叫做对象实例化。对象是由数据和方法组成，数据是对象静态的部分，方法是动态的形式。对象的修改以及与其他对象通信都是通过方法进行的。</p><br><pre><code>#!/usr/bin/ruby<br>puts “Ruby language”<br></code></pre><br><p>以上是一个简单的Ruby脚本。如果我们熟悉Pascal或者C之类的程序语言，我们可以看到一个名为<em>puts</em>的关键字或者是一个函数和一个字符串参数<em>“Ruby language”</em>。</p><br><p>看起来有点不同，Ruby是一门纯面向对象语言。<em>“Ruby language”</em>确实是一个字符串，常见的一种数据类型。但是它也是一个对象。与所有的对象一样，我们可以调用它们的方法。这与其他的语言有点不同。<em>puts</em>是一个方法。方法是定义在一个对象中的函数。方法是不能独自存在的。实际上<em>puts</em>方法是<em>Kernel</em>模块的一部分。</p><br><pre><code>#!/usr/bin/ruby<br>Kernel.puts “Ruby language”<br>Kernel.puts “Ruby language”.size<br></code></pre><br><p>在以上的脚本中我们写了两行代码。</p><br><pre><code>Kernel.puts “Ruby language”<br></code></pre><br><p><em>Kernel</em>是可以省略的，在第一个例子中我们调用<em>puts</em>方法就没有使用<em>Kernel</em>。这样可以少打些字节约时间。实际上它是对于<em>Kernel.puts</em>这个正式调用的简写。正如在C#中的Console.writeln和Java中的System.println。因此方法必须与一个对象相关联，或者如果是类方法就必须与类相关联。</p><br><pre><code>Kernel.puts “Ruby language”.size<br></code></pre><br><p>在这行代码中我们在终端上打印了<em>“Ruby language”</em>这个字符串的长度。对于有其他编程语言经验的程序员来说可能会困惑。在其他语言中字符串是一个原始数据类型，不能修改，并且没有自己的方法。在Ruby中字符串是一个完整的对象，有自己的方法。<em>size</em>方法其中一个，用于返回这个字符串的长度。</p><br><p>$ ./simple2.rb<br><br>Ruby language<br><br>13  </p><br><p>以上是这个例子的输出。</p><br><hr><br><p>接下来的例子我们看看整数。与字符串相似一个数字也是一个对象。</p><br><pre><code>#!/usr/bin/ruby<br>puts 6.object_id<br>puts 6.even?<br>puts 6.zero?<br>puts 6.class<br></code></pre><br><p>这个例子中我们定义了一个数字<em>6</em>。然后调用了一些这个数字的方法。</p><br><pre><code>puts 6.object_id<br></code></pre><br><p>这里<em>6</em>是一个对象，<em>object_id</em>是一个方法。这个方法返回了与这个对象相关联的id号。每个对象都拥有一个id号。如果我们要在对象上调用一个方法，就必须在他们之间加点号。</p><br><pre><code>puts 6.even?<br>puts 6.zero?<br></code></pre><br><p>这里我们对<em>6</em>这个对象调用了两个方法。如果一个数是偶数，那么<em>even?</em>返回<em>true</em>；如果一个数等于0,那么<em>zero?</em>返回<em>true</em>。注意这两个方法都是以问号能结尾的。在Ruby中约定了如果一个方法返回值是布尔类型，那么方法名以问号结尾。</p><br><pre><code>puts 6.class<br></code></pre><br><p><em>class</em>方法告诉我们当前正在处理的这个对象是什么类型的。在这里<em>6</em>是一个<em>Fixnum</em>类型。</p><br><p>$ ./objectnumber.rb<br><br>13<br><br>true<br><br>false<br><br>Fixnum  </p><br><p>以上是这个例子的输出结果。</p><br><h2>创建对象</h2><br><p>我们之前提到了在Ruby是对象使用之前必须先创建。对象可以被隐式创建或者显式创建。使用字面量符号创建对象是隐式创建；使用<em>new</em>关键字创建对象是显式创建。自定义对象都是显式创建的。自定义对象必须是从某个特定的类创建的。类是对象的模块，一个类可以创建多个对象。</p><br><pre><code>#!/usr/bin/ruby<br>class Being<br>end<br><br>puts 67<br>puts “ZetCode”<br><br>s = String.new “ZetCode”<br>puts s<br><br># n1 = Fixnum.new 67<br># puts n1<br><br>b = Being.new<br>puts b<br></code></pre><br><p>这个例子演示了Ruby中的对象创建。</p><br><pre><code>class Being<br>end<br></code></pre><br><p>这里是一个名为<em>Being</em>的对象模块。对象模块使用<em>class</em>关键字创建。自定义对象模块通常放在代码文件的顶部，或者分开放在另外的文件中。</p><br><pre><code>puts 67<br>puts “ZetCode”<br></code></pre><br><p>这两行代码我们用到了两个对象。<em>Fixnum</em>类型的<em>67</em>和<em>String</em>类型的<em>“ZetCode”</em>。<em>67</em>和<em>“ZetCode”</em>是使用字面符号创建了。字面符号是一个文本，表示了一个类型的特定值。这两个对象是Ruby解释器幕后创建的。在源代码中Ruby的一些对象是使用他们特定的字面符号创建的。</p><br><pre><code>s = String.new “ZetCode”<br>puts s<br></code></pre><br><p>这是正式的方法创建字符串对象。它与之前的隐式创建是等价的。</p><br><pre><code># n1 = Fixnum.new 67<br># puts n1<br></code></pre><br><p>不是所有的内置对象都可以使用<em>new</em>方法来创建。以上代码就不能编译通过。<em>Fixnum</em>对象只能通过字面符号来创建。</p><br><pre><code>b = Being.new<br>puts b<br></code></pre><br><p>这里我们创建了自定义对象的一个实例。<em>puts</em>方法输出了这个对象的简短描述。</p><br><p>$ ./ocreation.rb<br><br>67<br><br>ZetCode<br><br>ZetCode<br><br>#&lt;Being:0x9944d9c&gt;  </p><br><p>以上是输出结果。</p><br><hr><br><p>继续介绍一些正式的对象创建。  </p><br><pre><code>#!/usr/bin/ruby<br><br>s1 = String.new “Ruby”<br>puts s1.size<br>puts s1.downcase<br><br>a1 = Array.new<br>a1.push 1, 2, 3<br>puts a1.include? 3<br>puts a1.empty?<br><br>r1 = Range.new 1, 6<br>puts r1.class<br>puts r1.include? 4<br></code></pre><br><p>在这个例子中，我们创建三个内建对象并且调用了几个它们的方法。</p><br><pre><code>s1 = String.new “Ruby”<br>puts s1.size<br>puts s1.downcase<br></code></pre><br><p>创建一个字符串对象，并且调用了它的两个方法。<em>size</em>方法返回这个字符串的长度。<em>downcase</em>方法将这个字符串转为小写。</p><br><pre><code>a1 = Array.new<br>a1.push 1, 2, 3<br>puts a1.include? 3<br>puts a1.empty?<br></code></pre><br><p>这里创建了一个数组，并往其中添加了三个数字。然后调用了两个数组的方法。<em>include?</em>方法用于检查一个特定的值（在这个例子中是3）是否在数组内。<em>empty?</em>方法返回一个布尔类型的值表明这个数组是否为空。</p><br><pre><code>r1 = Range.new 1, 6<br>puts r1.class<br>puts r1.include? 4<br></code></pre><br><p>创建了一个<em>Range</em>类型的实例对象。它包含了1到6的数字。<em>class</em>方法返回这个对象的类型名称。在这个例子中<em>include?</em>方法检查数字<em>4</em>是否在这个范围内。</p><br><p>$ ./formal.rb<br><br>4<br><br>ruby<br><br>true<br><br>false<br><br>Range<br><br>true  </p><br><p>这个例子的运行输出结果。</p><br><h2>对象字面符</h2><br><p>前面提到了一些内建对象可以使用对象字面符创建。接下来的例子展示了一些对象字面符。</p><br><pre><code>#!/usr/bin/ruby<br><br>4.times { puts “Ruby” }<br><br>puts “Ruby”.size<br>puts “Ruby”.downcase<br><br>puts [1, 2, 3].include? 3<br>puts [1, 2, 3].empty?<br><br>puts :name.class<br>puts :name.frozen?<br><br>puts (1..6).class<br>puts (1..6).include? 4<br></code></pre><br><p>在这个例子中我们使用字面符创建了<em>Fixnum</em>、<em>Strings</em>、<em>Arrays</em>、 <em>Symbols</em>和<em>Ranges</em>对象。</p><br><pre><code>4.times { puts “Ruby” }<br></code></pre><br><p>我们可以直接对一个整数字面符号调用方法。这行代码将在终端上打印4次”Ruby”字符串。</p><br><pre><code>puts “Ruby”.size<br>puts “Ruby”.downcase<br></code></pre><br><p>我们对使用字面符号创建的字符串调用了两个方法。</p><br><pre><code>puts [1, 2, 3].include? 3<br>puts [1, 2, 3].empty?<br></code></pre><br><p>这里我们使用字面符号创建了两个数组。然后使用<em>include?</em>方法检查一个特定的数字是否是这个数组里；使用<em>empty?</em>方法检查这个数组是否为空。</p><br><pre><code>puts :name.class<br>puts :name.frozen?<br></code></pre><br><p>使用以冒号开头的字面符号创建了符号对象，并且调用的它的两个方法。</p><br><pre><code>puts (1..6).class<br>puts (1..6).include? 4<br></code></pre><br><p>使用字面符号创建了两个范围对象，并且调用了他们的两个方法。<em>class</em>方法返回这个类的名称，<em>include?</em>方法检查给定的数字是否是这个范围内。</p><br><p>$ ./literals.rb<br><br>Ruby<br><br>Ruby<br><br>Ruby<br><br>Ruby<br><br>4<br><br>ruby<br><br>true<br><br>false<br><br>Symbol<br><br>false<br><br>Range<br><br>true  </p><br><p>以上是例子的输出结果。</p><br><h2>对象层级</h2><br><p>在许多面向对象语言中对象是层级形式的。Ruby中也有对象层级。与树形层级相似，我们也有父对象和子对象。对象从它的父对象中继承数据和行为。层级的顶级是根对象，称为<em>Object</em>。在Ruby中每个对象都至少有一个父对象。也就是就每个对象都继承至<em>Object</em>对象的基类。</p><br><p>根据Ruby的官方文档，<em>Object</em>是Ruby的类层级的根。它的所有方法在所有的类中都是一样的，除非显示的覆盖了。</p><br><pre><code>#!/usr/bin/ruby<br><br>puts 4.is_a? Object<br>puts “Ruby”.is_a? Object<br>puts [2, 3].is_a? Object<br>puts :name.is_a? Object<br>puts (1..2).is_a? Object<br></code></pre><br><p>以上例子的代码展示了所有对象都是继承至根对象<em>Object</em>。</p><br><pre><code>puts 4.is_a? Object<br></code></pre><br><p>使用<em>is_a?</em>方法检查一个数字是否为特定的类型，也就是说它是否继承至给定的对象类型。</p><br><p>$ ./mother.rb <br><br>true<br><br>true<br><br>true<br><br>true<br><br>true  </p><br><p>所有方法都返回<em>true</em>，意味着所有的对象都继承至母类。</p><br><hr><br><p>即使是基本的Ruby对象，它们的继承层级也可能是很复杂的。</p><br><pre><code>#!/usr/bin/ruby<br><br>puts 6.class<br><br>puts 6.is_a? BasicObject<br>puts 6.is_a? Object<br>puts 6.is_a? Numeric<br>puts 6.is_a? Integer<br>puts 6.is_a? Fixnum<br><br>puts 6.is_a? Bignum<br>puts 6.is_a? String<br></code></pre><br><p>这个例子展示了小数字的继承层级。</p><br><pre><code>puts 6.class<br></code></pre><br><p>我们发现数字6的类型是<em>Fixnum</em>。</p><br><pre><code>puts 6.is_a? BasicObject<br>puts 6.is_a? Object<br>puts 6.is_a? Numeric<br>puts 6.is_a? Integer<br>puts 6.is_a? Fixnum<br></code></pre><br><p>以上这些代码全都返回<em>true</em>。数字6是<em>Fixnum</em>类型。从Ruby文档中我们发现另外四个对象是<em>Fuxnum</em>对象的父类。</p><br><pre><code>puts 6.is_a? Bignum<br>puts 6.is_a? String<br></code></pre><br><p>$ ./inheritance.rb<br><br>Fixnum<br><br>true<br><br>true<br><br>true<br><br>true<br><br>true<br><br>false<br><br>false  </p><br><p>以上是输出结果。</p><br><hr><br><p>这节的最后再举个例子展示下自定义对象的继承。</p><br><pre><code>#!/usr/bin/ruby<br><br>class Being<br><br>    def to_s<br>        “This is Being”<br>    end<br><br>    def get_id<br>        9<br>    end<br>end<br><br>class Living &lt; Being<br><br>    def to_s<br>        “This is Living”<br>    end<br>end<br><br>l = Living.new<br><br>puts l<br>puts l.get_id<br>puts l.is_a? Being<br>puts l.is_a? Object<br>puts l.is_a? BasicObject<br></code></pre><br><p>在这个例子中我们创建了两个对象。<em>Being</em>和<em>Living</em>。<em>Living</em>对象继承至<em>Being</em>。第一个是父对象，第二介是子对象。</p><br><pre><code>class Being<br><br>    def to_s<br>        “This is Being”<br>    end<br><br>    def get_id<br>        9<br>    end<br>end<br></code></pre><br><p>这里定义了一个Ruby的自定义对象。定义内容是<em>class</em>和<em>end</em>关键字之间。在定义里我们创建了两个方法。当<em>puts</em>方法接了一个对象作为参数时，会调用它的<em>to_s</em>方法。它通常返回这个对象的字符串描述。</p><br><pre><code>class Living &lt; Being<br><br>    def to_s<br>        “This is Living”<br>    end<br>end<br></code></pre><br><p>定义了一个<em>Living</em>对象，这个对象继承至<em>Being</em>对象。<em>&lt;</em>操作符用于创建继承关系。<em>to_s</em>方法被覆盖了。</p><br><pre><code>l = Living.new<br></code></pre><br><p>我们创建了一个Living实例对象。自定义对象使用<em>new</em>关键字创建。</p><br><pre><code>puts l<br></code></pre><br><p><em>puts</em>方法调用<em>Living</em>对象的<em>to_s</em>方法。只有当<em>Living</em>类没有定义<em>to_s</em>方法时，<em>Being</em>类的<em>to_s</em>方法才会被调用。</p><br><pre><code>puts l.get_id<br></code></pre><br><p><em>Living</em>对象没有定义<em>get_id</em>方法。在这种情况下就检查它的父类是否有此方法。在这里<em>Being</em>有这个方法，并且被调用。</p><br><pre><code>puts l.is_a? Being<br></code></pre><br><p>这行将返回<em>true</em>。<em>Living</em>对象是<em>Being</em>类型的，因为它继承至<em>Being</em>类。</p><br><pre><code>puts l.is_a? Object<br>puts l.is_a? BasicObject<br></code></pre><br><p>我们的<em>Living</em>自定义对象中，没有特别显示的指定与<em>Object</em>或者<em>BasicObject</em>的关系。然而这两行也返回<em>true</em>。这是因为在Ruby中所有对象都是自动设置为这两个对象的后代。这是Ruby解释器在幕后完成的。</p><br><p>$ ./custominher.rb<br><br>This is Living<br><br>9<br><br>true<br><br>true<br><br>true  </p><br><p>以上是输出结果。</p><br><h2>Ruby的顶级环境</h2><br><p>Ruby中有一个特殊的对象引用到Ruby的顶级环境，这是定义在其他上下文之外的默认执行环境。顶级环境名字是<em>main</em>。它是一个<em>Object</em>类型的实例对象。以下<em>main</em>分配了一个局部空间，所有的局部变量有属于它。</p><br><pre><code>#!/usr/bin/ruby<br><br>n1 = 3<br>n2 = 5<br><br>puts local_variables<br><br>Kernel.puts self<br>puts self.class<br></code></pre><br><p>这是描述Ruby顶级环境的第一个例子。</p><br><pre><code>n1 = 3<br>n2 = 5<br></code></pre><br><p>我们定义了两个数字类型的变量，这些变量是顶级环境的局部变量。</p><br><pre><code>puts local_variables<br></code></pre><br><p>这里我们输出所有的局部变量。<em>local_variables</em>是<em>Kernel</em>模块的一个方法，它包含了每个顶级环境的对象。</p><br><pre><code>Kernel.puts self<br></code></pre><br><p><em>self</em>是Ruby的伪变量。它返回当前对象的接收者。这行将在终端打印<em>“main”</em>。这是顶级环境的名字。<em>Kernel.puts</em>代码部分的<em>Kernel</em>可以省略。完整的名字表示的<em>puts</em>方法属于<em>Kernel</em>模块。</p><br><pre><code>puts self.class<br></code></pre><br><p>这行打印了顶级环境的类型。我们得到顶级环境的对象类型。它是<em>Object</em>类型，Ruby类层级的根。</p><br><p>$ ./toplevel.rb<br><br>n1<br><br>n2 <br><br>main <br><br>Object  </p><br><p>这是这个例子的输出结果。<em>n1</em>、<em>n2</em>是顶级环境所分配的局部变量。<em>main</em>是Ruby顶级执行环境的名字。最后<em>Object</em>是顶级环境的类型。</p><br><hr><br><p>我们再展示另一个关于Ruby顶级环境的例子。</p><br><pre><code>#!/usr/bin/ruby<br><br>@name = “Jane”<br>@age = 17<br><br>def info<br>   “#{@name} is #{@age} years old”<br>end<br><br>puts self.instance_variables<br>puts self.private_methods.include? :info<br><br>puts info<br></code></pre><br><p>我们展示的属于顶级环境的实例变量和方法。</p><br><pre><code>@name = “Jane”<br>@age = 17<br></code></pre><br><p>我们定义了两个实例变量。在Ruby中实例变量以<em>@</em>符号开头。实例变量属于指定的对象实例。在这里是属于Ruby的顶级环境。</p><br><pre><code>def info<br>   “#{@name} is #{@age} years old”<br>end<br></code></pre><br><p>这里定义了一个方法。每个方法都必须属于一个对象。这个方法是属于顶级环境的。所有顶级环境的方法都是私有的。私有方法的访问是受制的。</p><br><pre><code>puts self.instance_variables<br></code></pre><br><p><em>instance_variables</em>方法打印<em>self</em>的所有实例变量。</p><br><pre><code>puts self.private_methods.include? :info<br></code></pre><br><p>所有的顶级环境的方法都自动设为私有。<em>private_methods</em>返回该对象所有的私有方法。由于内容太多，我们就调用<em>include?</em>方法来检查<em>info</em>方法是否是其中一个。注意我们是通过符号名来引用<em>info</em>的。</p><br><p>$ ./toplevel2.rb<br><br>@name<br><br>@age<br><br>true<br><br>Jane is 17 years old  </p><br><p>以上是例子的输出结果。</p><br><p>这章包含了Ruby对象的基本内容。</p><br><hr><br><p>原文地址： <a href="http://zetcode.com/lang/rubytutorial/objects/" target="_blank" rel="external">http://zetcode.com/lang/rubytutorial/objects/</a><br><br>翻译：龙昌  admin@longchangjin.cn<br><br>完整教程：<a href="https://github.com/wusuopu/Ruby-tutorial" target="_blank" rel="external">https://github.com/wusuopu/Ruby-tutorial</a>  </p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://www.xefan.com/archives/83909.html" data-id="cjc95ct5i00i3n4q3tacqrk9m" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Ruby/">Ruby</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/翻译/">翻译</a></li></ul>

    </footer>
  </div>
  
</article>



  


  <nav id="page-nav">
    <a class="extend prev" rel="prev" href="/page/9/">&laquo;Prev</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/8/">8</a><a class="page-number" href="/page/9/">9</a><span class="page-number current">10</span><a class="page-number" href="/page/11/">11</a><a class="page-number" href="/page/12/">12</a><span class="space">&hellip;</span><a class="page-number" href="/page/30/">30</a><a class="extend next" rel="next" href="/page/11/">Next&raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Categories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Linux栏目/">Linux栏目</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Python栏目/">Python栏目</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Ruby栏目/">Ruby栏目</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/Ruby栏目/Web开发/">Web开发</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/Web开发/">Web开发</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/Web开发/Python栏目/">Python栏目</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/前端相关/">前端相关</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/嵌入式栏目/">嵌入式栏目</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/开源软件/">开源软件</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/教程/">教程</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/数据库/">数据库</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/数据结构和算法/">数据结构和算法</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/编程开发/">编程开发</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/网络日志/">网络日志</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/资源分享/">资源分享</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/ARM/">ARM</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Android/">Android</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Arch/">Arch</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/C/">C</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Django/">Django</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Docker/">Docker</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Dreamweaver/">Dreamweaver</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Fedora/">Fedora</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Flash/">Flash</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/GObject/">GObject</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Gentoo/">Gentoo</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Hash/">Hash</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Linux/">Linux</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Mac/">Mac</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/PS/">PS</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Qt/">Qt</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Raspberry-pi/">Raspberry pi</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Redis/">Redis</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Ruby/">Ruby</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Scrapy/">Scrapy</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/TQ2440/">TQ2440</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/USB/">USB</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/VirtualBox/">VirtualBox</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Web开发/">Web开发</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/WordPress/">WordPress</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Xcode/">Xcode</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/access/">access</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/adobe/">adobe</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/ajax/">ajax</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/angular/">angular</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/apache/">apache</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/asp/">asp</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/css/">css</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/firefox/">firefox</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/ftp/">ftp</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/gcc/">gcc</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/git/">git</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/grub/">grub</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/gtk/">gtk</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/gulp/">gulp</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/ibus/">ibus</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/js/">js</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/mongodb/">mongodb</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/mysql/">mysql</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/nginx/">nginx</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/node/">node</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/php/">php</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/pygame/">pygame</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/python/">python</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/react/">react</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/redis/">redis</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/shell/">shell</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/ubuntu/">ubuntu</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/vim/">vim</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/vmware/">vmware</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/w3m/">w3m</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/windows/">windows</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/xml/">xml</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/免费/">免费</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/内核/">内核</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/匹配算法/">匹配算法</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/单片机/">单片机</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/嵌入式/">嵌入式</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/开源软件/">开源软件</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/排序算法/">排序算法</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/文件空间/">文件空间</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/无线网/">无线网</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/正则式/">正则式</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/注册机/">注册机</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/游戏/">游戏</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/电脑技巧/">电脑技巧</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/空间/">空间</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/算法/">算法</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/红旗/">红旗</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/经典语录/">经典语录</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/网络日志/">网络日志</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/翻译/">翻译</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/视频教程/">视频教程</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/资源分享/">资源分享</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/转载/">转载</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/随笔/">随笔</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/ARM/" style="font-size: 13.68px;">ARM</a> <a href="/tags/Android/" style="font-size: 10px;">Android</a> <a href="/tags/Arch/" style="font-size: 13.16px;">Arch</a> <a href="/tags/C/" style="font-size: 16.32px;">C</a> <a href="/tags/Django/" style="font-size: 11.05px;">Django</a> <a href="/tags/Docker/" style="font-size: 10px;">Docker</a> <a href="/tags/Dreamweaver/" style="font-size: 10px;">Dreamweaver</a> <a href="/tags/Fedora/" style="font-size: 10.53px;">Fedora</a> <a href="/tags/Flash/" style="font-size: 10px;">Flash</a> <a href="/tags/GObject/" style="font-size: 12.63px;">GObject</a> <a href="/tags/Gentoo/" style="font-size: 10.53px;">Gentoo</a> <a href="/tags/Hash/" style="font-size: 10px;">Hash</a> <a href="/tags/Linux/" style="font-size: 20px;">Linux</a> <a href="/tags/Mac/" style="font-size: 10px;">Mac</a> <a href="/tags/PS/" style="font-size: 12.63px;">PS</a> <a href="/tags/Qt/" style="font-size: 10.53px;">Qt</a> <a href="/tags/Raspberry-pi/" style="font-size: 10px;">Raspberry pi</a> <a href="/tags/Redis/" style="font-size: 10px;">Redis</a> <a href="/tags/Ruby/" style="font-size: 18.95px;">Ruby</a> <a href="/tags/Scrapy/" style="font-size: 11.05px;">Scrapy</a> <a href="/tags/TQ2440/" style="font-size: 12.11px;">TQ2440</a> <a href="/tags/USB/" style="font-size: 11.05px;">USB</a> <a href="/tags/VirtualBox/" style="font-size: 11.05px;">VirtualBox</a> <a href="/tags/Web开发/" style="font-size: 16.84px;">Web开发</a> <a href="/tags/WordPress/" style="font-size: 10px;">WordPress</a> <a href="/tags/Xcode/" style="font-size: 10px;">Xcode</a> <a href="/tags/access/" style="font-size: 12.63px;">access</a> <a href="/tags/adobe/" style="font-size: 10px;">adobe</a> <a href="/tags/ajax/" style="font-size: 11.05px;">ajax</a> <a href="/tags/angular/" style="font-size: 13.16px;">angular</a> <a href="/tags/apache/" style="font-size: 10px;">apache</a> <a href="/tags/asp/" style="font-size: 13.16px;">asp</a> <a href="/tags/css/" style="font-size: 10.53px;">css</a> <a href="/tags/firefox/" style="font-size: 11.05px;">firefox</a> <a href="/tags/ftp/" style="font-size: 10px;">ftp</a> <a href="/tags/gcc/" style="font-size: 12.63px;">gcc</a> <a href="/tags/git/" style="font-size: 11.58px;">git</a> <a href="/tags/grub/" style="font-size: 10px;">grub</a> <a href="/tags/gtk/" style="font-size: 17.89px;">gtk</a> <a href="/tags/gulp/" style="font-size: 10px;">gulp</a> <a href="/tags/ibus/" style="font-size: 10px;">ibus</a> <a href="/tags/js/" style="font-size: 15.26px;">js</a> <a href="/tags/mongodb/" style="font-size: 15.79px;">mongodb</a> <a href="/tags/mysql/" style="font-size: 11.58px;">mysql</a> <a href="/tags/nginx/" style="font-size: 10px;">nginx</a> <a href="/tags/node/" style="font-size: 10px;">node</a> <a href="/tags/php/" style="font-size: 14.74px;">php</a> <a href="/tags/pygame/" style="font-size: 15.79px;">pygame</a> <a href="/tags/python/" style="font-size: 19.47px;">python</a> <a href="/tags/react/" style="font-size: 11.58px;">react</a> <a href="/tags/redis/" style="font-size: 10px;">redis</a> <a href="/tags/shell/" style="font-size: 10px;">shell</a> <a href="/tags/ubuntu/" style="font-size: 13.16px;">ubuntu</a> <a href="/tags/vim/" style="font-size: 18.42px;">vim</a> <a href="/tags/vmware/" style="font-size: 10px;">vmware</a> <a href="/tags/w3m/" style="font-size: 10px;">w3m</a> <a href="/tags/windows/" style="font-size: 13.16px;">windows</a> <a href="/tags/xml/" style="font-size: 10px;">xml</a> <a href="/tags/免费/" style="font-size: 10px;">免费</a> <a href="/tags/内核/" style="font-size: 10px;">内核</a> <a href="/tags/匹配算法/" style="font-size: 12.63px;">匹配算法</a> <a href="/tags/单片机/" style="font-size: 10.53px;">单片机</a> <a href="/tags/嵌入式/" style="font-size: 10px;">嵌入式</a> <a href="/tags/开源软件/" style="font-size: 14.21px;">开源软件</a> <a href="/tags/排序算法/" style="font-size: 14.21px;">排序算法</a> <a href="/tags/文件空间/" style="font-size: 10px;">文件空间</a> <a href="/tags/无线网/" style="font-size: 10px;">无线网</a> <a href="/tags/正则式/" style="font-size: 10px;">正则式</a> <a href="/tags/注册机/" style="font-size: 10.53px;">注册机</a> <a href="/tags/游戏/" style="font-size: 14.74px;">游戏</a> <a href="/tags/电脑技巧/" style="font-size: 14.21px;">电脑技巧</a> <a href="/tags/空间/" style="font-size: 10px;">空间</a> <a href="/tags/算法/" style="font-size: 17.37px;">算法</a> <a href="/tags/红旗/" style="font-size: 10px;">红旗</a> <a href="/tags/经典语录/" style="font-size: 10px;">经典语录</a> <a href="/tags/网络日志/" style="font-size: 13.16px;">网络日志</a> <a href="/tags/翻译/" style="font-size: 18.42px;">翻译</a> <a href="/tags/视频教程/" style="font-size: 14.74px;">视频教程</a> <a href="/tags/资源分享/" style="font-size: 15.79px;">资源分享</a> <a href="/tags/转载/" style="font-size: 10.53px;">转载</a> <a href="/tags/随笔/" style="font-size: 10px;">随笔</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/06/">June 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/05/">May 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/01/">January 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/11/">November 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/08/">August 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/07/">July 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/06/">June 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/04/">April 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/03/">March 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/01/">January 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/12/">December 2015</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/08/">August 2015</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/05/">May 2015</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/04/">April 2015</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/02/">February 2015</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/01/">January 2015</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2014/12/">December 2014</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2014/11/">November 2014</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2014/10/">October 2014</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2014/09/">September 2014</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2014/08/">August 2014</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2014/07/">July 2014</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2014/06/">June 2014</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2014/05/">May 2014</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2014/04/">April 2014</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2014/03/">March 2014</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2014/01/">January 2014</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2013/12/">December 2013</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2013/11/">November 2013</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2013/10/">October 2013</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2013/08/">August 2013</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2013/07/">July 2013</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2013/06/">June 2013</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2013/05/">May 2013</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2013/04/">April 2013</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2013/01/">January 2013</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2012/10/">October 2012</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2012/09/">September 2012</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2012/08/">August 2012</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2012/07/">July 2012</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2012/05/">May 2012</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2012/04/">April 2012</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2012/03/">March 2012</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2012/02/">February 2012</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2011/12/">December 2011</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2011/11/">November 2011</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2011/10/">October 2011</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2011/09/">September 2011</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2011/08/">August 2011</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2011/07/">July 2011</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2011/05/">May 2011</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2011/04/">April 2011</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2011/03/">March 2011</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2011/02/">February 2011</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2011/01/">January 2011</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2010/12/">December 2010</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2010/11/">November 2010</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2010/10/">October 2010</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2010/09/">September 2010</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2010/08/">August 2010</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2010/07/">July 2010</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2010/06/">June 2010</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2010/05/">May 2010</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2010/04/">April 2010</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2010/03/">March 2010</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2009/12/">December 2009</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2009/11/">November 2009</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2009/10/">October 2009</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2009/09/">September 2009</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2009/08/">August 2009</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2009/07/">July 2009</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2009/05/">May 2009</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2008/12/">December 2008</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2008/07/">July 2008</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/archives/84169.html">HAProxy+Nginx+gunicorn获取真实ip</a>
          </li>
        
          <li>
            <a href="/archives/84168.html">在Docker中运行X11程序</a>
          </li>
        
          <li>
            <a href="/archives/84167.html">由octpress迁移到了hexo</a>
          </li>
        
          <li>
            <a href="/archives/84166.html">通过串口连接raspberry pi</a>
          </li>
        
          <li>
            <a href="/archives/84165.html">使用CodePush对ReactNative进行热更新</a>
          </li>
        
      </ul>
    </div>
  </div>

  
    <div class="widget-wrap">
  <h3 class="widget-title">Link</h3>
    <div class="widget">
      <ul id="category-list">
        <li><a target="_blank" title="我的Github" href="https://github.com/wusuopu">@Github</a></li>
        <li><a target="_blank" title="我的微博" href="http://www.weibo.com/u/1768691343">@Weibo</a></li>
        <li><a target="_blank" title="我的Twitter" href="https://twitter.com/longchangjin">@Twitter</a></li>
        <li><a target="_blank" title="我的豆瓣" href="http://www.douban.com/people/lchj/">@Douban</a></li>

        <li><a target="_blank" title="" href="http://pythoner.net/">python开发者社区</a></li>
        <li><a target="_blank" title="" href="http://simple-is-better.com/">python.cn(news, jobs)</a></li>
        <li><a target="_blank" title="" href="http://gtk.awaysoft.com/">GTK+ 中文社区</a></li>
        <li><a target="_blank" title="小智LOGO - LOGO在线制作神器 - 3分钟完成公司LOGO设计" href="http://xzlogo.com/">小智LOGO</a></li>
      </ul>
    </div>
</div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2018 龍昌<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
<div style="display:none;"><script src="http://s94.cnzz.com/stat.php?id=1259846&web_id=1259846&show=pic" language="JavaScript"></script></div>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
    <a href="/about" class="mobile-nav-link">About</a>
  
    <a href="/gbook" class="mobile-nav-link">留言板</a>
  
</nav>
    

<script src="/js/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>

  </div>
</body>
</html>