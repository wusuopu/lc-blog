
<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js" lang="en"><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <title>龍昌博客</title>
  <meta name="author" content="龍昌">

  
  <meta name="description" content="使用Cairo绘制 这部分的Ruby GTK教程，我们将使用Cairo库进行一些绘制。 Cairo是一个用于创建2D矢量图像的库。我们可以用它来绘制自己的控件、图表或者各种效果或动画。 颜色 在第一个会例子，我们将介绍颜色。颜色是一个代表了红、绿和蓝（RGB）强度值的对象。 &hellip;">
  

  <!-- http://t.co/dKP3o1e -->
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  
  <link rel="canonical" href="http://www.xefan.com/page/7/index.html">
  <link href="/favicon.png" rel="icon">
  <link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
  <link href="/atom.xml" rel="alternate" title="龍昌博客" type="application/atom+xml">
  <script src="/javascripts/modernizr-2.0.js"></script>
  <script src="//ajax.useso.com/ajax/libs/jquery/1.9.1/jquery.min.js"></script>
  <script>!window.jQuery && document.write(unescape('%3Cscript src="./javascripts/libs/jquery.min.js"%3E%3C/script%3E'))</script>
  <script src="/javascripts/octopress.js" type="text/javascript"></script>
  <!--Fonts from Google"s Web font directory at http://google.com/webfonts -->
<link href="//fonts.useso.com/css?family=PT+Serif:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">
<link href="//fonts.useso.com/css?family=PT+Sans:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">

  

</head>

<body   >
  <header role="banner"><hgroup>
  <h1><a href="/">龍昌博客</a></h1>
  
    <h2>从Pythoneer转向Rubist</h2>
  
</hgroup>

</header>
  <nav role="navigation"><ul class="subscription" data-subscription="rss">
  <li><a href="/atom.xml" rel="subscribe-rss" title="subscribe via RSS">RSS</a></li>
  
</ul>
  
<form action="https://www.google.com/search" method="get">
  <fieldset role="search">
    <input type="hidden" name="q" value="site:www.xefan.com" />
    <input class="search" type="text" name="q" results="0" placeholder="Search"/>
  </fieldset>
</form>
  
<ul class="main-navigation">
  <li><a href="/">Home</a></li>
  <li><a href="/blog/archives">Archives</a></li>
 <li><a href="/about/">About</a></li>  <li><a href="/gbook/">留言板</a></li> 
</ul>

</nav>
  <div id="main">
    <div id="content">
      <div class="blog-index">
  
  
  
    <article>
      
  <header>
    
    <h1 class="entry-title"><a href="http://www.xefan.com/archives/83969.html">[翻译]Ruby GTK教程6——Cairo</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2013-11-24T00:00:00+08:00'><span class='date'><span class='date-month'>Nov</span> <span class='date-day'>24</span><span class='date-suffix'>th</span>, <span class='date-year'>2013</span></span> <span class='time'>12:00 am</span></time>
        
           | <a href="http://www.xefan.com/archives/83969.html#disqus_thread"
             data-disqus-identifier="http://www.xefan.com/archives/83969.html">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><h1>使用Cairo绘制</h1>


<p>这部分的Ruby GTK教程，我们将使用Cairo库进行一些绘制。</p>


<p>Cairo是一个用于创建2D矢量图像的库。我们可以用它来绘制自己的控件、图表或者各种效果或动画。</p>


<h2>颜色</h2>


<p>在第一个会例子，我们将介绍颜色。颜色是一个代表了红、绿和蓝（RGB）强度值的对象。Cairo的RGB有效值范围为0到1。</p>


<pre><code>#!/usr/bin/ruby

# ZetCode Ruby GTK tutorial
#
# This program shows how to work
# with colors in Cairo
#
# author: jan bodnar
# website: www.zetcode.com
# last modified: June 2009

require 'gtk2'


class RubyApp &lt; Gtk::Window

    def initialize
        super

        set_title "Colors"
        signal_connect "destroy" do 
            Gtk.main_quit 
        end

        init_ui

        set_default_size 360, 100
        set_window_position Gtk::Window::POS_CENTER

        show_all
    end

    def init_ui

        @darea = Gtk::DrawingArea.new

        @darea.signal_connect "expose-event" do  
            on_expose
        end

        add(@darea)

    end

    def on_expose

        cr = @darea.window.create_cairo_context  
        draw_colors cr

    end

    def draw_colors cr

        cr.set_source_rgb 0.2, 0.23, 0.9
        cr.rectangle 10, 15, 90, 60
        cr.fill

        cr.set_source_rgb 0.9, 0.1, 0.1
        cr.rectangle 130, 15, 90, 60
        cr.fill

        cr.set_source_rgb 0.4, 0.9, 0.4
        cr.rectangle 250, 15, 90, 60
        cr.fill
    end
end

Gtk.init
    window = RubyApp.new
Gtk.main
</code></pre>


<p>这个例子中我们绘制了三个矩形并且用三种不同的颜色填充。</p>


<pre><code>@darea = Gtk::DrawingArea.new
</code></pre>


<p>我们将在DrawingArea控件是进行绘制操作。</p>


<pre><code>@darea.signal_connect "expose-event" do  
    on_expose
end
</code></pre>


<p>当窗口需要重绘时<em>expose-event</em>事件将触发。对这个事件的响应中我们调用了<em>on_expose</em>方法。</p>


<pre><code>cr = @darea.window.create_cairo_context
</code></pre>


<p>从GdkWindow创建cairo上下文对象。这个上下文是我们将要进行所有绘制的对象。</p>


<pre><code>draw_colors cr
</code></pre>


<p>实际的绘制委托给<em>draw_colors</em>方法。</p>


<pre><code>cr.set_source_rgb 0.2, 0.23, 0.9
</code></pre>


<p><em>set_source_rgb</em>方法是设置cairo上下文的颜色。这个方法的三个参数是颜色的强度值。</p>


<pre><code>cr.rectangle 10, 15, 90, 60
</code></pre>


<p>绘制一个矩形。前两个参数是矩形左上角的x、y坐标。后两个参数是矩形的宽和高。</p>


<pre><code>cr.fill
</code></pre>


<p>使用当前的颜色填充矩形。</p>


<p><img alt="image1" src="http://zetcode.com/img/gui/rubygtk/colors.png"><br>
<em>图片：颜色</em></p>


<h2>基本形状</h2>


<p>下一个例子在窗口上绘制一些基本形状。</p>


<pre><code>#!/usr/bin/ruby

# ZetCode Ruby GTK tutorial
#
# This code example draws basic shapes
# with the Cairo library
#
# author: jan bodnar
# website: www.zetcode.com
# last modified: June 2009

require 'gtk2'


class RubyApp &lt; Gtk::Window

    def initialize
        super

        set_title "Basic shapes"
        signal_connect "destroy" do 
            Gtk.main_quit 
        end

        init_ui

        set_default_size 390, 240
        set_window_position Gtk::Window::POS_CENTER

        show_all
    end

    def init_ui

        @darea = Gtk::DrawingArea.new

        @darea.signal_connect "expose-event" do  
            on_expose
        end

        add(@darea)
    end

    def on_expose

        cr = @darea.window.create_cairo_context  
        draw_shapes cr
    end

    def draw_shapes cr

        cr.set_source_rgb 0.6, 0.6, 0.6

        cr.rectangle 20, 20, 120, 80
        cr.rectangle 180, 20, 80, 80
        cr.fill

        cr.arc 330, 60, 40, 0, 2*Math::PI
        cr.fill

        cr.arc 90, 160, 40, Math::PI/4, Math::PI
        cr.fill

        cr.translate 220, 180
        cr.scale 1, 0.7
        cr.arc 0, 0, 50, 0, 2*Math::PI
        cr.fill
    end
end

Gtk.init
    window = RubyApp.new
Gtk.main
</code></pre>


<p>这个例子我们将创建一个矩形、方形、圆形、弧形和椭圆形。我们将轮廓绘为蓝色，内部为白色。</p>


<pre><code>cr.rectangle 20, 20, 120, 80
cr.rectangle 180, 20, 80, 80
cr.fill
</code></pre>


<p>这几行绘制了一个矩形和一个方形。</p>


<pre><code>cr.arc 330, 60, 40, 0, 2*Math::PI
cr.fill
</code></pre>


<p><em>arc</em>方法绘制一个全圆。</p>


<pre><code>cr.translate 220, 180
cr.scale 1, 0.7
cr.arc 0, 0, 50, 0, 2*Math::PI
cr.fill
</code></pre>


<p><em>translate</em>方法将对象移动到指定的点。如果我们想要绘制椭圆，我们需要进行一些缩放。这里<em>scale</em>方法将y轴收缩。</p>


<p><img alt="image2" src="http://zetcode.com/img/gui/rubygtk/shapes.png"><br>
<em>图片：基本形状</em></p>


<h2>透明矩形</h2>


<p>透明度是透过实体的可见度。最简单的理解可以把它想象成玻璃或者水。光线可以透过玻璃，这样我们就可以看到玻璃后的物体。</p>


<p>在计算机图像中，我们可以使用透明混合实现透明度。透明混合处理图片和背景的组合，显示部透明。作品处理使用了阿尔法通道。</p>


<pre><code>#!/usr/bin/ruby

# ZetCode Ruby GTK tutorial
#
# This program shows transparent
# rectangles using Cairo
#
# author: jan bodnar
# website: www.zetcode.com
# last modified: June 2009

require 'gtk2'


class RubyApp &lt; Gtk::Window

    def initialize
        super

        set_title "Transparent rectangles"
        signal_connect "destroy" do 
            Gtk.main_quit 
        end

        init_ui

        set_default_size 590, 90
        set_window_position Gtk::Window::POS_CENTER

        show_all
    end

    def init_ui

        @darea = Gtk::DrawingArea.new

        @darea.signal_connect "expose-event" do  
            on_expose
        end

        add(@darea)

    end

    def on_expose

        cr = @darea.window.create_cairo_context

        for i in (1..10)
            cr.set_source_rgba 0, 0, 1, i*0.1
            cr.rectangle 50*i, 20, 40, 40
            cr.fill
        end
    end
end

Gtk.init
    window = RubyApp.new
Gtk.main
</code></pre>


<p>这个例子我们使用不同等级透明度绘制了10个矩形。</p>


<pre><code>cr.set_source_rgba 0, 0, 1, i*0.1
</code></pre>


<p><em>set_source_rgba</em>方法是最后一个参数是alpha透明度。</p>


<p><img alt="image3" src="http://zetcode.com/img/gui/rubygtk/transparency.png"> <br>
<em>图片：透明矩形</em></p>


<h2>甜甜圈</h2>


<p>接下来的例子我们通过旋转一堆椭圆来创建一个复杂的形状。</p>


<pre><code>#!/usr/bin/ruby

# ZetCode Ruby GTK tutorial
#
# This program creates a donut
# with Cairo library
#
# author: jan bodnar
# website: www.zetcode.com
# last modified: June 2009

require 'gtk2'


class RubyApp &lt; Gtk::Window

    def initialize
        super

        set_title "Donut"
        signal_connect "destroy" do 
            Gtk.main_quit 
        end

        init_ui

        set_default_size 350, 250
        set_window_position Gtk::Window::POS_CENTER

        show_all
    end

    def init_ui

        @darea = Gtk::DrawingArea.new

        @darea.signal_connect "expose-event" do  
            on_expose
        end

        add(@darea)

    end

    def on_expose

        cr = @darea.window.create_cairo_context  
        cr.set_line_width 0.5

        w = allocation.width
        h = allocation.height

        cr.translate w/2, h/2
        cr.arc 0, 0, 120, 0, 2*Math::PI
        cr.stroke

        for i in (1..36)
            cr.save
            cr.rotate i*Math::PI/36
            cr.scale 0.3, 1
            cr.arc 0, 0, 120, 0, 2*Math::PI
            cr.restore
            cr.stroke
        end
    end
end

Gtk.init
    window = RubyApp.new
Gtk.main
</code></pre>


<p>这个例子我们创建了一个甜甜圈。它的形状与饼干相似，因此取名为甜甜圈（donut）。</p>


<pre><code>cr.translate w/2, h/2
cr.arc 0, 0, 120, 0, 2*Math::PI
cr.stroke
</code></pre>


<p>在开始只是一个椭圆。</p>


<pre><code>for i in (1..36)
    cr.save
    cr.rotate i*Math::PI/36
    cr.scale 0.3, 1
    cr.arc 0, 0, 120, 0, 2*Math::PI
    cr.restore
    cr.stroke
end
</code></pre>


<p>经过一些旋转后变成了甜甜圈。</p>


<p><img alt="image4" src="http://zetcode.com/img/gui/rubygtk/donut.jpg"><br>
<em>图片：Donut</em></p>


<h2>绘制文本</h2>


<p>下一个例子我们在窗口上绘制一些文本。</p>


<pre><code>#!/usr/bin/ruby

# ZetCode Ruby GTK tutorial
#
# This program draws text
# using Cairo
#
# author: jan bodnar
# website: www.zetcode.com
# last modified: June 2009

require 'gtk2'


class RubyApp &lt; Gtk::Window

    def initialize
        super

        set_title "Soulmate"
        signal_connect "destroy" do 
            Gtk.main_quit 
        end

        init_ui

        set_default_size 370, 240
        set_window_position Gtk::Window::POS_CENTER

        show_all
    end

    def init_ui

        @darea = Gtk::DrawingArea.new

        @darea.signal_connect "expose-event" do  
            on_expose
        end

        add(@darea)

    end

    def on_expose

        cr = @darea.window.create_cairo_context

        cr.set_source_rgb 0.1, 0.1, 0.1

        cr.select_font_face "Purisa", Cairo::FONT_SLANT_NORMAL, 
            Cairo::FONT_WEIGHT_NORMAL
        cr.set_font_size 13

        cr.move_to 20, 30
        cr.show_text "Most relationships seem so transitory"
        cr.move_to 20, 60
        cr.show_text "They're all good but not the permanent one"
        cr.move_to 20, 120
        cr.show_text "Who doesn't long for someone to hold"
        cr.move_to 20, 150
        cr.show_text "Who knows how to love without being told"
        cr.move_to 20, 180
        cr.show_text "Somebody tell me why I'm on my own"
        cr.move_to 20, 210
        cr.show_text "If there's a soulmate for everyone"
    end
end

Gtk.init
    window = RubyApp.new
Gtk.main
</code></pre>


<p>我们显示了Natasha Bedingfields Soulmate歌的部分歌词。</p>


<pre><code>cr.select_font_face "Purisa", Cairo::FONT_SLANT_NORMAL, 
    Cairo::FONT_WEIGHT_NORMAL
</code></pre>


<p>这里我们指定我们使用的字体。</p>


<pre><code>cr.set_font_size 13
</code></pre>


<p>我们指定字体的大小。</p>


<pre><code>cr.move_to 20, 30
</code></pre>


<p>移动到开始绘制文本的坐标。</p>


<pre><code>cr.show_text "Most relationships seem so transitory"
</code></pre>


<p><em>show_text</em>方法在窗口上绘制文本。</p>


<p><img alt="image5" src="http://zetcode.com/img/gui/rubygtk/soulmate.png"><br>
<em>图片: Soulmate</em></p>


<p>这章的Ruby GTK教程我们使用Cairo库进行绘制。</p>


<hr>


<p>原文地址： <a href="http://zetcode.com/gui/rubygtk/cairo/">http://zetcode.com/gui/rubygtk/cairo/</a><br>
翻译：龙昌  admin@longchangjin.cn </p>

</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
    <h1 class="entry-title"><a href="http://www.xefan.com/archives/83966.html">[翻译]Ruby GTK教程5——对话框</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2013-11-23T00:00:00+08:00'><span class='date'><span class='date-month'>Nov</span> <span class='date-day'>23</span><span class='date-suffix'>rd</span>, <span class='date-year'>2013</span></span> <span class='time'>12:00 am</span></time>
        
           | <a href="http://www.xefan.com/archives/83966.html#disqus_thread"
             data-disqus-identifier="http://www.xefan.com/archives/83966.html">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><h1>对话框</h1>


<p>在这部分的Ruby GTK教程我们将介绍对话框。</p>


<p>对话框是现代GUI应用程序不可缺的一部分。对话是两个或者更多人之间交谈。在计算机程序中对话是一个用于与应用程序交互的窗口。对话框用于输入数据、修改数据、修改设置等。对话框在用户与计算机程序之间的交流具有重要意义。</p>


<h2>消息盒子</h2>


<p>消息对话框是应用程序便于给用户提供消息的对话框。消息由文本和图片数据组成。</p>


<pre><code>#!/usr/bin/ruby

# ZetCode Ruby GTK tutorial
#
# This example shows message
# dialogs
#
# author: jan bodnar
# website: www.zetcode.com
# last modified: June 2009

require 'gtk2'


class RubyApp &lt; Gtk::Window

    def initialize
        super

        set_title "Messages"
        signal_connect "destroy" do 
            Gtk.main_quit 
        end

        init_ui

        set_default_size 250, 100
        set_window_position Gtk::Window::POS_CENTER

        show_all
    end

    def init_ui

        table = Gtk::Table.new 2, 2, true

        info = Gtk::Button.new "Information"
        warn = Gtk::Button.new "Warning"
        ques = Gtk::Button.new "Question"
        erro = Gtk::Button.new "Error"

        info.signal_connect "clicked" do
            on_info
        end

        warn.signal_connect "clicked" do
            on_warn
        end

        ques.signal_connect "clicked" do
            on_ques
        end

        erro.signal_connect "clicked" do
            on_erro
        end

        table.attach info, 0, 1, 0, 1
        table.attach warn, 1, 2, 0, 1
        table.attach ques, 0, 1, 1, 2
        table.attach erro, 1, 2, 1, 2

        add table

    end

    def on_info
        md = Gtk::MessageDialog.new(self,
            Gtk::Dialog::DESTROY_WITH_PARENT, Gtk::MessageDialog::INFO, 
            Gtk::MessageDialog::BUTTONS_CLOSE, "Download completed")
        md.run
        md.destroy
    end


    def on_erro
        md = Gtk::MessageDialog.new(self, Gtk::Dialog::MODAL |
            Gtk::Dialog::DESTROY_WITH_PARENT, Gtk::MessageDialog::ERROR, 
            Gtk::MessageDialog::BUTTONS_CLOSE, "Error loading file")
        md.run
        md.destroy
    end


    def on_ques
        md = Gtk::MessageDialog.new(self,
            Gtk::Dialog::DESTROY_WITH_PARENT, Gtk::MessageDialog::QUESTION, 
            Gtk::MessageDialog::BUTTONS_CLOSE, "Are you sure to quit?")
        md.run
        md.destroy
    end

    def on_warn
        md = Gtk::MessageDialog.new(self,
            Gtk::Dialog::DESTROY_WITH_PARENT, Gtk::MessageDialog::WARNING, 
            Gtk::MessageDialog::BUTTONS_CLOSE, "Unallowed operation")
        md.run
        md.destroy
    end
end

Gtk.init
    window = RubyApp.new
Gtk.main
</code></pre>


<p>我们的例子中显示了四种消息对话框。信息、警告、询问和错误消息对话框。</p>


<pre><code>info = Gtk::Button.new "Information"
warn = Gtk::Button.new "Warning"
ques = Gtk::Button.new "Question"
erro = Gtk::Button.new "Error"
</code></pre>


<p>创建四个按钮。每个按钮将显示不同种类的消息对话框。</p>


<pre><code>def on_info
    md = Gtk::MessageDialog.new(self,
        Gtk::Dialog::DESTROY_WITH_PARENT, Gtk::MessageDialog::INFO, 
        Gtk::MessageDialog::BUTTONS_CLOSE, "Download completed")
    md.run
    md.destroy
end
</code></pre>


<p>如果我们点击了<em>info</em>按钮，信息对话框将显示。<em>Gtk::MessageDialog::INFO</em>指定了对话框的类型。<em>Gtk::MessageDialog::BUTTONS_CLOSE</em>指定在对话框中显示的按钮。最后一个参数是要显示的消息。对话框使用<em>run</em>方法显示。程序员必须也要调用<em>destroy</em>或者<em>hide</em>方法。<br>
<img alt="image1" src="http://zetcode.com/img/gui/rubygtk/information.png">  <img alt="image2" src="http://zetcode.com/img/gui/rubygtk/warning.png">  <br>
<img alt="image3" src="http://zetcode.com/img/gui/rubygtk/question.png">  <img alt="image4" src="http://zetcode.com/img/gui/rubygtk/error.png">   </p>


<h2>关于对话框(AboutDialog)</h2>


<p><em>关于对话框</em>显示了应用程序的信息。<em>关于对话框</em>可以显示logo、应用程序名、版本号、版权、网站或者授权信息。它也可能给出作者、文档编写才、翻译者和设计师的信息。</p>


<pre><code>#!/usr/bin/ruby

# ZetCode Ruby GTK tutorial
#
# This example demonstrates the
# AboutDialog dialog
#
# author: jan bodnar
# website: www.zetcode.com
# last modified: June 2009

require 'gtk2'


class RubyApp &lt; Gtk::Window

    def initialize
        super

        set_title "About dialog"
        signal_connect "destroy" do 
            Gtk.main_quit 
        end

        init_ui

        set_default_size 300, 150
        set_window_position Gtk::Window::POS_CENTER

        show_all
    end

    def init_ui

        button = Gtk::Button.new "About"
        button.set_size_request 80, 30

        button.signal_connect "clicked" do
            on_clicked
        end

        fix = Gtk::Fixed.new
        fix.put button, 20, 20

        add fix

    end

    def on_clicked
        about = Gtk::AboutDialog.new
        about.set_program_name "Battery"
        about.set_version "0.1"
        about.set_copyright "(c) Jan Bodnar"
        about.set_comments "Battery is a simple tool for battery checking"
        about.set_website "http://www.zetcode.com"
        about.set_logo Gdk::Pixbuf.new "battery.png"
        about.run
        about.destroy
    end
end

Gtk.init
    window = RubyApp.new
Gtk.main
</code></pre>


<p>代码伅使用了<em>AboutDialog</em>的一些特性。</p>


<pre><code>about = Gtk::AboutDialog.new
</code></pre>


<p>创建一个AboutDialog。</p>


<pre><code>about.set_program_name "Battery"
about.set_version "0.1"
about.set_copyright "(c) Jan Bodnar"
</code></pre>


<p>这里我们指定名称、版本号和版权信息。</p>


<pre><code>about.set_logo Gdk::Pixbuf.new "battery.png"
</code></pre>


<p>这行创建一个logo。 <br>
<img alt="image5" src="http://zetcode.com/img/gui/rubygtk/about.png"> <br>
<em>图片：AboutDialog</em></p>


<h2>字体选择对话框</h2>


<p>FontSelectionDialog是一个用于选择字体的对话框。它典型的应用于文本编辑或者格式化的应用程序中。</p>


<pre><code>#!/usr/bin/ruby

# ZetCode Ruby GTK tutorial
#
# This example works with the
# FontSelectionDialog
#
# author: jan bodnar
# website: www.zetcode.com
# last modified: June 2009

require 'gtk2'


class RubyApp &lt; Gtk::Window

    def initialize
        super

        set_title "FontSelectionDialog"
        signal_connect "destroy" do 
            Gtk.main_quit 
        end

        init_ui

        set_default_size 300, 150
        set_window_position Gtk::Window::POS_CENTER

        show_all
    end

    def init_ui

        set_border_width 10
        @label = Gtk::Label.new "The only victory over love is flight."
        button = Gtk::Button.new "Select font"

        button.signal_connect "clicked" do
            on_clicked
        end

        fix = Gtk::Fixed.new
        fix.put button, 100, 30
        fix.put @label, 30, 90
        add fix

    end

    def on_clicked
        fdia = Gtk::FontSelectionDialog.new "Select font name"
        response = fdia.run

        if response == Gtk::Dialog::RESPONSE_OK
            font_desc = Pango::FontDescription.new fdia.font_name
            if font_desc
                @label.modify_font font_desc
            end
        end
        fdia.destroy
    end     
end

Gtk.init
    window = RubyApp.new
Gtk.main
</code></pre>


<p>这个代码例子我们创建了一个按钮和一个标签。点击按钮之后显示字体选择对话框。</p>


<pre><code>fdia = Gtk::FontSelectionDialog.new "Select font name"
</code></pre>


<p>创建<em>FontSelectionDialog</em>。</p>


<pre><code>if response == Gtk::Dialog::RESPONSE_OK
    font_desc = Pango::FontDescription.new fdia.font_name
    if font_desc
        @label.modify_font font_desc
    end
end
</code></pre>


<p>如果点击确定按钮，标签的字体会变为我们在对话框中选中的。<br>
<img alt="image6" src="http://zetcode.com/img/gui/rubygtk/fontdialog.png"><br>
<em>图片：FontSelectionDialog</em></p>


<h2>颜色选择对话框</h2>


<p>ColorSelectionDialog是用于选择颜色的对话框。</p>


<pre><code>#!/usr/bin/ruby

# ZetCode Ruby GTK tutorial
#
# This example works with the
# ColorSelectionDialog
#
# author: jan bodnar
# website: www.zetcode.com
# last modified: June 2009

require 'gtk2'


class RubyApp &lt; Gtk::Window

    def initialize
        super

        set_title "ColorSelectionDialog"
        signal_connect "destroy" do 
            Gtk.main_quit 
        end

        init_ui

        set_default_size 350, 150
        set_window_position Gtk::Window::POS_CENTER

        show_all
    end

    def init_ui

        set_border_width 10
        @label = Gtk::Label.new "The only victory over love is flight."
        button = Gtk::Button.new "Select color"

        button.signal_connect "clicked" do
            on_clicked
        end

        fix = Gtk::Fixed.new
        fix.put button, 100, 30
        fix.put @label, 30, 90
        add fix
    end

    def on_clicked
        cdia = Gtk::ColorSelectionDialog.new "Select color"
        response = cdia.run

        if response == Gtk::Dialog::RESPONSE_OK
            colorsel = cdia.colorsel
            color = colorsel.current_color
            @label.modify_fg Gtk::STATE_NORMAL, color
        end

        cdia.destroy
    end
end

Gtk.init
    window = RubyApp.new
Gtk.main
</code></pre>


<p>这个例子与前一个例子很相似。这次我们是改变标签的颜色。</p>


<pre><code>cdia = Gtk::ColorSelectionDialog.new "Select color"
</code></pre>


<p>创建ColorSelectionDialog。</p>


<pre><code>if response == Gtk::Dialog::RESPONSE_OK
    colorsel = cdia.colorsel
    color = colorsel.current_color
    @label.modify_fg Gtk::STATE_NORMAL, color
end
</code></pre>


<p>如果按下OK按钮，我们得到颜色值并修改标签的颜色。</p>


<p><img alt="image7" src="http://zetcode.com/img/gui/rubygtk/colordialog.png"><br>
<em>图片：ColorSelectionDialog</em></p>


<p>这部分的Ruby GTK教程我们展示了对话框。</p>


<hr>


<p>原文地址： <a href="http://zetcode.com/gui/rubygtk/dialogs/">http://zetcode.com/gui/rubygtk/dialogs/</a><br>
翻译：龙昌  admin@longchangjin.cn </p>

</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
    <h1 class="entry-title"><a href="http://www.xefan.com/archives/83963.html">[翻译]Ruby GTK教程4——菜单&工具条</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2013-11-23T00:00:00+08:00'><span class='date'><span class='date-month'>Nov</span> <span class='date-day'>23</span><span class='date-suffix'>rd</span>, <span class='date-year'>2013</span></span> <span class='time'>12:00 am</span></time>
        
           | <a href="http://www.xefan.com/archives/83963.html#disqus_thread"
             data-disqus-identifier="http://www.xefan.com/archives/83963.html">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><h1>菜单&amp;工具条</h1>


<p>这部分的Ruby GTK教程我们将使用菜单和工具条。</p>


<p>菜单栏是GUI应用中最常用的部分之一。它是位于各个菜单的一组命令。在命令行应用程序中我们需要记住这些所有神秘的命令，而现在我们将这些大部分的命令按照逻辑归合在一起。接受这些标准将进一步减少在学习新应用上花费的时间。</p>


<h2>简单的菜单</h2>


<p>我们的第一个例子将创建一个有文件菜单的菜单栏。这个菜单只有一个菜单项，选择这一项将退出应用。</p>


<pre><code>#!/usr/bin/ruby

# ZetCode Ruby GTK tutorial
#
# This example shows a simple menu
#
# author: jan bodnar
# website: www.zetcode.com
# last modified: June 2009

require 'gtk2'


class RubyApp &lt; Gtk::Window

    def initialize
        super

        set_title "Simple menu"
        signal_connect "destroy" do 
            Gtk.main_quit 
        end

        init_ui

        set_default_size 250, 200
        set_window_position Gtk::Window::POS_CENTER

        show_all
    end

    def init_ui

        modify_bg Gtk::STATE_NORMAL, Gdk::Color.new(6400, 6400, 6440)

        mb = Gtk::MenuBar.new

        filemenu = Gtk::Menu.new
        filem = Gtk::MenuItem.new "File"
        filem.set_submenu filemenu

        exit = Gtk::MenuItem.new "Exit"
        exit.signal_connect "activate" do
            Gtk.main_quit
        end

        filemenu.append exit

        mb.append filem

        vbox = Gtk::VBox.new false, 2
        vbox.pack_start mb, false, false, 0

        add vbox
    end
end

Gtk.init
    window = RubyApp.new
Gtk.main
</code></pre>


<p>这是一个最小功能的菜单栏的例子。</p>


<pre><code>mb = Gtk::MenuBar.new
</code></pre>


<p>创建<em>MenuBar</em>控件，这是菜单的容器。</p>


<pre><code>filemenu = Gtk::Menu.new
filem = Gtk::MenuItem.new "File"
filem.set_submenu filemenu
</code></pre>


<p>创建顶级菜单项。</p>


<pre><code>exit = Gtk::MenuItem.new "Exit"
exit.signal_connect "activate" do
    Gtk.main_quit
end

filemenu.append exit
</code></pre>


<p>创建退出菜单项并添加到文件菜单项中。</p>


<pre><code>mb.append filem
</code></pre>


<p>将顶级菜单项添加到菜单栏控件中。</p>


<pre><code>vbox = Gtk::VBox.new false, 2
vbox.pack_start mb, false, false, 0
</code></pre>


<p>与其他套件不同，我们必须要自己处理菜单栏的布局。我们将菜单栏放入竖直盒子中。</p>


<p><img alt="image1" src="http://zetcode.com/img/gui/rubygtk/simplemenu.png"> <br>
<em>图片：简单的菜单</em></p>


<h2>子菜单</h2>


<p>最后展示如何创建一个子菜单。</p>


<pre><code>#!/usr/bin/ruby

# ZetCode Ruby GTK tutorial
#
# This example shows a submenu
#
# author: jan bodnar
# website: www.zetcode.com
# last modified: June 2009

require 'gtk2'


class RubyApp &lt; Gtk::Window

    def initialize
        super

        set_title "Submenu"
        signal_connect "destroy" do 
            Gtk.main_quit 
        end

        init_ui

        set_default_size 250, 200
        set_window_position Gtk::Window::POS_CENTER

        show_all
    end

    def init_ui

        modify_bg Gtk::STATE_NORMAL, Gdk::Color.new(6400, 6400, 6440)

        mb = Gtk::MenuBar.new

        filemenu = Gtk::Menu.new
        filem = Gtk::MenuItem.new "File"
        filem.set_submenu filemenu

        mb.append filem

        imenu = Gtk::Menu.new

        importm = Gtk::MenuItem.new "Import"
        importm.set_submenu imenu

        inews = Gtk::MenuItem.new "Import news feed..."
        ibookmarks = Gtk::MenuItem.new "Import bookmarks..."
        imail = Gtk::MenuItem.new "Import mail..."

        imenu.append inews
        imenu.append ibookmarks
        imenu.append imail

        filemenu.append importm

        exit = Gtk::MenuItem.new "Exit"
        exit.signal_connect "activate" do
            Gtk.main_quit
        end

        filemenu.append exit

        vbox = Gtk::VBox.new false, 2
        vbox.pack_start mb, false, false, 0

        add vbox
    end
end

Gtk.init
    window = RubyApp.new
Gtk.main
</code></pre>


<p>创建子菜单。</p>


<pre><code>imenu = Gtk::Menu.new
</code></pre>


<p>子菜单也是Menu控件。</p>


<pre><code>importm = Gtk::MenuItem.new "Import"
importm.set_submenu imenu
</code></pre>


<p>这是属于文件顶级菜单的菜单项的子菜单。</p>


<pre><code>inews = Gtk::MenuItem.new "Import news feed..."
ibookmarks = Gtk::MenuItem.new "Import bookmarks..."
imail = Gtk::MenuItem.new "Import mail..."

imenu.append inews
imenu.append ibookmarks
imenu.append imail
</code></pre>


<p>子菜单有自己的菜单项。</p>


<p><img alt="image2" src="http://zetcode.com/img/gui/rubygtk/submenu.png"><br>
<em>图片：子菜单</em></p>


<h2>图片菜单</h2>


<p>接下来的例子我们将进一步探索菜单。我们将在菜单项上添加图片和快捷键（accelerators）。</p>


<pre><code>#!/usr/bin/ruby

# ZetCode Ruby GTK tutorial
#
# This example shows a menu with
# images, accelerators and a separator
#
# author: jan bodnar
# website: www.zetcode.com
# last modified: June 2009

require 'gtk2'


class RubyApp &lt; Gtk::Window

    def initialize
        super

        set_title "Image menu"
        signal_connect "destroy" do 
            Gtk.main_quit 
        end

        init_ui

        set_default_size 250, 200
        set_window_position Gtk::Window::POS_CENTER

        show_all
    end

    def init_ui

        modify_bg Gtk::STATE_NORMAL, Gdk::Color.new(6400, 6400, 6440)

        mb = Gtk::MenuBar.new

        filemenu = Gtk::Menu.new
        filem = Gtk::MenuItem.new "File"
        filem.set_submenu filemenu

        agr = Gtk::AccelGroup.new
        add_accel_group agr

        newi = Gtk::ImageMenuItem.new Gtk::Stock::NEW, agr
        key, mod = Gtk::Accelerator.parse "N"
        newi.add_accelerator("activate", agr, key, 
            mod, Gtk::ACCEL_VISIBLE)
        filemenu.append newi

        openm = Gtk::ImageMenuItem.new Gtk::Stock::OPEN, agr
        key, mod = Gtk::Accelerator.parse "O"
        openm.add_accelerator("activate", agr, key, 
            mod, Gtk::ACCEL_VISIBLE)
        filemenu.append openm

        sep = Gtk::SeparatorMenuItem.new
        filemenu.append sep

        exit = Gtk::ImageMenuItem.new Gtk::Stock::QUIT, agr
        key, mod = Gtk::Accelerator.parse "Q"
        exit.add_accelerator("activate", agr, key, 
            mod, Gtk::ACCEL_VISIBLE)

        exit.signal_connect "activate" do
            Gtk.main_quit
        end
        filemenu.append exit

        mb.append filem

        vbox = Gtk::VBox.new false, 2
        vbox.pack_start mb, false, false, 0

        add vbox
    end
end

Gtk.init
    window = RubyApp.new
Gtk.main
</code></pre>


<p>这个例子显示了一个有子菜单的顶级菜单，每个菜单项都有一个图像和一个快捷键。退出菜单的快捷键是激活的。</p>


<pre><code>agr = Gtk::AccelGroup.new
add_accel_group agr
</code></pre>


<p>为了使用快捷键，我们创建了一个全局的<em>AccelGroup</em>对象。它稍后被用到。</p>


<pre><code>newi = Gtk::ImageMenuItem.new Gtk::Stock::NEW, agr
key, mod = Gtk::Accelerator.parse "N"
newi.add_accelerator("activate", agr, key, 
    mod, Gtk::ACCEL_VISIBLE)
filemenu.append newi
</code></pre>


<p>创建图片菜单项。图片来自图片库中。我们也创建了<em>Ctrl+N</em>快捷键。</p>


<pre><code>sep = Gtk::SeparatorMenuItem.new
filemenu.append sep
</code></pre>


<p>这行创建一条分隔线。它用于将菜单项按照逻辑分组。</p>


<p><img alt="image3" src="http://zetcode.com/img/gui/rubygtk/imagemenu.png"><br>
<em>图片：图片菜单</em></p>


<p>菜单将我们使用的命令进行分组。工具条提供了一个快速访问最常用命令的方式。</p>


<h2>简单的工具条</h2>


<p>接下来我们创建一个简单的工具条。</p>


<pre><code>#!/usr/bin/ruby

# ZetCode Ruby GTK tutorial
#
# This example shows a toolbar
# widget
#
# author: jan bodnar
# website: www.zetcode.com
# last modified: June 2009

require 'gtk2'


class RubyApp &lt; Gtk::Window

    def initialize
        super

        set_title "Toolbar"
        signal_connect "destroy" do 
            Gtk.main_quit 
        end

        init_ui

        set_default_size 250, 200
        set_window_position Gtk::Window::POS_CENTER

        show_all
    end

    def init_ui

        toolbar = Gtk::Toolbar.new
        toolbar.set_toolbar_style Gtk::Toolbar::Style::ICONS

        newtb = Gtk::ToolButton.new Gtk::Stock::NEW
        opentb = Gtk::ToolButton.new Gtk::Stock::OPEN
        savetb = Gtk::ToolButton.new Gtk::Stock::SAVE
        sep = Gtk::SeparatorToolItem.new
        quittb = Gtk::ToolButton.new Gtk::Stock::QUIT

        toolbar.insert 0, newtb
        toolbar.insert 1, opentb
        toolbar.insert 2, savetb
        toolbar.insert 3, sep
        toolbar.insert 4, quittb

        quittb.signal_connect "clicked" do
            Gtk.main_quit
        end

        vbox = Gtk::VBox.new false, 2
        vbox.pack_start toolbar, false, false, 0

        add(vbox)
    end
end

Gtk.init
    window = RubyApp.new
Gtk.main
</code></pre>


<p>这个例子显示了有四个工具按钮的工具栏。</p>


<pre><code>toolbar = Gtk::Toolbar.new
</code></pre>


<p>创建<em>Toolbar</em>控件。</p>


<pre><code>toolbar.set_toolbar_style Gtk::Toolbar::Style::ICONS
</code></pre>


<p>工具栏上我们只显示图标，没有文字。</p>


<pre><code>newtb = Gtk::ToolButton.new Gtk::Stock::NEW
</code></pre>


<p>创建了一个包含图片的ToolButton控件。图片来自内建的图片库。</p>


<pre><code>sep = Gtk::SeparatorToolItem.new
</code></pre>


<p>这是一个分隔符，用于将按钮按照逻辑分组。</p>


<pre><code>toolbar.insert 0, newtb
toolbar.insert 1, opentb
...
</code></pre>


<p>将按钮添加到工具栏。</p>


<p><img alt="image4" src="http://zetcode.com/img/gui/rubygtk/toolbar.png"><br>
<em>图片：工具栏</em></p>


<h2>撤消重做</h2>


<p>接下来的例子展示了如何停用工具栏上的按钮。这是GUI编程中的常见练习。例如对于保存按钮，在大多数编辑器中如果我们将文档的修改保存到磁盘中了，那么保存按钮会被停用。这是应用程序给用户的提示，所有修改都已保存。</p>


<pre><code>#!/usr/bin/ruby

# ZetCode Ruby GTK tutorial
#
# This example shows how to 
# activate/deactivate a ToolButton
#
# author: jan bodnar
# website: www.zetcode.com
# last modified: June 2009

require 'gtk2'


class RubyApp &lt; Gtk::Window


    def initialize
        super

        set_title "Undo redo"
        signal_connect "destroy" do 
            Gtk.main_quit 
        end

        @count = 2

        init_ui

        set_default_size 250, 200
        set_window_position Gtk::Window::POS_CENTER

        show_all
    end

    def init_ui

        toolbar = Gtk::Toolbar.new
        toolbar.set_toolbar_style Gtk::Toolbar::Style::ICONS

        @undo = Gtk::ToolButton.new Gtk::Stock::UNDO
        @redo = Gtk::ToolButton.new Gtk::Stock::REDO
        sep = Gtk::SeparatorToolItem.new
        quit = Gtk::ToolButton.new Gtk::Stock::QUIT

        toolbar.insert 0, @undo
        toolbar.insert 1, @redo
        toolbar.insert 2, sep
        toolbar.insert 3, quit

        @undo.signal_connect "clicked" do
            on_undo
        end

        @redo.signal_connect "clicked" do
            on_redo
        end

        quit.signal_connect "clicked" do
            Gtk.main_quit
        end

        vbox = Gtk::VBox.new false, 2
        vbox.pack_start toolbar, false, false, 0

        self.add vbox

    end

    def on_undo

        @count = @count - 1

        if @count &lt;= 0
            @undo.set_sensitive false
            @redo.set_sensitive true
        end
    end


    def on_redo
        @count = @count + 1

        if @count &gt;= 5
            @redo.set_sensitive false
            @undo.set_sensitive true
        end
    end
end

Gtk.init
    window = RubyApp.new
Gtk.main
</code></pre>


<p>我们例子从GTK资源中创建了撤消和重做按钮。每个按钮点击多次后会被禁用，变为灰色。</p>


<pre><code>@count = 2
</code></pre>


<p><em>@count</em>变量用于描述按钮是禁用还是激活。</p>


<pre><code>@undo = Gtk::ToolButton.new Gtk::Stock::UNDO
@redo = Gtk::ToolButton.new Gtk::Stock::REDO
</code></pre>


<p>创建两个工具按钮，图片来自资源库。</p>


<pre><code>@undo.signal_connect "clicked" do
    on_undo
end
</code></pre>


<p>点击undo按钮触发<em>on_undo</em>方法。</p>


<pre><code>if @count &lt;= 0
    @undo.set_sensitive false
    @redo.set_sensitive true
end
</code></pre>


<p>我们使用<em>set_sensitive</em>方法激活或者禁用控件。</p>


<p><img alt="image5" src="http://zetcode.com/img/gui/rubygtk/undoredo.png"><br>
<em>图片：撤消重做</em></p>


<p>这章的Ruby GTK教程我们展示了如何使用菜单和工具栏。</p>


<hr>


<p>原文地址： <a href="http://zetcode.com/gui/rubygtk/menustoolbars/">http://zetcode.com/gui/rubygtk/menustoolbars/</a><br>
翻译：龙昌  admin@longchangjin.cn  </p>

</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
    <h1 class="entry-title"><a href="http://www.xefan.com/archives/83960.html">[翻译]Ruby GTK教程3——控件</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2013-11-23T00:00:00+08:00'><span class='date'><span class='date-month'>Nov</span> <span class='date-day'>23</span><span class='date-suffix'>rd</span>, <span class='date-year'>2013</span></span> <span class='time'>12:00 am</span></time>
        
           | <a href="http://www.xefan.com/archives/83960.html#disqus_thread"
             data-disqus-identifier="http://www.xefan.com/archives/83960.html">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><h1>控件</h1>


<p>在这部分的Ruby GTK编程教程中我们将提到一些控件。</p>


<p>控件是GUI应用程序的基本构成。这些年来一些控件成为了所有平台所有套件的标准。如按钮、复选框或者滚动条。GTK套件的理念是保持控件的数量为最小的数量级，一些特殊的控件需要创建为自定义GTK控件。</p>


<h2>复选按钮（CheckButton）</h2>


<p><em>CheckButton</em>是一个有两种状态的控件，开和关。开状态表示选中。它用于表示一些布尔属性。</p>


<pre><code>#!/usr/bin/ruby

# ZetCode Ruby GTK tutorial
#
# This program toggles the title of the
# window with the CheckButton widget
#
# author: jan bodnar
# website: www.zetcode.com
# last modified: April 2009

require 'gtk2'

class RubyApp &lt; Gtk::Window
    def initialize
        super

        set_title "CheckButton"
        signal_connect "destroy" do 
            Gtk.main_quit 
        end

        init_ui

        set_default_size 250, 200
        set_window_position Gtk::Window::POS_CENTER
        show_all
    end


    def init_ui

        fixed = Gtk::Fixed.new
        add fixed

        cb = Gtk::CheckButton.new "Show title"
        cb.set_active true
        cb.set_can_focus false
        cb.signal_connect("clicked") do |w|
            on_clicked(w)
        end

        fixed.put cb, 50, 50

    end

    def on_clicked sender

        if sender.active?
            self.set_title "Check Button"
        else
           self.set_title ""
        end
    end
end

Gtk.init
    window = RubyApp.new
Gtk.main
</code></pre>


<p>我们将根据复选按钮的状态在窗口的标题栏显示一个标题。</p>


<pre><code>cb = Gtk::CheckButton.new "Show title"
</code></pre>


<p>创建<em>CheckButton</em>控件。</p>


<pre><code>cb.set_active true
</code></pre>


<p>标题默认是可见的，因此我们将按钮默认选中。</p>


<pre><code>if sender.active?
    self.set_title "Check Button"
else
    self.set_title ""
end
</code></pre>


<p>如果按钮选中则显示标题。</p>


<p><img alt="image1" src="http://zetcode.com/img/gui/rubygtk/checkbutton.png"><br>
<em>图片：复选按钮</em></p>


<h2>标签（Label）</h2>


<p>Label控件用于显示文本。</p>


<pre><code>#!/usr/bin/ruby

# ZetCode Ruby GTK tutorial
#
# This example demonstrates the Label widget
#
# author: jan bodnar
# website: www.zetcode.com
# last modified: June 2009

require 'gtk2'

$lyrics = %{Meet you downstairs in the bar and heard
your rolled up sleeves and your skull t-shirt
You say why did you do it with him today?
and sniff me out like I was Tanqueray

cause you're my fella, my guy
hand me your stella and fly
by the time I'm out the door
you tear men down like Roger Moore

I cheated myself
like I knew I would
I told ya, I was trouble
you know that I'm no good}


class RubyApp &lt; Gtk::Window

    def initialize
        super

        set_title  "You know I'm no Good"
        signal_connect "destroy" do 
            Gtk.main_quit 
        end

        init_ui

        set_default_size 250, 200
        set_window_position Gtk::Window::POS_CENTER

        show_all
    end

    def init_ui

        set_border_width 10
        label = Gtk::Label.new $lyrics
        add label

    end
end

Gtk.init
    window = RubyApp.new
Gtk.main
</code></pre>


<p>例子在窗口上显示了一些歌词。</p>


<pre><code> $lyrics = %{Meet you downstairs in the bar and heard
 your rolled up sleeves and your skull t-shirt
 ...
</code></pre>


<p>创建一个多行文本。</p>


<pre><code>set_border_width 10
</code></pre>


<p>标签被一些空白空间包围着。</p>


<pre><code>label = Gtk::Label.new $lyrics
add label
</code></pre>


<p>创建标签并添加到窗口内。</p>


<p><img alt="image2" src="http://zetcode.com/img/gui/rubygtk/label.png"><br>
<em>图片：标签控件</em></p>


<h2>输入框（Entry）</h2>


<p>Entry是单行文本输入字段，用于文本数据的输入。</p>


<pre><code>#!/usr/bin/ruby

# ZetCode Ruby GTK tutorial
#
# This example demonstrates the Entry widget
#
# author: jan bodnar
# website: www.zetcode.com
# last modified: June 2009

require 'gtk2'


class RubyApp &lt; Gtk::Window

    def initialize
        super

        set_title "Entry"
        signal_connect "destroy" do 
            Gtk.main_quit 
        end

        init_ui

        set_default_size 250, 200
        set_window_position Gtk::Window::POS_CENTER

        show_all
    end

    def init_ui

        fixed = Gtk::Fixed.new

        label = Gtk::Label.new "..."
        fixed.put label, 60, 40

        entry = Gtk::Entry.new
        fixed.put entry, 60, 100

        entry.signal_connect "key-release-event" do |w, e|
            on_key_release(w, e, label)
        end

        add(fixed)
    end

    def on_key_release sender, event, label
        label.set_text sender.text
    end
end

Gtk.init
    window = RubyApp.new
Gtk.main
</code></pre>


<p>这个例子显示了一个输入控件和一个标签。我们在输入框输入的文本会立即在标签上显示。</p>


<pre><code>entry = Gtk::Entry.new
</code></pre>


<p>创建Entry控件。</p>


<pre><code>entry.signal_connect "key-release-event" do |w, e|
    on_key_release(w, e, label)
end
</code></pre>


<p>我们将<em>on_key_release</em>方法插到Entry控件的<em>key-release-event</em>事件中。</p>


<pre><code>def on_key_release sender, event, label
    label.set_text sender.text
end
</code></pre>


<p>从Entry控件获取文本并设置到标签中。</p>


<p><img alt="image3" src="http://zetcode.com/img/gui/rubygtk/entry.png"><br>
<em>图片：Entry控件</em></p>


<h2>图片（Image）</h2>


<p>Image控件用于显示图片。</p>


<pre><code>#!/usr/bin/ruby

# ZetCode Ruby GTK tutorial
#
# This example demonstrates the Image widget
#
# author: jan bodnar
# website: www.zetcode.com
# last modified: June 2009

require 'gtk2'


class RubyApp &lt; Gtk::Window

    def initialize
        super

        set_title "Red Rock"
        signal_connect "destroy" do 
            Gtk.main_quit 
        end

        init_ui

        set_default_size 250, 200
        set_window_position Gtk::Window::POS_CENTER

        show_all
    end

    def init_ui

        set_border_width 2

        begin
            image = Gtk::Image.new "redrock.png"
        rescue
            puts "cannot load image"
            exit
        end

        add image
    end

end

Gtk.init
    window = RubyApp.new
Gtk.main
</code></pre>


<p>我们例子在窗口上显示了一个图片。</p>


<pre><code>set_border_width 2
</code></pre>


<p>我们在图片周围添加一些空白边框。</p>


<pre><code>begin
    image = Gtk::Image.new "redrock.png"
rescue
    puts "cannot load image"
    exit
end
</code></pre>


<p>创建Image控件。IO操作容易出现错误，因此我们处理可能的异常。</p>


<pre><code>add image
</code></pre>


<p>将控件添加到容器中。</p>


<p><img alt="image4" src="http://zetcode.com/img/gui/rubygtk/image.jpg"><br>
<em>图片：Image控件</em></p>


<h2>下拉框（ComboBox）</h2>


<p>ComboBox控件允许用户从一个列表选项中进行选择。</p>


<pre><code>#!/usr/bin/ruby

# ZetCode Ruby GTK tutorial
#
# This example demonstrates the ComboBox widget
#
# author: jan bodnar
# website: www.zetcode.com
# last modified: June 2009

require 'gtk2'


class RubyApp &lt; Gtk::Window

    def initialize
        super

        set_title "ComboBox"
        signal_connect "destroy" do 
            Gtk.main_quit 
        end

        init_ui

        set_default_size 250, 200
        set_window_position Gtk::Window::POS_CENTER

        show_all
    end

    def init_ui

        fixed = Gtk::Fixed.new
        label = Gtk::Label.new '-'
        fixed.put label, 50, 140

        cb = Gtk::ComboBox.new
        cb.signal_connect "changed" do |w, e|
            on_changed(w, e, label)
        end

        cb.append_text 'Ubuntu'
        cb.append_text 'Mandriva'
        cb.append_text 'Redhat'
        cb.append_text 'Gento'
        cb.append_text 'Mint'

        fixed.put cb, 50, 30

        add fixed

    end

    def on_changed sender, event, label
        label.set_label sender.active_text
    end
end

Gtk.init
    window = RubyApp.new
Gtk.main
</code></pre>


<p>这个例子显示了一个下拉框和一个标签。下拉框列表有5个选项。它们是Linux发行版的名称。标签控件显示下拉列表选中的选项。</p>


<pre><code>cb = Gtk::ComboBox.new
</code></pre>


<p>创建下拉框。</p>


<pre><code>cb.append_text 'Ubuntu'
cb.append_text 'Mandriva'
cb.append_text 'Redhat'
cb.append_text 'Gento'
cb.append_text 'Mint'
</code></pre>


<p>填充数据。</p>


<pre><code>def on_changed sender, event, label
    label.set_label sender.active_text
end
</code></pre>


<p>在<em>on_changed</em>方法里，我们获取选中的文本并设置到标签中。</p>


<p><img alt="image5" src="http://zetcode.com/img/gui/rubygtk/combobox.png"><br>
<em>图片：下拉框</em></p>


<p>在这章的Ruby GTK教程中我们显示了一些基本的控件。</p>


<hr>


<p>原文地址： <a href="http://zetcode.com/gui/rubygtk/widgets/">http://zetcode.com/gui/rubygtk/widgets/</a><br>
翻译：龙昌  admin@longchangjin.cn  </p>

</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
    <h1 class="entry-title"><a href="http://www.xefan.com/archives/83957.html">[翻译]Ruby GTK教程2——布局管理</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2013-11-21T00:00:00+08:00'><span class='date'><span class='date-month'>Nov</span> <span class='date-day'>21</span><span class='date-suffix'>st</span>, <span class='date-year'>2013</span></span> <span class='time'>12:00 am</span></time>
        
           | <a href="http://www.xefan.com/archives/83957.html#disqus_thread"
             data-disqus-identifier="http://www.xefan.com/archives/83957.html">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><h1>布局管理</h1>


<p>这一章我们将展示如何布置窗口或者对话框中的控件。</p>


<p>当我设计应用程序的用户界面时，我们决定了将要使用哪些控件以及如何在应用程序中组织这些控件。为了组织我们的控件，我们使用了一些称为布局容器的特殊不可见控件。这一章我们将提到<em>Alignment</em>、<em>Fixed</em>、<em>VBox</em>和<em>Table</em>。</p>


<h2>Fixed</h2>


<p>Fixed窗口是将子控件放置在固定位置固定大小。这个容器不会执行自动布局管理。在大部分的应用程序中我们不使用这个容器。它用于一些特殊的地方，例如游戏、使用图表的特殊应用、可移动可变大小的组件（如电子表格中的图表）。以下是一些小例子。</p>


<pre><code>#!/usr/bin/ruby

# ZetCode Ruby GTK tutorial
#
# In this program, we lay out widgets
# using absolute positioning
#
# author: jan bodnar
# website: www.zetcode.com
# last modified: June 2009

require 'gtk2'


class RubyApp &lt; Gtk::Window

    def initialize
        super

        set_title "Fixed"
        signal_connect "destroy" do 
            Gtk.main_quit 
        end

        init_ui

        set_default_size 300, 280
        set_window_position Gtk::Window::POS_CENTER

        show_all
    end

    def init_ui

        modify_bg Gtk::STATE_NORMAL, Gdk::Color.new(6400, 6400, 6440)

        begin       
            bardejov = Gdk::Pixbuf.new "bardejov.jpg"
            rotunda = Gdk::Pixbuf.new "rotunda.jpg"
            mincol = Gdk::Pixbuf.new "mincol.jpg"
        rescue IOError =&gt; e
            puts e
            puts "cannot load images"
            exit
        end

        image1 = Gtk::Image.new bardejov
        image2 = Gtk::Image.new rotunda
        image3 = Gtk::Image.new mincol

        fixed = Gtk::Fixed.new

        fixed.put image1, 20, 20
        fixed.put image2, 40, 160
        fixed.put image3, 170, 50

        add fixed

    end
end

Gtk.init
    window = RubyApp.new
Gtk.main
</code></pre>


<p>在我们在例子中我们在窗口上显示了三张图片。我们明确的指定了这些图片的x、y坐标的位置。</p>


<pre><code>modify_bg Gtk::STATE_NORMAL, Gdk::Color.new(6400, 6400, 6440)
</code></pre>


<p>为了更好的显示体验，我们修改背景颜色为灰色。</p>


<pre><code>bardejov = Gdk::Pixbuf.new "bardejov.jpg"
</code></pre>


<p>从磁盘上加载图片为Pixbug对象。</p>


<pre><code>image1 = Gtk::Image.new bardejov
image2 = Gtk::Image.new rotunda
image3 = Gtk::Image.new mincol
</code></pre>


<p><em>Image</em>是用于显示图片的控件。在它的构造函数接收一个<em>Pixbuf</em>对象。</p>


<pre><code>fixed = Gtk::Fixed.new
</code></pre>


<p>创建一个Fixed容器。</p>


<pre><code>fixed.put image1, 20, 20
</code></pre>


<p>将第一张图片放在x=20，y=20的坐标位置上。</p>


<pre><code> add fixed
</code></pre>


<p>最后我们将Fixed窗口放入窗口中。</p>


<p><img alt="image1" src="http://zetcode.com/img/gui/rubygtk/fixed.png"><br>
<em>图片：Fixed</em></p>


<h2>按钮</h2>


<p>Alignment容器用于控件它的子控件的对齐和大小。</p>


<pre><code>#!/usr/bin/ruby

# ZetCode Ruby GTK tutorial
#
# In this program, we position two buttons
# in the bottom right corner of the window.
# We use horizontal and vertical boxes.
#
# author: jan bodnar
# website: www.zetcode.com
# last modified: June 2009

require 'gtk2'


class RubyApp &lt; Gtk::Window

    def initialize
        super

        set_title "Buttons"
        signal_connect "destroy" do 
            Gtk.main_quit 
        end

        init_ui

        set_default_size 260, 150
        set_window_position Gtk::Window::POS_CENTER

        show_all
    end

    def init_ui

        vbox = Gtk::VBox.new false, 5
        hbox = Gtk::HBox.new true, 3

        valign = Gtk::Alignment.new 0, 1, 0, 0
        vbox.pack_start valign

        ok = Gtk::Button.new "OK"
        ok.set_size_request 70, 30
        close = Gtk::Button.new "Close"

        hbox.add ok
        hbox.add close

        halign = Gtk::Alignment.new 1, 0, 0, 0
        halign.add hbox

        vbox.pack_start halign, false, false, 3

        add vbox
    end
end

Gtk.init
    window = RubyApp.new
Gtk.main
</code></pre>


<p>这个例子的代码中，我们将两个按钮放置在窗口的右下角。为了实现这个功能我们使用了两个垂直盒子和一个水平盒子和两个对齐容器。</p>


<pre><code>valign = Gtk::Alignment.new 0, 1, 0, 0
</code></pre>


<p>这会将子控件放置在底部。</p>


<pre><code>vbox.pack_start valign
</code></pre>


<p>这里我们将Alignment控件放置在竖直例子中。</p>


<pre><code>hbox = Gtk::HBox.new true, 3 
...
ok = Gtk::Button.new "OK"
ok.set_size_request 70, 30
close = Gtk::Button.new "Close"

hbox.add ok
hbox.add close
</code></pre>


<p>创建一个水平盒子并放入两个按钮。</p>


<pre><code>halign = Gtk::Alignment.new 1, 0, 0, 0
halign.add hbox

vbox.pack_start halign, false, false, 3
</code></pre>


<p>这将会创建一个对齐容器用于将其子控件放置在右边。我们将水平盒子放入对齐容器里并将对齐容器放入竖直盒子中。我们必须记住对齐容器只有一个子控件，这就是为什么我们要使用盒子容器。 <br>
<img alt="image2" src="http://zetcode.com/img/gui/rubygtk/buttons.png"><br>
<em>图片：按钮</em></p>


<h2>计算器框架</h2>


<p>Table控件将控件按行和列进行排序。</p>


<pre><code>#!/usr/bin/ruby

# ZetCode Ruby GTK tutorial
#
# In this program we create a skeleton of
# a calculator. We use the Table widget. 
#
# author: jan bodnar
# website: www.zetcode.com
# last modified: June 2009

require 'gtk2'


class RubyApp &lt; Gtk::Window

    def initialize
        super

        set_title "Calculator"
        signal_connect "destroy" do 
            Gtk.main_quit 
        end

        init_ui

        set_default_size 300, 250
        set_window_position Gtk::Window::POS_CENTER

        show_all
    end

    def init_ui

        vbox = Gtk::VBox.new false, 2

        mb = Gtk::MenuBar.new
        filemenu = Gtk::Menu.new
        file = Gtk::MenuItem.new "File"
        file.set_submenu filemenu
        mb.append file

        vbox.pack_start mb, false, false, 0

        table = Gtk::Table.new 5, 4, true

        table.attach Gtk::Button.new("Cls"), 0, 1, 0, 1
        table.attach Gtk::Button.new("Bck"), 1, 2, 0, 1
        table.attach Gtk::Label.new, 2, 3, 0, 1
        table.attach Gtk::Button.new("Close"), 3, 4, 0, 1

        table.attach Gtk::Button.new("7"), 0, 1, 1, 2
        table.attach Gtk::Button.new("8"), 1, 2, 1, 2
        table.attach Gtk::Button.new("9"), 2, 3, 1, 2
        table.attach Gtk::Button.new("/"), 3, 4, 1, 2

        table.attach Gtk::Button.new("4"), 0, 1, 2, 3
        table.attach Gtk::Button.new("5"), 1, 2, 2, 3
        table.attach Gtk::Button.new("6"), 2, 3, 2, 3
        table.attach Gtk::Button.new("*"), 3, 4, 2, 3

        table.attach Gtk::Button.new("1"), 0, 1, 3, 4
        table.attach Gtk::Button.new("2"), 1, 2, 3, 4
        table.attach Gtk::Button.new("3"), 2, 3, 3, 4
        table.attach Gtk::Button.new("-"), 3, 4, 3, 4

        table.attach Gtk::Button.new("0"), 0, 1, 4, 5
        table.attach Gtk::Button.new("."), 1, 2, 4, 5
        table.attach Gtk::Button.new("="), 2, 3, 4, 5
        table.attach Gtk::Button.new("+"), 3, 4, 4, 5

        vbox.pack_start Gtk::Entry.new, false, false, 0

        vbox.pack_end table, true, true, 0

        add vbox

    end
end

Gtk.init
    window = RubyApp.new
Gtk.main
</code></pre>


<p>我们使用Table控件来创建计算器的框架。</p>


<pre><code>table = Gtk::Table.new 5, 4, true
</code></pre>


<p>我们创建了一个有5行4列的表格控件。第三个参数是homogenous参数。如果设置为true那么表格中的所有控件都是一样大小的。控件的大小等于表格容器中最大的那个控件。</p>


<pre><code>table.attach Gtk::Button.new("Cls"), 0, 1, 0, 1
</code></pre>


<p>我们将一个按钮附加到表格容器的左上角。前两个参数是单元格的左右边界，后两个参数是单元格的上下边界。</p>


<pre><code>vbox.pack_end table, true, true, 0
</code></pre>


<p>将表格控件打包放入竖直盒子里。<br>
<img alt="image3" src="http://zetcode.com/img/gui/rubygtk/calculator.png">  <br>
<em>图片：计算器框架</em></p>


<h2>窗口</h2>


<p>接下来我们创建一个更高级的例子。我们展示一个JDeveloper IDE中的窗口。</p>


<pre><code>#!/usr/bin/ruby

# ZetCode Ruby GTK tutorial
#
# This is a more complicated layout example.
# We use Alignment and Table widgets. 
#
# author: jan bodnar
# website: www.zetcode.com
# last modified: June 2009

require 'gtk2'


class RubyApp &lt; Gtk::Window

    def initialize
        super

        set_title "Windows"
        signal_connect "destroy" do 
            Gtk.main_quit 
        end

        init_ui

        set_default_size 300, 250
        set_window_position Gtk::Window::POS_CENTER

        show_all
    end

    def init_ui

        set_border_width 15

        table = Gtk::Table.new 8, 4, false
        table.set_column_spacings 3

        title = Gtk::Label.new "Windows"

        halign = Gtk::Alignment.new 0, 0, 0, 0
        halign.add title

        table.attach(halign, 0, 1, 0, 1, Gtk::FILL,
            Gtk::FILL, 0, 0)

        frame = Gtk::Frame.new
        table.attach(frame, 0, 2, 1, 3, Gtk::FILL | Gtk::EXPAND,
            Gtk::FILL | Gtk::EXPAND, 1, 1)

        activate = Gtk::Button.new "Activate"
        activate.set_size_request 50, 30
        table.attach(activate, 3, 4, 1, 2, Gtk::FILL,
            Gtk::SHRINK, 1, 1)

        valign = Gtk::Alignment.new 0, 0, 0, 0
        close = Gtk::Button.new "Close"
        close.set_size_request 70, 30
        valign.add close
        table.set_row_spacing 1, 3
        table.attach(valign, 3, 4, 2, 3, Gtk::FILL,
            Gtk::FILL | Gtk::EXPAND, 1, 1)

        halign2 = Gtk::Alignment.new 0, 1, 0, 0
        help = Gtk::Button.new "Help"
        help.set_size_request 70, 30
        halign2.add help
        table.set_row_spacing 3, 6
        table.attach(halign2, 0, 1, 4, 5, Gtk::FILL,
            Gtk::FILL, 0, 0)

        ok = Gtk::Button.new "OK"
        ok.set_size_request 70, 30
        table.attach(ok, 3, 4, 4, 5, Gtk::FILL,
            Gtk::FILL, 0, 0)

        add table
    end
end

Gtk.init
    window = RubyApp.new
Gtk.main
</code></pre>


<p>这个例子展示了我们如何可以使用Ruby GTK创建一个类似的窗口。</p>


<pre><code>table = Gtk::Table.new 8, 4, false
table.set_column_spacings 3
</code></pre>


<p>这个例子是基于Table容器的。每个列之间有3像素的空隙。</p>


<pre><code>title = Gtk::Label.new "Windows"

halign = Gtk::Alignment.new 0, 0, 0, 0
halign.add title

table.attach(halign, 0, 1, 0, 1, Gtk::FILL,
    Gtk::FILL, 0, 0)
</code></pre>


<p>这个代码创建了一个左对齐的标签。这个标签放置在表格的第一行中。</p>


<pre><code>frame = Gtk::Frame.new
table.attach(frame, 0, 2, 1, 3, Gtk::FILL | Gtk::EXPAND,
    Gtk::FILL | Gtk::EXPAND, 1, 1)
</code></pre>


<p><em>frame</em>控件跨度为2行2列。</p>


<pre><code>valign = Gtk::Alignment.new 0, 0, 0, 0
close = Gtk::Button.new "Close"
close.set_size_request 70, 30
valign.add close
table.set_row_spacing 1, 3
table.attach(valign, 3, 4, 2, 3, Gtk::FILL,
    Gtk::FILL | Gtk::EXPAND, 1, 1)
</code></pre>


<p>我们将关闭按钮放置在<em>frame</em>控件的下一个位置，在表格的第4列（我们是从0算起）。我们将按钮放在对齐控件内，这样我们就可以顶对齐了。</p>


<p><img alt="image4" src="http://zetcode.com/img/gui/rubygtk/windows.png"><br>
<em>图片：窗口</em></p>


<p>这部分的Ruby GTK教程，我们提到了布局控件。</p>


<hr>


<p>原文地址： <a href="http://zetcode.com/gui/rubygtk/layoutmanagement/">http://zetcode.com/gui/rubygtk/layoutmanagement/</a><br>
翻译：龙昌  admin@longchangjin.cn  </p>

</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
    <h1 class="entry-title"><a href="http://www.xefan.com/archives/83954.html">[翻译]Ruby GTK教程1——介绍</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2013-11-20T00:00:00+08:00'><span class='date'><span class='date-month'>Nov</span> <span class='date-day'>20</span><span class='date-suffix'>th</span>, <span class='date-year'>2013</span></span> <span class='time'>12:00 am</span></time>
        
           | <a href="http://www.xefan.com/archives/83954.html#disqus_thread"
             data-disqus-identifier="http://www.xefan.com/archives/83954.html">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><h1>Ruby GTK介绍</h1>


<p>在这部分的Ruby GTK编程教程中，我偿将介绍GTK库并且使用Ruby语言编写我们的第一个程序。</p>


<p>这个教程的目标是让你入门GTK和Ruby。贪吃蛇游戏的图片可以从这里<a href="http://zetcode.com/img/gui/rubygtk/images.zip">下载</a>。</p>


<h2>关于</h2>


<p>GTK是一个领先的创建图形化用户界面的套件。Ruby是一个流行的脚本语言。</p>


<h2>简单的例子</h2>


<p>第一个例子我们创建一个简单的窗口。这个窗口位置屏幕中间。</p>


<pre><code>#!/usr/bin/ruby

# ZetCode Ruby GTK tutorial
#
# This program centers a window on 
# the screen
#
# author: jan bodnar
# website: www.zetcode.com
# last modified: April 2009

require 'gtk2'

class RubyApp &lt; Gtk::Window

    def initialize
        super

        set_title "Center"
        signal_connect "destroy" do 
            Gtk.main_quit 
        end

        set_default_size 250, 200
        set_window_position Gtk::Window::POS_CENTER

        show
    end
end

Gtk.init
    window = RubyApp.new
Gtk.main
</code></pre>


<p>这个例子在屏幕中间显示了一个250x200像素的窗口。</p>


<pre><code>require 'gtk2'
</code></pre>


<p><em>require</em>关键字导入了这个应用程序中将要使用的类。</p>


<pre><code>class RubyApp &lt; Gtk::Window
</code></pre>


<p>这个例子继承自<em>Window</em>。<em>Window</em>是一个顶级容器。</p>


<pre><code>set_title "Center"
</code></pre>


<p>设置窗口的标题。</p>


<pre><code>signal_connect "destroy" do 
    Gtk.main_quit 
end
</code></pre>


<p>当我们点击标题栏的关闭按钮或者按下Alt+F4时<em>destroy</em>事件被触发。<em>main_quit</em>正常退出应用程序。</p>


<pre><code>set_default_size 250, 200
</code></pre>


<p>设置应用程序窗口的默认大小。</p>


<pre><code>set_window_position Gtk::Window::POS_CENTER
</code></pre>


<p>将窗口放置在屏幕中间。</p>


<pre><code>show
</code></pre>


<p>一些就绪，我们在屏幕上显示该窗口。</p>


<pre><code>Gtk.init
    window = RubyApp.new
Gtk.main
</code></pre>


<p>这三行启动应用程序。</p>


<h2>创建提示框</h2>


<p>第二个例子我们将显示一个提示框。提示框(Tooltip)是一个小的矩形窗口用于显示一些简洁的提示信息。它是一个常用的GUI组件。它是应用程序帮助系统的一部分。</p>


<pre><code>#!/usr/bin/ruby

# ZetCode Ruby GTK tutorial
#
# This code shows a tooltip on 
# a window and a button
#
# author: jan bodnar
# website: www.zetcode.com
# last modified: June 2009

require 'gtk2'

class RubyApp &lt; Gtk::Window

    def initialize
        super

        set_title  "Tooltips"
        signal_connect "destroy" do 
            Gtk.main_quit 
        end

        fixed = Gtk::Fixed.new
        add fixed

        button = Gtk::Button.new "Button"
        button.set_size_request 80, 35      
        button.set_tooltip_text "Button widget"

        fixed.put button, 50, 50

        set_tooltip_text "Window widget"
        set_default_size 250, 200
        set_window_position Gtk::Window::POS_CENTER

        show_all

    end
end

Gtk.init
    window = RubyApp.new
Gtk.main
</code></pre>


<p>这个例子创建了一个窗口。如果我们将鼠标光标放在窗口的区域中，将会出现一个提示框。</p>


<pre><code>button.set_tooltip_text "Button widget"
</code></pre>


<p>我们使用<em>set_tooltip_text</em>方法设置一个提示框。</p>


<p><img alt="image1" src="http://zetcode.com/img/gui/rubygtk/tooltip.png"><br>
<em>图片：提示框</em></p>


<h2>退出按钮</h2>


<p>在这节的最后一个例子我们将创建一个退出按钮。当我们按下这个按钮时程序结束。</p>


<pre><code>#!/usr/bin/ruby

# ZetCode Ruby GTK tutorial
#
# This program creates a quit
# button. When we press the button,
# the application terminates. 
#
# author: jan bodnar
# website: www.zetcode.com
# last modified: June 2009

require 'gtk2'

class RubyApp &lt; Gtk::Window

    def initialize
        super

        set_title  "Quit button"
        signal_connect "destroy" do 
            Gtk.main_quit 
        end

        init_ui

        show_all
    end

    def init_ui

        fixed = Gtk::Fixed.new
        add fixed

        button = Gtk::Button.new "Quit"
        button.set_size_request 80, 35      
        button.signal_connect "clicked" do 
            Gtk.main_quit 
        end

        fixed.put button, 50, 50

        set_default_size 250, 200
        set_window_position Gtk::Window::POS_CENTER
    end
end

Gtk.init
    window = RubyApp.new
Gtk.main
</code></pre>


<p>我们使用一个按钮控件。这是一个非常平常的控件。它显示一个文本、图像或者两者都显示。</p>


<pre><code>init_ui
</code></pre>


<p>我们将用户接口的创建委派给<em>init_ui</em>方法。</p>


<pre><code>show_all
</code></pre>


<p>我们有两个选择。对每个控件都调用<em>show</em>，或者调用<em>show_all</em>显示容器的所有了子控件。</p>


<pre><code>button = Gtk::Button.new "Quit"
</code></pre>


<p>这里创建一个按钮控件。</p>


<pre><code>button.set_size_request 80, 35
</code></pre>


<p>设置按钮的大小。</p>


<pre><code>button.signal_connect "clicked" do 
    Gtk.main_quit 
end
</code></pre>


<p>我们将<em>main_quit</em>方法插入到按钮的点击事件中。</p>


<pre><code>fixed.put button, 50, 50
</code></pre>


<p>将退出按钮放在<em>fixed</em>容器的x=50，y=50的位置。
<img alt="image2" src="http://zetcode.com/img/gui/rubygtk/quitbutton.png"><br>
<em>图片：退出按钮</em></p>


<p>这一节我们介绍Ruby语言的GTK库。</p>


<hr>


<p>原文地址： <a href="http://zetcode.com/gui/rubygtk/introduction/">http://zetcode.com/gui/rubygtk/introduction/</a><br>
翻译：龙昌  admin@longchangjin.cn  </p>

</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
    <h1 class="entry-title"><a href="http://www.xefan.com/archives/83949.html">[翻译]Ruby教程15——输入&输出</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2013-11-18T00:00:00+08:00'><span class='date'><span class='date-month'>Nov</span> <span class='date-day'>18</span><span class='date-suffix'>th</span>, <span class='date-year'>2013</span></span> <span class='time'>12:00 am</span></time>
        
           | <a href="http://www.xefan.com/archives/83949.html#disqus_thread"
             data-disqus-identifier="http://www.xefan.com/archives/83949.html">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><h1>Ruby的输入&amp;输出</h1>


<p>这部分的教程我们讨论Ruby的输入和输出操作。输入是程序从键盘、文件或者其他程序读取数据。输出是程序产生数据。可以输出到屏幕、文件或者其他程序。</p>


<p>输入&amp;输出是一个大的话题。稍后我们通过一些例子来大概介绍一下这个主题。Ruby中的一些类有些方法会执行输入&amp;输出操作。例如Kernel、IO、Dir或者File。</p>


<h2>输出到终端</h2>


<p>Ruby有一些在终端上打印输出的方法。这些方法是Kernel模块的一部分。Kernel模块的方法对于所有的Ruby对象都是有效的。</p>


<pre><code>#!/usr/bin/ruby

print "Apple "
print "Apple\n"

puts "Orange"
puts "Orange"
</code></pre>


<p><em>print</em>和<em>puts</em>方法会将文本输出到终端。它们的不同是会在最后加上一个换行符。</p>


<pre><code>print "Apple "
print "Apple\n"
</code></pre>


<p><em>print</em>在终端上打印两个连续的&#8221;Apple&#8221;字符串。如果我们想换一行，我们就必须显示的包含一个换行符。换行符是&#8217;\n&#8217;。<em>print</em>方法实际上是调用了对象的<em>to_s</em>方法。</p>


<pre><code>puts "Orange"
puts "Orange"
</code></pre>


<p><em>puts</em>方法在终端上打印两个字符串。每一个都各在一行。这个方法会自己添加换行符。</p>


<p>$ ./printing.rb 
Apple Apple<br>
Orange<br>
Orange  </p>


<p><em>printing.rb</em>脚本的输出结果。</p>


<p>根据Ruby的文档，<em>print</em>方法与<em>$stdout.print</em>是等效的。<em>$stdout</em>是全局变量，保存的标准输出流。</p>


<pre><code>#!/usr/bin/ruby

$stdout.print "Ruby language\n"
$stdout.puts "Python language"
</code></pre>


<p>我们使用$stdout变量打印两行内容。</p>


<p>Ruby有另外三种输出方法。</p>


<pre><code>#!/usr/bin/ruby

p "Lemon"
p "Lemon"

printf "There are %d apples\n", 3

putc 'K'
putc 0xA
</code></pre>


<p>这个例子中，我们展示了p、printf和putc方法。</p>


<pre><code>p "Lemon"
</code></pre>


<p><em>p</em>会调用对象的<em>inspect</em>方法。这个方法对于调试很有用。</p>


<pre><code>printf "There are %d apples\n", 3
</code></pre>


<p><em>printf</em>方法因C语言而出名。它能够将字符串格式化。</p>


<pre><code>putc 'K'
putc 0xA
</code></pre>


<p><em>putc</em>方法在终端上打印一个字符。第二行是打印一个换行符。0xA是换行符的十六进制代码。</p>


<p>$ ./printing3.rb <br>
&#8220;Lemon&#8221;<br>
&#8220;Lemon&#8221;<br>
There are 3 apples<br>
K  </p>


<p>printing3.rb的输出。</p>


<p>使用Kernel的方法在终端上打印数据是简短方便的方式。接下来的例子展示了更多在终端上打印数据的正式方法。</p>


<pre><code>ios = IO.new STDOUT.fileno
ios.write "ZetCode\n"
ios.close
</code></pre>


<p>这个例子我们打开标准输出流并往其中写入字符串。</p>


<pre><code>ios = IO.new STDOUT.fileno
</code></pre>


<p><em>new</em>方法返回一个可写的数据流。这个方法传入一个文件描述符数字。<em>STDOUT.fileno</em>返回了标准输出流的文件描述符。我们也可以直接写2。</p>


<pre><code>ios.write "ZetCode\n"
</code></pre>


<p>我们往打开的数据流写入字符串。</p>


<pre><code>ios.close
</code></pre>


<p>关闭输出流。</p>


<p>在Unix系统中标准的终端输出是连接到一个特殊的文件/dev/tty。将其打开并写入数据，既是写到终端上。</p>


<pre><code>#!/usr/bin/ruby

fd = IO.sysopen "/dev/tty", "w"
ios = IO.new(fd, "w")
ios.puts "ZetCode"
ios.close
</code></pre>


<p>写入到/dev/tty文件的一个例子。这仅能够在Unix上运行。</p>


<pre><code>fd = IO.sysopen "/dev/tty", "w"
</code></pre>


<p><em>sysopen</em>方法打开指定目录的文件，返回最后的文件描述符。</p>


<pre><code>ios = IO.new(fd, "w")
</code></pre>


<p>文件描述符数字用于打开一个数据流。</p>


<pre><code>ios.puts "ZetCode"
ios.close
</code></pre>


<p>往数据流中写入字符串然后关闭它。</p>


<h2>从终端输入</h2>


<p>这一节我们将创建一些处理输入的代码例子。</p>


<p>$stdin是一个全局变量保存了标准输入流。它可以用于从终端输入数据。</p>


<pre><code>#!/usr/bin/ruby

inp = $stdin.read
puts inp
</code></pre>


<p>上面的代码，我们使用<em>read</em>方法从终端读取输入。</p>


<pre><code>inp = $stdin.read
</code></pre>


<p><em>read</em>方法从标准输入读取数据直到文件结尾。EOF在Unix中是使用Ctrl + D产生，在Windows中是Ctrl + Z。</p>


<p>$ ./reading.rb<br>
Ruby language<br>
Ruby language  </p>


<p>我们启动了程序，这个脚本会读取数据直到我们按下Ctrl + D 或者 Ctrl + Z。</p>


<p>$ echo &#8220;ZetCode&#8221; | ./reading.rb<br>
ZetCode  </p>


<p>$ ./input.rb &lt; stones <br>
Garnet<br>
Topaz<br>
Opal<br>
Amethyst<br>
Ruby<br>
Jasper<br>
Pyrite<br>
Malachite<br>
Quartz  </p>


<p>如果我们使用重定向，脚本可以从其他程序或者文件中读取数据。</p>


<p>通常从终端读取数据是使用<em>gets</em>方法。</p>


<pre><code>#!/usr/bin/ruby

print "Enter your name: "
name = gets
puts "Hello #{name}"
</code></pre>


<p>使用<em>gets</em>方法读取用户输入的一行数据。</p>


<pre><code>name = gets
</code></pre>


<p><em>gets</em>方法从标准输入读取数据并分配给<em>name</em>变量。</p>


<pre><code>puts "Hello #{name}"
</code></pre>


<p>打印输入的数据。</p>


<p>$ ./readline.rb<br>
Enter your name: Jan<br>
Hello Jan  </p>


<p>输出结果。</p>


<p>接下来的两个脚本我们讨论<em>chomp</em>方法。它是字符串方法，用于移除字符串结尾的空白。当我们执行输入操作时它很有用。这个方法名和用法来自Perl语言。</p>


<pre><code>#!/usr/bin/ruby

print "Enter a string: "
inp = gets

puts "The string has #{inp.size} characters"
</code></pre>


<p>读取一个用户输入的字符串，并计算它的长度。</p>


<p>$ ./nochomp.rb <br>
Enter a string: Ruby<br>
The string has 5 characters  </p>


<p>这个提示表示了这个字符串有5个字符，因为它统计的换行符。</p>


<p>为了得到正确的结果，我们需要移除换行符。这正是<em>chomp</em>方法的作用。</p>


<pre><code>#!/usr/bin/ruby

print "Enter a string: "
inp = gets.chomp

puts "The string has #{inp.size} characters"
</code></pre>


<p>这次我们使用<em>chomp</em>方法截掉了换行符。</p>


<p>$ ./chomp.rb <br>
Enter a string: Ruby<br>
The string has 4 characters  </p>


<p><em>Ruby</em>字符串有4个字符。</p>


<h2>文件</h2>


<p>从Ruby官方文档我们知道<em>IO</em>类是所有输入输出的基类。<em>File</em>类只是<em>IO</em>类的一个子类。这两个类是紧密相关的。</p>


<pre><code>#!/usr/bin/ruby

f = File.open('output.txt', 'w')
f.puts "The Ruby tutorial"
f.close
</code></pre>


<p>第一个例子我们打开一个文件并往里面写入一些数据。</p>


<pre><code>f = File.open('output.txt', 'w')
</code></pre>


<p>以写模式打开&#8217;output.txt&#8217;文件。<em>open</em>方法返回数据流。</p>


<pre><code>f.puts "The Ruby tutorial"
</code></pre>


<p>往上面打开的数据流写入数据。<em>puts</em>方法也可用于往文件写入数据。</p>


<pre><code>f.close
</code></pre>


<p>最后关闭数据流。</p>


<p>$ ./simplewrite.rb<br>
$ cat output.txt <br>
The Ruby tutorial  </p>


<p>执行脚本并显示output.txt文件的内容。</p>


<p>以下是一个类似的例子显示了额外的方法。</p>


<pre><code>#!/usr/bin/ruby

File.open('langs', 'w') do |f|

    f.puts "Ruby"
    f.write "Java\n"
    f &lt;&lt; "Python\n"

end
</code></pre>


<p>如果<em>open</em>方法之后是一个代码块，Ruby会将打开的数据流传递给这个代码块。最后这个文件会自动关闭。</p>


<pre><code>f.puts "Ruby"
f.write "Java\n"
f &lt;&lt; "Python\n"
</code></pre>


<p>我们使用了三个方法写文件。</p>


<p>$ ./simplewrite2.rb<br>
$ cat langs <br>
Ruby<br>
Java<br>
Python  </p>


<p>执行这个脚本并查看里面的内容。</p>


<p>第二个例子我们显示一些<em>File</em>类的方法。</p>


<pre><code>#!/usr/bin/ruby

puts File.exists? 'tempfile'

f = File.new 'tempfile', 'w'
puts File.mtime 'tempfile'
puts f.size

File.rename 'tempfile', 'tempfile2'

f.close
</code></pre>


<p>这个例子创建了一个新文件&#8217;tempfile&#8217;并调用了一些方法。</p>


<pre><code>puts File.exists? 'tempfile'
</code></pre>


<p><em>exists?</em>方法检查给定的文件是否存在。这行返回false，因为我们还没有创建这个文件。</p>


<pre><code>f = File.new 'tempfile', 'w'
</code></pre>


<p>创建文件。</p>


<pre><code>puts File.mtime 'tempfile'
</code></pre>


<p><em>mtime</em>方法返回这个文件的最后修改时间。</p>


<pre><code>puts f.size
</code></pre>


<p>查看文件的大小。这里返回0,因为我们还没有往文件写入数据。</p>


<pre><code>File.rename 'tempfile', 'tempfile2'
</code></pre>


<p>最后我们使用<em>rename</em>将文件重命名。</p>


<p>$ ./testfile.rb<br>
false<br>
2011-11-05 16:19:36 +0100<br>
0  </p>


<p>输出结果。</p>


<p>接下来我们从磁盘文件读取内容。</p>


<pre><code>#!/usr/bin/ruby

f = File.open("stones")

while line = f.gets do
    puts line
end

f.close
</code></pre>


<p>这是一个简单的脚本，打开<em>stones</em>文件并在终端上打印它的内容。</p>


<pre><code>f = File.open("stones")
</code></pre>


<p>打开&#8217;stones&#8217;文件，默认是只读模式。</p>


<pre><code>while line = f.gets do
    puts line
end
</code></pre>


<p><em>gets</em>方法从I/O数据流读取一行数据。当读到文件结尾时while代码块退出。</p>


<p>$ ./readlines2.rb<br>
Garnet<br>
Topaz<br>
Opal<br>
Amethyst<br>
Ruby<br>
Jasper<br>
Pyrite<br>
Malachite<br>
Quartz  </p>


<p>例子输出结果。</p>


<p>下一个例子将从文件读取数据。</p>


<pre><code>#!/usr/bin/ruby

fname = 'alllines.rb'

File.readlines(fname).each do |line|
    puts line
end
</code></pre>


<p>这个脚本显示了另一个读取文件内容的方式。这个例子将它自己的代码打印在终端上。</p>


<pre><code>File.readlines(fname).each do |line|
    puts line
end
</code></pre>


<p><em>readlines</em>读取指定文件的每一行内容，并作为数据返回。我们使用<em>each</em>方法遍历数组，并将其在终端上打印。</p>


<pre><code>$ ./alllines.rb
#!/usr/bin/ruby

fname = 'alllines.rb'

File.readlines(fname).each do |line|
    puts line
end
</code></pre>


<p>输出结果。</p>


<h2>目录</h2>


<p>在这一节我们使用目录。Ruby中有一个Dir类可以操作目录。</p>


<pre><code>#!/usr/bin/ruby

Dir.mkdir "tmp"
puts Dir.exists? "tmp"

puts Dir.pwd
Dir.chdir "tmp"
puts Dir.pwd

Dir.chdir '..'
puts Dir.pwd
Dir.rmdir "tmp"
puts Dir.exists? "tmp"
</code></pre>


<p>这个脚本我们使用了Dir类的四个方法。</p>


<pre><code>Dir.mkdir "tmp"
</code></pre>


<p><em>mkdir</em>方法创建一个新目录&#8217;tmp&#8217;。</p>


<pre><code>puts Dir.exists? "tmp"
</code></pre>


<p>使用<em>exists?</em>方法检查一个目录是否存在。</p>


<pre><code>puts Dir.pwd
</code></pre>


<p><em>pwd</em>方法打印当前的工作目录。这是我们启动脚本的目录。</p>


<pre><code>Dir.chdir '..'
</code></pre>


<p><em>chdir</em>方法切换目录。&#8217;..&#8217;目录是当前工作目录的父目录。</p>


<pre><code>Dir.rmdir "tmp"
puts Dir.exists? "tmp"
</code></pre>


<p>最后我们使用<em>rmdir</em>方法移除目录。这时<em>exists?</em>方法返回false。</p>


<p>$ ./dirs.rb<br>
true<br>
/home/vronskij/programming/ruby/io<br>
/home/vronskij/programming/ruby/io/tmp<br>
/home/vronskij/programming/ruby/io<br>
false  </p>


<p>例子的输出结果。
第二个例子我们检索目录所有的条目，包括文件和子目录。</p>


<pre><code>#!/usr/bin/ruby

fls = Dir.entries '.'
puts fls.inspect
</code></pre>


<p><em>entries</em> 方法返回指定目录的所有条目。</p>


<pre><code>fls = Dir.entries '.'
puts fls.inspect
</code></pre>


<p>我们得到了当前目录下的文件和目录数组。&#8217;.&#8217;代表当前工作目录。<em>inspect</em>方法使得数组更加可读。</p>


<p>$ ./allfiles.rb<br>
[&#8220;putc.rb&#8221;, &#8220;simplewrite.rb&#8221;, &#8220;readlines2.rb&#8221;, &#8220;fileexists.rb~&#8221; &#8230;  </p>


<p>输出结果。</p>


<p>第三个例子使用了home目录。每个计算机用户都有一个分配给他的唯一的目录，称为home目录。它是用于存放用户自己的文件。</p>


<pre><code>#!/usr/bin/ruby

puts Dir.home
puts Dir.home 'root'
</code></pre>


<p>这个脚本打印两个home目录。</p>


<pre><code>puts Dir.home
</code></pre>


<p>如果没有指定用户名则返回当前用户的home目录。当前用户是指定启动这个脚本文件的用户。</p>


<pre><code>puts Dir.home 'root'
</code></pre>


<p>这里我们指定了一个用户。</p>


<p>$ ./homedir.rb<br>
/home/vronskij<br>
/root  </p>


<p>输出结果。</p>


<h2>执行外部程序</h2>


<p>Ruby有一些方式可以执行外部程序。我们的例子中我们使用了Linux中有名的命令。Windows或者Mac读取可以使用他们自己系统的命令。</p>


<pre><code>#!/usr/bin/ruby

data = system 'ls'
puts data
</code></pre>


<p>调用<em>ls</em>命令列出目录内容。</p>


<pre><code>data = system 'ls'
</code></pre>


<p><em>system</em>命令在一个子shell中执行外部程序。这个方法是属于Kernel Ruby 模块的。</p>


<p>$ ./system.rb<br>
allfiles.rb   characters.rb  fileexists.rb   homedir.rb~ &#8230;  </p>


<p>输出结果。</p>


<p>我们展示另外两个执行外部程序的方式。</p>


<pre><code>#!/usr/bin/ruby

out = `pwd`
puts out

out = %x[uptime]
puts out

out = %x[ls | grep 'readline']
puts out
</code></pre>


<p>执行外部程序我们可以使用反引号&#8220;和%x[]字符。</p>


<pre><code>out = `pwd`
</code></pre>


<p>这里我们使用反引号执行<em>pwd</em>命令。这个命令返回当前的工作目录。</p>


<pre><code>out = %x[uptime]
</code></pre>


<p>这里我得到<em>uptime</em>命令的输出，它显示系统运行了多久。</p>


<pre><code>out = %x[ls | grep 'readline']
</code></pre>


<p>我们也可以使用复合命令。</p>


<p>$ ./system2.rb<br>
/home/vronskij/programming/ruby/io<br>
 22:50:50 up  5:32,  1 user,  load average: 0.46, 0.44, 0.45<br>
readline.rb<br>
readline.rb~<br>
readlines2.rb<br>
readlines2.rb~  </p>


<p>输出结果。</p>


<p>我们可以使用<em>open</em>方法执行命令。这个方法是属于Kernel模块的。它创建一个IO对象连接到指定的数据流、文件或者子进程。如果我们想要连接到子进程，我们将打开路径以管道符(|)开头。</p>


<pre><code>#!/usr/bin/ruby

f = open("|ls -l |head -3")
out = f.read
puts out
f.close

puts $?.success?
</code></pre>


<p>这个例子我们打印了<em>ls -l | head -3</em>命令的结果。我们也还检查了子进程的状态。</p>


<pre><code>f = open("|ls -l |head -3")
</code></pre>


<p>连接到子进程。</p>


<pre><code>out = f.read
puts out
</code></pre>


<p>读取并打印子进程的数据。</p>


<pre><code>f.close
</code></pre>


<p>关闭文件句柄。</p>


<pre><code>puts $?.success?
</code></pre>


<p><em>$?</em>是一个特殊的变量，设置为上次执行过的子进程。如果子进程成功退出<em>success?</em>方法返回true。</p>


<p>$ ./system3.rb<br>
total 148<br>
-rwxr-xr-x 1 vronskij vronskij   57 2011-10-30 23:33 allfiles.rb<br>
-rwxr-xr-x 1 vronskij vronskij   58 2011-10-30 23:33 allfiles.rb~<br>
true  </p>


<p>输出结果。</p>


<h2>重定向标准输出</h2>


<p>Ruby对标准输入、标准输出和标准错误输出都有预定义的全局变量。<em>$stdout</em> 是标准输出的变量名。</p>


<pre><code>#!/usr/bin/ruby

$stdout = File.open "output.log", "a"

puts "Ruby"
puts "Java"

$stdout.close
$stdout = STDOUT

puts "Python"
</code></pre>


<p>上面的例子我们将输出重定向到output.log文件。</p>


<pre><code>$stdout = File.open "output.log", "a"
</code></pre>


<p>这行创建一个新的标准输出。现在标准输出流向ouput.log文件。这个文件以追加方式打开，如果文件不存在则创建，否则打开并将数据追加到文件尾部。</p>


<pre><code>puts "Ruby"
puts "Java"
</code></pre>


<p>打印两个字符串。这些字符串不会像平常一样在终端上显示了。而是追加到output.log文件中。</p>


<pre><code>$stdout.close
</code></pre>


<p>关闭文件句柄。</p>


<pre><code>$stdout = STDOUT

puts "Python"
</code></pre>


<p>使用预定义的常量<em>STDOUT</em>重新创建正常的标准输出。&#8221;Python&#8221;字符串在终端上打印。</p>


<p>这部分的教程我们使用了输入和输出操作。</p>


<hr>


<p>原文地址： <a href="http://zetcode.com/lang/rubytutorial/io/">http://zetcode.com/lang/rubytutorial/io/</a><br>
翻译：龙昌  admin@longchangjin.cn<br>
完整教程：<a href="https://github.com/wusuopu/Ruby-tutorial">https://github.com/wusuopu/Ruby-tutorial</a> </p>

</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
    <h1 class="entry-title"><a href="http://www.xefan.com/archives/83945.html">[翻译]Ruby教程14——正则表达式</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2013-11-17T00:00:00+08:00'><span class='date'><span class='date-month'>Nov</span> <span class='date-day'>17</span><span class='date-suffix'>th</span>, <span class='date-year'>2013</span></span> <span class='time'>12:00 am</span></time>
        
           | <a href="http://www.xefan.com/archives/83945.html#disqus_thread"
             data-disqus-identifier="http://www.xefan.com/archives/83945.html">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><h1>Ruby的正则表达式</h1>


<p>在这部分和教程中我们将讨论正则表达式。</p>


<p>正则表达式用于文本搜索和更高级的文本操作。内建正则表达式的工具如grep、sed；文本编辑器如vi、emacs；编程语言如Tcl、Perl、Python。Ruby也内建支持正则表达式。</p>


<p>从另一方面来看正则表达式语法构成了一个文本匹配的领域专用语言。</p>


<p><em>pattern</em>（模式）是一个正则表达式，它定义了我们要搜索或者操作的文本。它由文本字面和元字符构成。模式位于两个分隔符内。在Ruby中是<em>//</em>字符。它们通知正则表达式函数的开始和结束。</p>


<p>这里是元字符的部分列表。</p>


<table>
    <tr>
        <td>.</td>
        <td>匹配任意一个字符</td>
    </tr>
    <tr>
        <td>*</td>
        <td>匹配前一个元素0次或多次</td>
    </tr>
    <tr>
        <td>[]</td>
        <td>括号表达式。匹配括号内的一个字符</td>
    </tr>
    <tr>
        <td>[^]</td>
        <td>匹配不在括号内的一个字符</td>
    </tr>
    <tr>
        <td>^</td>
        <td>匹配字符串的开始位置</td>
    </tr>
    <tr>
        <td>$</td>
        <td>匹配字符串的结束位置</td>
    </tr>
    <tr>
        <td>|</td>
        <td>交替操作</td>
    </tr>
</table>




<p>=~操作符对字符串匹配正则表达式，如果匹配则返回匹配字符串的偏移量否则为nil。 <em>RegExp</em>类是用来开发正则表达式。还有两个速记的方式来创建正则表达式。下面的例子将显示它们。</p>


<pre><code>#!/usr/bin/ruby

re = Regexp.new 'Jane'
p "Jane is hot".match re

p "Jane is hot" =~ /Jane/
p "Jane is hot".match %r{Jane}
</code></pre>


<p>第一个例子我们显示了对字符串应用正则表达式的三种方式。</p>


<pre><code>re = Regexp.new 'Jane'
p "Jane is hot".match re
</code></pre>


<p>上面两行我们创建了一个简单的包含正则表达式文本的<em>Regexp</em>对象。使用<em>match</em>方法我们对<em>&#8220;Jane is hot&#8221;</em>句子应用这个正则表达式。检查&#8217;Jance&#8217;是否在这个句子中。</p>


<pre><code>p "Jane is hot" =~ /Jane/
p "Jane is hot".match %r{Jane}
</code></pre>


<p>这两行完成相同的工作。两个斜杠//和%R{}字符是第一种方式的简写。在这个教程中，我们将使用斜杠。这是在许多语言中是事实上的标准。</p>


<pre><code>$ ./regex.rb
#&lt;MatchData "Jane"&gt;
0
#&lt;MatchData "Jane"&gt;
</code></pre>


<p>这三种情况都匹配的。<em>match</em>方法返回匹配的数据，如果没有则返回nil。=~操作符返回第一个匹配的字符的位置，或者nil。</p>


<h2>点字符</h2>


<p>点字符是一个可以匹配任意单字符的正则表达式字符。注意必须要有些字符，它不能被忽略。</p>


<pre><code>#!/usr/bin/ruby

p "Seven".match /.even/
p "even".match /.even/
p "eleven".match /.even/
p "proven".match /.even/
</code></pre>


<p>第一个例子，我们对字符串使用<em>match</em>方法应用正则表达式。<em>match</em>方法成功则返回匹配到的数据，否则返回nil。</p>


<pre><code>p "Seven".match /.even/
</code></pre>


<p>&#8220;Seven&#8221;是一个字符串，可以调用<em>match</em>方法。这个方法的参数是一个模式。/.even/正则表达式模式是查找以任意字符开头接着是<em>&#8216;even&#8217;</em>的字符串。</p>


<pre><code>$ ./dot.rb
#&lt;MatchData "Seven"&gt;
nil
#&lt;MatchData "leven"&gt;
nil
</code></pre>


<p>从输出结果中我们看到哪些是匹配的哪些是没有匹配的。</p>


<hr>


<p>正如前面所说的，如果有点字符，那么就必须要有一个任意的字符。它不能被忽略。如果我们想到查找一个文本，其中有字符能被忽略的。换言之，我们想要一个模式可以同时匹配&#8217;seven&#8217;和&#8217;even&#8217;。对于这个我们可以使用一个<em>?</em>重复字符。<em>?</em>重复字符表示前一个字符可能出现0或者1次。</p>


<pre><code>#!/usr/bin/ruby

p "seven".match /.even/
p "even".match /.even/
p "even".match /.?even/
</code></pre>


<p>这个脚本使用<em>?</em>重复字符。</p>


<pre><code>p "even".match /.even/
</code></pre>


<p>这行打印nil，因为正则表达式在&#8217;even&#8217;之前要接受一个字符。</p>


<pre><code>p "even".match /.?even/
</code></pre>


<p>我们稍微修改一下正则表达式。<em>&#8217;.?&#8217;</em>代表没有字符或者有一个字符。这次匹配成功。</p>


<pre><code>$ ./dot2.rb
#&lt;MatchData "seven"&gt;
nil
#&lt;MatchData "even"&gt;
</code></pre>


<p>输出结果。</p>


<h2>正则表达式方法</h2>


<p>前面的两个例子我们对正则表达式使用了<em>match</em>方法。除了<em>match</em>之外还有其他的方法也接受正则表达式参数。</p>


<pre><code>#!/usr/bin/ruby

puts "motherboard" =~ /board/
puts "12, 911, 12, 111"[/\d{3}/]

puts "motherboard".gsub /board/, "land"

p "meet big deep nil need".scan /.[e][e]./
p "This is Sparta!".split(/\s/)
</code></pre>


<p>这个例子显示了正则表达式的一些方法。</p>


<pre><code>puts "motherboard" =~ /board/
</code></pre>


<p>=~操作符将正则表达式放在右边，字符串放在左边。</p>


<pre><code>puts "12, 911, 12, 111"[/\d{3}/]
</code></pre>


<p>正则表达式可以位于字符串后面的中括号内。这行打印第一个3个数字。</p>


<pre><code>puts "motherboard".gsub /board/, "land"
</code></pre>


<p>使用<em>gsub</em>方法我们将&#8217;board&#8217;字符串替换成&#8217;land&#8217;。</p>


<pre><code>p "meet big deep nil need".scan /.[e][e]./
</code></pre>


<p><em>scan</em>方法查找字符串匹配。它会查找所有出现的匹配，而不仅是第一个。这行打印所有与模式匹配的字符串。</p>


<pre><code>p "This is Sparta!".split(/\s/)
</code></pre>


<p><em>split</em>方法使用给定的正则式来分隔字符串。<em>\s</em>字符代表了任何空白字符。</p>


<pre><code>$ ./apply.rb
6
911
motherland
["meet", "deep", "need"]
["This", "is", "Sparta!"]
</code></pre>


<p>apply.rb脚本的输出结果。</p>


<h2>特殊变量</h2>


<p>一些使用正则式的方法会激活一些特殊的变量。包括上次匹配的字符串、上次匹配结果的前面部分和上次匹配结果的后面部分。这些变量方便了程序员。</p>


<pre><code>#!/usr/bin/ruby

puts "Her name is Jane" =~ /name/

p $`
p $&amp;
p $'
</code></pre>


<p>这个例子显示了三个特殊的变量。</p>


<pre><code>puts "Her name is Jane" =~ /name/
</code></pre>


<p>这行代码是一个简单的正则式匹配。我们在&#8217;Her name is Jane&#8217;句子中查找&#8217;name&#8217;。我们使用=~操作符。这个操作符也会设置三个特殊的变量。这行返回数字4。</p>


<pre><code>p $`
</code></pre>


<p><em>$`</em>特殊变量包含了上次匹配结果之前的文本。</p>


<pre><code>p $&amp;
</code></pre>


<p><em>$&amp;</em>为匹配的文本。</p>


<pre><code>p $'
</code></pre>


<p><em>$&#8217;</em>变量包含上次匹配结果之后的文本。</p>


<p>$ ./svars.rb<br>
4<br>
&#8220;Her &#8221;<br>
&#8220;name&#8221;<br>
&#8221; is Jane&#8221;  </p>


<p>例子的输出结果。</p>


<h2>锚点</h2>


<p>锚点是在文本中匹配位置的字符。我们展示三个锚点字符。^字符匹配了行的开头；$字符匹配了行的结尾；\b字符匹配词的边界。</p>


<pre><code>#!/usr/bin/ruby

sen1 = "Everywhere I look I see Jane"
sen2 = "Jane is the best thing that happened to me"

p sen1.match /^Jane/ 
p sen2.match /^Jane/

p sen1.match /Jane$/ 
p sen2.match /Jane$/
</code></pre>


<p>第一个例子我们使用了^和$。</p>


<pre><code>sen1 = "Everywhere I look I see Jane"
sen2 = "Jane is the best thing that happened to me"
</code></pre>


<p>有两个句子。&#8217;Jane&#8217;位于第一个的结尾第二个的开头。</p>


<pre><code>p sen1.match /^Jane/ 
p sen2.match /^Jane/
</code></pre>


<p>这里我们查找这两个句子是否以&#8217;Jane&#8217;开头。</p>


<pre><code>p sen1.match /Jane$/ 
p sen2.match /Jane$/
</code></pre>


<p>这里我们在句子结尾查找匹配。</p>


<pre><code>$ ./anchors.rb
nil
#&lt;MatchData "Jane"&gt;
#&lt;MatchData "Jane"&gt;
nil
</code></pre>


<p>运行结果。</p>


<hr>


<p>通常一个请求仅包含一个匹配全部的词。我们会默认计算所有匹配，包括更大的或者复合词。让我们通过一个例子来阐述。</p>


<pre><code>#!/usr/bin/ruby

text = "The cat also known as the domestic cat is a small, 
usually furry, domesticated, carnivorous mammal."

p text.scan /cat/

p $`
p $&amp;
p $'
</code></pre>


<p>有一个句子。我们使用<em>scan</em>在这个句子中查找所有的&#8217;cat&#8217;字符串。</p>


<pre><code>text = "The cat also known as the domestic cat is a small, 
usually furry, domesticated, carnivorous mammal."
</code></pre>


<p>问题是这个文本中有三个&#8217;cat&#8217;字符串。要匹配的&#8217;cat&#8217;表示一个哺乳动物,/cat/却匹配了&#8217;domesticated&#8217;词的8-10的字母。这不是我们想要的。</p>


<pre><code>$ ./boudaries.rb
["cat", "cat", "cat"]
"The cat also known as the domestic cat is a small, \nusually furry, domesti"
"cat"
"ed, carnivorous mammal."
</code></pre>


<p>最后一次匹配的&#8217;domesticated&#8217;在下一个例子中将被使用\b锚点字符排除。</p>


<hr>


<p>\b字符用于设置要查找的词的边界。</p>


<pre><code>#!/usr/bin/ruby

text = "The cat also known as the domestic cat is a small, 
usually furry, domesticated, carnivorous mammal."

p text.scan /\bcat\b/

p $`
p $&amp;
p $'
</code></pre>


<p>这个例子使用\b元字符进行了改善。</p>


<pre><code>p text.scan /\bcat\b/
</code></pre>


<p>使用上面的正则式我们将查找&#8217;cat&#8217;整个词，不计算子词。</p>


<h2>字符类</h2>


<p>我们可以结合方括号将字符转换成字符类。字符类可以匹配在方括号内的任意字符。/[ab]/模式意味a或者b，相反的/ab/意味着a接着b。</p>


<pre><code>#!/usr/bin/ruby

words = %w/ sit MIT fit fat lot pad /

pattern = /[fs]it/

words.each do |word|
   if word.match pattern
       puts "#{word} matches the pattern" 
   else
       puts "#{word} does not match the pattern" 
   end
end
</code></pre>


<p>有一系列的6个3字母的单词。我们对数组的每个字符串采用特定字符集的正则式。</p>


<pre><code>pattern = /[fs]it/
</code></pre>


<p>这个式模式在这个数组中查找到了&#8217;fit&#8217;、&#8217;sit&#8217;。我们从字符集使用&#8217;f&#8217;或者&#8217;s&#8217;。</p>


<p>$ ./classes.rb<br>
sit matches the pattern<br>
MIT does not match the pattern<br>
fit matches the pattern<br>
fat does not match the pattern<br>
lot does not match the pattern<br>
pad does not match the pattern  </p>


<p>有两个匹配的。</p>


<hr>


<p>一个例子我们将进一步探讨字符类。</p>


<pre><code>#!/usr/bin/ruby

p "car".match %r{[abc][a][rs]}
p "car".match /[a-r]+/
p "23af 433a 4ga".scan /\b[a-f0-9]+\b/
</code></pre>


<p>例子中有三个字符类正则式。</p>


<pre><code>p "car".match %r{[abc][a][rs]}
</code></pre>


<p>这行的正则式由三个字符类构成。每个都对应一个字符。[abc]是a、b或者c。[a]就是a。第三个[rs]是r或者s。这里匹配&#8217;car&#8217;字符串。</p>


<pre><code>p "car".match /[a-r]+/
</code></pre>


<p>我们在字符类中使用了一个连接符<em>-</em>。连接符是一个元字符表示一个范围：这里是a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, 或r。由于字符类仅对应一个字符。我们也可以使用+重复字符。这表示前一个字符集的字符可以重复一次或者多次。&#8217;car&#8217;字符串被匹配了。</p>


<pre><code>p "23af 433a 4ga".scan /\b[a-f0-9]+\b/
</code></pre>


<p>这行有一个由三个子字符串构成的字符串。使用<em>scan</em>方法检查十六进制整数。我们有两个范围。第一个[a-f]代表a到f的字符。第二个[0-9]代表字数0到9。+表示这些字符可以重复多次。最后\b创建一个边界，表示仅接受由这些字符构成的字符串。</p>


<pre><code>$ ./classes2.rb
#&lt;MatchData "car"&gt;
#&lt;MatchData "car"&gt;
["23af", "433a"]
</code></pre>


<p>输出结果。 </p>


<hr>


<p>如果字符类的第一个字符是脱字符（^），则对该类反转。它会匹配除了这些之外的任何字符。</p>


<pre><code>#!/usr/bin/ruby

p "ABC".match /[^a-z]{3}/
p "abc".match /[^a-z]{3}/
</code></pre>


<p>这个例子我们在字符类中使用脱字符。</p>


<pre><code>p "ABC".match /[^a-z]{3}/
</code></pre>


<p>我们查找一个有3个字母的字符串。这些字母不能在a到z之间。&#8221;ABC&#8221;字符串匹配这个正则式，因为所有的三个字符都是大写字母。</p>


<pre><code>p "abc".match /[^a-z]{3}/
</code></pre>


<p>&#8220;abc&#8221;字符串没有匹配。</p>


<pre><code>$ ./caret.rb
#&lt;MatchData "ABC"&gt;
nil
</code></pre>


<p>输出结果。</p>


<h2>量词</h2>


<p>标记或者组后面的量词表示前面的元素允许出现多少次。</p>


<pre><code> ?     - 0 or 1 match
 *     - 0 or more
 +     - 1 or more
 {n}   - exactly n
 {n,}  - n or more
 {,n}  - n or less (??)
 {n,m} - range n to m
</code></pre>


<p>上面是通常的量词列表。</p>


<pre><code>#!/usr/bin/ruby

p "seven dig moon car lot fire".scan /\w{3}/
p "seven dig moon car lot fire".scan /\b\w{3}\b/
</code></pre>


<p>例子中我们想要选择这些有3个字符的单词。\w字符是一个词字符。\w{3}意味着前面的词字符出现3次。</p>


<pre><code>p "seven dig moon car lot fire".scan /\w{3}/
</code></pre>


<p>第一只是对每个字符串截取前三个字符。这不是我们想要的。</p>


<pre><code>p "seven dig moon car lot fire".scan /\b\w{3}\b/
</code></pre>


<p>这是改进的搜索。我们将之前的模式放在边界符\b之间。现在仅查找有三个字符的单词。</p>


<pre><code>$ ./nchars.rb
["sev", "dig", "moo", "car", "lot", "fir"]
["dig", "car", "lot"]
</code></pre>


<p>输出结果。</p>


<hr>


<p>{n,m}是一个重复结构对于有n到m个字符的字符串。</p>


<pre><code>#!/usr/bin/ruby

p "I dig moon lottery it fire".scan /\b\w{2,4}\b/
</code></pre>


<p>上面的例子我们选择有2、3、4个字符的单词。我们再次使用了边界符\b。</p>


<pre><code>$ ./rchars.rb
["dig", "moon", "it", "fire"]
</code></pre>


<p>这个例子打印了一个有2-4个字符的单词数组。</p>


<hr>


<p>下一个例子我们展示<em>?</em>元字符。接着<em>?</em>的字符是可选的。<em>?</em>之前的字符可以出现一次或者0次。</p>


<pre><code>#!/usr/bin/ruby

p "color colour colors colours".scan /colou?rs/
p "color colour colors colours".scan /colou?rs?/

p "color colour colors colours".scan /\bcolor\b|\bcolors\b|\bcolour\b|\bcolours\b/
</code></pre>


<p>我们想要在一个文本中查找<em>colour</em>单词。这个单词有两种拼写方式，美式的&#8217;colour&#8217;和英式的&#8217;color&#8217;。我们想要两种都查找，此外我们还想查找复数形式。</p>


<pre><code>p "color colour colors colours".scan /colou?rs/
</code></pre>


<p>colou?rs模式查找&#8217;colours&#8217;和&#8217;colors&#8217;。u字符在?字符之前表示是可选的。</p>


<pre><code>p "color colour colors colours".scan /colou?rs?/
</code></pre>


<p>colou?rs?模式使u和s字符是可选的。因此我们会查找到这四个组合。</p>


<pre><code>p "color colour colors colours".scan /\bcolor\b|\bcolors\b|\bcolour\b|\bcolours\b/
</code></pre>


<p>相同的请求可以间隔的写。</p>


<pre><code>$ ./qmark.rb
["colors", "colours"]
["color", "colour", "colors", "colours"]
["color", "colour", "colors", "colours"]
</code></pre>


<p>输出结果。</p>


<hr>


<p>这节的最后一个例子我们展示+字符。它允许前面的字符重复1次或多次。</p>


<pre><code>#!/usr/bin/ruby

nums = %w/ 234 1 23 53434 234532453464 23455636
    324f 34532452343452 343 2324 24221 34$34232/

nums.each do |num|
    m = num.match /[0-9]+/

    if m.to_s.eql? num
        puts num
    end              
end
</code></pre>


<p>这个例子我们有一个数字数组。数字可以有一个或者多个数字字符。</p>


<pre><code>nums = %w/ 234 1 23 53434 234532453464 23455636
    324f 34532452343452 343 2324 24221 34$34232/
</code></pre>


<p>这是一个字符串数组。其中有两个不是数字，因为它们包含了非数字字符。</p>


<pre><code>nums.each do |num|
    m = num.match /[0-9]+/

    if m.to_s.eql? num
        puts num
    end              
end
</code></pre>


<p>我们遍历数组并对每个字符串应用正则式。表达式[0-9]+代表了0到9的任意字符重复0次或者多次。默认的这个表达式也会查找子字符串。
在34$34232中引擎认为34是一个数字。\b边界符在这里是无效的，因为我们没有具体的字符，引擎不知道该在哪里停止查找。这就是为什么我们在代码块中包含一个if条件式。仅当匹配结果等于原字符串才认为它是一个数字。</p>


<p>$ ./numbers.rb<br>
234<br>
1<br>
23<br>
53434<br>
234532453464<br>
23455636<br>
34532452343452<br>
343<br>
2324<br>
24221  </p>


<p>这些的值是数字。</p>


<h2>忽略大小写搜索</h2>


<p>我们可以执行忽略大小写的搜索。正则表达式可以接一个选项。它是一个单一的字符，以某种方式修改模式。这里不区分大小写的搜索我们使用i选项。</p>


<pre><code>#!/usr/bin/ruby

p "Jane".match /Jane/
p "Jane".match /jane/
p "Jane".match /JANE/

p "Jane".match /jane/i
p "Jane".match /Jane/i
p "Jane".match /JANE/i
</code></pre>


<p>这个例子显示了区分大小写和不区分大小写的搜索。</p>


<pre><code>p "Jane".match /Jane/
p "Jane".match /jane/
p "Jane".match /JANE/
</code></pre>


<p>这三行的字符必须完全匹配模式。仅有第一行是匹配的。</p>


<pre><code>p "Jane".match /jane/i
p "Jane".match /Jane/i
p "Jane".match /JANE/i
</code></pre>


<p>这里我们使用i选项，接在第二个/字符后面。我们进行不区分大小写的搜索。这三行者匹配了。</p>


<pre><code>$ ./icase.rb
#&lt;MatchData "Jane"&gt;
nil
nil
#&lt;MatchData "Jane"&gt;
#&lt;MatchData "Jane"&gt;
#&lt;MatchData "Jane"&gt;
</code></pre>


<p>例子的输出结果。</p>


<h2>交替</h2>


<p>一个例子解释交替操作符（|）。这个操作符可以创建一个有多个选择的正则式。</p>


<pre><code>#!/usr/bin/ruby

names = %w/Jane Thomas Robert Lucy Beky
    John Peter Andy/

pattern = /Jane|Beky|Robert/

names.each do |name|

    if name =~ pattern
        puts "#{name} is my friend"
    else
        puts "#{name} is not my friend"
    end
end
</code></pre>


<p><em>names</em>数组中有8个名字。我们将在数组中查找多虑字符串的组合。</p>


<pre><code>pattern = /Jane|Beky|Robert/
</code></pre>


<p>这是搜索模式。它表示Jane, Beky和Robert是我的朋友。如果你查找他们就会找到我的朋友。</p>


<p>$ ./alternation.rb<br>
Jane is my friend<br>
Thomas is not my friend<br>
Robert is my friend<br>
Lucy is not my friend<br>
Beky is my friend<br>
John is not my friend<br>
Peter is not my friend<br>
Andy is not my friend  </p>


<p>这是脚本的输出结果。</p>


<h2>子模式</h2>


<p>我们可以使用括号()创建子模式。</p>


<pre><code>#!/usr/bin/ruby

p "bookworm" =~ /book(worm)?$/
p "book" =~ /book(worm)?$/
p "worm" =~ /book(worm)?$/
p "bookstore" =~ /book(worm)?$/
</code></pre>


<p>我们有如下正则式模式：book(worm)?$。(worm)是一个子模式。仅有两个字符串可以匹配：&#8217;book&#8217;或者&#8217;bookworm&#8217;。接在子模式后面的?字符意味着这个子模式出现0或者1次。这里$字符确切的匹配字符串的结尾。没有它单词bookstore和bookmania也会被匹配。</p>


<pre><code>#!/usr/bin/ruby

p "book" =~ /book(shelf|worm)?$/
p "bookshelf" =~ /book(shelf|worm)?$/
p "bookworm" =~ /book(shelf|worm)?$/
p "bookstore" =~ /book(shelf|worm)?$/
</code></pre>


<p>子模式经常是多个单词组合交替结合的。例如，book(shelf|worm)匹配&#8217;bookshelf&#8217;和&#8217;bookworm&#8217;，book(shelf|worm)?匹配&#8217;bookshelf&#8217;，&#8217;bookworm&#8217;和&#8217;book&#8217;。</p>


<p>$ ./subpatterns2.rb<br>
0<br>
0<br>
0<br>
nil  </p>


<p>最后一个子模式没有匹配。记住0不意味着没有匹配。对于=~操作符，它是第一个匹配到的字符的索引。</p>


<h2>邮箱例子</h2>


<p>最后一个例子，我们创建一个正则式模式检查邮箱地址。</p>


<pre><code>#!/usr/bin/ruby

emails = %w/ luke@gmail.com andy@yahoo.com 23214sdj^as
    f3444@gmail.com /

pattern = /^[a-zA-Z0-9._-]+@[a-zA-Z0-9-]+\.[a-zA-Z.]{2,5}$/

emails.each do |email|

    if email.match pattern
        puts "#{email} matches"
    else
        puts "#{email} does not match"
    end

end
</code></pre>


<p>注意这个例子提供了仅一种解决方案。它不需要是最好的。</p>


<pre><code>emails = %w/ luke@gmail.com andy@yahoocom 23214sdj^as
    f3444@gmail.com /
</code></pre>


<p>这是一个邮箱数组，仅有两个是有效的。</p>


<pre><code>pattern = /^[a-zA-Z0-9._-]+@[a-zA-Z0-9-]+\.[a-zA-Z.]{2,5}$/
</code></pre>


<p>这是一个模式，第一个^和最后一个$是获取完整匹配。在模式之前和之后都不允许有字符。邮箱分为5部分。第一部分是本地部分，它通常是公司、个体或者昵称的名字。[a-zA-Z0-9._-]+列出了所有可能用于本地部分的字符，它们可以使用一次或者多次。第二部分是字面符@，第三部分是域名部分。它通常是邮箱的提供商，如 yahoo或者gmail。字符集[a-zA-Z0-9-]+指明了所有的可以用于域名的字符。+量词将这些字符使用一次或者多次。第四部分是点字符。它的前面接一个转义符。(&#46;)因为点字符是一个元字符具有特殊意义。转义之后得到一个字面上的点。最后一部分是顶级域名。这个模式是[a-zA-Z.]{2,5}。顶级域名有2到5个字符，如sk, net, info, travel。这同样也有点字符，这是因此一些顶级域名有两部分如co.uk。</p>


<p>$ ./email.rb<br>
luke@gmail.com matches<br>
andy@yahoocom does not match<br>
23214sdj^as does not match<br>
f3444@gmail.com matches  </p>


<p>这个正则式标记了两个有效的邮箱地址。</p>


<p>在这章，我们学习了Ruby的正则表达式。</p>


<hr>


<p>原文地址： <a href="http://zetcode.com/lang/rubytutorial/regex/">http://zetcode.com/lang/rubytutorial/regex/</a><br>
翻译：龙昌  admin@longchangjin.cn<br>
完整教程：<a href="https://github.com/wusuopu/Ruby-tutorial">https://github.com/wusuopu/Ruby-tutorial</a> </p>

</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
    <h1 class="entry-title"><a href="http://www.xefan.com/archives/83942.html">[翻译]Ruby教程13——面向对象2</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2013-11-17T00:00:00+08:00'><span class='date'><span class='date-month'>Nov</span> <span class='date-day'>17</span><span class='date-suffix'>th</span>, <span class='date-year'>2013</span></span> <span class='time'>12:00 am</span></time>
        
           | <a href="http://www.xefan.com/archives/83942.html#disqus_thread"
             data-disqus-identifier="http://www.xefan.com/archives/83942.html">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><h1>Ruby的面向对象编程2</h1>


<p>在这章的教程我们继续讨论Ruby的面向对象编程。</p>


<p>我们以属性修饰符开始。将会包涵类常量、类方法和操作符重载。我们将定义多态，并展示在Ruby中如何使用它。我们也会提及模块和异常。</p>


<h2>属性修饰符</h2>


<p>Ruby的所有变量都是私有的。它只能通过方法来访问。这些方法通常称为设值函数(setters)和获得者(getters)。创建一个setter和getter方法是很平常的事情。加些Ruby有便利的方法来创建这两种方法。它们是<em>attr_reader</em>、<em>attr_writer</em>和<em>attr_accessor</em>。</p>


<p><em>attr_reader</em>用于创建getter方法。<em>attr_writer</em>用于setter方法。<em>attr_accessor</em>用于创建两种方法。</p>


<pre><code>#!/usr/bin/ruby

class Car

    attr_reader :name, :price
    attr_writer :name, :price

    def to_s
        "#{@name}: #{@price}"
    end

end


c1 = Car.new
c2 = Car.new

c1.name = "Porsche"
c1.price = 23500

c2.name = "Volkswagen"
c2.price = 9500

puts "The #{c1.name} costs #{c1.price}"

p c1
p c2
</code></pre>


<p>定义了一个<em>Car</em>类，在类内部我们使用了<em>attr_reader</em>和<em>attr_writer</em>创建了两个<em>getter</em>和<em>setter</em>方法。</p>


<pre><code>attr_reader :name, :price
</code></pre>


<p>这里我们创建了两个实例方法名为：<em>name</em>和<em>price</em>。注意<em>attr_reader</em>将方法名符号作为参数。</p>


<pre><code>attr_writer :name, :price
</code></pre>


<p><em>attr_writer</em>创建了两个<em>setter</em>方法<em>name</em>、<em>price</em>和两个实例变量<em>@name</em>、 <em>@price</em>。</p>


<pre><code>c1.name = "Porsche"
c1.price = 23500
</code></pre>


<p>这里的上下文中调用了两个<em>setter</em>方法，为实例变量填充数据。</p>


<pre><code>puts "The #{c1.name} costs #{c1.price}"
</code></pre>


<p>这里调用了两个<em>getter</em>方法获取数据。</p>


<p>$ ./arw.rb <br>
The Porsche costs 23500<br>
Porsche: 23500<br>
Volkswagen: 9500  </p>


<p>例子的输出结果。</p>


<hr>


<p>正如上面阐述的，<em>attr_accessor</em>方法会创建<em>getter</em>、<em>setter</em>方法和它们的实例变量。</p>


<pre><code>#!/usr/bin/ruby

class Book
   attr_accessor :title, :pages    
end

b1 = Book.new
b1.title = "Hidden motives"
b1.pages = 255

p "The book #{b1.title} has #{b1.pages} pages"
</code></pre>


<p>定义了一个<em>Book</em>类，它使用<em>attr_accessor</em>创建了两对方法和两个实例变量。</p>


<pre><code>class Book
   attr_accessor :title, :pages    
end
</code></pre>


<p><em>attr_accessor</em>方法设置了<em>title</em>、<em>pages</em> 方法以及<em>@title</em>、<em>@pages</em>实例变量。</p>


<pre><code>b1 = Book.new
b1.title = "Hidden motives"
b1.pages = 255
</code></pre>


<p>创建了一个<em>Book</em>对象。调用两个setter方法为对象的实例变量填充数据。</p>


<pre><code>p "The book #{b1.title} has #{b1.pages} pages"
</code></pre>


<p>这行的代码我们调用getter方法读取实例变量的值。</p>


<p>$ ./accessor.rb<br>
&#8220;The book Hidden motives has 255 pages&#8221;  </p>


<p>例子的输出结果。</p>


<h2>类的常量</h2>


<p>Ruby允许创建类常量。这些常量不属于特定的对象，它们是属于类的。作为约定，常量以大写字母开头。</p>


<pre><code>#!/usr/bin/ruby

class MMath

    PI = 3.141592
end


puts MMath::PI
</code></pre>


<p>创建一个<em>MMath</em>类，包含了一个<em>PI</em>常量。</p>


<pre><code>PI = 3.141592
</code></pre>


<p>我们创建了一个<em>PI</em>常量。记住在Ruby中常量不是强制的。</p>


<pre><code>puts MMath::PI
</code></pre>


<p>使用<em>::</em>操作符访问<em>PI</em>常量。</p>


<p>$ ./classconstant.rb <br>
3.141592  </p>


<p>例子输出结果。</p>


<h2>to_s方法</h2>


<p>每个对象都有一个<em>to_s</em>方法，它返回该对象的一个字符串描述。注意<em>puts</em>方法将一个对象作为参数时，该对象的<em>to_s</em>方法将被调用。</p>


<pre><code>#!/usr/bin/ruby

class Being

    def to_s
        "This is Being class"
    end
end

b = Being.new
puts b.to_s
puts b
</code></pre>


<p>定义一个<em>Being</em>类并重载了<em>to_s</em>方法。</p>


<pre><code>def to_s
    "This is Being class"
end
</code></pre>


<p>每个创建的类都继承自基类<em>Object</em>。<em>to_s</em>方法属于这个类。我们重载了<em>to_s</em>方法，使得描述信息更加可读。</p>


<pre><code>b = Being.new
puts b.to_s
puts b
</code></pre>


<p>创建一个<em>Being</em>的对象，调用两次<em>to_s</em>方法。第一次是显式调用，第二次是隐式调用。</p>


<p>$ ./tostring.rb <br>
This is Being class<br>
This is Being class  </p>


<p>例子的运行结果。</p>


<h2>操作符重载</h2>


<p>操作符重载是基本参数的不同进行的操作也不同。</p>


<p>Ruby中操作符和方法仅有一点区别。</p>


<pre><code>#!/usr/bin/ruby

class Circle

    attr_accessor :radius

    def initialize r
        @radius = r
    end

    def +(other)
        Circle.new @radius + other.radius
    end

    def to_s
        "Circle with radius: #{@radius}"
    end
end


c1 = Circle.new 5
c2 = Circle.new 6
c3 = c1 + c2

p c3
</code></pre>


<p>这个例子中，我们创建了一个<em>Circle</em>类，并重载了+操作符，用于将两个<em>circle</em>对象相加。</p>


<pre><code>def +(other)
    Circle.new @radius + other.radius
end
</code></pre>


<p>我们定义了一个名为<em>+</em>的方法，这个方法将两个<em>circle</em>对象的半径相加。</p>


<pre><code>c1 = Circle.new 5
c2 = Circle.new 6
c3 = c1 + c2
</code></pre>


<p>创建两个<em>circle</em>对象。在第三行我们将这两个对象相加生成一个新的对象。</p>


<p>$ ./operatoroverloading.rb<br>
Circle with radius: 11  </p>


<p>这两个对象相加生成的第三个对象半径为11。</p>


<h2>类方法</h2>


<p>Ruby方法分为类方法和实例方法。类方法只能被类调用，不能被实例调用。</p>


<p>类方法不能访问实例变量。</p>


<pre><code>#!/usr/bin/ruby

class Circle

    def initialize x
        @r = x
    end

    def self.info
       "This is a Circle class" 
    end

    def area
        @r * @r * 3.141592
    end

end


p Circle.info
c = Circle.new 3
p c.area
</code></pre>


<p>上面的例子展示了一个<em>Circle</em>类。除了构造函数之外，还有一个类方法和一个实例方法。</p>


<pre><code>def self.info
    "This is a Circle class" 
end
</code></pre>


<p>以<em>self</em>关键字开头的是类方法。</p>


<pre><code>def area
    "Circle, radius: #{@r}"
end
</code></pre>


<p>实例方法不以<em>self</em>关键字开头。</p>


<pre><code>p Circle.info
</code></pre>


<p>调用类方法。注意我们是通过类来调用这个方法。</p>


<pre><code>c = Circle.new 3
p c.area
</code></pre>


<p>为了调用实例方法我们必须得先创建一个对象。实例方法总是被对象调用。这里<em>c</em>变量保存了该对象，我们利用点操作符调用<em>area</em>方法。</p>


<p>$ ./classmethods.rb<br>
&#8220;This is a Circle class&#8221;<br>
28.274328  </p>


<p>例子的输出描述了Ruby的类方法。</p>


<hr>


<p>在Ruby中有三种方式创建类方法。</p>


<pre><code>#!/usr/bin/ruby

class Wood

    def self.info
       "This is a Wood class" 
    end
end

class Brick

    class &lt;&lt; self
        def info
           "This is a Brick class" 
        end
    end
end

class Rock

end

def Rock.info
   "This is a Rock class" 
end


p Wood.info
p Brick.info
p Rock.info
</code></pre>


<p>这个例子创建了三个类，每个都有一个类方法。</p>


<pre><code>def self.info
    "This is a Wood class" 
end
</code></pre>


<p>类方法可以以<em>self</em>关键字开头。</p>


<pre><code>class &lt;&lt; self
    def info
        "This is a Brick class" 
    end
end
</code></pre>


<p>另一个方式是将方法定义放在<em>class &lt;&lt; self</em>结构之后。</p>


<pre><code>def Rock.info
   "This is a Rock class" 
end
</code></pre>


<p>这是第三种定义类方法的方式。</p>


<p>$ ./classmethods2.rb<br>
&#8220;This is a Wood class&#8221;<br>
&#8220;This is a Brick class&#8221;<br>
&#8220;This is a Rock class&#8221;  </p>


<p>调用<em>Wood</em>、<em>Brick</em>和<em>Rock</em>这三个类的类方法的输出结果。</p>


<h2>创建实例方法的三种方式</h2>


<p>Ruby有三种基本的方式创建实例方法。实例方法是属于实例对象的。它们是通过对象使用点操作符调用。</p>


<pre><code>#!/usr/bin/ruby

class Wood

    def info
       "This is a wood object"        
    end
end

wood = Wood.new
p wood.info

class Brick

    attr_accessor :info
end

brick = Brick.new
brick.info = "This is a brick object"
p brick.info

class Rock

end

rock = Rock.new

def rock.info
    "This is a rock object"
end

p rock.info
</code></pre>


<p>这个例子我们创建了三个实例对象<em>Wood</em>、<em>Brick</em>和<em>Rock</em>。每个对象都有一介上实例方法。</p>


<pre><code>class Wood

    def info
       "This is a wood object"        
    end
end

wood = Wood.new
p wood.info
</code></pre>


<p>这可能是最常用的一种方式。<em>info</em>方法定义在<em>Wood</em>类的内部。稍后创建一个对象并调用它的<em>info</em>方法。</p>


<pre><code>class Brick

    attr_accessor :info
end

brick = Brick.new
brick.info = "This is a brick object"
p brick.info
</code></pre>


<p>另一种创建实例方法的方式是使用属性修饰符。这是一种方便的方式可以减少程序员的按键输入。<em>attr_accessor</em>创建两个方法getter和setter，同样也创建一个实例变量用于存储数据。创建一个<em>brick</em>对象，数据使用setter方法保存在<em>@info</em>变量中。最后使用getter方法读取消息。</p>


<pre><code>class Rock

end

rock = Rock.new

def rock.info
    "This is a rock object"
end

p rock.info
</code></pre>


<p>第三种方法我们创建了一个空的<em>Rock</em>类。稍后实例化一个对象，动态的为这个对外创建一个方法。</p>


<p>$ ./threeways.rb<br>
&#8220;This is a wood object&#8221;<br>
&#8220;This is a brick object&#8221;<br>
&#8220;This is a rock object&#8221;  </p>


<p>例子的输出结果。</p>


<h2>多态性</h2>


<p>多态是使用一个操作符或者函数对不同的数据进行不同的处理。实践中多态意味着如果类B继承自类A，它没有必要将类A的所有都继承；它可以做一些与类A不同的事情。</p>


<p>注意静态语言如C++、Java、或者C#和动态语言如Python、Ruby的多态有些不同。在静态语言中编译器决定了方法的定义。在动态语言中我们专注了同名方法的不同操作。</p>


<pre><code>#!/usr/bin/ruby

class Animal

    def make_noise 
        "Some noise"
    end

    def sleep 
        puts "#{self.class.name} is sleeping." 
    end

end

class Dog &lt; Animal

    def make_noise 
        'Woof!'         
    end

end

class Cat &lt; Animal

    def make_noise 
        'Meow!' 
    end 
end

[Animal.new, Dog.new, Cat.new].each do |animal|
  puts animal.make_noise
  animal.sleep
end
</code></pre>


<p>我们创建了一个简单的继承结构。有一个<em>Animal</em>基类和两个后代<em>Cat</em>和<em>Dog</em>。这三个类都有它自己的<em>make_noise</em>方法实现。后代的实现方法会替换掉<em>Animal</em>类的。</p>


<pre><code>class Dog &lt; Animal

    def make_noise 
        'Woof!'         
    end

end
</code></pre>


<p><em>Dog</em>类的<em>make_noise</em>实现替换掉了<em>Animal</em>类的实现。</p>


<pre><code>[Animal.new, Dog.new, Cat.new].each do |animal|
  puts animal.make_noise
  animal.sleep
end
</code></pre>


<p>为每个类的创建了一个实例对象，并对该对象调用了<em>make_noise</em>方法和<em>sleep</em>方法。</p>


<p>$ ./polymorhism.rb<br>
Some noise<br>
Animal is sleeping.<br>
Woof!<br>
Dog is sleeping.<br>
Meow!<br>
Cat is sleeping.  </p>


<p>polymorhism.rb脚本的输出结果。</p>


<h2>模块</h2>


<p>一个Ruby模块是方法、类和常量的集合。模块与类相似也有些不同。模块不能创建实例，没有子类。</p>


<p>模块用于将相关的类、方法和常量聚集单独放在一个模块中。这样也避免了命名的冲突，因为模块将它包含的对象进行了封装。从这方面来看Ruby的模块与C#的命名空间和Java的包相似。</p>


<p>在Ruby中模块也支持混合类（mixins）。混入类（mixin）是一个创建多继承的工厂。如果一个类继承自多个类，则称为多继承。</p>


<pre><code>#!/usr/bin/ruby

puts Math::PI
puts Math.sin 2
</code></pre>


<p>Ruby有一个内建的<em>Math</em>模块。它有许多方法和常量。我们使用<em>::</em>操作符访问PI常量。与类相同使用点操作符访问方法。</p>


<pre><code>#!/usr/bin/ruby

include Math

puts PI
puts sin 2
</code></pre>


<p>如果我包含了一个模块，我们就可以直接引用Math的对象了。模块导入使用<em>include</em>关键字。</p>


<p>$ ./modules.rb<br>
3.141592653589793<br>
0.9092974268256817  </p>


<p>程序的输出结果。</p>


<hr>


<p>下面的例子我们展示了如何使用模块来组织代码。</p>


<pre><code>#!/usr/bin/ruby

module Forest

    class Rock ; end
    class Tree ; end
    class Animal ; end

end

module Town

   class Pool ; end
   class Cinema ; end
   class Square ; end
   class Animal ; end

end


p Forest::Tree.new
p Forest::Rock.new
p Town::Cinema.new

p Forest::Animal.new
p Town::Animal.new
</code></pre>


<p>Ruby代码可以主义分组。<em>Rocks</em>和<em>Tree</em>属于<em>Forest</em>。<em>Pools</em>、<em>Cinema</em>、<em>Squares</em>属于<em>Town</em>。使用模块让我们的代码更加有条理。<em>Animals</em>可以在<em>Forest</em>里也可以有<em>Town</em>里。对于一个脚本我们不能定义两个<em>Animal</em>类，它们会冲突。将它们放在不同的模块即可解决这个问题。</p>


<pre><code>p Forest::Tree.new
p Forest::Rock.new
p Town::Cinema.new
</code></pre>


<p>创建属于<em>Forest</em>和<em>Town</em>的对象。我们使用<em>::</em>操作符访问模块里的对象。</p>


<pre><code>p Forest::Animal.new
p Town::Animal.new
</code></pre>


<p>创建两个Animal对象。Ruby解释器会将它们标识为它们的模块名。</p>


<pre><code>$ ./modules3.rb
#&lt;Forest::Tree:0x97f35ec&gt;
#&lt;Forest::Rock:0x97f35b0&gt;
#&lt;Town::Cinema:0x97f3588&gt;
#&lt;Forest::Animal:0x97f3560&gt;
#&lt;Town::Animal:0x97f3538&gt;
</code></pre>


<p>modules3.rb程序的输出。</p>


<hr>


<p>这节的最后一个例子我们将展示使用模块进行多继承。在这里的上下文中模块称为混合类（mixins）。</p>


<pre><code>#!/usr/bin/ruby

module Device
    def switch_on ; puts "on" end    
    def switch_off ; puts "off" end
end

module Volume
    def volume_up ; puts "volume up" end    
    def vodule_down ; puts "volume down" end
end

module Pluggable
    def plug_in ; puts "plug in" end    
    def plug_out ; puts "plug out" end
end

class CellPhone
    include Device, Volume, Pluggable

    def ring
        puts "ringing"
    end    
end

cph = CellPhone.new
cph.switch_on
cph.volume_up
cph.ring
</code></pre>


<p>我们定义了三个模块和一个类。模块代表了一些功能。一个设备可以调节开头。许多对象都可以分享这个功能，包含电视、手机、电脑和冰箱。相对于为每个对象创建这个功能，我们是将它分隔在一个模块里，它可以被每个对象包含。这样代码将更加有条理更紧凑。</p>


<pre><code>module Volume
    def volume_up ; puts "volume up" end    
    def vodule_down ; puts "volume down" end
end
</code></pre>


<p><em>Volume</em>模块组织了负责控制音量等级的方法。如果一个设备需要这些方法，它只需要简单的在自己的类中包含这个模块即可。</p>


<pre><code>class CellPhone
    include Device, Volume, Pluggable

    def ring
        puts "ringing"
    end    
end
</code></pre>


<p><em>CellPhone</em>添加了这三个模块。这些模块的方法混合在<em>CellPhone</em>类中。对于这个类的实例对象同样有效。<em>CellPhone</em>类也有一个自己的<em>ring</em>方法。</p>


<pre><code>cph = CellPhone.new
cph.switch_on
cph.volume_up
cph.ring
</code></pre>


<p>创建了一个<em>CellPhone</em>对象并调用了三个方法。</p>


<p>$ ./mixins.rb<br>
on<br>
volume up<br>
ringing  </p>


<p>例子的运行结果。</p>


<h2>异常</h2>


<p>异常是对象偏离了正常的程序执行流的信号。<br>
异常出现、抛出或者开始。</p>


<p>在应用程序执行期间，许多事情可能引起错误。磁盘满了我们不能保存文件。网络断了但应用程序试图连接某个网站。所有的这些可能引起应用程序崩溃。为了避免这个的发生，我们应当在程序异常时预先处理错误。对于这个我们可以使用异常处理。</p>


<p>异常是对象，它们是内建<em>Exception</em>类的后代。<em>Exception</em>对象携带了关于异常的信息。它的类型（异常的类名），可选的描述字符串，和一个可选的跟踪信息。为了获取关于程序运行异常的额外信息，程序可以子类化<em>Exception</em>或者更多是<em>StandardError</em>。</p>


<pre><code>#!/usr/bin/ruby

x = 35
y = 0

begin
    z = x / y
    puts z
rescue =&gt; e
    puts e
    p e
end
</code></pre>


<p>上面的程序我们故意的除以0,这个导致一个错误。</p>


<pre><code>begin
    z = x / y
    puts z
</code></pre>


<p>出错的语句位置<em>begin</em>关键字之后。</p>


<pre><code>rescue =&gt; e
    puts e
    p e
end
</code></pre>


<p><em>rescue</em>关键字之后的代码我们处理一个异常。这里我们在终端上打印错误信息。<em>e</em>是一个异常对象，在错误发生时创建的。</p>


<pre><code>$ ./zerodivision.rb
divided by 0
#&lt;ZeroDivisionError: divided by 0&gt;
</code></pre>


<p>输出结果我们看到了异常信息。最后一行显示了异常对象名为<em>ZeroDivisionError</em>。</p>


<hr>


<p>程序员可以使用<em>raise</em>关键字发起自己的异常。</p>


<pre><code>#!/usr/bin/ruby

age = 17

begin
    if age &lt; 18
        raise "Person is a minor"
    end

    puts "Entry allowed"
rescue =&gt; e
    puts e
    p e
    exit 1
end
</code></pre>


<p>俱乐部不允许不满18岁的青年进入。我们使用Ruby脚本模拟这个情况。</p>


<pre><code>begin
    if age &lt; 18
        raise "Person is a minor"
    end

    puts "Entry allowed"
</code></pre>


<p>如果是未成年人，将出现一个异常。如果<em>raise</em>关键字没有指明异常参数，则<em>RuntimeError</em>异常将引发。这个代码不会到达<em>puts &#8220;Entry allowed&#8221;</em>这行。代码执行中断并继续<em>rescue</em>的代码块。</p>


<pre><code>rescue =&gt; e
    puts e
    p e
    exit 1
end
</code></pre>


<p>在<em>rescue</em>代码块中我们打印错误信息，<em>RuntimeError</em>对象的一个字符串描述。我们也调用了<em>exit</em>方法通知环境该脚本错误退出。</p>


<pre><code>$ ./raise_exception.rb 
Person is a minor
#&lt;RuntimeError: Person is a minor&gt;
$ echo $?
1
</code></pre>


<p>未成年人不允许进行俱乐部。bash的$?变量设置了这个脚本错误退出。</p>


<hr>


<p>Ruby的<em>ensure</em>从名创建的代码块总是会被执行，不管是否有异常。</p>


<pre><code>#!/usr/bin/ruby

begin
    f = File.open("stones", "r")

    while line = f.gets do
        puts line
    end

rescue =&gt; e
    puts e
    p e
ensure
    f.close if f
end
</code></pre>


<p>这个例子我们尝试打开并读取stones文件。I/O操作容易出现错误。</p>


<pre><code>ensure
    f.close if f
end
</code></pre>


<p>在<em>ensure</em>的代码块中我们关闭文件处理对象。我们查检处理对象是否存在，因为它可能没有被创建。分配的资源通常位于<em>ensure</em>代码块里。</p>


<hr>


<p>如果想到，我们可以创建自定义的异常。Ruby中自定义异常继承自<em>StandardError</em>类。</p>


<pre><code>#!/usr/bin/ruby

class BigValueError &lt; StandardError ; end

LIMIT = 333
x = 3_432_453

begin

    if x &gt; LIMIT
        raise BigValueError, "Exceeded the maximum value"
    end

    puts "Script continues"

rescue =&gt; e
    puts e
    p e
    exit 1
end
</code></pre>


<p>我们有一个情况不能处理大的数字。</p>


<pre><code>class BigValueError &lt; StandardError ; end
</code></pre>


<p>我们定义一个<em>BigValueError</em>类。这个类继承自<em>StandardError</em>类。</p>


<pre><code>LIMIT = 333
</code></pre>


<p>数字超过这个常量就被认为是大的。</p>


<pre><code>if x &gt; LIMIT
    raise BigValueError, "Exceeded the maximum value"
end
</code></pre>


<p>如果值比<em>LIMIT</em>在，则抛出一个自定义异常。异常信息为<em>&#8220;Exceeded the maximum value&#8221;</em>。</p>


<pre><code>$ ./custom_exception.rb
Exceeded the maximum value
#&lt;BigValueError: Exceeded the maximum value&gt;
</code></pre>


<p>执行程序。</p>


<p>在这一章我们完成了Ruby语言的面向对象编程。</p>


<hr>


<p>原文地址： <a href="http://zetcode.com/lang/rubytutorial/oop2/">http://zetcode.com/lang/rubytutorial/oop2/</a><br>
翻译：龙昌  admin@longchangjin.cn<br>
完整教程：<a href="https://github.com/wusuopu/Ruby-tutorial">https://github.com/wusuopu/Ruby-tutorial</a> </p>

</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
    <h1 class="entry-title"><a href="http://www.xefan.com/archives/83939.html">[翻译]Ruby教程12——面向对象</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2013-11-16T00:00:00+08:00'><span class='date'><span class='date-month'>Nov</span> <span class='date-day'>16</span><span class='date-suffix'>th</span>, <span class='date-year'>2013</span></span> <span class='time'>12:00 am</span></time>
        
           | <a href="http://www.xefan.com/archives/83939.html#disqus_thread"
             data-disqus-identifier="http://www.xefan.com/archives/83939.html">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><h1>Ruby的面向对象编程</h1>


<p>在这部分的Ruby教程我们将讨论面向对象编程。</p>


<p>编程语言有过程式编程、函数式编程和面向对象编程范式。Ruby中面向对象语言并包含了一些函数式和过程式。</p>


<p>面向对象(OOP)是一种使用对象及其接口来设计应用程序和计算机程序的编程范式。</p>


<p>面向对象的基本概念如下：</p>


<ul>
<li>抽象（Abstraction）  </li>
<li>多态（Polymorphism）  </li>
<li>封装（Encapsulation）  </li>
<li>继承（Inheritance）  </li>
</ul>


<p>抽象是对于现实中复杂的问题通过适当的建模将其简化。多态是使用相同的操作符或者函数对不同的输入数据进行不同处理。封装是将一个类的具体实现对其他对象进行隐藏。继承是一种使用已经定义的类来创建新的类的方式。</p>


<h2>对象</h2>


<p>对象是Ruby面向对象程序的基本组成。一个对象包含了数据和方法。对象之间通过方法进行交流。每个对象可以接收消息、发送消息和处理数据。</p>


<p>创建一个对象需要两步。首先定义一个类。类是对象的模板。它是一张蓝图，用来描述这个类的所有对象的状态和行为。一个类可以创建多个对象。运行时创建的对象称为这个类的实例。</p>


<pre><code>#!/usr/bin/ruby

class Being

end

b = Being.new
puts b
</code></pre>


<p>第一个例子我们创建了一个简单的对象。</p>


<pre><code>class Being

end
</code></pre>


<p>定义一个简单的类，内容为空。表示它没有任何数据和方法。</p>


<pre><code>b = Being.new
</code></pre>


<p>创建一个<em>Being</em>类的新实例。这里我们使用<em>new</em>方法，新创建的对象保存在变量b中。</p>


<pre><code>puts b
</code></pre>


<p>在终端上打印对象的基本描述。当我们打印一个对象时，实际上是调用的<em>to_s</em>方法。但是我们没有任何的定义，因为每个创建的对象都是继承自<em>Object</em>。它有一些基本的函数，<em>to_s</em>是其中一个。</p>


<pre><code>$ ./simple.rb
#&lt;Being:0x9f3c290&gt;
</code></pre>


<p>我们得到这个对象的类名。</p>


<h2>构造函数</h2>


<p>构造函数是一个特殊的方法。它在对象创建时自动执行。它没有返回值。构造函数的目的是初始化对象的状态。在Ruby中构造函数名为<em>intialize</em>。</p>


<p>构造函数不能被继承。父对象的构造函数是通过<em>super</em>方法来调用。它们的调用顺序与继承顺序一致。</p>


<pre><code>#!/usr/bin/ruby

class Being

    def initialize
        puts "Being is created"
    end

end

Being.new
</code></pre>


<p>定义一个<em>Being</em>类。</p>


<pre><code>class Being

    def initialize
        puts "Being is created"
    end

end
</code></pre>


<p>类<em>Being</em>定义了一个构造函数名为<em>initialize</em>。它在终端上打印一条信息。Ruby中方法定义位置<em>def</em>和<em>end</em>关键字之间。</p>


<pre><code>Being.new
</code></pre>


<p>创建一个<em>Being</em>类的实例对象。在对象初创时构造函数将被调用。</p>


<p>$ ./constructor.rb<br>
Being is created  </p>


<p>程序的输出。</p>


<hr>


<p>对象的属性是绑定在对象里的数据项。这些数据项也称为实例变量（instance variables）或者成员字段（member fields）。实例变量在类中定义但是各个对象都有单独的复本。</p>


<p>下面的例子我们初始化类的成员数据。变量初始化是构造函数的典型工作。</p>


<pre><code>#!/usr/bin/ruby

class Person

    def initialize name
        @name = name
    end

    def get_name
        @name
    end

end

p1 = Person.new "Jane"
p2 = Person.new "Beky"

puts p1.get_name
puts p2.get_name
</code></pre>


<p>上面的例子定义了一个<em>Person</em>类，并且有一个实例变量。</p>


<pre><code>class Person

    def initialize name
        @name = name
    end
</code></pre>


<p><em>Person</em>的构造函数设置了一个实例变量<em>name</em>。构造函数的<em>name</em>参数是在创建时传递的。构造函数是在实例对象创建时调用。<em>@name</em>是一个实例变量。在Ruby中实例变量以@字符开头。</p>


<pre><code>def get_name
    @name
end
</code></pre>


<p><em>get_name</em>方法返回成员字段。在Ruby蝇成员字段只能通过方法来访问。</p>


<pre><code>p1 = Person.new "Jane"
p2 = Person.new "Beky"
</code></pre>


<p>我们创建了<em>Person</em>类的两个对象。每个对象的构造函数都传递了一个字符串参数。</p>


<pre><code>puts p1.get_name
puts p2.get_name
</code></pre>


<p>通过调用每个对象的<em>get_name</em>方法来打印成员字段。</p>


<p>$ ./person.rb<br>
Jane<br>
Beky  </p>


<p>从程序的输出看到每个实例都有自己的<em>name</em>成员字段。</p>


<hr>


<p>我们可以创建一个对象而不调用构造函数。Ruby有一个特殊的<em>allocate</em>方法。<em>allocate</em>方法为新的对象分配空间而不调用<em>initialize</em>。</p>


<pre><code>#!/usr/bin/ruby

class Being

   def initialize
       puts "Being created"
   end   
end


b1 = Being.new
b2 = Being.allocate
puts b2
</code></pre>


<p>这个例子我们创建了两个对象。第一介对象使用<em>new</em>方法，第二个对象使用<em>allocate</em>方法。</p>


<pre><code>b1 = Being.new
</code></pre>


<p>这里我们通过<em>new</em>关键字创建一个实例对象。构造函数<em>initialize</em>将会调用，并且在终端上打印消息。</p>


<pre><code>b2 = Being.allocate
puts b2
</code></pre>


<p>这里使用<em>allocate</em>方法，没有调用构造函数。使用<em>puts</em>关键字调用对象的<em>to_s</em>方法将其显示。</p>


<pre><code>$ ./allocate.rb
Being created
#&lt;Being:0x8ea0044&gt;
</code></pre>


<p>程序的输出。</p>


<h2>构造函数重载</h2>


<p>重载构造函数可以使用类有多种类型的构造函数。这样我们可以使用不同数量或者不同类型的参数来创建对象。</p>


<p>Ruby没有我们所知的其他语言那样的构造函数重载。在Ruby中这种行为可以通过一些有默认值的扩展参数来模拟。</p>


<pre><code>#!/usr/bin/ruby


class Person

    def initialize name="unknown", age=0
        @name = name
        @age = age        
    end

    def to_s
        "Name: #{@name}, Age: #{@age}"
    end

end

p1 = Person.new
p2 = Person.new "unknown", 17
p3 = Person.new "Becky", 19
p4 = Person.new "Robert"

p p1, p2, p3, p4
</code></pre>


<p>这个例子展示了模拟构造函数的重载。当<em>name</em>参数没有指定时使用<em>&#8220;unknow&#8221;</em>代替，对于<em>age</em>使用0。</p>


<pre><code>def initialize name="unknown", age=0
    @name = name
    @age = age        
end
</code></pre>


<p>这个构造传入两个参数。它们都有默认值。当我们创建对象没有指定值时就使用默认值。注意参数顺序必须一致。第一个是<em>name</em>，第二介是<em>age</em>。</p>


<pre><code>p1 = Person.new
p2 = Person.new "unknown", 17
p3 = Person.new "Becky", 19
p4 = Person.new "Robert"

p p1, p2, p3, p4
</code></pre>


<p>我们创建了四个对象。构造函数传入了不同个数的参数。</p>


<p>$ ./consover.rb<br>
Name: unknown, Age: 0<br>
Name: unknown, Age: 17<br>
Name: Becky, Age: 19<br>
Name: Robert, Age: 0  </p>


<p>例子的输出结果。</p>


<h2>方法</h2>


<p>方法是定义在类里面的函数。它们用于对对象的属性执行一些操作。方法在面向对象范式的封装性中必不可少。例如我们<em>AccessDatabase</em>类中有一个<em>connect</em>方法，我们不需要关心这个方法到底是如何连接数据库的。我们仅需要知道使用这个方法连接数据库。这对程序功能的划分必不可少，尤其是大的应用程序。</p>


<p>在Ruby中数据仅能够通过方法访问。</p>


<pre><code>#!/usr/bin/ruby

class Person

    def initialize name
        @name = name
    end

    def get_name
        @name
    end

end

per = Person.new "Jane"

puts per.get_name
puts per.send :get_name
</code></pre>


<p>这个例子展示了调用方法的两个基本方式。</p>


<pre><code>puts per.get_name
</code></pre>


<p>通常的方式是在对象后面使用点操作符。</p>


<pre><code>puts per.send :get_name
</code></pre>


<p>另种方式是使用内建的<em>send</em>方法。它将方法名符号作为参数传入。</p>


<hr>


<p>方法通常对对象的数据进行一些操作。</p>


<pre><code>#!/usr/bin/ruby

class Circle

    @@PI = 3.141592

    def initialize
        @radius = 0
    end

    def set_radius radius
        @radius = radius
    end

    def area
        @radius * @radius * @@PI
    end

end


c = Circle.new
c.set_radius 5
puts c.area
</code></pre>


<p>这个例子的代码我们定义了一个<em>Circle</em>类两个方法。</p>


<pre><code>@@PI = 3.141592
</code></pre>


<p>我们在<em>Circle</em>类中定义了一个<em>@@PI</em>变量。类变量以<em>@@</em>开头。类变量是属于类的，每个对象都可以访问它们的类变量。我们<em>@@PI</em>来计算圆的面积。</p>


<p>def initialize
    @radius = 0
end</p>


<p>定义了一个成员字段。它是圆的半径。如果我们想在外部修改这个变量，我们必须使用公开的<em>set_radius</em>方法。这个数据是受保护的。</p>


<pre><code>def set_radius radius
    @radius = radius
end
</code></pre>


<p>这是<em>set_radius</em>方法。它为<em>@radius</em>实例变量设置一个新的值。</p>


<pre><code>def area
    @radius * @radius * @@PI
end
</code></pre>


<p><em>area</em>方法返回圆的面积。</p>


<pre><code>c = Circle.new
c.set_radius 5
puts c.area
</code></pre>


<p>我们创建一个<em>Circle</em>类的实例对象，并且通过<em>set_radius</em>方法设置它的半径。</p>


<p>$ ./circle.rb<br>
78.5398  </p>


<p>例子的输出结果。</p>


<h2>访问修饰符</h2>


<p>访问修饰符设置成员和方法的可见性。Ruby有三种访问修饰符：<em>public</em>、<em>protected</em>和<em>private</em>。在Ruby中所有的数据都是私有的。访问修饰符可以仅对方法使用。Ruby中的方法是公开的，除非使用了其他修饰符。</p>


<p>公开的方法在类的内部和外部都可以访问。保护和私有的方法略微不同。都不能在类外部访问，仅能在这个类和它的子类或者父类内部访问。</p>


<p>注意与其他面向对象编程语言不同，继承不会充当访问修饰符。仅有两件事很重要。第一，我们是否可以在类的内部或者外部访问方法。第二，是否我们要使用或者不使用<em>self</em>关键字。</p>


<p>访问修饰符保护数据避免受到意外的修改。使用程序更健壮。实现一些主要用于修改数据的方法。这些方法最好是私有的。只有真正需要修改才将接口公开给用户。多年来用户习惯使用特殊方法并对打破向后兼容普遍不满。</p>


<pre><code>#!/usr/bin/ruby

class Some

     def method1
         puts "public method1 called"
     end

    public

     def method2
         puts "public method2 called"  
     end

     def method3
         puts "public method3 called"
         method1
         self.method1
     end          
end

s = Some.new
s.method1
s.method2
s.method3
</code></pre>


<p>这个例子解释了Ruby公有方法的用法。</p>


<pre><code>def method1
    puts "public method1 called"
end
</code></pre>


<p><em>method1</em>是公有的，尽管我们没有使用<em>public</em>修饰符。因为方法默认都是公有的，除非指明为其他。</p>


<pre><code>public

  def method2
      puts "public method2 called"  
  end

  ...
</code></pre>


<p><em>public</em>关键字之后的方法是公有的。</p>


<pre><code>def method3
    puts "public method3 called"
    method1
    self.method1
end
</code></pre>


<p>在公有方法<em>method3</em>中我们通过使用和没有使用<em>self</em>关键字调用了另一个公有方法。</p>


<pre><code>s = Some.new
s.method1
s.method2
s.method3
</code></pre>


<p>公有方法是仅能够在类外部调用的方法。</p>


<p>$ ./public_methods.rb  
public method1 called  
public method2 called  
public method3 called  
public method1 called  
public method1 called</p>


<p>例子运行结果。</p>


<hr>


<p>下一个例子看私有方法。</p>


<pre><code>#!/usr/bin/ruby


class Some

    def initialize
        method1
        # self.method1
    end

    private

     def method1
         puts "private method1 called"  
     end

end


s = Some.new
# s.method1
</code></pre>


<p>私有方法是Ruby中严厉的方法。它们只能够在类内部调用并且不能使用<em>self</em>关键字。</p>


<pre><code>def initialize
    method1
    # self.method1
end
</code></pre>


<p>在构造函数方法中我们调用了私有方法<em>method1</em>。使用<em>self</em>调用的被注释了。私有方法不能指定接收者。</p>


<pre><code>private

  def method1
      puts "private method1 called"  
  end
</code></pre>


<p><em>private</em>关键字之后的是私有方法。</p>


<pre><code>s = Some.new
# s.method1
</code></pre>


<p>创建了一个<em>Some</em>类的实例对象。在外部调用这个方法是禁止的，如果将这行取消注释Ruby解释器会报错。</p>


<p>$ ./private_methods.rb<br>
private method called  </p>


<p>输出结果。</p>


<hr>


<p>最后我们使用保护方法。保护方法和私有方法的区别很小。保护方法与私有方法相似，不过它们可以通过<em>self</em>关键字调用。</p>


<pre><code>#!/usr/bin/ruby

class Some

    def initialize
        method1
        self.method1
    end

    protected

     def method1
         puts "protected method1 called"  
     end

end


s = Some.new
# s.method1
</code></pre>


<p>上面的例子展示了保护方法的用法。</p>


<pre><code>def initialize
    method1
    self.method1
end
</code></pre>


<p>保护方法可以使用和不使用<em>self</em>关键字。</p>


<pre><code>protected

  def method1
      puts "protected method1 called"  
  end
</code></pre>


<p>保护方法以<em>protected</em>关键字开头。</p>


<pre><code>s = Some.new
# s.method1
</code></pre>


<p>保护方法不能在类外部调用。取消注释会报错。</p>


<h2>继承</h2>


<p>继承是使用已经定义的类来构造新的类的方式。新构建的类称为派生类。派生自的类称为基类。继承的好处是代码利用，减少程序的复杂性。派生类（后代）覆盖或者扩展基类（祖先）的函数。</p>


<pre><code>#!/usr/bin/ruby

class Being

    def initialize
        puts "Being class created"
    end
end

class Human &lt; Being

   def initialize
       super
       puts "Human class created"
   end
end

Being.new
Human.new
</code></pre>


<p>这个程序我们定义了两个类：一个基类<em>Being</em>和一个派生类<em>Human</em>。</p>


<pre><code>class Human &lt; Being
</code></pre>


<p>Ruby中使用<em>&lt;</em>操作符创建继承关系。<em>Human</em>类继承自<em>Being</em>类。</p>


<pre><code>def initialize
    super
    puts "Human class created"
end
</code></pre>


<p><em>super</em>方法调用父类的构造函数。</p>


<pre><code>Being.new
Human.new
</code></pre>


<p>实例化了<em>Being</em>类和<em>Human</em>类。</p>


<p>$ ./inheritance.rb <br>
Being class created<br>
Being class created<br>
Human class created  </p>


<p>首先创建<em>Being</em>类。基类<em>Human</em>同样也调用了父类的构造函数。</p>


<hr>


<p>一个对象的关系可能很复杂。一个对象可以有多个祖先。Ruby有<em>ancestors</em>方法获取一个类的祖先列表。</p>


<p>每个Ruby对象都是<em>Object</em>、<em>BaseObject</em>和<em>Kernel</em>的后代。它们内建于Ruby语言的内核中。</p>


<pre><code>#!/usr/bin/ruby


class Being 
end

class Living &lt; Being 
end

class Mammal &lt; Living 
end

class Human &lt; Mammal 
end


p Human.ancestors
</code></pre>


<p>这个例子中定义了四个类。<em>Human</em>、<em>Mammal</em>、<em>Living</em>和<em>Being</em>。</p>


<pre><code>p Human.ancestors
</code></pre>


<p>打印Human类的祖先。</p>


<p>$ ./ancestors.rb <br>
[Human, Mammal, Living, Being, Object, Kernel, BasicObject]  </p>


<p><em>Human</em>类有三个自定义的和三个内建的祖先。</p>


<hr>


<p>一个更复杂的例子。</p>


<pre><code>#!/usr/bin/ruby

class Being

    @@count = 0

    def initialize
        @@count += 1
        puts "Being class created"
    end

    def show_count
        "There are #{@@count} beings"
    end

end

class Human &lt; Being

   def initialize
       super
       puts "Human is created"
   end
end

class Animal &lt; Being

   def initialize
       super
       puts "Animal is created"
   end
end

class Dog &lt; Animal

   def initialize
       super
       puts "Dog is created"
   end
end

Human.new
d = Dog.new
puts d.show_count
</code></pre>


<p>我们定义了四个类。继承的层级有点复杂。<em>Human</em>和<em>Animal</em>继承自<em>Being</em>。<em>Dog</em>继承自<em>Animal</em>。我们还使用了类变量来统计beings的创建个数。</p>


<pre><code>@@count = 0
</code></pre>


<p>我们定义一个类变量。它用于统计beings的创建个数。</p>


<pre><code>def initialize
    @@count += 1
    puts "Being class created"
end
</code></pre>


<p>每次<em>Being</em>类实例化时我们将<em>@@count</em>变量加1。这使用我们可以跟踪实例创建的个数。</p>


<pre><code>class Animal &lt; Being
...

class Dog &lt; Animal
...
</code></pre>


<p><em>Animal</em>继承自<em>Being</em>，<em>Dog</em>继承自<em>Animal</em>。进一步的<em>Dog</em>也继承自<em>Being</em>。</p>


<pre><code>Human.new
d = Dog.new
puts d.show_count
</code></pre>


<p>我们通过<em>Human</em>和<em>Dog</em>创建实例。然后调用<em>Dog</em>对象的<em>show_count</em>方法。<em>Dog</em>类没有该方法，将调用<em>Being</em>类的。</p>


<p>$ ./inheritance2.rb 
Being class created<br>
Human is created<br>
Being class created<br>
Animal is created<br>
Dog is created<br>
There are 2 beings  </p>


<p><em>Human</em>对象调用了两个构造函数。<em>Dog</em>对象调用了三个构造函数。创建了两个<em>Being</em>实例。</p>


<hr>


<p>方法和数据成员可见性在继承中不起作用。这与其他通常的面向对象编程语言是显著的不同。</p>


<p>在C#或者Java中公有的和保护的数据成员和方法可以被继承，私有的不能。与这相比，在Ruby中私有的数据成员和方法也可以被继承。数据成员和方法的可见性不会受继承的影响。</p>


<pre><code>#!/usr/bin/ruby

class Base

    def initialize
        @name = "Base"
    end

    private

     def private_method
         puts "private method called"
     end

    protected

     def protected_method
         puts "protected_method called"
     end

    public

     def get_name
         return @name
     end
end


class Derived &lt; Base

    def public_method
        private_method
        protected_method
    end
end

d = Derived.new
d.public_method
puts d.get_name
</code></pre>


<p>这个例子中有两个类。<em>Derived</em>继承乍<em>Base</em>。它继承了三个方法和一个数据字段。</p>


<pre><code>def public_method
    private_method
    protected_method
end
</code></pre>


<p><em>Derived</em>类的<em>public_method</em>调用了一个私有方法和一个保护方法。它们定义在父类中。</p>


<pre><code>d = Derived.new
d.public_method
puts d.get_name
</code></pre>


<p>创建一个<em>Derived</em>类的实例。调用<em>public_method</em>方法和<em>get_name</em>方法，它返回私有的实例变量<em>@name</em>。记住Ruby中所有的实例变量都是私有的。<em>get_name</em>方法返回这个变量不管<em>@name</em>是私有的还是在父类中定义的。</p>


<p>$ ./inheritance3.rb<br>
private method called<br>
protected_method called<br>
Base  </p>


<p>输出结果证实了在Ruby中公有的、保护的、私有的方法和私有的成员字段都能被继承。</p>


<h2>super方法</h2>


<p><em>super</em>方法调用父类的同名方法。如果没有传递参数它将自动的把当前的所有参数传入。如果写为<em>super()</em>则没有参数传入。</p>


<pre><code>#!/usr/bin/ruby

class Base

    def show x=0, y=0
        p "Base class, x: #{x}, y: #{y}"
    end
end

class Derived &lt; Base

    def show x, y
        super
        super x
        super x, y
        super()
    end
end


d = Derived.new
d.show 3, 3
</code></pre>


<p>这个例子有两个类一个继承。它们都定义了<em>show</em>方法。这个方法在<em>Derived</em>类中使用super调用了父类的方法。</p>


<pre><code>def show x, y
    super
    super x
    super x, y
    super()
end
</code></pre>


<p><em>super</em>不带参数则会传递将当前传入的参数，这里是x=3、y=3。<em>super()</em>方法不传递参数。</p>


<p>$ ./super.rb<br>
&#8220;Base class, x: 3, y: 3&#8221;<br>
&#8220;Base class, x: 3, y: 0&#8221;<br>
&#8220;Base class, x: 3, y: 3&#8221;<br>
&#8220;Base class, x: 0, y: 0&#8221;  </p>


<p>输出结果。</p>


<p>这是Ruby的面向对象的第一部分。</p>


<hr>


<p>原文地址： <a href="http://zetcode.com/lang/rubytutorial/oop/">http://zetcode.com/lang/rubytutorial/oop/</a><br>
翻译：龙昌  admin@longchangjin.cn<br>
完整教程：<a href="https://github.com/wusuopu/Ruby-tutorial">https://github.com/wusuopu/Ruby-tutorial</a> </p>

</div>
  
  


    </article>
  
  <div class="pagination">
    
      <a class="prev" href="/page/8">&larr; Older</a>
    
    <a href="/blog/archives">Blog Archives</a>
    
    <a class="next" href="/page/6">Newer &rarr;</a>
    
  </div>
</div>
<aside class="sidebar">
  
    <section>
  <h1>Subscription</h1>
  <!--以下是QQ邮件列表订阅嵌入代码--><script >var nId = "e7ee5da6d322dc7157c25cfd8a7700bb23a056dd1fb18cb4",nWidth="auto",sColor="light",sText="请输入邮件地址：" ;</script><script src="http://list.qq.com/zh_CN/htmledition/js/qf/page/qfcode.js" charset="gb18030"></script>
</section>
<section>
  <h1>Recent Posts</h1>
  <ul id="recent_posts">
    
      <li class="post">
        <a href="http://www.xefan.com/archives/84146.html">Unicorn是如何与nginx通讯的——介绍ruby中的unix Socket</a>
      </li>
    
      <li class="post">
        <a href="http://www.xefan.com/archives/84145.html">Ruby的内存陷阱</a>
      </li>
    
      <li class="post">
        <a href="http://www.xefan.com/archives/84144.html">未来的Ruby 3.0</a>
      </li>
    
      <li class="post">
        <a href="http://www.xefan.com/archives/84143.html">Ruby中一些重要的钩子方法</a>
      </li>
    
      <li class="post">
        <a href="http://www.xefan.com/archives/84142.html">使用Unicorn部署rails应用</a>
      </li>
    
  </ul>
</section>
<section>
  <h1>Categories</h1>
    <ul id="category-list"><li><a href='/categories/linux栏目/index.html'>linux栏目 (48)</a></li><li><a href='/categories/python栏目/index.html'>python栏目 (34)</a></li><li><a href='/categories/ruby栏目/index.html'>ruby栏目 (31)</a></li><li><a href='/categories/web开发/index.html'>web开发 (19)</a></li><li><a href='/categories/嵌入式栏目/index.html'>嵌入式栏目 (11)</a></li><li><a href='/categories/开源软件/index.html'>开源软件 (20)</a></li><li><a href='/categories/教程/index.html'>教程 (15)</a></li><li><a href='/categories/数据库/index.html'>数据库 (10)</a></li><li><a href='/categories/数据结构和算法/index.html'>数据结构和算法 (16)</a></li><li><a href='/categories/编程开发/index.html'>编程开发 (38)</a></li><li><a href='/categories/网络日志/index.html'>网络日志 (11)</a></li><li><a href='/categories/资源分享/index.html'>资源分享 (23)</a></li></ul>
</section>
<section>
  <h1>Tag Cloud</h1>
    <span id="tag-cloud"><a href='/tags/access/index.html' style='font-size: 105.3731343283582%'>access(6)</a> <a href='/tags/adobe/index.html' style='font-size: 100.8955223880597%'>adobe(1)</a> <a href='/tags/ajax/index.html' style='font-size: 101.7910447761194%'>ajax(2)</a> <a href='/tags/apache/index.html' style='font-size: 100.8955223880597%'>apache(1)</a> <a href='/tags/arch/index.html' style='font-size: 106.26865671641791%'>Arch(7)</a> <a href='/tags/arm/index.html' style='font-size: 107.16417910447761%'>ARM(8)</a> <a href='/tags/asp/index.html' style='font-size: 106.26865671641791%'>asp(7)</a> <a href='/tags/c/index.html' style='font-size: 111.64179104477611%'>C(13)</a> <a href='/tags/css/index.html' style='font-size: 101.7910447761194%'>css(2)</a> <a href='/tags/django/index.html' style='font-size: 102.68656716417911%'>Django(3)</a> <a href='/tags/dreamweaver/index.html' style='font-size: 100.8955223880597%'>Dreamweaver(1)</a> <a href='/tags/fedora/index.html' style='font-size: 101.7910447761194%'>Fedora(2)</a> <a href='/tags/firefox/index.html' style='font-size: 102.68656716417911%'>firefox(3)</a> <a href='/tags/flash/index.html' style='font-size: 100.8955223880597%'>Flash(1)</a> <a href='/tags/ftp/index.html' style='font-size: 100.8955223880597%'>ftp(1)</a> <a href='/tags/gcc/index.html' style='font-size: 105.3731343283582%'>gcc(6)</a> <a href='/tags/gentoo/index.html' style='font-size: 101.7910447761194%'>Gentoo(2)</a> <a href='/tags/git/index.html' style='font-size: 103.58208955223881%'>git(4)</a> <a href='/tags/gobject/index.html' style='font-size: 105.3731343283582%'>GObject(6)</a> <a href='/tags/grub/index.html' style='font-size: 100.8955223880597%'>grub(1)</a> <a href='/tags/gtk/index.html' style='font-size: 115.22388059701493%'>gtk(17)</a> <a href='/tags/hash/index.html' style='font-size: 100.8955223880597%'>Hash(1)</a> <a href='/tags/ibus/index.html' style='font-size: 100.8955223880597%'>ibus(1)</a> <a href='/tags/js/index.html' style='font-size: 100.8955223880597%'>js(1)</a> <a href='/tags/linux/index.html' style='font-size: 160.0%'>Linux(67)</a> <a href='/tags/mongodb/index.html' style='font-size: 110.74626865671642%'>mongodb(12)</a> <a href='/tags/mysql/index.html' style='font-size: 103.58208955223881%'>mysql(4)</a> <a href='/tags/nginx/index.html' style='font-size: 100.8955223880597%'>nginx(1)</a> <a href='/tags/node/index.html' style='font-size: 100.8955223880597%'>node(1)</a> <a href='/tags/php/index.html' style='font-size: 108.95522388059702%'>php(10)</a> <a href='/tags/ps/index.html' style='font-size: 105.3731343283582%'>PS(6)</a> <a href='/tags/pygame/index.html' style='font-size: 110.74626865671642%'>pygame(12)</a> <a href='/tags/python/index.html' style='font-size: 145.67164179104478%'>python(51)</a> <a href='/tags/qt/index.html' style='font-size: 101.7910447761194%'>Qt(2)</a> <a href='/tags/redis/index.html' style='font-size: 100.8955223880597%'>Redis(1)</a> <a href='/tags/redis/index.html' style='font-size: 100.8955223880597%'>redis(1)</a> <a href='/tags/ruby/index.html' style='font-size: 128.65671641791045%'>Ruby(32)</a> <a href='/tags/scrapy/index.html' style='font-size: 102.68656716417911%'>Scrapy(3)</a> <a href='/tags/shell/index.html' style='font-size: 100.8955223880597%'>shell(1)</a> <a href='/tags/tq2440/index.html' style='font-size: 104.4776119402985%'>TQ2440(5)</a> <a href='/tags/ubuntu/index.html' style='font-size: 106.26865671641791%'>ubuntu(7)</a> <a href='/tags/usb/index.html' style='font-size: 102.68656716417911%'>USB(3)</a> <a href='/tags/vim/index.html' style='font-size: 123.28358208955224%'>vim(26)</a> <a href='/tags/virtualbox/index.html' style='font-size: 102.68656716417911%'>VirtualBox(3)</a> <a href='/tags/vmware/index.html' style='font-size: 100.8955223880597%'>vmware(1)</a> <a href='/tags/w3m/index.html' style='font-size: 100.8955223880597%'>w3m(1)</a> <a href='/tags/web开发/index.html' style='font-size: 113.43283582089552%'>Web开发(15)</a> <a href='/tags/windows/index.html' style='font-size: 106.26865671641791%'>windows(7)</a> <a href='/tags/wordpress/index.html' style='font-size: 100.8955223880597%'>WordPress(1)</a> <a href='/tags/xml/index.html' style='font-size: 100.8955223880597%'>xml(1)</a> <a href='/tags/免费/index.html' style='font-size: 100.8955223880597%'>免费(1)</a> <a href='/tags/内核/index.html' style='font-size: 100.8955223880597%'>内核(1)</a> <a href='/tags/匹配算法/index.html' style='font-size: 105.3731343283582%'>匹配算法(6)</a> <a href='/tags/单片机/index.html' style='font-size: 101.7910447761194%'>单片机(2)</a> <a href='/tags/嵌入式/index.html' style='font-size: 100.8955223880597%'>嵌入式(1)</a> <a href='/tags/开源软件/index.html' style='font-size: 108.05970149253731%'>开源软件(9)</a> <a href='/tags/排序算法/index.html' style='font-size: 108.05970149253731%'>排序算法(9)</a> <a href='/tags/文件空间/index.html' style='font-size: 100.8955223880597%'>文件空间(1)</a> <a href='/tags/无线网/index.html' style='font-size: 100.8955223880597%'>无线网(1)</a> <a href='/tags/正则式/index.html' style='font-size: 100.8955223880597%'>正则式(1)</a> <a href='/tags/注册机/index.html' style='font-size: 101.7910447761194%'>注册机(2)</a> <a href='/tags/游戏/index.html' style='font-size: 108.95522388059702%'>游戏(10)</a> <a href='/tags/电脑技巧/index.html' style='font-size: 108.05970149253731%'>电脑技巧(9)</a> <a href='/tags/空间/index.html' style='font-size: 100.8955223880597%'>空间(1)</a> <a href='/tags/算法/index.html' style='font-size: 114.32835820895522%'>算法(16)</a> <a href='/tags/红旗/index.html' style='font-size: 100.8955223880597%'>红旗(1)</a> <a href='/tags/经典语录/index.html' style='font-size: 100.8955223880597%'>经典语录(1)</a> <a href='/tags/网络日志/index.html' style='font-size: 105.3731343283582%'>网络日志(6)</a> <a href='/tags/翻译/index.html' style='font-size: 122.38805970149254%'>翻译(25)</a> <a href='/tags/视频教程/index.html' style='font-size: 108.95522388059702%'>视频教程(10)</a> <a href='/tags/资源分享/index.html' style='font-size: 110.74626865671642%'>资源分享(12)</a> <a href='/tags/转载/index.html' style='font-size: 101.7910447761194%'>转载(2)</a> <a href='/tags/随笔/index.html' style='font-size: 100.8955223880597%'>随笔(1)</a> </span>
</section>
<section>
  <h1>Link</h1>
    <ul id="category-list">
      <li><a target="_blank" title="我的Github" href="https://github.com/wusuopu">@Github</a></li>
      <li><a target="_blank" title="我的微博" href="http://www.weibo.com/u/1768691343">@Weibo</a></li>
      <li><a target="_blank" title="我的Twitter" href="https://twitter.com/longchangjin">@Twitter</a></li>
      <li><a target="_blank" title="我的豆瓣" href="http://www.douban.com/people/lchj/">@Douban</a></li>

      <li><a target="_blank" title="" href="http://www.vimer.cn/">Vimer的程序世界</a></li>
      <li><a target="_blank" title="" href="http://pythoner.net/">python开发者社区</a></li>
      <li><a target="_blank" title="" href="http://simple-is-better.com/">python.cn(news, jobs)</a></li>
      <li><a target="_blank" title="" href="http://gtk.awaysoft.com/">GTK+ 中文社区</a></li>
    </ul>
</section>

  
</aside>

    </div>
  </div>
  <footer role="contentinfo"><p>
  Copyright &copy; 2015 - 龍昌 -
  <span class="credit">Powered by <a href="http://octopress.org">Octopress</a></span>
</p>
<div style="display:none;"><script src="http://s94.cnzz.com/stat.php?id=1259846&web_id=1259846&show=pic" language="JavaScript"></script></div>

</footer>
  

<script type="text/javascript">
      var disqus_shortname = 'longchang';
      
        
        var disqus_script = 'count.js';
      
    (function () {
      var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
      dsq.src = '//' + disqus_shortname + '.disqus.com/' + disqus_script;
      //dsq.src = '/javascripts/disqus/' + disqus_script;
      (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    }());
</script>











</body>
</html>
