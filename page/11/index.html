<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>龍昌博客</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="关注Linux及开源信息">
<meta property="og:type" content="website">
<meta property="og:title" content="龍昌博客">
<meta property="og:url" content="http://www.xefan.com/page/11/index.html">
<meta property="og:site_name" content="龍昌博客">
<meta property="og:description" content="关注Linux及开源信息">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="龍昌博客">
<meta name="twitter:description" content="关注Linux及开源信息">
  
    <link rel="alternate" href="/atom.xml" title="龍昌博客" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  <link rel="stylesheet" href="/css/style.css">
  

</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">龍昌博客</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">从Pythoneer转向Rubist</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
          <a class="main-nav-link" href="/about">About</a>
        
          <a class="main-nav-link" href="/gbook">留言板</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://www.xefan.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-/archives/83960.html" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/archives/83960.html" class="article-date">
  <time datetime="2013-11-23T11:15:27.000Z" itemprop="datePublished">2013-11-23</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Ruby栏目/">Ruby栏目</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/archives/83960.html">[翻译]Ruby GTK教程3——控件</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p></p><h1>控件</h1><p></p>
<p>在这部分的Ruby GTK编程教程中我们将提到一些控件。</p><br><p>控件是GUI应用程序的基本构成。这些年来一些控件成为了所有平台所有套件的标准。如按钮、复选框或者滚动条。GTK套件的理念是保持控件的数量为最小的数量级，一些特殊的控件需要创建为自定义GTK控件。</p><br><h2>复选按钮（CheckButton）</h2><br><p><em>CheckButton</em>是一个有两种状态的控件，开和关。开状态表示选中。它用于表示一些布尔属性。</p><br><pre><code>#!/usr/bin/ruby<br><br># ZetCode Ruby GTK tutorial<br>#<br># This program toggles the title of the<br># window with the CheckButton widget<br>#<br># author: jan bodnar<br># website: www.zetcode.com<br># last modified: April 2009<br><br>require ‘gtk2’<br><br>class RubyApp &lt; Gtk::Window<br>    def initialize<br>        super<br><br>        set_title “CheckButton”<br>        signal_connect “destroy” do<br>            Gtk.main_quit<br>        end<br><br>        init_ui<br><br>        set_default_size 250, 200<br>        set_window_position Gtk::Window::POS_CENTER<br>        show_all<br>    end<br><br><br>    def init_ui<br><br>        fixed = Gtk::Fixed.new<br>        add fixed<br><br>        cb = Gtk::CheckButton.new “Show title”<br>        cb.set_active true<br>        cb.set_can_focus false<br>        cb.signal_connect(“clicked”) do |w|<br>            on_clicked(w)<br>        end<br><br>        fixed.put cb, 50, 50<br><br>    end<br><br>    def on_clicked sender<br><br>        if sender.active?<br>            self.set_title “Check Button”<br>        else<br>           self.set_title “”<br>        end<br>    end<br>end<br><br>Gtk.init<br>    window = RubyApp.new<br>Gtk.main<br></code></pre><br><p>我们将根据复选按钮的状态在窗口的标题栏显示一个标题。</p><br><pre><code>cb = Gtk::CheckButton.new “Show title”<br></code></pre><br><p>创建<em>CheckButton</em>控件。</p><br><pre><code>cb.set_active true<br></code></pre><br><p>标题默认是可见的，因此我们将按钮默认选中。</p><br><pre><code>if sender.active?<br>    self.set_title “Check Button”<br>else<br>    self.set_title “”<br>end<br></code></pre><br><p>如果按钮选中则显示标题。</p><br><p><img alt="image1" src="http://zetcode.com/img/gui/rubygtk/checkbutton.png"><br><br><em>图片：复选按钮</em></p><br><h2>标签（Label）</h2><br><p>Label控件用于显示文本。</p><br><pre><code>#!/usr/bin/ruby<br><br># ZetCode Ruby GTK tutorial<br>#<br># This example demonstrates the Label widget<br>#<br># author: jan bodnar<br># website: www.zetcode.com<br># last modified: June 2009<br><br>require ‘gtk2’<br><br>$lyrics = %{Meet you downstairs in the bar and heard<br>your rolled up sleeves and your skull t-shirt<br>You say why did you do it with him today?<br>and sniff me out like I was Tanqueray<br><br>cause you’re my fella, my guy<br>hand me your stella and fly<br>by the time I’m out the door<br>you tear men down like Roger Moore<br><br>I cheated myself<br>like I knew I would<br>I told ya, I was trouble<br>you know that I’m no good}<br><br><br>class RubyApp &lt; Gtk::Window<br><br>    def initialize<br>        super<br><br>        set_title  “You know I’m no Good”<br>        signal_connect “destroy” do<br>            Gtk.main_quit<br>        end<br><br>        init_ui<br><br>        set_default_size 250, 200<br>        set_window_position Gtk::Window::POS_CENTER<br><br>        show_all<br>    end<br><br>    def init_ui<br><br>        set_border_width 10<br>        label = Gtk::Label.new $lyrics<br>        add label<br><br>    end<br>end<br><br>Gtk.init<br>    window = RubyApp.new<br>Gtk.main<br></code></pre><br><p>例子在窗口上显示了一些歌词。</p><br><pre><code> $lyrics = %{Meet you downstairs in the bar and heard<br> your rolled up sleeves and your skull t-shirt<br> …<br></code></pre><br><p>创建一个多行文本。</p><br><pre><code>set_border_width 10<br></code></pre><br><p>标签被一些空白空间包围着。</p><br><pre><code>label = Gtk::Label.new $lyrics<br>add label<br></code></pre><br><p>创建标签并添加到窗口内。</p><br><p><img alt="image2" src="http://zetcode.com/img/gui/rubygtk/label.png"><br><br><em>图片：标签控件</em></p><br><h2>输入框（Entry）</h2><br><p>Entry是单行文本输入字段，用于文本数据的输入。</p><br><pre><code>#!/usr/bin/ruby<br><br># ZetCode Ruby GTK tutorial<br>#<br># This example demonstrates the Entry widget<br>#<br># author: jan bodnar<br># website: www.zetcode.com<br># last modified: June 2009<br><br>require ‘gtk2’<br><br><br>class RubyApp &lt; Gtk::Window<br><br>    def initialize<br>        super<br><br>        set_title “Entry”<br>        signal_connect “destroy” do<br>            Gtk.main_quit<br>        end<br><br>        init_ui<br><br>        set_default_size 250, 200<br>        set_window_position Gtk::Window::POS_CENTER<br><br>        show_all<br>    end<br><br>    def init_ui<br><br>        fixed = Gtk::Fixed.new<br><br>        label = Gtk::Label.new “…”<br>        fixed.put label, 60, 40<br><br>        entry = Gtk::Entry.new<br>        fixed.put entry, 60, 100<br><br>        entry.signal_connect “key-release-event” do |w, e|<br>            on_key_release(w, e, label)<br>        end<br><br>        add(fixed)<br>    end<br><br>    def on_key_release sender, event, label<br>        label.set_text sender.text<br>    end<br>end<br><br>Gtk.init<br>    window = RubyApp.new<br>Gtk.main<br></code></pre><br><p>这个例子显示了一个输入控件和一个标签。我们在输入框输入的文本会立即在标签上显示。</p><br><pre><code>entry = Gtk::Entry.new<br></code></pre><br><p>创建Entry控件。</p><br><pre><code>entry.signal_connect “key-release-event” do |w, e|<br>    on_key_release(w, e, label)<br>end<br></code></pre><br><p>我们将<em>on_key_release</em>方法插到Entry控件的<em>key-release-event</em>事件中。</p><br><pre><code>def on_key_release sender, event, label<br>    label.set_text sender.text<br>end<br></code></pre><br><p>从Entry控件获取文本并设置到标签中。</p><br><p><img alt="image3" src="http://zetcode.com/img/gui/rubygtk/entry.png"><br><br><em>图片：Entry控件</em></p><br><h2>图片（Image）</h2><br><p>Image控件用于显示图片。</p><br><pre><code>#!/usr/bin/ruby<br><br># ZetCode Ruby GTK tutorial<br>#<br># This example demonstrates the Image widget<br>#<br># author: jan bodnar<br># website: www.zetcode.com<br># last modified: June 2009<br><br>require ‘gtk2’<br><br><br>class RubyApp &lt; Gtk::Window<br><br>    def initialize<br>        super<br><br>        set_title “Red Rock”<br>        signal_connect “destroy” do<br>            Gtk.main_quit<br>        end<br><br>        init_ui<br><br>        set_default_size 250, 200<br>        set_window_position Gtk::Window::POS_CENTER<br><br>        show_all<br>    end<br><br>    def init_ui<br><br>        set_border_width 2<br><br>        begin<br>            image = Gtk::Image.new “redrock.png”<br>        rescue<br>            puts “cannot load image”<br>            exit<br>        end<br><br>        add image<br>    end<br><br>end<br><br>Gtk.init<br>    window = RubyApp.new<br>Gtk.main<br></code></pre><br><p>我们例子在窗口上显示了一个图片。</p><br><pre><code>set_border_width 2<br></code></pre><br><p>我们在图片周围添加一些空白边框。</p><br><pre><code>begin<br>    image = Gtk::Image.new “redrock.png”<br>rescue<br>    puts “cannot load image”<br>    exit<br>end<br></code></pre><br><p>创建Image控件。IO操作容易出现错误，因此我们处理可能的异常。</p><br><pre><code>add image<br></code></pre><br><p>将控件添加到容器中。</p><br><p><img alt="image4" src="http://zetcode.com/img/gui/rubygtk/image.jpg"><br><br><em>图片：Image控件</em></p><br><h2>下拉框（ComboBox）</h2><br><p>ComboBox控件允许用户从一个列表选项中进行选择。</p><br><pre><code>#!/usr/bin/ruby<br><br># ZetCode Ruby GTK tutorial<br>#<br># This example demonstrates the ComboBox widget<br>#<br># author: jan bodnar<br># website: www.zetcode.com<br># last modified: June 2009<br><br>require ‘gtk2’<br><br><br>class RubyApp &lt; Gtk::Window<br><br>    def initialize<br>        super<br><br>        set_title “ComboBox”<br>        signal_connect “destroy” do<br>            Gtk.main_quit<br>        end<br><br>        init_ui<br><br>        set_default_size 250, 200<br>        set_window_position Gtk::Window::POS_CENTER<br><br>        show_all<br>    end<br><br>    def init_ui<br><br>        fixed = Gtk::Fixed.new<br>        label = Gtk::Label.new ‘-‘<br>        fixed.put label, 50, 140<br><br>        cb = Gtk::ComboBox.new<br>        cb.signal_connect “changed” do |w, e|<br>            on_changed(w, e, label)<br>        end<br><br>        cb.append_text ‘Ubuntu’<br>        cb.append_text ‘Mandriva’<br>        cb.append_text ‘Redhat’<br>        cb.append_text ‘Gento’<br>        cb.append_text ‘Mint’<br><br>        fixed.put cb, 50, 30<br><br>        add fixed<br><br>    end<br><br>    def on_changed sender, event, label<br>        label.set_label sender.active_text<br>    end<br>end<br><br>Gtk.init<br>    window = RubyApp.new<br>Gtk.main<br></code></pre><br><p>这个例子显示了一个下拉框和一个标签。下拉框列表有5个选项。它们是Linux发行版的名称。标签控件显示下拉列表选中的选项。</p><br><pre><code>cb = Gtk::ComboBox.new<br></code></pre><br><p>创建下拉框。</p><br><pre><code>cb.append_text ‘Ubuntu’<br>cb.append_text ‘Mandriva’<br>cb.append_text ‘Redhat’<br>cb.append_text ‘Gento’<br>cb.append_text ‘Mint’<br></code></pre><br><p>填充数据。</p><br><pre><code>def on_changed sender, event, label<br>    label.set_label sender.active_text<br>end<br></code></pre><br><p>在<em>on_changed</em>方法里，我们获取选中的文本并设置到标签中。</p><br><p><img alt="image5" src="http://zetcode.com/img/gui/rubygtk/combobox.png"><br><br><em>图片：下拉框</em></p><br><p>在这章的Ruby GTK教程中我们显示了一些基本的控件。</p><br><hr><br><p>原文地址： <a href="http://zetcode.com/gui/rubygtk/widgets/" target="_blank" rel="external">http://zetcode.com/gui/rubygtk/widgets/</a><br><br>翻译：龙昌  admin@longchangjin.cn  </p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://www.xefan.com/archives/83960.html" data-id="cktcclrvu00j0yp4k5qzrggze" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Ruby/">Ruby</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/gtk/">gtk</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/翻译/">翻译</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-/archives/83957.html" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/archives/83957.html" class="article-date">
  <time datetime="2013-11-21T22:58:00.000Z" itemprop="datePublished">2013-11-21</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Ruby栏目/">Ruby栏目</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/archives/83957.html">[翻译]Ruby GTK教程2——布局管理</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p></p><h1>布局管理</h1><p></p>
<p>这一章我们将展示如何布置窗口或者对话框中的控件。</p><br><p>当我设计应用程序的用户界面时，我们决定了将要使用哪些控件以及如何在应用程序中组织这些控件。为了组织我们的控件，我们使用了一些称为布局容器的特殊不可见控件。这一章我们将提到<em>Alignment</em>、<em>Fixed</em>、<em>VBox</em>和<em>Table</em>。</p><br><h2>Fixed</h2><br><p>Fixed窗口是将子控件放置在固定位置固定大小。这个容器不会执行自动布局管理。在大部分的应用程序中我们不使用这个容器。它用于一些特殊的地方，例如游戏、使用图表的特殊应用、可移动可变大小的组件（如电子表格中的图表）。以下是一些小例子。</p><br><pre><code>#!/usr/bin/ruby<br><br># ZetCode Ruby GTK tutorial<br>#<br># In this program, we lay out widgets<br># using absolute positioning<br>#<br># author: jan bodnar<br># website: www.zetcode.com<br># last modified: June 2009<br><br>require ‘gtk2’<br><br><br>class RubyApp &lt; Gtk::Window<br><br>    def initialize<br>        super<br><br>        set_title “Fixed”<br>        signal_connect “destroy” do<br>            Gtk.main_quit<br>        end<br><br>        init_ui<br><br>        set_default_size 300, 280<br>        set_window_position Gtk::Window::POS_CENTER<br><br>        show_all<br>    end<br><br>    def init_ui<br><br>        modify_bg Gtk::STATE_NORMAL, Gdk::Color.new(6400, 6400, 6440)<br><br>        begin<br>            bardejov = Gdk::Pixbuf.new “bardejov.jpg”<br>            rotunda = Gdk::Pixbuf.new “rotunda.jpg”<br>            mincol = Gdk::Pixbuf.new “mincol.jpg”<br>        rescue IOError =&gt; e<br>            puts e<br>            puts “cannot load images”<br>            exit<br>        end<br><br>        image1 = Gtk::Image.new bardejov<br>        image2 = Gtk::Image.new rotunda<br>        image3 = Gtk::Image.new mincol<br><br>        fixed = Gtk::Fixed.new<br><br>        fixed.put image1, 20, 20<br>        fixed.put image2, 40, 160<br>        fixed.put image3, 170, 50<br><br>        add fixed<br><br>    end<br>end<br><br>Gtk.init<br>    window = RubyApp.new<br>Gtk.main<br></code></pre><br><p>在我们在例子中我们在窗口上显示了三张图片。我们明确的指定了这些图片的x、y坐标的位置。</p><br><pre><code>modify_bg Gtk::STATE_NORMAL, Gdk::Color.new(6400, 6400, 6440)<br></code></pre><br><p>为了更好的显示体验，我们修改背景颜色为灰色。</p><br><pre><code>bardejov = Gdk::Pixbuf.new “bardejov.jpg”<br></code></pre><br><p>从磁盘上加载图片为Pixbug对象。</p><br><pre><code>image1 = Gtk::Image.new bardejov<br>image2 = Gtk::Image.new rotunda<br>image3 = Gtk::Image.new mincol<br></code></pre><br><p><em>Image</em>是用于显示图片的控件。在它的构造函数接收一个<em>Pixbuf</em>对象。</p><br><pre><code>fixed = Gtk::Fixed.new<br></code></pre><br><p>创建一个Fixed容器。</p><br><pre><code>fixed.put image1, 20, 20<br></code></pre><br><p>将第一张图片放在x=20，y=20的坐标位置上。</p><br><pre><code> add fixed<br></code></pre><br><p>最后我们将Fixed窗口放入窗口中。</p><br><p><img alt="image1" src="http://zetcode.com/img/gui/rubygtk/fixed.png"><br><br><em>图片：Fixed</em></p><br><h2>按钮</h2><br><p>Alignment容器用于控件它的子控件的对齐和大小。</p><br><pre><code>#!/usr/bin/ruby<br><br># ZetCode Ruby GTK tutorial<br>#<br># In this program, we position two buttons<br># in the bottom right corner of the window.<br># We use horizontal and vertical boxes.<br>#<br># author: jan bodnar<br># website: www.zetcode.com<br># last modified: June 2009<br><br>require ‘gtk2’<br><br><br>class RubyApp &lt; Gtk::Window<br><br>    def initialize<br>        super<br><br>        set_title “Buttons”<br>        signal_connect “destroy” do<br>            Gtk.main_quit<br>        end<br><br>        init_ui<br><br>        set_default_size 260, 150<br>        set_window_position Gtk::Window::POS_CENTER<br><br>        show_all<br>    end<br><br>    def init_ui<br><br>        vbox = Gtk::VBox.new false, 5<br>        hbox = Gtk::HBox.new true, 3<br><br>        valign = Gtk::Alignment.new 0, 1, 0, 0<br>        vbox.pack_start valign<br><br>        ok = Gtk::Button.new “OK”<br>        ok.set_size_request 70, 30<br>        close = Gtk::Button.new “Close”<br><br>        hbox.add ok<br>        hbox.add close<br><br>        halign = Gtk::Alignment.new 1, 0, 0, 0<br>        halign.add hbox<br><br>        vbox.pack_start halign, false, false, 3<br><br>        add vbox<br>    end<br>end<br><br>Gtk.init<br>    window = RubyApp.new<br>Gtk.main<br></code></pre><br><p>这个例子的代码中，我们将两个按钮放置在窗口的右下角。为了实现这个功能我们使用了两个垂直盒子和一个水平盒子和两个对齐容器。</p><br><pre><code>valign = Gtk::Alignment.new 0, 1, 0, 0<br></code></pre><br><p>这会将子控件放置在底部。</p><br><pre><code>vbox.pack_start valign<br></code></pre><br><p>这里我们将Alignment控件放置在竖直例子中。</p><br><pre><code>hbox = Gtk::HBox.new true, 3<br>…<br>ok = Gtk::Button.new “OK”<br>ok.set_size_request 70, 30<br>close = Gtk::Button.new “Close”<br><br>hbox.add ok<br>hbox.add close<br></code></pre><br><p>创建一个水平盒子并放入两个按钮。</p><br><pre><code>halign = Gtk::Alignment.new 1, 0, 0, 0<br>halign.add hbox<br><br>vbox.pack_start halign, false, false, 3<br></code></pre><br><p>这将会创建一个对齐容器用于将其子控件放置在右边。我们将水平盒子放入对齐容器里并将对齐容器放入竖直盒子中。我们必须记住对齐容器只有一个子控件，这就是为什么我们要使用盒子容器。 <br><br><img alt="image2" src="http://zetcode.com/img/gui/rubygtk/buttons.png"><br><br><em>图片：按钮</em></p><br><h2>计算器框架</h2><br><p>Table控件将控件按行和列进行排序。</p><br><pre><code>#!/usr/bin/ruby<br><br># ZetCode Ruby GTK tutorial<br>#<br># In this program we create a skeleton of<br># a calculator. We use the Table widget.<br>#<br># author: jan bodnar<br># website: www.zetcode.com<br># last modified: June 2009<br><br>require ‘gtk2’<br><br><br>class RubyApp &lt; Gtk::Window<br><br>    def initialize<br>        super<br><br>        set_title “Calculator”<br>        signal_connect “destroy” do<br>            Gtk.main_quit<br>        end<br><br>        init_ui<br><br>        set_default_size 300, 250<br>        set_window_position Gtk::Window::POS_CENTER<br><br>        show_all<br>    end<br><br>    def init_ui<br><br>        vbox = Gtk::VBox.new false, 2<br><br>        mb = Gtk::MenuBar.new<br>        filemenu = Gtk::Menu.new<br>        file = Gtk::MenuItem.new “File”<br>        file.set_submenu filemenu<br>        mb.append file<br><br>        vbox.pack_start mb, false, false, 0<br><br>        table = Gtk::Table.new 5, 4, true<br><br>        table.attach Gtk::Button.new(“Cls”), 0, 1, 0, 1<br>        table.attach Gtk::Button.new(“Bck”), 1, 2, 0, 1<br>        table.attach Gtk::Label.new, 2, 3, 0, 1<br>        table.attach Gtk::Button.new(“Close”), 3, 4, 0, 1<br><br>        table.attach Gtk::Button.new(“7”), 0, 1, 1, 2<br>        table.attach Gtk::Button.new(“8”), 1, 2, 1, 2<br>        table.attach Gtk::Button.new(“9”), 2, 3, 1, 2<br>        table.attach Gtk::Button.new(“/“), 3, 4, 1, 2<br><br>        table.attach Gtk::Button.new(“4”), 0, 1, 2, 3<br>        table.attach Gtk::Button.new(“5”), 1, 2, 2, 3<br>        table.attach Gtk::Button.new(“6”), 2, 3, 2, 3<br>        table.attach Gtk::Button.new(“*”), 3, 4, 2, 3<br><br>        table.attach Gtk::Button.new(“1”), 0, 1, 3, 4<br>        table.attach Gtk::Button.new(“2”), 1, 2, 3, 4<br>        table.attach Gtk::Button.new(“3”), 2, 3, 3, 4<br>        table.attach Gtk::Button.new(“-“), 3, 4, 3, 4<br><br>        table.attach Gtk::Button.new(“0”), 0, 1, 4, 5<br>        table.attach Gtk::Button.new(“.”), 1, 2, 4, 5<br>        table.attach Gtk::Button.new(“=”), 2, 3, 4, 5<br>        table.attach Gtk::Button.new(“+”), 3, 4, 4, 5<br><br>        vbox.pack_start Gtk::Entry.new, false, false, 0<br><br>        vbox.pack_end table, true, true, 0<br><br>        add vbox<br><br>    end<br>end<br><br>Gtk.init<br>    window = RubyApp.new<br>Gtk.main<br></code></pre><br><p>我们使用Table控件来创建计算器的框架。</p><br><pre><code>table = Gtk::Table.new 5, 4, true<br></code></pre><br><p>我们创建了一个有5行4列的表格控件。第三个参数是homogenous参数。如果设置为true那么表格中的所有控件都是一样大小的。控件的大小等于表格容器中最大的那个控件。</p><br><pre><code>table.attach Gtk::Button.new(“Cls”), 0, 1, 0, 1<br></code></pre><br><p>我们将一个按钮附加到表格容器的左上角。前两个参数是单元格的左右边界，后两个参数是单元格的上下边界。</p><br><pre><code>vbox.pack_end table, true, true, 0<br></code></pre><br><p>将表格控件打包放入竖直盒子里。<br><br><img alt="image3" src="http://zetcode.com/img/gui/rubygtk/calculator.png">  <br><br><em>图片：计算器框架</em></p><br><h2>窗口</h2><br><p>接下来我们创建一个更高级的例子。我们展示一个JDeveloper IDE中的窗口。</p><br><pre><code>#!/usr/bin/ruby<br><br># ZetCode Ruby GTK tutorial<br>#<br># This is a more complicated layout example.<br># We use Alignment and Table widgets.<br>#<br># author: jan bodnar<br># website: www.zetcode.com<br># last modified: June 2009<br><br>require ‘gtk2’<br><br><br>class RubyApp &lt; Gtk::Window<br><br>    def initialize<br>        super<br><br>        set_title “Windows”<br>        signal_connect “destroy” do<br>            Gtk.main_quit<br>        end<br><br>        init_ui<br><br>        set_default_size 300, 250<br>        set_window_position Gtk::Window::POS_CENTER<br><br>        show_all<br>    end<br><br>    def init_ui<br><br>        set_border_width 15<br><br>        table = Gtk::Table.new 8, 4, false<br>        table.set_column_spacings 3<br><br>        title = Gtk::Label.new “Windows”<br><br>        halign = Gtk::Alignment.new 0, 0, 0, 0<br>        halign.add title<br><br>        table.attach(halign, 0, 1, 0, 1, Gtk::FILL,<br>            Gtk::FILL, 0, 0)<br><br>        frame = Gtk::Frame.new<br>        table.attach(frame, 0, 2, 1, 3, Gtk::FILL | Gtk::EXPAND,<br>            Gtk::FILL | Gtk::EXPAND, 1, 1)<br><br>        activate = Gtk::Button.new “Activate”<br>        activate.set_size_request 50, 30<br>        table.attach(activate, 3, 4, 1, 2, Gtk::FILL,<br>            Gtk::SHRINK, 1, 1)<br><br>        valign = Gtk::Alignment.new 0, 0, 0, 0<br>        close = Gtk::Button.new “Close”<br>        close.set_size_request 70, 30<br>        valign.add close<br>        table.set_row_spacing 1, 3<br>        table.attach(valign, 3, 4, 2, 3, Gtk::FILL,<br>            Gtk::FILL | Gtk::EXPAND, 1, 1)<br><br>        halign2 = Gtk::Alignment.new 0, 1, 0, 0<br>        help = Gtk::Button.new “Help”<br>        help.set_size_request 70, 30<br>        halign2.add help<br>        table.set_row_spacing 3, 6<br>        table.attach(halign2, 0, 1, 4, 5, Gtk::FILL,<br>            Gtk::FILL, 0, 0)<br><br>        ok = Gtk::Button.new “OK”<br>        ok.set_size_request 70, 30<br>        table.attach(ok, 3, 4, 4, 5, Gtk::FILL,<br>            Gtk::FILL, 0, 0)<br><br>        add table<br>    end<br>end<br><br>Gtk.init<br>    window = RubyApp.new<br>Gtk.main<br></code></pre><br><p>这个例子展示了我们如何可以使用Ruby GTK创建一个类似的窗口。</p><br><pre><code>table = Gtk::Table.new 8, 4, false<br>table.set_column_spacings 3<br></code></pre><br><p>这个例子是基于Table容器的。每个列之间有3像素的空隙。</p><br><pre><code>title = Gtk::Label.new “Windows”<br><br>halign = Gtk::Alignment.new 0, 0, 0, 0<br>halign.add title<br><br>table.attach(halign, 0, 1, 0, 1, Gtk::FILL,<br>    Gtk::FILL, 0, 0)<br></code></pre><br><p>这个代码创建了一个左对齐的标签。这个标签放置在表格的第一行中。</p><br><pre><code>frame = Gtk::Frame.new<br>table.attach(frame, 0, 2, 1, 3, Gtk::FILL | Gtk::EXPAND,<br>    Gtk::FILL | Gtk::EXPAND, 1, 1)<br></code></pre><br><p><em>frame</em>控件跨度为2行2列。</p><br><pre><code>valign = Gtk::Alignment.new 0, 0, 0, 0<br>close = Gtk::Button.new “Close”<br>close.set_size_request 70, 30<br>valign.add close<br>table.set_row_spacing 1, 3<br>table.attach(valign, 3, 4, 2, 3, Gtk::FILL,<br>    Gtk::FILL | Gtk::EXPAND, 1, 1)<br></code></pre><br><p>我们将关闭按钮放置在<em>frame</em>控件的下一个位置，在表格的第4列（我们是从0算起）。我们将按钮放在对齐控件内，这样我们就可以顶对齐了。</p><br><p><img alt="image4" src="http://zetcode.com/img/gui/rubygtk/windows.png"><br><br><em>图片：窗口</em></p><br><p>这部分的Ruby GTK教程，我们提到了布局控件。</p><br><hr><br><p>原文地址： <a href="http://zetcode.com/gui/rubygtk/layoutmanagement/" target="_blank" rel="external">http://zetcode.com/gui/rubygtk/layoutmanagement/</a><br><br>翻译：龙昌  admin@longchangjin.cn  </p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://www.xefan.com/archives/83957.html" data-id="cktcclrvw00j7yp4k942ivioc" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Ruby/">Ruby</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/gtk/">gtk</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/翻译/">翻译</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-/archives/83954.html" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/archives/83954.html" class="article-date">
  <time datetime="2013-11-20T23:28:32.000Z" itemprop="datePublished">2013-11-20</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Ruby栏目/">Ruby栏目</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/archives/83954.html">[翻译]Ruby GTK教程1——介绍</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p></p><h1>Ruby GTK介绍</h1><p></p>
<p>在这部分的Ruby GTK编程教程中，我偿将介绍GTK库并且使用Ruby语言编写我们的第一个程序。</p><br><p>这个教程的目标是让你入门GTK和Ruby。贪吃蛇游戏的图片可以从这里<a href="http://zetcode.com/img/gui/rubygtk/images.zip" target="_blank" rel="external">下载</a>。</p><br><h2>关于</h2><br><p>GTK是一个领先的创建图形化用户界面的套件。Ruby是一个流行的脚本语言。</p><br><h2>简单的例子</h2><br><p>第一个例子我们创建一个简单的窗口。这个窗口位置屏幕中间。</p><br><pre><code>#!/usr/bin/ruby<br><br># ZetCode Ruby GTK tutorial<br>#<br># This program centers a window on<br># the screen<br>#<br># author: jan bodnar<br># website: www.zetcode.com<br># last modified: April 2009<br><br>require ‘gtk2’<br><br>class RubyApp &lt; Gtk::Window<br><br>    def initialize<br>        super<br><br>        set_title “Center”<br>        signal_connect “destroy” do<br>            Gtk.main_quit<br>        end<br><br>        set_default_size 250, 200<br>        set_window_position Gtk::Window::POS_CENTER<br><br>        show<br>    end<br>end<br><br>Gtk.init<br>    window = RubyApp.new<br>Gtk.main<br></code></pre><br><p>这个例子在屏幕中间显示了一个250x200像素的窗口。</p><br><pre><code>require ‘gtk2’<br></code></pre><br><p><em>require</em>关键字导入了这个应用程序中将要使用的类。</p><br><pre><code>class RubyApp &lt; Gtk::Window<br></code></pre><br><p>这个例子继承自<em>Window</em>。<em>Window</em>是一个顶级容器。</p><br><pre><code>set_title “Center”<br></code></pre><br><p>设置窗口的标题。</p><br><pre><code>signal_connect “destroy” do<br>    Gtk.main_quit<br>end<br></code></pre><br><p>当我们点击标题栏的关闭按钮或者按下Alt+F4时<em>destroy</em>事件被触发。<em>main_quit</em>正常退出应用程序。</p><br><pre><code>set_default_size 250, 200<br></code></pre><br><p>设置应用程序窗口的默认大小。</p><br><pre><code>set_window_position Gtk::Window::POS_CENTER<br></code></pre><br><p>将窗口放置在屏幕中间。</p><br><pre><code>show<br></code></pre><br><p>一些就绪，我们在屏幕上显示该窗口。</p><br><pre><code>Gtk.init<br>    window = RubyApp.new<br>Gtk.main<br></code></pre><br><p>这三行启动应用程序。</p><br><h2>创建提示框</h2><br><p>第二个例子我们将显示一个提示框。提示框(Tooltip)是一个小的矩形窗口用于显示一些简洁的提示信息。它是一个常用的GUI组件。它是应用程序帮助系统的一部分。</p><br><pre><code>#!/usr/bin/ruby<br><br># ZetCode Ruby GTK tutorial<br>#<br># This code shows a tooltip on<br># a window and a button<br>#<br># author: jan bodnar<br># website: www.zetcode.com<br># last modified: June 2009<br><br>require ‘gtk2’<br><br>class RubyApp &lt; Gtk::Window<br><br>    def initialize<br>        super<br><br>        set_title  “Tooltips”<br>        signal_connect “destroy” do<br>            Gtk.main_quit<br>        end<br><br>        fixed = Gtk::Fixed.new<br>        add fixed<br><br>        button = Gtk::Button.new “Button”<br>        button.set_size_request 80, 35<br>        button.set_tooltip_text “Button widget”<br><br>        fixed.put button, 50, 50<br><br>        set_tooltip_text “Window widget”<br>        set_default_size 250, 200<br>        set_window_position Gtk::Window::POS_CENTER<br><br>        show_all<br><br>    end<br>end<br><br>Gtk.init<br>    window = RubyApp.new<br>Gtk.main<br></code></pre><br><p>这个例子创建了一个窗口。如果我们将鼠标光标放在窗口的区域中，将会出现一个提示框。</p><br><pre><code>button.set_tooltip_text “Button widget”<br></code></pre><br><p>我们使用<em>set_tooltip_text</em>方法设置一个提示框。</p><br><p><img alt="image1" src="http://zetcode.com/img/gui/rubygtk/tooltip.png"><br><br><em>图片：提示框</em></p><br><h2>退出按钮</h2><br><p>在这节的最后一个例子我们将创建一个退出按钮。当我们按下这个按钮时程序结束。</p><br><pre><code>#!/usr/bin/ruby<br><br># ZetCode Ruby GTK tutorial<br>#<br># This program creates a quit<br># button. When we press the button,<br># the application terminates.<br>#<br># author: jan bodnar<br># website: www.zetcode.com<br># last modified: June 2009<br><br>require ‘gtk2’<br><br>class RubyApp &lt; Gtk::Window<br><br>    def initialize<br>        super<br><br>        set_title  “Quit button”<br>        signal_connect “destroy” do<br>            Gtk.main_quit<br>        end<br><br>        init_ui<br><br>        show_all<br>    end<br><br>    def init_ui<br><br>        fixed = Gtk::Fixed.new<br>        add fixed<br><br>        button = Gtk::Button.new “Quit”<br>        button.set_size_request 80, 35<br>        button.signal_connect “clicked” do<br>            Gtk.main_quit<br>        end<br><br>        fixed.put button, 50, 50<br><br>        set_default_size 250, 200<br>        set_window_position Gtk::Window::POS_CENTER<br>    end<br>end<br><br>Gtk.init<br>    window = RubyApp.new<br>Gtk.main<br></code></pre><br><p>我们使用一个按钮控件。这是一个非常平常的控件。它显示一个文本、图像或者两者都显示。</p><br><pre><code>init_ui<br></code></pre><br><p>我们将用户接口的创建委派给<em>init_ui</em>方法。</p><br><pre><code>show_all<br></code></pre><br><p>我们有两个选择。对每个控件都调用<em>show</em>，或者调用<em>show_all</em>显示容器的所有了子控件。</p><br><pre><code>button = Gtk::Button.new “Quit”<br></code></pre><br><p>这里创建一个按钮控件。</p><br><pre><code>button.set_size_request 80, 35<br></code></pre><br><p>设置按钮的大小。</p><br><pre><code>button.signal_connect “clicked” do<br>    Gtk.main_quit<br>end<br></code></pre><br><p>我们将<em>main_quit</em>方法插入到按钮的点击事件中。</p><br><pre><code>fixed.put button, 50, 50<br></code></pre><br><p>将退出按钮放在<em>fixed</em>容器的x=50，y=50的位置。<br><img alt="image2" src="http://zetcode.com/img/gui/rubygtk/quitbutton.png"><br><br><em>图片：退出按钮</em></p><br><p>这一节我们介绍Ruby语言的GTK库。</p><br><hr><br><p>原文地址： <a href="http://zetcode.com/gui/rubygtk/introduction/" target="_blank" rel="external">http://zetcode.com/gui/rubygtk/introduction/</a><br><br>翻译：龙昌  admin@longchangjin.cn  </p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://www.xefan.com/archives/83954.html" data-id="cktcclrvr00ivyp4kgys00nl1" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Ruby/">Ruby</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/gtk/">gtk</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/翻译/">翻译</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-/archives/83949.html" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/archives/83949.html" class="article-date">
  <time datetime="2013-11-18T20:05:19.000Z" itemprop="datePublished">2013-11-18</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Ruby栏目/">Ruby栏目</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/archives/83949.html">[翻译]Ruby教程15——输入&amp;输出</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p></p><h1>Ruby的输入&amp;输出</h1><p></p>
<p>这部分的教程我们讨论Ruby的输入和输出操作。输入是程序从键盘、文件或者其他程序读取数据。输出是程序产生数据。可以输出到屏幕、文件或者其他程序。</p><br><p>输入&amp;输出是一个大的话题。稍后我们通过一些例子来大概介绍一下这个主题。Ruby中的一些类有些方法会执行输入&amp;输出操作。例如Kernel、IO、Dir或者File。</p><br><h2>输出到终端</h2><br><p>Ruby有一些在终端上打印输出的方法。这些方法是Kernel模块的一部分。Kernel模块的方法对于所有的Ruby对象都是有效的。</p><br><pre><code>#!/usr/bin/ruby<br><br>print “Apple “<br>print “Apple\n”<br><br>puts “Orange”<br>puts “Orange”<br></code></pre><br><p><em>print</em>和<em>puts</em>方法会将文本输出到终端。它们的不同是会在最后加上一个换行符。</p><br><pre><code>print “Apple “<br>print “Apple\n”<br></code></pre><br><p><em>print</em>在终端上打印两个连续的”Apple”字符串。如果我们想换一行，我们就必须显示的包含一个换行符。换行符是’\n’。<em>print</em>方法实际上是调用了对象的<em>to_s</em>方法。</p><br><pre><code>puts “Orange”<br>puts “Orange”<br></code></pre><br><p><em>puts</em>方法在终端上打印两个字符串。每一个都各在一行。这个方法会自己添加换行符。</p><br><p>$ ./printing.rb<br>Apple Apple<br><br>Orange<br><br>Orange  </p><br><p><em>printing.rb</em>脚本的输出结果。</p><br><p>根据Ruby的文档，<em>print</em>方法与<em>$stdout.print</em>是等效的。<em>$stdout</em>是全局变量，保存的标准输出流。</p><br><pre><code>#!/usr/bin/ruby<br><br>$stdout.print “Ruby language\n”<br>$stdout.puts “Python language”<br></code></pre><br><p>我们使用$stdout变量打印两行内容。</p><br><p>Ruby有另外三种输出方法。</p><br><pre><code>#!/usr/bin/ruby<br><br>p “Lemon”<br>p “Lemon”<br><br>printf “There are %d apples\n”, 3<br><br>putc ‘K’<br>putc 0xA<br></code></pre><br><p>这个例子中，我们展示了p、printf和putc方法。</p><br><pre><code>p “Lemon”<br></code></pre><br><p><em>p</em>会调用对象的<em>inspect</em>方法。这个方法对于调试很有用。</p><br><pre><code>printf “There are %d apples\n”, 3<br></code></pre><br><p><em>printf</em>方法因C语言而出名。它能够将字符串格式化。</p><br><pre><code>putc ‘K’<br>putc 0xA<br></code></pre><br><p><em>putc</em>方法在终端上打印一个字符。第二行是打印一个换行符。0xA是换行符的十六进制代码。</p><br><p>$ ./printing3.rb <br><br>“Lemon”<br><br>“Lemon”<br><br>There are 3 apples<br><br>K  </p><br><p>printing3.rb的输出。</p><br><p>使用Kernel的方法在终端上打印数据是简短方便的方式。接下来的例子展示了更多在终端上打印数据的正式方法。</p><br><pre><code>ios = IO.new STDOUT.fileno<br>ios.write “ZetCode\n”<br>ios.close<br></code></pre><br><p>这个例子我们打开标准输出流并往其中写入字符串。</p><br><pre><code>ios = IO.new STDOUT.fileno<br></code></pre><br><p><em>new</em>方法返回一个可写的数据流。这个方法传入一个文件描述符数字。<em>STDOUT.fileno</em>返回了标准输出流的文件描述符。我们也可以直接写2。</p><br><pre><code>ios.write “ZetCode\n”<br></code></pre><br><p>我们往打开的数据流写入字符串。</p><br><pre><code>ios.close<br></code></pre><br><p>关闭输出流。</p><br><p>在Unix系统中标准的终端输出是连接到一个特殊的文件/dev/tty。将其打开并写入数据，既是写到终端上。</p><br><pre><code>#!/usr/bin/ruby<br><br>fd = IO.sysopen “/dev/tty”, “w”<br>ios = IO.new(fd, “w”)<br>ios.puts “ZetCode”<br>ios.close<br></code></pre><br><p>写入到/dev/tty文件的一个例子。这仅能够在Unix上运行。</p><br><pre><code>fd = IO.sysopen “/dev/tty”, “w”<br></code></pre><br><p><em>sysopen</em>方法打开指定目录的文件，返回最后的文件描述符。</p><br><pre><code>ios = IO.new(fd, “w”)<br></code></pre><br><p>文件描述符数字用于打开一个数据流。</p><br><pre><code>ios.puts “ZetCode”<br>ios.close<br></code></pre><br><p>往数据流中写入字符串然后关闭它。</p><br><h2>从终端输入</h2><br><p>这一节我们将创建一些处理输入的代码例子。</p><br><p>$stdin是一个全局变量保存了标准输入流。它可以用于从终端输入数据。</p><br><pre><code>#!/usr/bin/ruby<br><br>inp = $stdin.read<br>puts inp<br></code></pre><br><p>上面的代码，我们使用<em>read</em>方法从终端读取输入。</p><br><pre><code>inp = $stdin.read<br></code></pre><br><p><em>read</em>方法从标准输入读取数据直到文件结尾。EOF在Unix中是使用Ctrl + D产生，在Windows中是Ctrl + Z。</p><br><p>$ ./reading.rb<br><br>Ruby language<br><br>Ruby language  </p><br><p>我们启动了程序，这个脚本会读取数据直到我们按下Ctrl + D 或者 Ctrl + Z。</p><br><p>$ echo “ZetCode” | ./reading.rb<br><br>ZetCode  </p><br><p>$ ./input.rb &lt; stones <br><br>Garnet<br><br>Topaz<br><br>Opal<br><br>Amethyst<br><br>Ruby<br><br>Jasper<br><br>Pyrite<br><br>Malachite<br><br>Quartz  </p><br><p>如果我们使用重定向，脚本可以从其他程序或者文件中读取数据。</p><br><p>通常从终端读取数据是使用<em>gets</em>方法。</p><br><pre><code>#!/usr/bin/ruby<br><br>print “Enter your name: “<br>name = gets<br>puts “Hello #{name}”<br></code></pre><br><p>使用<em>gets</em>方法读取用户输入的一行数据。</p><br><pre><code>name = gets<br></code></pre><br><p><em>gets</em>方法从标准输入读取数据并分配给<em>name</em>变量。</p><br><pre><code>puts “Hello #{name}”<br></code></pre><br><p>打印输入的数据。</p><br><p>$ ./readline.rb<br><br>Enter your name: Jan<br><br>Hello Jan  </p><br><p>输出结果。</p><br><p>接下来的两个脚本我们讨论<em>chomp</em>方法。它是字符串方法，用于移除字符串结尾的空白。当我们执行输入操作时它很有用。这个方法名和用法来自Perl语言。</p><br><pre><code>#!/usr/bin/ruby<br><br>print “Enter a string: “<br>inp = gets<br><br>puts “The string has #{inp.size} characters”<br></code></pre><br><p>读取一个用户输入的字符串，并计算它的长度。</p><br><p>$ ./nochomp.rb <br><br>Enter a string: Ruby<br><br>The string has 5 characters  </p><br><p>这个提示表示了这个字符串有5个字符，因为它统计的换行符。</p><br><p>为了得到正确的结果，我们需要移除换行符。这正是<em>chomp</em>方法的作用。</p><br><pre><code>#!/usr/bin/ruby<br><br>print “Enter a string: “<br>inp = gets.chomp<br><br>puts “The string has #{inp.size} characters”<br></code></pre><br><p>这次我们使用<em>chomp</em>方法截掉了换行符。</p><br><p>$ ./chomp.rb <br><br>Enter a string: Ruby<br><br>The string has 4 characters  </p><br><p><em>Ruby</em>字符串有4个字符。</p><br><h2>文件</h2><br><p>从Ruby官方文档我们知道<em>IO</em>类是所有输入输出的基类。<em>File</em>类只是<em>IO</em>类的一个子类。这两个类是紧密相关的。</p><br><pre><code>#!/usr/bin/ruby<br><br>f = File.open(‘output.txt’, ‘w’)<br>f.puts “The Ruby tutorial”<br>f.close<br></code></pre><br><p>第一个例子我们打开一个文件并往里面写入一些数据。</p><br><pre><code>f = File.open(‘output.txt’, ‘w’)<br></code></pre><br><p>以写模式打开’output.txt’文件。<em>open</em>方法返回数据流。</p><br><pre><code>f.puts “The Ruby tutorial”<br></code></pre><br><p>往上面打开的数据流写入数据。<em>puts</em>方法也可用于往文件写入数据。</p><br><pre><code>f.close<br></code></pre><br><p>最后关闭数据流。</p><br><p>$ ./simplewrite.rb<br><br>$ cat output.txt <br><br>The Ruby tutorial  </p><br><p>执行脚本并显示output.txt文件的内容。</p><br><p>以下是一个类似的例子显示了额外的方法。</p><br><pre><code>#!/usr/bin/ruby<br><br>File.open(‘langs’, ‘w’) do |f|<br><br>    f.puts “Ruby”<br>    f.write “Java\n”<br>    f &lt;&lt; “Python\n”<br><br>end<br></code></pre><br><p>如果<em>open</em>方法之后是一个代码块，Ruby会将打开的数据流传递给这个代码块。最后这个文件会自动关闭。</p><br><pre><code>f.puts “Ruby”<br>f.write “Java\n”<br>f &lt;&lt; “Python\n”<br></code></pre><br><p>我们使用了三个方法写文件。</p><br><p>$ ./simplewrite2.rb<br><br>$ cat langs <br><br>Ruby<br><br>Java<br><br>Python  </p><br><p>执行这个脚本并查看里面的内容。</p><br><p>第二个例子我们显示一些<em>File</em>类的方法。</p><br><pre><code>#!/usr/bin/ruby<br><br>puts File.exists? ‘tempfile’<br><br>f = File.new ‘tempfile’, ‘w’<br>puts File.mtime ‘tempfile’<br>puts f.size<br><br>File.rename ‘tempfile’, ‘tempfile2’<br><br>f.close<br></code></pre><br><p>这个例子创建了一个新文件’tempfile’并调用了一些方法。</p><br><pre><code>puts File.exists? ‘tempfile’<br></code></pre><br><p><em>exists?</em>方法检查给定的文件是否存在。这行返回false，因为我们还没有创建这个文件。</p><br><pre><code>f = File.new ‘tempfile’, ‘w’<br></code></pre><br><p>创建文件。</p><br><pre><code>puts File.mtime ‘tempfile’<br></code></pre><br><p><em>mtime</em>方法返回这个文件的最后修改时间。</p><br><pre><code>puts f.size<br></code></pre><br><p>查看文件的大小。这里返回0,因为我们还没有往文件写入数据。</p><br><pre><code>File.rename ‘tempfile’, ‘tempfile2’<br></code></pre><br><p>最后我们使用<em>rename</em>将文件重命名。</p><br><p>$ ./testfile.rb<br><br>false<br><br>2011-11-05 16:19:36 +0100<br><br>0  </p><br><p>输出结果。</p><br><p>接下来我们从磁盘文件读取内容。</p><br><pre><code>#!/usr/bin/ruby<br><br>f = File.open(“stones”)<br><br>while line = f.gets do<br>    puts line<br>end<br><br>f.close<br></code></pre><br><p>这是一个简单的脚本，打开<em>stones</em>文件并在终端上打印它的内容。</p><br><pre><code>f = File.open(“stones”)<br></code></pre><br><p>打开’stones’文件，默认是只读模式。</p><br><pre><code>while line = f.gets do<br>    puts line<br>end<br></code></pre><br><p><em>gets</em>方法从I/O数据流读取一行数据。当读到文件结尾时while代码块退出。</p><br><p>$ ./readlines2.rb<br><br>Garnet<br><br>Topaz<br><br>Opal<br><br>Amethyst<br><br>Ruby<br><br>Jasper<br><br>Pyrite<br><br>Malachite<br><br>Quartz  </p><br><p>例子输出结果。</p><br><p>下一个例子将从文件读取数据。</p><br><pre><code>#!/usr/bin/ruby<br><br>fname = ‘alllines.rb’<br><br>File.readlines(fname).each do |line|<br>    puts line<br>end<br></code></pre><br><p>这个脚本显示了另一个读取文件内容的方式。这个例子将它自己的代码打印在终端上。</p><br><pre><code>File.readlines(fname).each do |line|<br>    puts line<br>end<br></code></pre><br><p><em>readlines</em>读取指定文件的每一行内容，并作为数据返回。我们使用<em>each</em>方法遍历数组，并将其在终端上打印。</p><br><pre><code>$ ./alllines.rb<br>#!/usr/bin/ruby<br><br>fname = ‘alllines.rb’<br><br>File.readlines(fname).each do |line|<br>    puts line<br>end<br></code></pre><br><p>输出结果。</p><br><h2>目录</h2><br><p>在这一节我们使用目录。Ruby中有一个Dir类可以操作目录。</p><br><pre><code>#!/usr/bin/ruby<br><br>Dir.mkdir “tmp”<br>puts Dir.exists? “tmp”<br><br>puts Dir.pwd<br>Dir.chdir “tmp”<br>puts Dir.pwd<br><br>Dir.chdir ‘..’<br>puts Dir.pwd<br>Dir.rmdir “tmp”<br>puts Dir.exists? “tmp”<br></code></pre><br><p>这个脚本我们使用了Dir类的四个方法。</p><br><pre><code>Dir.mkdir “tmp”<br></code></pre><br><p><em>mkdir</em>方法创建一个新目录’tmp’。</p><br><pre><code>puts Dir.exists? “tmp”<br></code></pre><br><p>使用<em>exists?</em>方法检查一个目录是否存在。</p><br><pre><code>puts Dir.pwd<br></code></pre><br><p><em>pwd</em>方法打印当前的工作目录。这是我们启动脚本的目录。</p><br><pre><code>Dir.chdir ‘..’<br></code></pre><br><p><em>chdir</em>方法切换目录。’..’目录是当前工作目录的父目录。</p><br><pre><code>Dir.rmdir “tmp”<br>puts Dir.exists? “tmp”<br></code></pre><br><p>最后我们使用<em>rmdir</em>方法移除目录。这时<em>exists?</em>方法返回false。</p><br><p>$ ./dirs.rb<br><br>true<br><br>/home/vronskij/programming/ruby/io<br><br>/home/vronskij/programming/ruby/io/tmp<br><br>/home/vronskij/programming/ruby/io<br><br>false  </p><br><p>例子的输出结果。<br>第二个例子我们检索目录所有的条目，包括文件和子目录。</p><br><pre><code>#!/usr/bin/ruby<br><br>fls = Dir.entries ‘.’<br>puts fls.inspect<br></code></pre><br><p><em>entries</em> 方法返回指定目录的所有条目。</p><br><pre><code>fls = Dir.entries ‘.’<br>puts fls.inspect<br></code></pre><br><p>我们得到了当前目录下的文件和目录数组。’.’代表当前工作目录。<em>inspect</em>方法使得数组更加可读。</p><br><p>$ ./allfiles.rb<br><br>[“putc.rb”, “simplewrite.rb”, “readlines2.rb”, “fileexists.rb~” …  </p><br><p>输出结果。</p><br><p>第三个例子使用了home目录。每个计算机用户都有一个分配给他的唯一的目录，称为home目录。它是用于存放用户自己的文件。</p><br><pre><code>#!/usr/bin/ruby<br><br>puts Dir.home<br>puts Dir.home ‘root’<br></code></pre><br><p>这个脚本打印两个home目录。</p><br><pre><code>puts Dir.home<br></code></pre><br><p>如果没有指定用户名则返回当前用户的home目录。当前用户是指定启动这个脚本文件的用户。</p><br><pre><code>puts Dir.home ‘root’<br></code></pre><br><p>这里我们指定了一个用户。</p><br><p>$ ./homedir.rb<br><br>/home/vronskij<br><br>/root  </p><br><p>输出结果。</p><br><h2>执行外部程序</h2><br><p>Ruby有一些方式可以执行外部程序。我们的例子中我们使用了Linux中有名的命令。Windows或者Mac读取可以使用他们自己系统的命令。</p><br><pre><code>#!/usr/bin/ruby<br><br>data = system ‘ls’<br>puts data<br></code></pre><br><p>调用<em>ls</em>命令列出目录内容。</p><br><pre><code>data = system ‘ls’<br></code></pre><br><p><em>system</em>命令在一个子shell中执行外部程序。这个方法是属于Kernel Ruby 模块的。</p><br><p>$ ./system.rb<br><br>allfiles.rb   characters.rb  fileexists.rb   homedir.rb~ …  </p><br><p>输出结果。</p><br><p>我们展示另外两个执行外部程序的方式。</p><br><pre><code>#!/usr/bin/ruby<br><br>out = <code>pwd</code><br>puts out<br><br>out = %x[uptime]<br>puts out<br><br>out = %x[ls | grep ‘readline’]<br>puts out<br></code></pre><br><p>执行外部程序我们可以使用反引号<code>`和%x[]字符。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;out =</code>pwd`<br><br></p><p>这里我们使用反引号执行<em>pwd</em>命令。这个命令返回当前的工作目录。</p><br><pre><code>out = %x[uptime]<br></code></pre><br><p>这里我得到<em>uptime</em>命令的输出，它显示系统运行了多久。</p><br><pre><code>out = %x[ls | grep ‘readline’]<br></code></pre><br><p>我们也可以使用复合命令。</p><br><p>$ ./system2.rb<br><br>/home/vronskij/programming/ruby/io<br><br> 22:50:50 up  5:32,  1 user,  load average: 0.46, 0.44, 0.45<br><br>readline.rb<br><br>readline.rb~<br><br>readlines2.rb<br><br>readlines2.rb~  </p><br><p>输出结果。</p><br><p>我们可以使用<em>open</em>方法执行命令。这个方法是属于Kernel模块的。它创建一个IO对象连接到指定的数据流、文件或者子进程。如果我们想要连接到子进程，我们将打开路径以管道符(|)开头。</p><br><pre><code>#!/usr/bin/ruby<br><br>f = open(“|ls -l |head -3”)<br>out = f.read<br>puts out<br>f.close<br><br>puts $?.success?<br></code></pre><br><p>这个例子我们打印了<em>ls -l | head -3</em>命令的结果。我们也还检查了子进程的状态。</p><br><pre><code>f = open(“|ls -l |head -3”)<br></code></pre><br><p>连接到子进程。</p><br><pre><code>out = f.read<br>puts out<br></code></pre><br><p>读取并打印子进程的数据。</p><br><pre><code>f.close<br></code></pre><br><p>关闭文件句柄。</p><br><pre><code>puts $?.success?<br></code></pre><br><p><em>$?</em>是一个特殊的变量，设置为上次执行过的子进程。如果子进程成功退出<em>success?</em>方法返回true。</p><br><p>$ ./system3.rb<br><br>total 148<br><br>-rwxr-xr-x 1 vronskij vronskij   57 2011-10-30 23:33 allfiles.rb<br><br>-rwxr-xr-x 1 vronskij vronskij   58 2011-10-30 23:33 allfiles.rb~<br><br>true  </p><br><p>输出结果。</p><br><h2>重定向标准输出</h2><br><p>Ruby对标准输入、标准输出和标准错误输出都有预定义的全局变量。<em>$stdout</em> 是标准输出的变量名。</p><br><pre><code>#!/usr/bin/ruby<br><br>$stdout = File.open “output.log”, “a”<br><br>puts “Ruby”<br>puts “Java”<br><br>$stdout.close<br>$stdout = STDOUT<br><br>puts “Python”<br></code></pre><br><p>上面的例子我们将输出重定向到output.log文件。</p><br><pre><code>$stdout = File.open “output.log”, “a”<br></code></pre><br><p>这行创建一个新的标准输出。现在标准输出流向ouput.log文件。这个文件以追加方式打开，如果文件不存在则创建，否则打开并将数据追加到文件尾部。</p><br><pre><code>puts “Ruby”<br>puts “Java”<br></code></pre><br><p>打印两个字符串。这些字符串不会像平常一样在终端上显示了。而是追加到output.log文件中。</p><br><pre><code>$stdout.close<br></code></pre><br><p>关闭文件句柄。</p><br><pre><code>$stdout = STDOUT<br><br>puts “Python”<br></code></pre><br><p>使用预定义的常量<em>STDOUT</em>重新创建正常的标准输出。”Python”字符串在终端上打印。</p><br><p>这部分的教程我们使用了输入和输出操作。</p><br><hr><br><p>原文地址： <a href="http://zetcode.com/lang/rubytutorial/io/" target="_blank" rel="external">http://zetcode.com/lang/rubytutorial/io/</a><br><br>翻译：龙昌  admin@longchangjin.cn<br><br>完整教程：<a href="https://github.com/wusuopu/Ruby-tutorial" target="_blank" rel="external">https://github.com/wusuopu/Ruby-tutorial</a> </p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://www.xefan.com/archives/83949.html" data-id="cktcclrw500jwyp4k8qbvvr59" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Ruby/">Ruby</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/翻译/">翻译</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-/archives/83945.html" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/archives/83945.html" class="article-date">
  <time datetime="2013-11-17T21:41:05.000Z" itemprop="datePublished">2013-11-17</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Ruby栏目/">Ruby栏目</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/archives/83945.html">[翻译]Ruby教程14——正则表达式</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p></p><h1>Ruby的正则表达式</h1><p></p>
<p>在这部分和教程中我们将讨论正则表达式。</p><br><p>正则表达式用于文本搜索和更高级的文本操作。内建正则表达式的工具如grep、sed；文本编辑器如vi、emacs；编程语言如Tcl、Perl、Python。Ruby也内建支持正则表达式。</p><br><p>从另一方面来看正则表达式语法构成了一个文本匹配的领域专用语言。</p><br><p><em>pattern</em>（模式）是一个正则表达式，它定义了我们要搜索或者操作的文本。它由文本字面和元字符构成。模式位于两个分隔符内。在Ruby中是<em>//</em>字符。它们通知正则表达式函数的开始和结束。</p><br><p>这里是元字符的部分列表。</p><br><table><br>    <tr><br>        <td>.</td><br>        <td>匹配任意一个字符</td><br>    </tr><br>    <tr><br>        <td><em></em></td><br>        <td>匹配前一个元素0次或多次</td><br>    </tr><br>    <tr><br>        <td>[]</td><br>        <td>括号表达式。匹配括号内的一个字符</td><br>    </tr><br>    <tr><br>        <td>[^]</td><br>        <td>匹配不在括号内的一个字符</td><br>    </tr><br>    <tr><br>        <td>^</td><br>        <td>匹配字符串的开始位置</td><br>    </tr><br>    <tr><br>        <td>$</td><br>        <td>匹配字符串的结束位置</td><br>    </tr><br>    <tr><br>        <td>|</td><br>        <td>交替操作</td><br>    </tr><br></table><br><br><p>=~操作符对字符串匹配正则表达式，如果匹配则返回匹配字符串的偏移量否则为nil。 <em>RegExp</em>类是用来开发正则表达式。还有两个速记的方式来创建正则表达式。下面的例子将显示它们。</p><br><pre><code>#!/usr/bin/ruby<br><br>re = Regexp.new ‘Jane’<br>p “Jane is hot”.match re<br><br>p “Jane is hot” =~ /Jane/<br>p “Jane is hot”.match %r{Jane}<br></code></pre><br><p>第一个例子我们显示了对字符串应用正则表达式的三种方式。</p><br><pre><code>re = Regexp.new ‘Jane’<br>p “Jane is hot”.match re<br></code></pre><br><p>上面两行我们创建了一个简单的包含正则表达式文本的<em>Regexp</em>对象。使用<em>match</em>方法我们对<em>“Jane is hot”</em>句子应用这个正则表达式。检查’Jance’是否在这个句子中。</p><br><pre><code>p “Jane is hot” =~ /Jane/<br>p “Jane is hot”.match %r{Jane}<br></code></pre><br><p>这两行完成相同的工作。两个斜杠//和%R{}字符是第一种方式的简写。在这个教程中，我们将使用斜杠。这是在许多语言中是事实上的标准。</p><br><pre><code>$ ./regex.rb<br>#&lt;MatchData “Jane”&gt;<br>0<br>#&lt;MatchData “Jane”&gt;<br></code></pre><br><p>这三种情况都匹配的。<em>match</em>方法返回匹配的数据，如果没有则返回nil。=~操作符返回第一个匹配的字符的位置，或者nil。</p><br><h2>点字符</h2><br><p>点字符是一个可以匹配任意单字符的正则表达式字符。注意必须要有些字符，它不能被忽略。</p><br><pre><code>#!/usr/bin/ruby<br><br>p “Seven”.match /.even/<br>p “even”.match /.even/<br>p “eleven”.match /.even/<br>p “proven”.match /.even/<br></code></pre><br><p>第一个例子，我们对字符串使用<em>match</em>方法应用正则表达式。<em>match</em>方法成功则返回匹配到的数据，否则返回nil。</p><br><pre><code>p “Seven”.match /.even/<br></code></pre><br><p>“Seven”是一个字符串，可以调用<em>match</em>方法。这个方法的参数是一个模式。/.even/正则表达式模式是查找以任意字符开头接着是<em>‘even’</em>的字符串。</p><br><pre><code>$ ./dot.rb<br>#&lt;MatchData “Seven”&gt;<br>nil<br>#&lt;MatchData “leven”&gt;<br>nil<br></code></pre><br><p>从输出结果中我们看到哪些是匹配的哪些是没有匹配的。</p><br><hr><br><p>正如前面所说的，如果有点字符，那么就必须要有一个任意的字符。它不能被忽略。如果我们想到查找一个文本，其中有字符能被忽略的。换言之，我们想要一个模式可以同时匹配’seven’和’even’。对于这个我们可以使用一个<em>?</em>重复字符。<em>?</em>重复字符表示前一个字符可能出现0或者1次。</p><br><pre><code>#!/usr/bin/ruby<br><br>p “seven”.match /.even/<br>p “even”.match /.even/<br>p “even”.match /.?even/<br></code></pre><br><p>这个脚本使用<em>?</em>重复字符。</p><br><pre><code>p “even”.match /.even/<br></code></pre><br><p>这行打印nil，因为正则表达式在’even’之前要接受一个字符。</p><br><pre><code>p “even”.match /.?even/<br></code></pre><br><p>我们稍微修改一下正则表达式。<em>‘.?’</em>代表没有字符或者有一个字符。这次匹配成功。</p><br><pre><code>$ ./dot2.rb<br>#&lt;MatchData “seven”&gt;<br>nil<br>#&lt;MatchData “even”&gt;<br></code></pre><br><p>输出结果。</p><br><h2>正则表达式方法</h2><br><p>前面的两个例子我们对正则表达式使用了<em>match</em>方法。除了<em>match</em>之外还有其他的方法也接受正则表达式参数。</p><br><pre><code>#!/usr/bin/ruby<br><br>puts “motherboard” =~ /board/<br>puts “12, 911, 12, 111”[/\d{3}/]<br><br>puts “motherboard”.gsub /board/, “land”<br><br>p “meet big deep nil need”.scan /.[e][e]./<br>p “This is Sparta!”.split(/\s/)<br></code></pre><br><p>这个例子显示了正则表达式的一些方法。</p><br><pre><code>puts “motherboard” =~ /board/<br></code></pre><br><p>=~操作符将正则表达式放在右边，字符串放在左边。</p><br><pre><code>puts “12, 911, 12, 111”[/\d{3}/]<br></code></pre><br><p>正则表达式可以位于字符串后面的中括号内。这行打印第一个3个数字。</p><br><pre><code>puts “motherboard”.gsub /board/, “land”<br></code></pre><br><p>使用<em>gsub</em>方法我们将’board’字符串替换成’land’。</p><br><pre><code>p “meet big deep nil need”.scan /.[e][e]./<br></code></pre><br><p><em>scan</em>方法查找字符串匹配。它会查找所有出现的匹配，而不仅是第一个。这行打印所有与模式匹配的字符串。</p><br><pre><code>p “This is Sparta!”.split(/\s/)<br></code></pre><br><p><em>split</em>方法使用给定的正则式来分隔字符串。<em>\s</em>字符代表了任何空白字符。</p><br><pre><code>$ ./apply.rb<br>6<br>911<br>motherland<br>[“meet”, “deep”, “need”]<br>[“This”, “is”, “Sparta!”]<br></code></pre><br><p>apply.rb脚本的输出结果。</p><br><h2>特殊变量</h2><br><p>一些使用正则式的方法会激活一些特殊的变量。包括上次匹配的字符串、上次匹配结果的前面部分和上次匹配结果的后面部分。这些变量方便了程序员。</p><br><pre><code>#!/usr/bin/ruby<br><br>puts “Her name is Jane” =~ /name/<br><br>p $<code>p $&amp;amp;
p $&#39;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这个例子显示了三个特殊的变量。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;puts &quot;Her name is Jane&quot; =~ /name/
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这行代码是一个简单的正则式匹配。我们在&#39;Her name is Jane&#39;句子中查找&#39;name&#39;。我们使用=~操作符。这个操作符也会设置三个特殊的变量。这行返回数字4。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;p $</code><br></code></pre><br><p><em>$<code>&lt;/em&gt;特殊变量包含了上次匹配结果之前的文本。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;p $&amp;amp;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;em&gt;$&amp;amp;&lt;/em&gt;为匹配的文本。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;p $&#39;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;em&gt;$&#39;&lt;/em&gt;变量包含上次匹配结果之后的文本。&lt;/p&gt;
&lt;p&gt;$ ./svars.rb&lt;br&gt;
4&lt;br&gt;
&quot;Her &quot;&lt;br&gt;
&quot;name&quot;&lt;br&gt;
&quot; is Jane&quot;  &lt;/p&gt;
&lt;p&gt;例子的输出结果。&lt;/p&gt;
&lt;h2&gt;锚点&lt;/h2&gt;
&lt;p&gt;锚点是在文本中匹配位置的字符。我们展示三个锚点字符。^字符匹配了行的开头；$字符匹配了行的结尾；\b字符匹配词的边界。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#!/usr/bin/ruby

sen1 = &quot;Everywhere I look I see Jane&quot;
sen2 = &quot;Jane is the best thing that happened to me&quot;

p sen1.match /^Jane/ 
p sen2.match /^Jane/

p sen1.match /Jane$/ 
p sen2.match /Jane$/
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;第一个例子我们使用了^和$。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;sen1 = &quot;Everywhere I look I see Jane&quot;
sen2 = &quot;Jane is the best thing that happened to me&quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;有两个句子。&#39;Jane&#39;位于第一个的结尾第二个的开头。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;p sen1.match /^Jane/ 
p sen2.match /^Jane/
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这里我们查找这两个句子是否以&#39;Jane&#39;开头。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;p sen1.match /Jane$/ 
p sen2.match /Jane$/
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这里我们在句子结尾查找匹配。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ ./anchors.rb
nil
#&amp;lt;MatchData &quot;Jane&quot;&amp;gt;
#&amp;lt;MatchData &quot;Jane&quot;&amp;gt;
nil
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;运行结果。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;通常一个请求仅包含一个匹配全部的词。我们会默认计算所有匹配，包括更大的或者复合词。让我们通过一个例子来阐述。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#!/usr/bin/ruby

text = &quot;The cat also known as the domestic cat is a small, 
usually furry, domesticated, carnivorous mammal.&quot;

p text.scan /cat/

p $</code><br>p $&amp;<br>p $’<br><br><p>有一个句子。我们使用<em>scan</em>在这个句子中查找所有的’cat’字符串。</p><br><pre><code>text = “The cat also known as the domestic cat is a small,<br>usually furry, domesticated, carnivorous mammal.”<br></code></pre><br><p>问题是这个文本中有三个’cat’字符串。要匹配的’cat’表示一个哺乳动物,/cat/却匹配了’domesticated’词的8-10的字母。这不是我们想要的。</p><br><pre><code>$ ./boudaries.rb<br>[“cat”, “cat”, “cat”]<br>“The cat also known as the domestic cat is a small, \nusually furry, domesti”<br>“cat”<br>“ed, carnivorous mammal.”<br></code></pre><br><p>最后一次匹配的’domesticated’在下一个例子中将被使用\b锚点字符排除。</p><br><hr><br><p>\b字符用于设置要查找的词的边界。</p><br><pre><code>#!/usr/bin/ruby<br><br>text = “The cat also known as the domestic cat is a small,<br>usually furry, domesticated, carnivorous mammal.”<br><br>p text.scan /\bcat\b/<br><br>p $`<br>p $&amp;<br>p $’<br></code></pre><br><p>这个例子使用\b元字符进行了改善。</p><br><pre><code>p text.scan /\bcat\b/<br></code></pre><br><p>使用上面的正则式我们将查找’cat’整个词，不计算子词。</p><br><h2>字符类</h2><br><p>我们可以结合方括号将字符转换成字符类。字符类可以匹配在方括号内的任意字符。/[ab]/模式意味a或者b，相反的/ab/意味着a接着b。</p><br><pre><code>#!/usr/bin/ruby<br><br>words = %w/ sit MIT fit fat lot pad /<br><br>pattern = /[fs]it/<br><br>words.each do |word|<br>   if word.match pattern<br>       puts “#{word} matches the pattern”<br>   else<br>       puts “#{word} does not match the pattern”<br>   end<br>end<br></code></pre><br><p>有一系列的6个3字母的单词。我们对数组的每个字符串采用特定字符集的正则式。</p><br><pre><code>pattern = /[fs]it/<br></code></pre><br><p>这个式模式在这个数组中查找到了’fit’、’sit’。我们从字符集使用’f’或者’s’。</p><br><p>$ ./classes.rb<br><br>sit matches the pattern<br><br>MIT does not match the pattern<br><br>fit matches the pattern<br><br>fat does not match the pattern<br><br>lot does not match the pattern<br><br>pad does not match the pattern  </p><br><p>有两个匹配的。</p><br><hr><br><p>一个例子我们将进一步探讨字符类。</p><br><pre><code>#!/usr/bin/ruby<br><br>p “car”.match %r{[abc][a][rs]}<br>p “car”.match /[a-r]+/<br>p “23af 433a 4ga”.scan /\b[a-f0-9]+\b/<br></code></pre><br><p>例子中有三个字符类正则式。</p><br><pre><code>p “car”.match %r{[abc][a][rs]}<br></code></pre><br><p>这行的正则式由三个字符类构成。每个都对应一个字符。[abc]是a、b或者c。[a]就是a。第三个[rs]是r或者s。这里匹配’car’字符串。</p><br><pre><code>p “car”.match /[a-r]+/<br></code></pre><br><p>我们在字符类中使用了一个连接符<em>-</em>。连接符是一个元字符表示一个范围：这里是a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, 或r。由于字符类仅对应一个字符。我们也可以使用+重复字符。这表示前一个字符集的字符可以重复一次或者多次。’car’字符串被匹配了。</p><br><pre><code>p “23af 433a 4ga”.scan /\b[a-f0-9]+\b/<br></code></pre><br><p>这行有一个由三个子字符串构成的字符串。使用<em>scan</em>方法检查十六进制整数。我们有两个范围。第一个[a-f]代表a到f的字符。第二个[0-9]代表字数0到9。+表示这些字符可以重复多次。最后\b创建一个边界，表示仅接受由这些字符构成的字符串。</p><br><pre><code>$ ./classes2.rb<br>#&lt;MatchData “car”&gt;<br>#&lt;MatchData “car”&gt;<br>[“23af”, “433a”]<br></code></pre><br><p>输出结果。 </p><br><hr><br><p>如果字符类的第一个字符是脱字符（^），则对该类反转。它会匹配除了这些之外的任何字符。</p><br><pre><code>#!/usr/bin/ruby<br><br>p “ABC”.match /[^a-z]{3}/<br>p “abc”.match /[^a-z]{3}/<br></code></pre><br><p>这个例子我们在字符类中使用脱字符。</p><br><pre><code>p “ABC”.match /[^a-z]{3}/<br></code></pre><br><p>我们查找一个有3个字母的字符串。这些字母不能在a到z之间。”ABC”字符串匹配这个正则式，因为所有的三个字符都是大写字母。</p><br><pre><code>p “abc”.match /[^a-z]{3}/<br></code></pre><br><p>“abc”字符串没有匹配。</p><br><pre><code>$ ./caret.rb<br>#&lt;MatchData “ABC”&gt;<br>nil<br></code></pre><br><p>输出结果。</p><br><h2>量词</h2><br><p>标记或者组后面的量词表示前面的元素允许出现多少次。</p><br><pre><code> ?     - 0 or 1 match
 </code></pre></em>     - 0 or more<br> +     - 1 or more<br> {n}   - exactly n<br> {n,}  - n or more<br> {,n}  - n or less (??)<br> {n,m} - range n to m<br><br></p><p>上面是通常的量词列表。</p><br><pre><code>#!/usr/bin/ruby<br><br>p “seven dig moon car lot fire”.scan /\w{3}/<br>p “seven dig moon car lot fire”.scan /\b\w{3}\b/<br></code></pre><br><p>例子中我们想要选择这些有3个字符的单词。\w字符是一个词字符。\w{3}意味着前面的词字符出现3次。</p><br><pre><code>p “seven dig moon car lot fire”.scan /\w{3}/<br></code></pre><br><p>第一只是对每个字符串截取前三个字符。这不是我们想要的。</p><br><pre><code>p “seven dig moon car lot fire”.scan /\b\w{3}\b/<br></code></pre><br><p>这是改进的搜索。我们将之前的模式放在边界符\b之间。现在仅查找有三个字符的单词。</p><br><pre><code>$ ./nchars.rb<br>[“sev”, “dig”, “moo”, “car”, “lot”, “fir”]<br>[“dig”, “car”, “lot”]<br></code></pre><br><p>输出结果。</p><br><hr><br><p>{n,m}是一个重复结构对于有n到m个字符的字符串。</p><br><pre><code>#!/usr/bin/ruby<br><br>p “I dig moon lottery it fire”.scan /\b\w{2,4}\b/<br></code></pre><br><p>上面的例子我们选择有2、3、4个字符的单词。我们再次使用了边界符\b。</p><br><pre><code>$ ./rchars.rb<br>[“dig”, “moon”, “it”, “fire”]<br></code></pre><br><p>这个例子打印了一个有2-4个字符的单词数组。</p><br><hr><br><p>下一个例子我们展示<em>?</em>元字符。接着<em>?</em>的字符是可选的。<em>?</em>之前的字符可以出现一次或者0次。</p><br><pre><code>#!/usr/bin/ruby<br><br>p “color colour colors colours”.scan /colou?rs/<br>p “color colour colors colours”.scan /colou?rs?/<br><br>p “color colour colors colours”.scan /\bcolor\b|\bcolors\b|\bcolour\b|\bcolours\b/<br></code></pre><br><p>我们想要在一个文本中查找<em>colour</em>单词。这个单词有两种拼写方式，美式的’colour’和英式的’color’。我们想要两种都查找，此外我们还想查找复数形式。</p><br><pre><code>p “color colour colors colours”.scan /colou?rs/<br></code></pre><br><p>colou?rs模式查找’colours’和’colors’。u字符在?字符之前表示是可选的。</p><br><pre><code>p “color colour colors colours”.scan /colou?rs?/<br></code></pre><br><p>colou?rs?模式使u和s字符是可选的。因此我们会查找到这四个组合。</p><br><pre><code>p “color colour colors colours”.scan /\bcolor\b|\bcolors\b|\bcolour\b|\bcolours\b/<br></code></pre><br><p>相同的请求可以间隔的写。</p><br><pre><code>$ ./qmark.rb<br>[“colors”, “colours”]<br>[“color”, “colour”, “colors”, “colours”]<br>[“color”, “colour”, “colors”, “colours”]<br></code></pre><br><p>输出结果。</p><br><hr><br><p>这节的最后一个例子我们展示+字符。它允许前面的字符重复1次或多次。</p><br><pre><code>#!/usr/bin/ruby<br><br>nums = %w/ 234 1 23 53434 234532453464 23455636<br>    324f 34532452343452 343 2324 24221 34$34232/<br><br>nums.each do |num|<br>    m = num.match /[0-9]+/<br><br>    if m.to_s.eql? num<br>        puts num<br>    end<br>end<br></code></pre><br><p>这个例子我们有一个数字数组。数字可以有一个或者多个数字字符。</p><br><pre><code>nums = %w/ 234 1 23 53434 234532453464 23455636<br>    324f 34532452343452 343 2324 24221 34$34232/<br></code></pre><br><p>这是一个字符串数组。其中有两个不是数字，因为它们包含了非数字字符。</p><br><pre><code>nums.each do |num|<br>    m = num.match /[0-9]+/<br><br>    if m.to<em>s.eql? num<br>        puts num<br>    end<br>end<br></em></code></pre><br><p>我们遍历数组并对每个字符串应用正则式。表达式[0-9]+代表了0到9的任意字符重复0次或者多次。默认的这个表达式也会查找子字符串。<br>在34$34232中引擎认为34是一个数字。\b边界符在这里是无效的，因为我们没有具体的字符，引擎不知道该在哪里停止查找。这就是为什么我们在代码块中包含一个if条件式。仅当匹配结果等于原字符串才认为它是一个数字。</p><br><p>$ ./numbers.rb<br><br>234<br><br>1<br><br>23<br><br>53434<br><br>234532453464<br><br>23455636<br><br>34532452343452<br><br>343<br><br>2324<br><br>24221  </p><br><p>这些的值是数字。</p><br><h2>忽略大小写搜索</h2><br><p>我们可以执行忽略大小写的搜索。正则表达式可以接一个选项。它是一个单一的字符，以某种方式修改模式。这里不区分大小写的搜索我们使用i选项。</p><br><pre><code>#!/usr/bin/ruby<br><br>p “Jane”.match /Jane/<br>p “Jane”.match /jane/<br>p “Jane”.match /JANE/<br><br>p “Jane”.match /jane/i<br>p “Jane”.match /Jane/i<br>p “Jane”.match /JANE/i<br></code></pre><br><p>这个例子显示了区分大小写和不区分大小写的搜索。</p><br><pre><code>p “Jane”.match /Jane/<br>p “Jane”.match /jane/<br>p “Jane”.match /JANE/<br></code></pre><br><p>这三行的字符必须完全匹配模式。仅有第一行是匹配的。</p><br><pre><code>p “Jane”.match /jane/i<br>p “Jane”.match /Jane/i<br>p “Jane”.match /JANE/i<br></code></pre><br><p>这里我们使用i选项，接在第二个/字符后面。我们进行不区分大小写的搜索。这三行者匹配了。</p><br><pre><code>$ ./icase.rb<br>#&lt;MatchData “Jane”&gt;<br>nil<br>nil<br>#&lt;MatchData “Jane”&gt;<br>#&lt;MatchData “Jane”&gt;<br>#&lt;MatchData “Jane”&gt;<br></code></pre><br><p>例子的输出结果。</p><br><h2>交替</h2><br><p>一个例子解释交替操作符（|）。这个操作符可以创建一个有多个选择的正则式。</p><br><pre><code>#!/usr/bin/ruby<br><br>names = %w/Jane Thomas Robert Lucy Beky<br>    John Peter Andy/<br><br>pattern = /Jane|Beky|Robert/<br><br>names.each do |name|<br><br>    if name =~ pattern<br>        puts “#{name} is my friend”<br>    else<br>        puts “#{name} is not my friend”<br>    end<br>end<br></code></pre><br><p><em>names</em>数组中有8个名字。我们将在数组中查找多虑字符串的组合。</p><br><pre><code>pattern = /Jane|Beky|Robert/<br></code></pre><br><p>这是搜索模式。它表示Jane, Beky和Robert是我的朋友。如果你查找他们就会找到我的朋友。</p><br><p>$ ./alternation.rb<br><br>Jane is my friend<br><br>Thomas is not my friend<br><br>Robert is my friend<br><br>Lucy is not my friend<br><br>Beky is my friend<br><br>John is not my friend<br><br>Peter is not my friend<br><br>Andy is not my friend  </p><br><p>这是脚本的输出结果。</p><br><h2>子模式</h2><br><p>我们可以使用括号()创建子模式。</p><br><pre><code>#!/usr/bin/ruby<br><br>p “bookworm” =~ /book(worm)?$/<br>p “book” =~ /book(worm)?$/<br>p “worm” =~ /book(worm)?$/<br>p “bookstore” =~ /book(worm)?$/<br></code></pre><br><p>我们有如下正则式模式：book(worm)?$。(worm)是一个子模式。仅有两个字符串可以匹配：’book’或者’bookworm’。接在子模式后面的?字符意味着这个子模式出现0或者1次。这里$字符确切的匹配字符串的结尾。没有它单词bookstore和bookmania也会被匹配。</p><br><pre><code>#!/usr/bin/ruby<br><br>p “book” =~ /book(shelf|worm)?$/<br>p “bookshelf” =~ /book(shelf|worm)?$/<br>p “bookworm” =~ /book(shelf|worm)?$/<br>p “bookstore” =~ /book(shelf|worm)?$/<br></code></pre><br><p>子模式经常是多个单词组合交替结合的。例如，book(shelf|worm)匹配’bookshelf’和’bookworm’，book(shelf|worm)?匹配’bookshelf’，’bookworm’和’book’。</p><br><p>$ ./subpatterns2.rb<br><br>0<br><br>0<br><br>0<br><br>nil  </p><br><p>最后一个子模式没有匹配。记住0不意味着没有匹配。对于=~操作符，它是第一个匹配到的字符的索引。</p><br><h2>邮箱例子</h2><br><p>最后一个例子，我们创建一个正则式模式检查邮箱地址。</p><br><pre><code>#!/usr/bin/ruby<br><br>emails = %w/ luke@gmail.com andy@yahoo.com 23214sdj^as<br>    f3444@gmail.com /<br><br>pattern = /^[a-zA-Z0-9.-]+@[a-zA-Z0-9-]+.[a-zA-Z.]{2,5}$/<br><br>emails.each do |email|<br><br>    if email.match pattern<br>        puts “#{email} matches”<br>    else<br>        puts “#{email} does not match”<br>    end<br><br>end<br></code></pre><br><p>注意这个例子提供了仅一种解决方案。它不需要是最好的。</p><br><pre><code>emails = %w/ luke@gmail.com andy@yahoocom 23214sdj^as<br>    f3444@gmail.com /<br></code></pre><br><p>这是一个邮箱数组，仅有两个是有效的。</p><br><pre><code>pattern = /^[a-zA-Z0-9.<em>-]+@[a-zA-Z0-9-]+.[a-zA-Z.]{2,5}$/<br></em></code></pre><br><p>这是一个模式，第一个^和最后一个$是获取完整匹配。在模式之前和之后都不允许有字符。邮箱分为5部分。第一部分是本地部分，它通常是公司、个体或者昵称的名字。[a-zA-Z0-9.-]+列出了所有可能用于本地部分的字符，它们可以使用一次或者多次。第二部分是字面符@，第三部分是域名部分。它通常是邮箱的提供商，如 yahoo或者gmail。字符集[a-zA-Z0-9-]+指明了所有的可以用于域名的字符。+量词将这些字符使用一次或者多次。第四部分是点字符。它的前面接一个转义符。(.)因为点字符是一个元字符具有特殊意义。转义之后得到一个字面上的点。最后一部分是顶级域名。这个模式是[a-zA-Z.]{2,5}。顶级域名有2到5个字符，如sk, net, info, travel。这同样也有点字符，这是因此一些顶级域名有两部分如co.uk。</p><br><p>$ ./email.rb<br><br>luke@gmail.com matches<br><br>andy@yahoocom does not match<br><br>23214sdj^as does not match<br><br>f3444@gmail.com matches  </p><br><p>这个正则式标记了两个有效的邮箱地址。</p><br><p>在这章，我们学习了Ruby的正则表达式。</p><br><hr><br><p>原文地址： <a href="http://zetcode.com/lang/rubytutorial/regex/" target="_blank" rel="external">http://zetcode.com/lang/rubytutorial/regex/</a><br><br>翻译：龙昌  admin@longchangjin.cn<br><br>完整教程：<a href="https://github.com/wusuopu/Ruby-tutorial" target="_blank" rel="external">https://github.com/wusuopu/Ruby-tutorial</a> </p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://www.xefan.com/archives/83945.html" data-id="cktcclrvz00jiyp4knz728iwp" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Ruby/">Ruby</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/翻译/">翻译</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-/archives/83942.html" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/archives/83942.html" class="article-date">
  <time datetime="2013-11-17T12:38:07.000Z" itemprop="datePublished">2013-11-17</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Ruby栏目/">Ruby栏目</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/archives/83942.html">[翻译]Ruby教程13——面向对象2</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p></p><h1>Ruby的面向对象编程2</h1><p></p>
<p>在这章的教程我们继续讨论Ruby的面向对象编程。</p><br><p>我们以属性修饰符开始。将会包涵类常量、类方法和操作符重载。我们将定义多态，并展示在Ruby中如何使用它。我们也会提及模块和异常。</p><br><h2>属性修饰符</h2><br><p>Ruby的所有变量都是私有的。它只能通过方法来访问。这些方法通常称为设值函数(setters)和获得者(getters)。创建一个setter和getter方法是很平常的事情。加些Ruby有便利的方法来创建这两种方法。它们是<em>attr_reader</em>、<em>attr_writer</em>和<em>attr_accessor</em>。</p><br><p><em>attr_reader</em>用于创建getter方法。<em>attr_writer</em>用于setter方法。<em>attr_accessor</em>用于创建两种方法。</p><br><pre><code>#!/usr/bin/ruby<br><br>class Car<br><br>    attr_reader :name, :price<br>    attr_writer :name, :price<br><br>    def to_s<br>        “#{@name}: #{@price}”<br>    end<br><br>end<br><br><br>c1 = Car.new<br>c2 = Car.new<br><br>c1.name = “Porsche”<br>c1.price = 23500<br><br>c2.name = “Volkswagen”<br>c2.price = 9500<br><br>puts “The #{c1.name} costs #{c1.price}”<br><br>p c1<br>p c2<br></code></pre><br><p>定义了一个<em>Car</em>类，在类内部我们使用了<em>attr_reader</em>和<em>attr_writer</em>创建了两个<em>getter</em>和<em>setter</em>方法。</p><br><pre><code>attr_reader :name, :price<br></code></pre><br><p>这里我们创建了两个实例方法名为：<em>name</em>和<em>price</em>。注意<em>attr_reader</em>将方法名符号作为参数。</p><br><pre><code>attr_writer :name, :price<br></code></pre><br><p><em>attr_writer</em>创建了两个<em>setter</em>方法<em>name</em>、<em>price</em>和两个实例变量<em>@name</em>、 <em>@price</em>。</p><br><pre><code>c1.name = “Porsche”<br>c1.price = 23500<br></code></pre><br><p>这里的上下文中调用了两个<em>setter</em>方法，为实例变量填充数据。</p><br><pre><code>puts “The #{c1.name} costs #{c1.price}”<br></code></pre><br><p>这里调用了两个<em>getter</em>方法获取数据。</p><br><p>$ ./arw.rb <br><br>The Porsche costs 23500<br><br>Porsche: 23500<br><br>Volkswagen: 9500  </p><br><p>例子的输出结果。</p><br><hr><br><p>正如上面阐述的，<em>attr_accessor</em>方法会创建<em>getter</em>、<em>setter</em>方法和它们的实例变量。</p><br><pre><code>#!/usr/bin/ruby<br><br>class Book<br>   attr_accessor :title, :pages<br>end<br><br>b1 = Book.new<br>b1.title = “Hidden motives”<br>b1.pages = 255<br><br>p “The book #{b1.title} has #{b1.pages} pages”<br></code></pre><br><p>定义了一个<em>Book</em>类，它使用<em>attr_accessor</em>创建了两对方法和两个实例变量。</p><br><pre><code>class Book<br>   attr_accessor :title, :pages<br>end<br></code></pre><br><p><em>attr_accessor</em>方法设置了<em>title</em>、<em>pages</em> 方法以及<em>@title</em>、<em>@pages</em>实例变量。</p><br><pre><code>b1 = Book.new<br>b1.title = “Hidden motives”<br>b1.pages = 255<br></code></pre><br><p>创建了一个<em>Book</em>对象。调用两个setter方法为对象的实例变量填充数据。</p><br><pre><code>p “The book #{b1.title} has #{b1.pages} pages”<br></code></pre><br><p>这行的代码我们调用getter方法读取实例变量的值。</p><br><p>$ ./accessor.rb<br><br>“The book Hidden motives has 255 pages”  </p><br><p>例子的输出结果。</p><br><h2>类的常量</h2><br><p>Ruby允许创建类常量。这些常量不属于特定的对象，它们是属于类的。作为约定，常量以大写字母开头。</p><br><pre><code>#!/usr/bin/ruby<br><br>class MMath<br><br>    PI = 3.141592<br>end<br><br><br>puts MMath::PI<br></code></pre><br><p>创建一个<em>MMath</em>类，包含了一个<em>PI</em>常量。</p><br><pre><code>PI = 3.141592<br></code></pre><br><p>我们创建了一个<em>PI</em>常量。记住在Ruby中常量不是强制的。</p><br><pre><code>puts MMath::PI<br></code></pre><br><p>使用<em>::</em>操作符访问<em>PI</em>常量。</p><br><p>$ ./classconstant.rb <br><br>3.141592  </p><br><p>例子输出结果。</p><br><h2>to_s方法</h2><br><p>每个对象都有一个<em>to_s</em>方法，它返回该对象的一个字符串描述。注意<em>puts</em>方法将一个对象作为参数时，该对象的<em>to_s</em>方法将被调用。</p><br><pre><code>#!/usr/bin/ruby<br><br>class Being<br><br>    def to_s<br>        “This is Being class”<br>    end<br>end<br><br>b = Being.new<br>puts b.to_s<br>puts b<br></code></pre><br><p>定义一个<em>Being</em>类并重载了<em>to_s</em>方法。</p><br><pre><code>def to_s<br>    “This is Being class”<br>end<br></code></pre><br><p>每个创建的类都继承自基类<em>Object</em>。<em>to_s</em>方法属于这个类。我们重载了<em>to_s</em>方法，使得描述信息更加可读。</p><br><pre><code>b = Being.new<br>puts b.to_s<br>puts b<br></code></pre><br><p>创建一个<em>Being</em>的对象，调用两次<em>to_s</em>方法。第一次是显式调用，第二次是隐式调用。</p><br><p>$ ./tostring.rb <br><br>This is Being class<br><br>This is Being class  </p><br><p>例子的运行结果。</p><br><h2>操作符重载</h2><br><p>操作符重载是基本参数的不同进行的操作也不同。</p><br><p>Ruby中操作符和方法仅有一点区别。</p><br><pre><code>#!/usr/bin/ruby<br><br>class Circle<br><br>    attr_accessor :radius<br><br>    def initialize r<br>        @radius = r<br>    end<br><br>    def +(other)<br>        Circle.new @radius + other.radius<br>    end<br><br>    def to_s<br>        “Circle with radius: #{@radius}”<br>    end<br>end<br><br><br>c1 = Circle.new 5<br>c2 = Circle.new 6<br>c3 = c1 + c2<br><br>p c3<br></code></pre><br><p>这个例子中，我们创建了一个<em>Circle</em>类，并重载了+操作符，用于将两个<em>circle</em>对象相加。</p><br><pre><code>def +(other)<br>    Circle.new @radius + other.radius<br>end<br></code></pre><br><p>我们定义了一个名为<em>+</em>的方法，这个方法将两个<em>circle</em>对象的半径相加。</p><br><pre><code>c1 = Circle.new 5<br>c2 = Circle.new 6<br>c3 = c1 + c2<br></code></pre><br><p>创建两个<em>circle</em>对象。在第三行我们将这两个对象相加生成一个新的对象。</p><br><p>$ ./operatoroverloading.rb<br><br>Circle with radius: 11  </p><br><p>这两个对象相加生成的第三个对象半径为11。</p><br><h2>类方法</h2><br><p>Ruby方法分为类方法和实例方法。类方法只能被类调用，不能被实例调用。</p><br><p>类方法不能访问实例变量。</p><br><pre><code>#!/usr/bin/ruby<br><br>class Circle<br><br>    def initialize x<br>        @r = x<br>    end<br><br>    def self.info<br>       “This is a Circle class”<br>    end<br><br>    def area<br>        @r <em> @r </em> 3.141592<br>    end<br><br>end<br><br><br>p Circle.info<br>c = Circle.new 3<br>p c.area<br></code></pre><br><p>上面的例子展示了一个<em>Circle</em>类。除了构造函数之外，还有一个类方法和一个实例方法。</p><br><pre><code>def self.info<br>    “This is a Circle class”<br>end<br></code></pre><br><p>以<em>self</em>关键字开头的是类方法。</p><br><pre><code>def area<br>    “Circle, radius: #{@r}”<br>end<br></code></pre><br><p>实例方法不以<em>self</em>关键字开头。</p><br><pre><code>p Circle.info<br></code></pre><br><p>调用类方法。注意我们是通过类来调用这个方法。</p><br><pre><code>c = Circle.new 3<br>p c.area<br></code></pre><br><p>为了调用实例方法我们必须得先创建一个对象。实例方法总是被对象调用。这里<em>c</em>变量保存了该对象，我们利用点操作符调用<em>area</em>方法。</p><br><p>$ ./classmethods.rb<br><br>“This is a Circle class”<br><br>28.274328  </p><br><p>例子的输出描述了Ruby的类方法。</p><br><hr><br><p>在Ruby中有三种方式创建类方法。</p><br><pre><code>#!/usr/bin/ruby<br><br>class Wood<br><br>    def self.info<br>       “This is a Wood class”<br>    end<br>end<br><br>class Brick<br><br>    class &lt;&lt; self<br>        def info<br>           “This is a Brick class”<br>        end<br>    end<br>end<br><br>class Rock<br><br>end<br><br>def Rock.info<br>   “This is a Rock class”<br>end<br><br><br>p Wood.info<br>p Brick.info<br>p Rock.info<br></code></pre><br><p>这个例子创建了三个类，每个都有一个类方法。</p><br><pre><code>def self.info<br>    “This is a Wood class”<br>end<br></code></pre><br><p>类方法可以以<em>self</em>关键字开头。</p><br><pre><code>class &lt;&lt; self<br>    def info<br>        “This is a Brick class”<br>    end<br>end<br></code></pre><br><p>另一个方式是将方法定义放在<em>class &lt;&lt; self</em>结构之后。</p><br><pre><code>def Rock.info<br>   “This is a Rock class”<br>end<br></code></pre><br><p>这是第三种定义类方法的方式。</p><br><p>$ ./classmethods2.rb<br><br>“This is a Wood class”<br><br>“This is a Brick class”<br><br>“This is a Rock class”  </p><br><p>调用<em>Wood</em>、<em>Brick</em>和<em>Rock</em>这三个类的类方法的输出结果。</p><br><h2>创建实例方法的三种方式</h2><br><p>Ruby有三种基本的方式创建实例方法。实例方法是属于实例对象的。它们是通过对象使用点操作符调用。</p><br><pre><code>#!/usr/bin/ruby<br><br>class Wood<br><br>    def info<br>       “This is a wood object”<br>    end<br>end<br><br>wood = Wood.new<br>p wood.info<br><br>class Brick<br><br>    attr_accessor :info<br>end<br><br>brick = Brick.new<br>brick.info = “This is a brick object”<br>p brick.info<br><br>class Rock<br><br>end<br><br>rock = Rock.new<br><br>def rock.info<br>    “This is a rock object”<br>end<br><br>p rock.info<br></code></pre><br><p>这个例子我们创建了三个实例对象<em>Wood</em>、<em>Brick</em>和<em>Rock</em>。每个对象都有一介上实例方法。</p><br><pre><code>class Wood<br><br>    def info<br>       “This is a wood object”<br>    end<br>end<br><br>wood = Wood.new<br>p wood.info<br></code></pre><br><p>这可能是最常用的一种方式。<em>info</em>方法定义在<em>Wood</em>类的内部。稍后创建一个对象并调用它的<em>info</em>方法。</p><br><pre><code>class Brick<br><br>    attr_accessor :info<br>end<br><br>brick = Brick.new<br>brick.info = “This is a brick object”<br>p brick.info<br></code></pre><br><p>另一种创建实例方法的方式是使用属性修饰符。这是一种方便的方式可以减少程序员的按键输入。<em>attr_accessor</em>创建两个方法getter和setter，同样也创建一个实例变量用于存储数据。创建一个<em>brick</em>对象，数据使用setter方法保存在<em>@info</em>变量中。最后使用getter方法读取消息。</p><br><pre><code>class Rock<br><br>end<br><br>rock = Rock.new<br><br>def rock.info<br>    “This is a rock object”<br>end<br><br>p rock.info<br></code></pre><br><p>第三种方法我们创建了一个空的<em>Rock</em>类。稍后实例化一个对象，动态的为这个对外创建一个方法。</p><br><p>$ ./threeways.rb<br><br>“This is a wood object”<br><br>“This is a brick object”<br><br>“This is a rock object”  </p><br><p>例子的输出结果。</p><br><h2>多态性</h2><br><p>多态是使用一个操作符或者函数对不同的数据进行不同的处理。实践中多态意味着如果类B继承自类A，它没有必要将类A的所有都继承；它可以做一些与类A不同的事情。</p><br><p>注意静态语言如C++、Java、或者C#和动态语言如Python、Ruby的多态有些不同。在静态语言中编译器决定了方法的定义。在动态语言中我们专注了同名方法的不同操作。</p><br><pre><code>#!/usr/bin/ruby<br><br>class Animal<br><br>    def make_noise<br>        “Some noise”<br>    end<br><br>    def sleep<br>        puts “#{self.class.name} is sleeping.”<br>    end<br><br>end<br><br>class Dog &lt; Animal<br><br>    def make_noise<br>        ‘Woof!’<br>    end<br><br>end<br><br>class Cat &lt; Animal<br><br>    def make_noise<br>        ‘Meow!’<br>    end<br>end<br><br>[Animal.new, Dog.new, Cat.new].each do |animal|<br>  puts animal.make_noise<br>  animal.sleep<br>end<br></code></pre><br><p>我们创建了一个简单的继承结构。有一个<em>Animal</em>基类和两个后代<em>Cat</em>和<em>Dog</em>。这三个类都有它自己的<em>make_noise</em>方法实现。后代的实现方法会替换掉<em>Animal</em>类的。</p><br><pre><code>class Dog &lt; Animal<br><br>    def make_noise<br>        ‘Woof!’<br>    end<br><br>end<br></code></pre><br><p><em>Dog</em>类的<em>make_noise</em>实现替换掉了<em>Animal</em>类的实现。</p><br><pre><code>[Animal.new, Dog.new, Cat.new].each do |animal|<br>  puts animal.make_noise<br>  animal.sleep<br>end<br></code></pre><br><p>为每个类的创建了一个实例对象，并对该对象调用了<em>make_noise</em>方法和<em>sleep</em>方法。</p><br><p>$ ./polymorhism.rb<br><br>Some noise<br><br>Animal is sleeping.<br><br>Woof!<br><br>Dog is sleeping.<br><br>Meow!<br><br>Cat is sleeping.  </p><br><p>polymorhism.rb脚本的输出结果。</p><br><h2>模块</h2><br><p>一个Ruby模块是方法、类和常量的集合。模块与类相似也有些不同。模块不能创建实例，没有子类。</p><br><p>模块用于将相关的类、方法和常量聚集单独放在一个模块中。这样也避免了命名的冲突，因为模块将它包含的对象进行了封装。从这方面来看Ruby的模块与C#的命名空间和Java的包相似。</p><br><p>在Ruby中模块也支持混合类（mixins）。混入类（mixin）是一个创建多继承的工厂。如果一个类继承自多个类，则称为多继承。</p><br><pre><code>#!/usr/bin/ruby<br><br>puts Math::PI<br>puts Math.sin 2<br></code></pre><br><p>Ruby有一个内建的<em>Math</em>模块。它有许多方法和常量。我们使用<em>::</em>操作符访问PI常量。与类相同使用点操作符访问方法。</p><br><pre><code>#!/usr/bin/ruby<br><br>include Math<br><br>puts PI<br>puts sin 2<br></code></pre><br><p>如果我包含了一个模块，我们就可以直接引用Math的对象了。模块导入使用<em>include</em>关键字。</p><br><p>$ ./modules.rb<br><br>3.141592653589793<br><br>0.9092974268256817  </p><br><p>程序的输出结果。</p><br><hr><br><p>下面的例子我们展示了如何使用模块来组织代码。</p><br><pre><code>#!/usr/bin/ruby<br><br>module Forest<br><br>    class Rock ; end<br>    class Tree ; end<br>    class Animal ; end<br><br>end<br><br>module Town<br><br>   class Pool ; end<br>   class Cinema ; end<br>   class Square ; end<br>   class Animal ; end<br><br>end<br><br><br>p Forest::Tree.new<br>p Forest::Rock.new<br>p Town::Cinema.new<br><br>p Forest::Animal.new<br>p Town::Animal.new<br></code></pre><br><p>Ruby代码可以主义分组。<em>Rocks</em>和<em>Tree</em>属于<em>Forest</em>。<em>Pools</em>、<em>Cinema</em>、<em>Squares</em>属于<em>Town</em>。使用模块让我们的代码更加有条理。<em>Animals</em>可以在<em>Forest</em>里也可以有<em>Town</em>里。对于一个脚本我们不能定义两个<em>Animal</em>类，它们会冲突。将它们放在不同的模块即可解决这个问题。</p><br><pre><code>p Forest::Tree.new<br>p Forest::Rock.new<br>p Town::Cinema.new<br></code></pre><br><p>创建属于<em>Forest</em>和<em>Town</em>的对象。我们使用<em>::</em>操作符访问模块里的对象。</p><br><pre><code>p Forest::Animal.new<br>p Town::Animal.new<br></code></pre><br><p>创建两个Animal对象。Ruby解释器会将它们标识为它们的模块名。</p><br><pre><code>$ ./modules3.rb<br>#&lt;Forest::Tree:0x97f35ec&gt;<br>#&lt;Forest::Rock:0x97f35b0&gt;<br>#&lt;Town::Cinema:0x97f3588&gt;<br>#&lt;Forest::Animal:0x97f3560&gt;<br>#&lt;Town::Animal:0x97f3538&gt;<br></code></pre><br><p>modules3.rb程序的输出。</p><br><hr><br><p>这节的最后一个例子我们将展示使用模块进行多继承。在这里的上下文中模块称为混合类（mixins）。</p><br><pre><code>#!/usr/bin/ruby<br><br>module Device<br>    def switch_on ; puts “on” end<br>    def switch_off ; puts “off” end<br>end<br><br>module Volume<br>    def volume_up ; puts “volume up” end<br>    def vodule_down ; puts “volume down” end<br>end<br><br>module Pluggable<br>    def plug_in ; puts “plug in” end<br>    def plug_out ; puts “plug out” end<br>end<br><br>class CellPhone<br>    include Device, Volume, Pluggable<br><br>    def ring<br>        puts “ringing”<br>    end<br>end<br><br>cph = CellPhone.new<br>cph.switch_on<br>cph.volume_up<br>cph.ring<br></code></pre><br><p>我们定义了三个模块和一个类。模块代表了一些功能。一个设备可以调节开头。许多对象都可以分享这个功能，包含电视、手机、电脑和冰箱。相对于为每个对象创建这个功能，我们是将它分隔在一个模块里，它可以被每个对象包含。这样代码将更加有条理更紧凑。</p><br><pre><code>module Volume<br>    def volume_up ; puts “volume up” end<br>    def vodule_down ; puts “volume down” end<br>end<br></code></pre><br><p><em>Volume</em>模块组织了负责控制音量等级的方法。如果一个设备需要这些方法，它只需要简单的在自己的类中包含这个模块即可。</p><br><pre><code>class CellPhone<br>    include Device, Volume, Pluggable<br><br>    def ring<br>        puts “ringing”<br>    end<br>end<br></code></pre><br><p><em>CellPhone</em>添加了这三个模块。这些模块的方法混合在<em>CellPhone</em>类中。对于这个类的实例对象同样有效。<em>CellPhone</em>类也有一个自己的<em>ring</em>方法。</p><br><pre><code>cph = CellPhone.new<br>cph.switch_on<br>cph.volume_up<br>cph.ring<br></code></pre><br><p>创建了一个<em>CellPhone</em>对象并调用了三个方法。</p><br><p>$ ./mixins.rb<br><br>on<br><br>volume up<br><br>ringing  </p><br><p>例子的运行结果。</p><br><h2>异常</h2><br><p>异常是对象偏离了正常的程序执行流的信号。<br><br>异常出现、抛出或者开始。</p><br><p>在应用程序执行期间，许多事情可能引起错误。磁盘满了我们不能保存文件。网络断了但应用程序试图连接某个网站。所有的这些可能引起应用程序崩溃。为了避免这个的发生，我们应当在程序异常时预先处理错误。对于这个我们可以使用异常处理。</p><br><p>异常是对象，它们是内建<em>Exception</em>类的后代。<em>Exception</em>对象携带了关于异常的信息。它的类型（异常的类名），可选的描述字符串，和一个可选的跟踪信息。为了获取关于程序运行异常的额外信息，程序可以子类化<em>Exception</em>或者更多是<em>StandardError</em>。</p><br><pre><code>#!/usr/bin/ruby<br><br>x = 35<br>y = 0<br><br>begin<br>    z = x / y<br>    puts z<br>rescue =&gt; e<br>    puts e<br>    p e<br>end<br></code></pre><br><p>上面的程序我们故意的除以0,这个导致一个错误。</p><br><pre><code>begin<br>    z = x / y<br>    puts z<br></code></pre><br><p>出错的语句位置<em>begin</em>关键字之后。</p><br><pre><code>rescue =&gt; e<br>    puts e<br>    p e<br>end<br></code></pre><br><p><em>rescue</em>关键字之后的代码我们处理一个异常。这里我们在终端上打印错误信息。<em>e</em>是一个异常对象，在错误发生时创建的。</p><br><pre><code>$ ./zerodivision.rb<br>divided by 0<br>#&lt;ZeroDivisionError: divided by 0&gt;<br></code></pre><br><p>输出结果我们看到了异常信息。最后一行显示了异常对象名为<em>ZeroDivisionError</em>。</p><br><hr><br><p>程序员可以使用<em>raise</em>关键字发起自己的异常。</p><br><pre><code>#!/usr/bin/ruby<br><br>age = 17<br><br>begin<br>    if age &lt; 18<br>        raise “Person is a minor”<br>    end<br><br>    puts “Entry allowed”<br>rescue =&gt; e<br>    puts e<br>    p e<br>    exit 1<br>end<br></code></pre><br><p>俱乐部不允许不满18岁的青年进入。我们使用Ruby脚本模拟这个情况。</p><br><pre><code>begin<br>    if age &lt; 18<br>        raise “Person is a minor”<br>    end<br><br>    puts “Entry allowed”<br></code></pre><br><p>如果是未成年人，将出现一个异常。如果<em>raise</em>关键字没有指明异常参数，则<em>RuntimeError</em>异常将引发。这个代码不会到达<em>puts “Entry allowed”</em>这行。代码执行中断并继续<em>rescue</em>的代码块。</p><br><pre><code>rescue =&gt; e<br>    puts e<br>    p e<br>    exit 1<br>end<br></code></pre><br><p>在<em>rescue</em>代码块中我们打印错误信息，<em>RuntimeError</em>对象的一个字符串描述。我们也调用了<em>exit</em>方法通知环境该脚本错误退出。</p><br><pre><code>$ ./raise_exception.rb<br>Person is a minor<br>#&lt;RuntimeError: Person is a minor&gt;<br>$ echo $?<br>1<br></code></pre><br><p>未成年人不允许进行俱乐部。bash的$?变量设置了这个脚本错误退出。</p><br><hr><br><p>Ruby的<em>ensure</em>从名创建的代码块总是会被执行，不管是否有异常。</p><br><pre><code>#!/usr/bin/ruby<br><br>begin<br>    f = File.open(“stones”, “r”)<br><br>    while line = f.gets do<br>        puts line<br>    end<br><br>rescue =&gt; e<br>    puts e<br>    p e<br>ensure<br>    f.close if f<br>end<br></code></pre><br><p>这个例子我们尝试打开并读取stones文件。I/O操作容易出现错误。</p><br><pre><code>ensure<br>    f.close if f<br>end<br></code></pre><br><p>在<em>ensure</em>的代码块中我们关闭文件处理对象。我们查检处理对象是否存在，因为它可能没有被创建。分配的资源通常位于<em>ensure</em>代码块里。</p><br><hr><br><p>如果想到，我们可以创建自定义的异常。Ruby中自定义异常继承自<em>StandardError</em>类。</p><br><pre><code>#!/usr/bin/ruby<br><br>class BigValueError &lt; StandardError ; end<br><br>LIMIT = 333<br>x = 3_432_453<br><br>begin<br><br>    if x &gt; LIMIT<br>        raise BigValueError, “Exceeded the maximum value”<br>    end<br><br>    puts “Script continues”<br><br>rescue =&gt; e<br>    puts e<br>    p e<br>    exit 1<br>end<br></code></pre><br><p>我们有一个情况不能处理大的数字。</p><br><pre><code>class BigValueError &lt; StandardError ; end<br></code></pre><br><p>我们定义一个<em>BigValueError</em>类。这个类继承自<em>StandardError</em>类。</p><br><pre><code>LIMIT = 333<br></code></pre><br><p>数字超过这个常量就被认为是大的。</p><br><pre><code>if x &gt; LIMIT<br>    raise BigValueError, “Exceeded the maximum value”<br>end<br></code></pre><br><p>如果值比<em>LIMIT</em>在，则抛出一个自定义异常。异常信息为<em>“Exceeded the maximum value”</em>。</p><br><pre><code>$ ./custom_exception.rb<br>Exceeded the maximum value<br>#&lt;BigValueError: Exceeded the maximum value&gt;<br></code></pre><br><p>执行程序。</p><br><p>在这一章我们完成了Ruby语言的面向对象编程。</p><br><hr><br><p>原文地址： <a href="http://zetcode.com/lang/rubytutorial/oop2/" target="_blank" rel="external">http://zetcode.com/lang/rubytutorial/oop2/</a><br><br>翻译：龙昌  admin@longchangjin.cn<br><br>完整教程：<a href="https://github.com/wusuopu/Ruby-tutorial" target="_blank" rel="external">https://github.com/wusuopu/Ruby-tutorial</a> </p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://www.xefan.com/archives/83942.html" data-id="cktcclrvv00j4yp4k5ni29yhw" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Ruby/">Ruby</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/翻译/">翻译</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-/archives/83939.html" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/archives/83939.html" class="article-date">
  <time datetime="2013-11-16T23:09:17.000Z" itemprop="datePublished">2013-11-16</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Ruby栏目/">Ruby栏目</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/archives/83939.html">[翻译]Ruby教程12——面向对象</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p></p><h1>Ruby的面向对象编程</h1><p></p>
<p>在这部分的Ruby教程我们将讨论面向对象编程。</p><br><p>编程语言有过程式编程、函数式编程和面向对象编程范式。Ruby中面向对象语言并包含了一些函数式和过程式。</p><br><p>面向对象(OOP)是一种使用对象及其接口来设计应用程序和计算机程序的编程范式。</p><br><p>面向对象的基本概念如下：</p><br><ul><br><li>抽象（Abstraction）  </li><br><li>多态（Polymorphism）  </li><br><li>封装（Encapsulation）  </li><br><li>继承（Inheritance）  </li><br></ul><br><p>抽象是对于现实中复杂的问题通过适当的建模将其简化。多态是使用相同的操作符或者函数对不同的输入数据进行不同处理。封装是将一个类的具体实现对其他对象进行隐藏。继承是一种使用已经定义的类来创建新的类的方式。</p><br><h2>对象</h2><br><p>对象是Ruby面向对象程序的基本组成。一个对象包含了数据和方法。对象之间通过方法进行交流。每个对象可以接收消息、发送消息和处理数据。</p><br><p>创建一个对象需要两步。首先定义一个类。类是对象的模板。它是一张蓝图，用来描述这个类的所有对象的状态和行为。一个类可以创建多个对象。运行时创建的对象称为这个类的实例。</p><br><pre><code>#!/usr/bin/ruby<br><br>class Being<br><br>end<br><br>b = Being.new<br>puts b<br></code></pre><br><p>第一个例子我们创建了一个简单的对象。</p><br><pre><code>class Being<br><br>end<br></code></pre><br><p>定义一个简单的类，内容为空。表示它没有任何数据和方法。</p><br><pre><code>b = Being.new<br></code></pre><br><p>创建一个<em>Being</em>类的新实例。这里我们使用<em>new</em>方法，新创建的对象保存在变量b中。</p><br><pre><code>puts b<br></code></pre><br><p>在终端上打印对象的基本描述。当我们打印一个对象时，实际上是调用的<em>to_s</em>方法。但是我们没有任何的定义，因为每个创建的对象都是继承自<em>Object</em>。它有一些基本的函数，<em>to_s</em>是其中一个。</p><br><pre><code>$ ./simple.rb<br>#&lt;Being:0x9f3c290&gt;<br></code></pre><br><p>我们得到这个对象的类名。</p><br><h2>构造函数</h2><br><p>构造函数是一个特殊的方法。它在对象创建时自动执行。它没有返回值。构造函数的目的是初始化对象的状态。在Ruby中构造函数名为<em>intialize</em>。</p><br><p>构造函数不能被继承。父对象的构造函数是通过<em>super</em>方法来调用。它们的调用顺序与继承顺序一致。</p><br><pre><code>#!/usr/bin/ruby<br><br>class Being<br><br>    def initialize<br>        puts “Being is created”<br>    end<br><br>end<br><br>Being.new<br></code></pre><br><p>定义一个<em>Being</em>类。</p><br><pre><code>class Being<br><br>    def initialize<br>        puts “Being is created”<br>    end<br><br>end<br></code></pre><br><p>类<em>Being</em>定义了一个构造函数名为<em>initialize</em>。它在终端上打印一条信息。Ruby中方法定义位置<em>def</em>和<em>end</em>关键字之间。</p><br><pre><code>Being.new<br></code></pre><br><p>创建一个<em>Being</em>类的实例对象。在对象初创时构造函数将被调用。</p><br><p>$ ./constructor.rb<br><br>Being is created  </p><br><p>程序的输出。</p><br><hr><br><p>对象的属性是绑定在对象里的数据项。这些数据项也称为实例变量（instance variables）或者成员字段（member fields）。实例变量在类中定义但是各个对象都有单独的复本。</p><br><p>下面的例子我们初始化类的成员数据。变量初始化是构造函数的典型工作。</p><br><pre><code>#!/usr/bin/ruby<br><br>class Person<br><br>    def initialize name<br>        @name = name<br>    end<br><br>    def get_name<br>        @name<br>    end<br><br>end<br><br>p1 = Person.new “Jane”<br>p2 = Person.new “Beky”<br><br>puts p1.get_name<br>puts p2.get_name<br></code></pre><br><p>上面的例子定义了一个<em>Person</em>类，并且有一个实例变量。</p><br><pre><code>class Person<br><br>    def initialize name<br>        @name = name<br>    end<br></code></pre><br><p><em>Person</em>的构造函数设置了一个实例变量<em>name</em>。构造函数的<em>name</em>参数是在创建时传递的。构造函数是在实例对象创建时调用。<em>@name</em>是一个实例变量。在Ruby中实例变量以@字符开头。</p><br><pre><code>def get_name<br>    @name<br>end<br></code></pre><br><p><em>get_name</em>方法返回成员字段。在Ruby蝇成员字段只能通过方法来访问。</p><br><pre><code>p1 = Person.new “Jane”<br>p2 = Person.new “Beky”<br></code></pre><br><p>我们创建了<em>Person</em>类的两个对象。每个对象的构造函数都传递了一个字符串参数。</p><br><pre><code>puts p1.get_name<br>puts p2.get_name<br></code></pre><br><p>通过调用每个对象的<em>get_name</em>方法来打印成员字段。</p><br><p>$ ./person.rb<br><br>Jane<br><br>Beky  </p><br><p>从程序的输出看到每个实例都有自己的<em>name</em>成员字段。</p><br><hr><br><p>我们可以创建一个对象而不调用构造函数。Ruby有一个特殊的<em>allocate</em>方法。<em>allocate</em>方法为新的对象分配空间而不调用<em>initialize</em>。</p><br><pre><code>#!/usr/bin/ruby<br><br>class Being<br><br>   def initialize<br>       puts “Being created”<br>   end<br>end<br><br><br>b1 = Being.new<br>b2 = Being.allocate<br>puts b2<br></code></pre><br><p>这个例子我们创建了两个对象。第一介对象使用<em>new</em>方法，第二个对象使用<em>allocate</em>方法。</p><br><pre><code>b1 = Being.new<br></code></pre><br><p>这里我们通过<em>new</em>关键字创建一个实例对象。构造函数<em>initialize</em>将会调用，并且在终端上打印消息。</p><br><pre><code>b2 = Being.allocate<br>puts b2<br></code></pre><br><p>这里使用<em>allocate</em>方法，没有调用构造函数。使用<em>puts</em>关键字调用对象的<em>to_s</em>方法将其显示。</p><br><pre><code>$ ./allocate.rb<br>Being created<br>#&lt;Being:0x8ea0044&gt;<br></code></pre><br><p>程序的输出。</p><br><h2>构造函数重载</h2><br><p>重载构造函数可以使用类有多种类型的构造函数。这样我们可以使用不同数量或者不同类型的参数来创建对象。</p><br><p>Ruby没有我们所知的其他语言那样的构造函数重载。在Ruby中这种行为可以通过一些有默认值的扩展参数来模拟。</p><br><pre><code>#!/usr/bin/ruby<br><br><br>class Person<br><br>    def initialize name=”unknown”, age=0<br>        @name = name<br>        @age = age<br>    end<br><br>    def to_s<br>        “Name: #{@name}, Age: #{@age}”<br>    end<br><br>end<br><br>p1 = Person.new<br>p2 = Person.new “unknown”, 17<br>p3 = Person.new “Becky”, 19<br>p4 = Person.new “Robert”<br><br>p p1, p2, p3, p4<br></code></pre><br><p>这个例子展示了模拟构造函数的重载。当<em>name</em>参数没有指定时使用<em>“unknow”</em>代替，对于<em>age</em>使用0。</p><br><pre><code>def initialize name=”unknown”, age=0<br>    @name = name<br>    @age = age<br>end<br></code></pre><br><p>这个构造传入两个参数。它们都有默认值。当我们创建对象没有指定值时就使用默认值。注意参数顺序必须一致。第一个是<em>name</em>，第二介是<em>age</em>。</p><br><pre><code>p1 = Person.new<br>p2 = Person.new “unknown”, 17<br>p3 = Person.new “Becky”, 19<br>p4 = Person.new “Robert”<br><br>p p1, p2, p3, p4<br></code></pre><br><p>我们创建了四个对象。构造函数传入了不同个数的参数。</p><br><p>$ ./consover.rb<br><br>Name: unknown, Age: 0<br><br>Name: unknown, Age: 17<br><br>Name: Becky, Age: 19<br><br>Name: Robert, Age: 0  </p><br><p>例子的输出结果。</p><br><h2>方法</h2><br><p>方法是定义在类里面的函数。它们用于对对象的属性执行一些操作。方法在面向对象范式的封装性中必不可少。例如我们<em>AccessDatabase</em>类中有一个<em>connect</em>方法，我们不需要关心这个方法到底是如何连接数据库的。我们仅需要知道使用这个方法连接数据库。这对程序功能的划分必不可少，尤其是大的应用程序。</p><br><p>在Ruby中数据仅能够通过方法访问。</p><br><pre><code>#!/usr/bin/ruby<br><br>class Person<br><br>    def initialize name<br>        @name = name<br>    end<br><br>    def get_name<br>        @name<br>    end<br><br>end<br><br>per = Person.new “Jane”<br><br>puts per.get_name<br>puts per.send :get_name<br></code></pre><br><p>这个例子展示了调用方法的两个基本方式。</p><br><pre><code>puts per.get_name<br></code></pre><br><p>通常的方式是在对象后面使用点操作符。</p><br><pre><code>puts per.send :get_name<br></code></pre><br><p>另种方式是使用内建的<em>send</em>方法。它将方法名符号作为参数传入。</p><br><hr><br><p>方法通常对对象的数据进行一些操作。</p><br><pre><code>#!/usr/bin/ruby<br><br>class Circle<br><br>    @@PI = 3.141592<br><br>    def initialize<br>        @radius = 0<br>    end<br><br>    def set_radius radius<br>        @radius = radius<br>    end<br><br>    def area<br>        @radius <em> @radius </em> @@PI<br>    end<br><br>end<br><br><br>c = Circle.new<br>c.set_radius 5<br>puts c.area<br></code></pre><br><p>这个例子的代码我们定义了一个<em>Circle</em>类两个方法。</p><br><pre><code>@@PI = 3.141592<br></code></pre><br><p>我们在<em>Circle</em>类中定义了一个<em>@@PI</em>变量。类变量以<em>@@</em>开头。类变量是属于类的，每个对象都可以访问它们的类变量。我们<em>@@PI</em>来计算圆的面积。</p><br><p>def initialize<br>    @radius = 0<br>end</p><br><p>定义了一个成员字段。它是圆的半径。如果我们想在外部修改这个变量，我们必须使用公开的<em>set_radius</em>方法。这个数据是受保护的。</p><br><pre><code>def set_radius radius<br>    @radius = radius<br>end<br></code></pre><br><p>这是<em>set_radius</em>方法。它为<em>@radius</em>实例变量设置一个新的值。</p><br><pre><code>def area<br>    @radius <em> @radius </em> @@PI<br>end<br></code></pre><br><p><em>area</em>方法返回圆的面积。</p><br><pre><code>c = Circle.new<br>c.set_radius 5<br>puts c.area<br></code></pre><br><p>我们创建一个<em>Circle</em>类的实例对象，并且通过<em>set_radius</em>方法设置它的半径。</p><br><p>$ ./circle.rb<br><br>78.5398  </p><br><p>例子的输出结果。</p><br><h2>访问修饰符</h2><br><p>访问修饰符设置成员和方法的可见性。Ruby有三种访问修饰符：<em>public</em>、<em>protected</em>和<em>private</em>。在Ruby中所有的数据都是私有的。访问修饰符可以仅对方法使用。Ruby中的方法是公开的，除非使用了其他修饰符。</p><br><p>公开的方法在类的内部和外部都可以访问。保护和私有的方法略微不同。都不能在类外部访问，仅能在这个类和它的子类或者父类内部访问。</p><br><p>注意与其他面向对象编程语言不同，继承不会充当访问修饰符。仅有两件事很重要。第一，我们是否可以在类的内部或者外部访问方法。第二，是否我们要使用或者不使用<em>self</em>关键字。</p><br><p>访问修饰符保护数据避免受到意外的修改。使用程序更健壮。实现一些主要用于修改数据的方法。这些方法最好是私有的。只有真正需要修改才将接口公开给用户。多年来用户习惯使用特殊方法并对打破向后兼容普遍不满。</p><br><pre><code>#!/usr/bin/ruby<br><br>class Some<br><br>     def method1<br>         puts “public method1 called”<br>     end<br><br>    public<br><br>     def method2<br>         puts “public method2 called”<br>     end<br><br>     def method3<br>         puts “public method3 called”<br>         method1<br>         self.method1<br>     end<br>end<br><br>s = Some.new<br>s.method1<br>s.method2<br>s.method3<br></code></pre><br><p>这个例子解释了Ruby公有方法的用法。</p><br><pre><code>def method1<br>    puts “public method1 called”<br>end<br></code></pre><br><p><em>method1</em>是公有的，尽管我们没有使用<em>public</em>修饰符。因为方法默认都是公有的，除非指明为其他。</p><br><pre><code>public<br><br>  def method2<br>      puts “public method2 called”<br>  end<br><br>  …<br></code></pre><br><p><em>public</em>关键字之后的方法是公有的。</p><br><pre><code>def method3<br>    puts “public method3 called”<br>    method1<br>    self.method1<br>end<br></code></pre><br><p>在公有方法<em>method3</em>中我们通过使用和没有使用<em>self</em>关键字调用了另一个公有方法。</p><br><pre><code>s = Some.new<br>s.method1<br>s.method2<br>s.method3<br></code></pre><br><p>公有方法是仅能够在类外部调用的方法。</p><br><p>$ ./public_methods.rb<br>public method1 called<br>public method2 called<br>public method3 called<br>public method1 called<br>public method1 called</p><br><p>例子运行结果。</p><br><hr><br><p>下一个例子看私有方法。</p><br><pre><code>#!/usr/bin/ruby<br><br><br>class Some<br><br>    def initialize<br>        method1<br>        # self.method1<br>    end<br><br>    private<br><br>     def method1<br>         puts “private method1 called”<br>     end<br><br>end<br><br><br>s = Some.new<br># s.method1<br></code></pre><br><p>私有方法是Ruby中严厉的方法。它们只能够在类内部调用并且不能使用<em>self</em>关键字。</p><br><pre><code>def initialize<br>    method1<br>    # self.method1<br>end<br></code></pre><br><p>在构造函数方法中我们调用了私有方法<em>method1</em>。使用<em>self</em>调用的被注释了。私有方法不能指定接收者。</p><br><pre><code>private<br><br>  def method1<br>      puts “private method1 called”<br>  end<br></code></pre><br><p><em>private</em>关键字之后的是私有方法。</p><br><pre><code>s = Some.new<br># s.method1<br></code></pre><br><p>创建了一个<em>Some</em>类的实例对象。在外部调用这个方法是禁止的，如果将这行取消注释Ruby解释器会报错。</p><br><p>$ ./private_methods.rb<br><br>private method called  </p><br><p>输出结果。</p><br><hr><br><p>最后我们使用保护方法。保护方法和私有方法的区别很小。保护方法与私有方法相似，不过它们可以通过<em>self</em>关键字调用。</p><br><pre><code>#!/usr/bin/ruby<br><br>class Some<br><br>    def initialize<br>        method1<br>        self.method1<br>    end<br><br>    protected<br><br>     def method1<br>         puts “protected method1 called”<br>     end<br><br>end<br><br><br>s = Some.new<br># s.method1<br></code></pre><br><p>上面的例子展示了保护方法的用法。</p><br><pre><code>def initialize<br>    method1<br>    self.method1<br>end<br></code></pre><br><p>保护方法可以使用和不使用<em>self</em>关键字。</p><br><pre><code>protected<br><br>  def method1<br>      puts “protected method1 called”<br>  end<br></code></pre><br><p>保护方法以<em>protected</em>关键字开头。</p><br><pre><code>s = Some.new<br># s.method1<br></code></pre><br><p>保护方法不能在类外部调用。取消注释会报错。</p><br><h2>继承</h2><br><p>继承是使用已经定义的类来构造新的类的方式。新构建的类称为派生类。派生自的类称为基类。继承的好处是代码利用，减少程序的复杂性。派生类（后代）覆盖或者扩展基类（祖先）的函数。</p><br><pre><code>#!/usr/bin/ruby<br><br>class Being<br><br>    def initialize<br>        puts “Being class created”<br>    end<br>end<br><br>class Human &lt; Being<br><br>   def initialize<br>       super<br>       puts “Human class created”<br>   end<br>end<br><br>Being.new<br>Human.new<br></code></pre><br><p>这个程序我们定义了两个类：一个基类<em>Being</em>和一个派生类<em>Human</em>。</p><br><pre><code>class Human &lt; Being<br></code></pre><br><p>Ruby中使用<em>&lt;</em>操作符创建继承关系。<em>Human</em>类继承自<em>Being</em>类。</p><br><pre><code>def initialize<br>    super<br>    puts “Human class created”<br>end<br></code></pre><br><p><em>super</em>方法调用父类的构造函数。</p><br><pre><code>Being.new<br>Human.new<br></code></pre><br><p>实例化了<em>Being</em>类和<em>Human</em>类。</p><br><p>$ ./inheritance.rb <br><br>Being class created<br><br>Being class created<br><br>Human class created  </p><br><p>首先创建<em>Being</em>类。基类<em>Human</em>同样也调用了父类的构造函数。</p><br><hr><br><p>一个对象的关系可能很复杂。一个对象可以有多个祖先。Ruby有<em>ancestors</em>方法获取一个类的祖先列表。</p><br><p>每个Ruby对象都是<em>Object</em>、<em>BaseObject</em>和<em>Kernel</em>的后代。它们内建于Ruby语言的内核中。</p><br><pre><code>#!/usr/bin/ruby<br><br><br>class Being<br>end<br><br>class Living &lt; Being<br>end<br><br>class Mammal &lt; Living<br>end<br><br>class Human &lt; Mammal<br>end<br><br><br>p Human.ancestors<br></code></pre><br><p>这个例子中定义了四个类。<em>Human</em>、<em>Mammal</em>、<em>Living</em>和<em>Being</em>。</p><br><pre><code>p Human.ancestors<br></code></pre><br><p>打印Human类的祖先。</p><br><p>$ ./ancestors.rb <br><br>[Human, Mammal, Living, Being, Object, Kernel, BasicObject]  </p><br><p><em>Human</em>类有三个自定义的和三个内建的祖先。</p><br><hr><br><p>一个更复杂的例子。</p><br><pre><code>#!/usr/bin/ruby<br><br>class Being<br><br>    @@count = 0<br><br>    def initialize<br>        @@count += 1<br>        puts “Being class created”<br>    end<br><br>    def show_count<br>        “There are #{@@count} beings”<br>    end<br><br>end<br><br>class Human &lt; Being<br><br>   def initialize<br>       super<br>       puts “Human is created”<br>   end<br>end<br><br>class Animal &lt; Being<br><br>   def initialize<br>       super<br>       puts “Animal is created”<br>   end<br>end<br><br>class Dog &lt; Animal<br><br>   def initialize<br>       super<br>       puts “Dog is created”<br>   end<br>end<br><br>Human.new<br>d = Dog.new<br>puts d.show_count<br></code></pre><br><p>我们定义了四个类。继承的层级有点复杂。<em>Human</em>和<em>Animal</em>继承自<em>Being</em>。<em>Dog</em>继承自<em>Animal</em>。我们还使用了类变量来统计beings的创建个数。</p><br><pre><code>@@count = 0<br></code></pre><br><p>我们定义一个类变量。它用于统计beings的创建个数。</p><br><pre><code>def initialize<br>    @@count += 1<br>    puts “Being class created”<br>end<br></code></pre><br><p>每次<em>Being</em>类实例化时我们将<em>@@count</em>变量加1。这使用我们可以跟踪实例创建的个数。</p><br><pre><code>class Animal &lt; Being<br>…<br><br>class Dog &lt; Animal<br>…<br></code></pre><br><p><em>Animal</em>继承自<em>Being</em>，<em>Dog</em>继承自<em>Animal</em>。进一步的<em>Dog</em>也继承自<em>Being</em>。</p><br><pre><code>Human.new<br>d = Dog.new<br>puts d.show_count<br></code></pre><br><p>我们通过<em>Human</em>和<em>Dog</em>创建实例。然后调用<em>Dog</em>对象的<em>show_count</em>方法。<em>Dog</em>类没有该方法，将调用<em>Being</em>类的。</p><br><p>$ ./inheritance2.rb<br>Being class created<br><br>Human is created<br><br>Being class created<br><br>Animal is created<br><br>Dog is created<br><br>There are 2 beings  </p><br><p><em>Human</em>对象调用了两个构造函数。<em>Dog</em>对象调用了三个构造函数。创建了两个<em>Being</em>实例。</p><br><hr><br><p>方法和数据成员可见性在继承中不起作用。这与其他通常的面向对象编程语言是显著的不同。</p><br><p>在C#或者Java中公有的和保护的数据成员和方法可以被继承，私有的不能。与这相比，在Ruby中私有的数据成员和方法也可以被继承。数据成员和方法的可见性不会受继承的影响。</p><br><pre><code>#!/usr/bin/ruby<br><br>class Base<br><br>    def initialize<br>        @name = “Base”<br>    end<br><br>    private<br><br>     def private_method<br>         puts “private method called”<br>     end<br><br>    protected<br><br>     def protected_method<br>         puts “protected_method called”<br>     end<br><br>    public<br><br>     def get_name<br>         return @name<br>     end<br>end<br><br><br>class Derived &lt; Base<br><br>    def public_method<br>        private_method<br>        protected_method<br>    end<br>end<br><br>d = Derived.new<br>d.public_method<br>puts d.get_name<br></code></pre><br><p>这个例子中有两个类。<em>Derived</em>继承乍<em>Base</em>。它继承了三个方法和一个数据字段。</p><br><pre><code>def public_method<br>    private_method<br>    protected_method<br>end<br></code></pre><br><p><em>Derived</em>类的<em>public_method</em>调用了一个私有方法和一个保护方法。它们定义在父类中。</p><br><pre><code>d = Derived.new<br>d.public_method<br>puts d.get_name<br></code></pre><br><p>创建一个<em>Derived</em>类的实例。调用<em>public_method</em>方法和<em>get_name</em>方法，它返回私有的实例变量<em>@name</em>。记住Ruby中所有的实例变量都是私有的。<em>get_name</em>方法返回这个变量不管<em>@name</em>是私有的还是在父类中定义的。</p><br><p>$ ./inheritance3.rb<br><br>private method called<br><br>protected_method called<br><br>Base  </p><br><p>输出结果证实了在Ruby中公有的、保护的、私有的方法和私有的成员字段都能被继承。</p><br><h2>super方法</h2><br><p><em>super</em>方法调用父类的同名方法。如果没有传递参数它将自动的把当前的所有参数传入。如果写为<em>super()</em>则没有参数传入。</p><br><pre><code>#!/usr/bin/ruby<br><br>class Base<br><br>    def show x=0, y=0<br>        p “Base class, x: #{x}, y: #{y}”<br>    end<br>end<br><br>class Derived &lt; Base<br><br>    def show x, y<br>        super<br>        super x<br>        super x, y<br>        super()<br>    end<br>end<br><br><br>d = Derived.new<br>d.show 3, 3<br></code></pre><br><p>这个例子有两个类一个继承。它们都定义了<em>show</em>方法。这个方法在<em>Derived</em>类中使用super调用了父类的方法。</p><br><pre><code>def show x, y<br>    super<br>    super x<br>    super x, y<br>    super()<br>end<br></code></pre><br><p><em>super</em>不带参数则会传递将当前传入的参数，这里是x=3、y=3。<em>super()</em>方法不传递参数。</p><br><p>$ ./super.rb<br><br>“Base class, x: 3, y: 3”<br><br>“Base class, x: 3, y: 0”<br><br>“Base class, x: 3, y: 3”<br><br>“Base class, x: 0, y: 0”  </p><br><p>输出结果。</p><br><p>这是Ruby的面向对象的第一部分。</p><br><hr><br><p>原文地址： <a href="http://zetcode.com/lang/rubytutorial/oop/" target="_blank" rel="external">http://zetcode.com/lang/rubytutorial/oop/</a><br><br>翻译：龙昌  admin@longchangjin.cn<br><br>完整教程：<a href="https://github.com/wusuopu/Ruby-tutorial" target="_blank" rel="external">https://github.com/wusuopu/Ruby-tutorial</a> </p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://www.xefan.com/archives/83939.html" data-id="cktcclrvt00iyyp4k7fuzwjz2" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Ruby/">Ruby</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/翻译/">翻译</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-/archives/83935.html" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/archives/83935.html" class="article-date">
  <time datetime="2013-11-15T19:39:14.000Z" itemprop="datePublished">2013-11-15</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Ruby栏目/">Ruby栏目</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/archives/83935.html">[翻译]Ruby教程11——哈希表</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p></p><h1>哈希表</h1><p></p>
<p>这部分的教程我们将提到哈希表。哈希表是一个键-值对的集合。与数组相似，不同与数组的是哈希表的索引是确定的，数组的只能是整数。哈希表有时称为相关联的数组。</p><br><p>哈希表是非常有用的集合。它有许多方法供程序员使用。</p><br><h2>创建哈希表</h2><br><p>有两种创建哈希表的方式：使用<em>new</em>关键字或者哈希表的字面量。</p><br><pre><code>#!/usr/bin/ruby<br><br>names = Hash.new<br>names[1] = “Jane”<br>names[2] = “Thomas”<br><br>puts names<br></code></pre><br><p>第一个脚本创建了一个哈希表并添加了两个键-值对。</p><br><pre><code>names = Hash.new<br></code></pre><br><p>创建一个哈希对象。</p><br><pre><code>names[1] = “Jane”<br>names[2] = “Thomas”<br></code></pre><br><p>添加两对值。数字1、2是哈希表的键。键放在中括号里。<em>names</em>是属于键的值。</p><br><pre><code>puts names<br></code></pre><br><p>打印哈希表。</p><br><pre><code>$ ./create.rb<br>{1=&gt;”Jane”, 2=&gt;”Thomas”}<br></code></pre><br><p>从输出结果我们看到一个哈希表是用花括号括起来的。键和值是使用<em>=&gt;</em>符号成对搭配。</p><br><hr><br><p><em>store</em>方法可以用于给哈希表设置一些初始值。它可以代替花括号。</p><br><pre><code>#!/usr/bin/ruby<br><br>names = Hash.new<br>names.store(1, “Jane”)<br>names.store(2, “Thomas”)<br>names.store(3, “Rebecca”)<br><br>puts names<br></code></pre><br><p>创建了一个相似的脚本，这次我们使用<em>store</em>方法。</p><br><pre><code>names.store(1, “Jane”)<br></code></pre><br><p><em>store</em>方法的第一个参数是键，第二个参数是值。</p><br><hr><br><p>第三个脚本我们使用字面符来创建哈希表。它的值是用花括号括起来的。并且键和值是用<em>=&gt;</em>符号成对分配。</p><br><pre><code>#!/usr/bin/ruby<br><br>domains = { “de” =&gt; “Germany”,<br>            “sk” =&gt; “Slovakia”,<br>            “hu” =&gt; “Hungary”,<br>            “us” =&gt; “United States”,<br>            “no” =&gt; “Norway”<br>          }<br><br>puts domains[“de”]<br>puts domains[“sk”]<br></code></pre><br><p>创建哈希表<em>domains</em>包含5对内容。这里键和值都是字符串。</p><br><p>$ ./create3.rb <br><br>Germany<br><br>Slovakia  </p><br><p>例子的输出结果。</p><br><h2>基本用法</h2><br><p>这一节我们展示Ruby哈希表的一些很基础的方法。</p><br><pre><code>#!/usr/bin/ruby<br><br>names = Hash.new<br><br>names[1] = “Jane”<br>names[2] = “Thomas”<br>names[3] = “Robert”<br>names[4] = “Julia”<br>names[5] = “Rebecca”<br><br>puts “The size of the hash is #{names.size}”<br><br>puts names.keys.inspect<br>puts names.values.inspect<br></code></pre><br><p>上面的脚本中创建了一个有5个值的哈希表，介绍了哈希表的三个方法。</p><br><pre><code>puts “The size of the hash is #{names.size}”<br></code></pre><br><p><em>size</em>方法返回哈希表的大小。与<em>length</em>方法相同。</p><br><pre><code>puts names.keys.inspect<br>puts names.values.inspect<br></code></pre><br><p><em>keys</em>方法返回哈希表的所有键。以此类推，<em>values</em>方法返回哈希表的所有值。返回的数据是一个数组形式的。为了使输出更加可读我们使用了<em>inspect</em>方法。</p><br><p>$ ./basic.rb<br><br>The size of the hash is 5<br><br>[1, 2, 3, 4, 5]<br><br>[“Jane”, “Thomas”, “Robert”, “Julia”, “Rebecca”]  </p><br><p>例子的输出结果。注意最后两个方法是两个数组。</p><br><hr><br><p>这节的第二个例子展示了哈希表实例的三个方法。</p><br><pre><code>#!/usr/bin/ruby<br><br>names1 = Hash.new<br><br>names1[1] = “Jane”<br>names1[2] = “Thomas”<br>names1[3] = “Robert”<br>names1[4] = “Julia”<br>names1[5] = “Rebecca”<br><br>names2 = names1.dup<br><br>puts names1.eql? names2<br><br>puts names1.empty?<br>names1.clear<br>puts names1.empty?<br></code></pre><br><p>创建了一个<em>names</em>哈希表，对该对象调用了三个方法。</p><br><pre><code>names2 = names1.dup<br></code></pre><br><p>通过<em>dup</em>方法创建了一个副本。</p><br><pre><code>puts names1.eql? names2<br></code></pre><br><p><em>eql?</em>方法比较两个哈希表对象是否相等。这里是相同的，打印true。</p><br><pre><code>puts names1.empty?<br></code></pre><br><p><em>empty?</em>方法检查哈希表是否为空。这行打印false，因为<em>names1</em>有5项数据。</p><br><pre><code>names1.clear<br>puts names1.empty?<br></code></pre><br><p><em>clear</em>方法删除哈希表的所有内容。接着调用<em>empty?</em>方法返回true。</p><br><p>$ ./basic2.rb<br><br>true<br><br>false<br><br>true  </p><br><p>输出结果。</p><br><hr><br><p>有一个方法可以判断一个键或者值是否在这个哈希表中。</p><br><pre><code>#!/usr/bin/ruby<br><br>domains = { :de =&gt; “Germany”, :sk =&gt; “Slovakia”,<br>            :no =&gt; “Norway”, :us =&gt; “United States”<br>          }<br><br>puts domains.has_key? :de<br>puts domains.include? :no<br>puts domains.key? :me<br>puts domains.member? :sk<br><br>puts domains.has_value? “Slovakia”<br>puts domains.value? “Germany”<br></code></pre><br><p>创建了一个有4对数据的哈希表<em>domains</em>。键是用的符号，因为它更有效。</p><br><pre><code>puts domains.has_key? :de<br>puts domains.include? :no<br>puts domains.key? :me<br>puts domains.member? :sk<br></code></pre><br><p>这里我们用了四个方法来判断哈希表是否包含该键。它们的功能都是相同的。</p><br><pre><code>puts domains.has_value? “Slovakia”<br>puts domains.value? “Germany”<br></code></pre><br><p>这里用了两个方法检查这两个字符串是否在哈希表中。</p><br><p>$ ./has.rb<br><br>true<br><br>true<br><br>false<br><br>true<br><br>true<br><br>true  </p><br><p>输出结果。</p><br><hr><br><p>这节的最后一个例子，我们将从哈希表中读取内容。</p><br><pre><code>#!/usr/bin/ruby<br><br>stones = { 1 =&gt; “garnet”, 2 =&gt; “topaz”,<br>           3 =&gt; “opal”, 4 =&gt; “amethyst”<br>         }<br><br>puts stones.fetch 1<br>puts stones[2]<br>puts stones.values_at 1, 2, 3<br></code></pre><br><p>这个脚本展示了三个读取值的方法。</p><br><pre><code>puts stones.fetch 1<br></code></pre><br><p><em>fetch</em>方法通过给定的键读取值。</p><br><pre><code>puts stones[2]<br></code></pre><br><p>也可以使用中括号来获取一个值，这行会打印<em>“topaz”</em>。</p><br><pre><code>puts stones.values_at 1, 2, 3<br></code></pre><br><p><em>values_at</em>方法可以一次获取多个值。这个方法通过给定的键返回一个数组包含了对应的值。</p><br><p>$ ./read.rb<br><br>garnet<br><br>topaz<br><br>garnet<br><br>topaz<br><br>opal  </p><br><p>例子的输出结果。</p><br><h2>循环遍历哈希表</h2><br><p>有一些方法可以用于循环遍历哈希表。</p><br><pre><code>#!/usr/bin/ruby<br><br>stones = { 1 =&gt; “garnet”, 2 =&gt; “topaz”,<br>           3 =&gt; “opal”, 4 =&gt; “amethyst”<br>         }<br><br>stones.each { |k, v| puts “Key: #{k}, Value: #{v}” }<br>stones.each_key { |key| puts “#{key}” }<br>stones.each_value { |val| puts “#{val}” }<br>stones.each_pair { |k, v| puts “Key: #{k}, Value: #{v}” }<br></code></pre><br><p>上面的例子我们展示的四个方法。用这些方法显示了所有的键、值。</p><br><pre><code>stones.each { |k, v| puts “Key: #{k}, Value: #{v}” }<br></code></pre><br><p><em>each</em>方法对每个键都调用了给定的代码块，键-值对作为参数传递。</p><br><pre><code>stones.each_key { |key| puts “#{key}” }<br></code></pre><br><p>我们使用<em>each_key</em>方法循环遍历了哈希表所有的键。将它们打印在终端上。</p><br><pre><code>stones.each_value { |val| puts “#{val}” }<br></code></pre><br><p><em>each_value</em>用于循环遍历哈希表所有的值。</p><br><pre><code>stones.each_pair { |k, v| puts “Key: #{k}, Value: #{v}” }<br></code></pre><br><p><em>each_pair</em>方法与<em>each</em>方法相同。</p><br><p>$ ./loop.rb<br><br>Key: 1, Value: garnet<br><br>Key: 2, Value: topaz<br><br>Key: 3, Value: opal<br><br>Key: 4, Value: amethyst<br><br>1<br><br>2<br><br>3<br><br>4<br><br>garnet<br><br>topaz<br><br>opal<br><br>amethyst<br><br>Key: 1, Value: garnet<br><br>Key: 2, Value: topaz<br><br>Key: 3, Value: opal<br><br>Key: 4, Value: amethyst  </p><br><p>输出结果。</p><br><h2>删除键值对</h2><br><p>接下来的例子关注哈希表的删除。</p><br><pre><code>#!/usr/bin/ruby<br><br>names = Hash.new<br><br>names[1] = “Jane”<br>names[2] = “Thomas”<br>names[3] = “Robert”<br>names[4] = “Julia”<br>names[5] = “Rebecca”<br><br>names.delete 4<br>names.shift<br><br>puts names<br></code></pre><br><p>这个脚本我们使用了两个方法：<em>delete</em>和<em>shift</em>。<em>delete</em>方法是删除指定的键的值，并将其返回。<em>shift</em>方法删除哈希表的第一对键值，并将其作为数组返回。</p><br><pre><code>names.delete 4<br></code></pre><br><p>删除<em>4 =&gt; “Julia”</em>这对值。</p><br><pre><code>names.shift<br></code></pre><br><p>这行代码删除<em>1 =&gt; “Jane”</em>这对值。</p><br><pre><code>$ ./deleteitem.rb<br>{2=&gt;”Thomas”, 3=&gt;”Robert”, 5=&gt;”Rebecca”}<br></code></pre><br><p>输出结果显示还剩的内容。</p><br><hr><br><p><em>reject</em>和<em>delete_if</em>方法可以从哈希表中移除多项内容。如果这些方法所给定的代码块中的条件式返回true，则删除对应的键值对。这两个方法有个重要区别。<em>reject</em>方法作用于复本，<em>delete_if</em>作用于原对象。</p><br><pre><code>#!/usr/local/bin/ruby<br><br>names1 = Hash.new<br><br>names1[1] = “Jane”<br>names1[2] = “Thomas”<br>names1[3] = “Robert”<br>names1[4] = “Julia”<br>names1[5] = “Rebecca”<br><br>puts names1.reject { |k, v| v =~ /R.<em>/ }<br>puts names1<br>puts names1.delete_if { |k, v| k&lt;=3 }<br>puts names1<br></em></code></pre><br><p>这个例子使用上面的方法删除多项键值对。</p><br><pre><code>puts names1.reject { |k, v| v =~ /R./ }<br></code></pre><br><p><em>reject</em>方法移除所有满足代码块中正则式的值，并返回修改后的哈希表，原哈希表不变。</p><br><pre><code>puts names1<br></code></pre><br><p>这行的输出证实了原哈希表没有改变。</p><br><pre><code>puts names1.delete_if { |k, v| k&lt;=3 }<br></code></pre><br><p>这里我们删除键小于等于3的键值对。这个方法修改了原对象。</p><br><pre><code>$ ./massdelete.rb<br>{1=&gt;”Jane”, 2=&gt;”Thomas”, 4=&gt;”Julia”}<br>{1=&gt;”Jane”, 2=&gt;”Thomas”, 3=&gt;”Robert”, 4=&gt;”Julia”, 5=&gt;”Rebecca”}<br>{4=&gt;”Julia”, 5=&gt;”Rebecca”}<br>{4=&gt;”Julia”, 5=&gt;”Rebecca”}<br></code></pre><br><p>输出结果。</p><br><h2>添加内容</h2><br><p><em>merge</em>和<em>update</em>方法可以给哈希表添加键值对。</p><br><pre><code>#!/usr/bin/ruby<br><br>names1 = Hash.new<br><br>names1[1] = “Jane”<br>names1[2] = “Thomas”<br><br>names2 = Hash.new<br><br>names2[3] = “Robert”<br>names2[4] = “Julia”<br><br>names = names1.merge names2<br>puts names<br><br>names = names1.update names2<br>puts names<br></code></pre><br><p>这个脚本中我们创建了两个哈希表，然后对它们调用了<em>merge</em>和<em>update</em>方法。</p><br><pre><code>names = names1.merge names2<br>puts names<br></code></pre><br><p>合并<em>names1</em>和<em>names2</em>，结果分配给<em>names</em>。</p><br><pre><code>$ ./merge.rb<br>{1=&gt;”Jane”, 2=&gt;”Thomas”, 3=&gt;”Robert”, 4=&gt;”Julia”}<br>{1=&gt;”Jane”, 2=&gt;”Thomas”, 3=&gt;”Robert”, 4=&gt;”Julia”}<br></code></pre><br><p>最后的哈希表包含了<em>names1</em>和<em>names2</em>的内容。</p><br><h2>merge与merge!</h2><br><p>最后一节，我们重述一下Ruby的习俗。一些Ruby的方法以感叹号结尾。这个标志在语法上没有意义，它只是表明调用这个方法会修改对象的内容。</p><br><pre><code>#!/usr/bin/ruby<br><br>names1 = Hash.new<br><br>names1[1] = “Jane”<br>names1[2] = “Thomas”<br><br>names2 = Hash.new<br><br>names2[3] = “Robert”<br>names2[4] = “Julia”<br><br>names = names1.merge names2<br>puts names<br>puts names1<br><br>names = names1.merge! names2<br>puts names<br>puts names1<br></code></pre><br><p>我们展示了<em>merge</em>和<em>merge!</em>方法的不同。</p><br><pre><code>names = names1.merge names2<br></code></pre><br><p><em>merge</em>不会修改<em>names1</em>，它作用于一个新的复本。</p><br><pre><code>names = names1.merge! names2<br></code></pre><br><p><em>merge!</em>方法作用于原对象。<em>names1</em>被修改了。</p><br><pre><code>$ ./merge2.rb<br>{1=&gt;”Jane”, 2=&gt;”Thomas”, 3=&gt;”Robert”, 4=&gt;”Julia”}<br>{1=&gt;”Jane”, 2=&gt;”Thomas”}<br>{1=&gt;”Jane”, 2=&gt;”Thomas”, 3=&gt;”Robert”, 4=&gt;”Julia”}<br>{1=&gt;”Jane”, 2=&gt;”Thomas”, 3=&gt;”Robert”, 4=&gt;”Julia”}<br></code></pre><br><p><em>merge2.rb</em>程序的输出。</p><br><p>在这章我们学习了Ruby的哈希表。</p><br><hr><br><p>原文地址： <a href="http://zetcode.com/lang/rubytutorial/hashes/" target="_blank" rel="external">http://zetcode.com/lang/rubytutorial/hashes/</a><br><br>翻译：龙昌  admin@longchangjin.cn<br><br>完整教程：<a href="https://github.com/wusuopu/Ruby-tutorial" target="_blank" rel="external">https://github.com/wusuopu/Ruby-tutorial</a> </p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://www.xefan.com/archives/83935.html" data-id="cktcclrvp00ioyp4kx65dq6qz" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Ruby/">Ruby</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/翻译/">翻译</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-/archives/83932.html" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/archives/83932.html" class="article-date">
  <time datetime="2013-11-14T19:50:05.000Z" itemprop="datePublished">2013-11-14</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Ruby栏目/">Ruby栏目</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/archives/83932.html">[翻译]Ruby教程10——数组</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p></p><h1>数组</h1><p></p>
<p>这一部分的教程将介绍数组。数组是有序对象的集合。</p><br><p>一个这是在某个时刻只能保存一项数值。不过数组可以保存多项。这些数据项被称为数组的元素。数组可以保存任何类型的数据。每个元素可以使用索引来引用。第一个元素的索引值为0。</p><br><p>注意Ruby的数组与C、C++或者Java中的数组有很大的不同。</p><br><pre><code>#!/usr/bin/ruby<br><br>nums = [1, 2, 3, 4, 5]<br><br>nums.each do |num|<br>    puts num<br>end<br></code></pre><br><p>我们的第一个例子创建了一个包含5个整数的数组，然后在终端上打印这些元素。</p><br><pre><code>nums = [1, 2, 3, 4, 5]<br></code></pre><br><p>这行创建了一个包含5个整数的数组，每个元素使用逗号分隔开来。</p><br><pre><code>nums.each do |num|<br>    puts num<br>end<br></code></pre><br><p>我们使用<em>each</em>方法遍历数组并在终端上打印每个元素。</p><br><p>$ ./array.rb<br><br>1<br><br>2<br><br>3<br><br>4<br><br>5  </p><br><p>程序的输出结果。</p><br><h2>创建数组</h2><br><p>Ruby中数组是一个对象，可以使用<em>new</em>方法进行实例化。</p><br><pre><code>#!/usr/bin/ruby<br><br>nums = Array.new<br><br>nums.push 1<br>nums.push 2<br>nums.push 3<br>nums.push 4<br>nums.push 5<br><br>puts nums<br></code></pre><br><p>这个脚本中我们创建了一个数组<em>nums</em>，然后往里面添加了5个整数。</p><br><pre><code>nums = Array.new<br></code></pre><br><p>创建数组对象。</p><br><pre><code>nums.push 1<br></code></pre><br><p><em>push</em>方法是往数组尾部添加一项数据。</p><br><hr><br><p>我们继续使用<em>new</em>方法创建数组。</p><br><pre><code>#!/usr/bin/ruby<br><br>a1 = Array.new<br>a2 = Array.new 3<br>a3 = Array.new 6, “coin”<br>a4 = Array.new [11]<br>a5 = Array.new (15) {|e| e<em>e}<br><br>puts [a1, a2, a3, a4, a5].inspect<br></em></code></pre><br><p><em>Array</em>类的<em>new</em>方法有一些选项。</p><br><pre><code>a1 = Array.new<br></code></pre><br><p>创建一个空的数组，支持稍后再往其中填充数据。</p><br><pre><code>a2 = Array.new 3<br></code></pre><br><p>创建一个数组包含3个<em>nil</em>对象。</p><br><pre><code>a3 = Array.new 6, “coin”<br></code></pre><br><p>创建一个数组包含6个<em>“coin”</em>字符串。第一个选项是数组的大小；第二个选项是填充的对象。</p><br><pre><code>a4 = Array.new [11]<br></code></pre><br><p>第四个数组只有一项数据。</p><br><pre><code>a5 = Array.new (15) {|e| ee}<br></code></pre><br><p>创建一个有15个元素的数组，第个元素都是在代码块中创建。这里计算了序号数的平方。</p><br><pre><code>puts [a1, a2, a3, a4, a5].inspect<br></code></pre><br><p>将所有的数组放在一个数组中。数组是可以放入另一个数组里的。然后调用数组的<em>inspect</em>方法，它将对其所有的元素都调用该方法。<em>inspect</em>方法将返回代表这个数组的字符串。当我们需要快速检查数组内容时它非常有用。</p><br><p>$ ./arraynew.rb<br><br>[[], [nil, nil, nil], [“coin”, “coin”, “coin”, “coin”, “coin”, “coin”], <br><br>[11], [0, 1, 4, 9, 16, 25, 36, 49, 64, 81, 100, 121, 144, 169, 196]]  </p><br><p>我们可以所有创建的数组。</p><br><hr><br><p>接下来的脚本展示了多种创建数组的方法。</p><br><pre><code>#!/usr/bin/ruby<br><br>integers = [1, 2, 3, 4, 5]<br>animals = %w( donkey dog cat dolphin eagle )<br>weights = Array.new<br>weights &lt;&lt; 4.55 &lt;&lt; 3.22 &lt;&lt; 3.55 &lt;&lt; 8.55 &lt;&lt; 3.23<br><br>puts integers.inspect<br>puts animals.inspect<br>puts weights.inspect<br></code></pre><br><p>我们创建了三个数组分别包含了整数、字符串和小数。</p><br><pre><code>integers = [1, 2, 3, 4, 5]<br></code></pre><br><p>这行创建了一个包含5个整数的数组。这是最经典的方法。数组的每个元素放在中括号中用逗号隔开。</p><br><pre><code>animals = %w( donkey dog cat dolphin eagle )<br></code></pre><br><p>这行代码创建了一个有5个元素的字符串数组。这种方式我们不需要逗号和双引号，减少了按键次数。</p><br><pre><code>weights = Array.new<br>weights &lt;&lt; 4.55 &lt;&lt; 3.22 &lt;&lt; 3.55 &lt;&lt; 8.55 &lt;&lt; 3.23<br></code></pre><br><p>第三种方法有两步。首先创建一个数组对象，然后用数据将其初始化。这是正式的数组创建方法。上面方法实际上是这个的简写。</p><br><pre><code>puts integers.inspect<br></code></pre><br><p>The inspect method prints the string representation of the array to the terminal.</p><br><p>$ ./creation.rb<br><br>[1, 2, 3, 4, 5]<br><br>[“donkey”, “dog”, “cat”, “dolphin”, “eagle”]<br><br>[4.55, 3.22, 3.55, 8.55, 3.23]  </p><br><p>例子的输出结果。</p><br><hr><br><p>数组的数据项没限制必须是数字和字符串。数组可以包含Ruby中的所有类型的数据。</p><br><pre><code>#!/usr/bin/ruby<br><br>class Empty<br><br>end<br><br>nums = [1, 2, 3, 4, 5]<br><br>various = [1, -1, “big”, 3.4, Empty.new, nums, :two]<br><br>puts various.inspect<br></code></pre><br><p>我们在数组中放了多种Ruby对象。</p><br><pre><code>various = [1, -1, “big”, 3.4, Empty.new, nums, :two]<br></code></pre><br><p>这个数组包含了数字、字符串、自定义对象、另一个数组和一个符号。</p><br><pre><code>$ ./arrayobjects.rb<br>[1, -1, “big”, 3.4, #&lt;Empty:0x987f704&gt;, [1, 2, 3, 4, 5], :two]<br></code></pre><br><p><em>arrayobjects.rb</em>脚本的运行结果。</p><br><hr><br><p>下一个例子展示嵌套数组；即一个数组包含另一个数组。Ruby中可以在数组中嵌套数组。</p><br><pre><code>#!/usr/bin/ruby<br><br>numbers = [1, 2, 3, [2, 4, 6, [11, 12]]]<br><br>puts numbers.length<br>puts numbers[0], numbers[1]<br><br>puts numbers[3][0]<br>puts numbers[3][1]<br><br>puts numbers[3][3][0]<br>puts numbers[3][3][1]<br><br>puts numbers.flatten!.inspect<br></code></pre><br><p>数组<em>[11, 12]</em>被嵌套在<em>[2, 4, 6, …]</em>里，这个数组又被嵌套在<em>[1, 2, 3, …]</em>数组里。</p><br><pre><code>puts numbers.length<br></code></pre><br><p><em>length</em>方法返回4。内嵌数组只算一个元素。</p><br><pre><code>puts numbers[0], numbers[1]<br></code></pre><br><p>这里<em>[]</em>字符用于访问数组的元素。上面这行代码返回第一个和第二个元素。</p><br><pre><code>puts numbers[3][0]<br>puts numbers[3][1]<br></code></pre><br><p>这里我们访问内嵌数组的元素。<em>[3][0]</em>返回内嵌数组的第一个元素，在这里是2。同样的<em>[3][1]</em>返回内嵌数组的第二个元素，这里是4。</p><br><pre><code>puts numbers[3][3][0]<br>puts numbers[3][3][1]<br></code></pre><br><p>现在我们进入更深一层。我们访问更深一层数组的元素。<em>[3][3]</em>返回<em>[11, 12]</em>数组。然后从这个数组获取第一个和第二个元素。</p><br><pre><code>puts numbers.flatten!.inspect<br></code></pre><br><p><em>flatten!</em>方法将数组变为平坦。它将所有的内嵌数组元素创建成一个新的数组。</p><br><p>$ ./arrayofarrays.rb<br><br>4<br><br>1<br><br>2<br><br>2<br><br>4<br><br>11<br><br>12<br><br>[1, 2, 3, 2, 4, 6, 11, 12]  </p><br><p>输出结果。 </p><br><h2>打印数组内容</h2><br><p>要在终端上打印数组的元素有多种方法可以完成。</p><br><pre><code>#!/usr/bin/ruby<br><br>integers = [1, 2, 3, 4, 5]<br><br>puts integers<br>puts integers.inspect<br><br>integers.each do |e|<br>    puts e<br>end<br></code></pre><br><p>这个脚本我们将数组的元素打印了三次。</p><br><pre><code>puts integers<br></code></pre><br><p>数组作为puts/print方法的参数是最简单的方式。每行将打印一个元素。</p><br><pre><code>puts integers.inspect<br></code></pre><br><p>使用<em>inspect</em>方法输出结果的可读性更好。</p><br><pre><code>integers.each do |e|<br>    puts e<br>end<br></code></pre><br><p><em>each</em>方法为每个元素都调用一次一个代码块，元素作为参数传递。我们简单的参元素使用<em>puts</em>方法。</p><br><p>$ ./printarray1.rb<br><br>1<br><br>2<br><br>3<br><br>4<br><br>5<br><br>[1, 2, 3, 4, 5]<br><br>1<br><br>2<br><br>3<br><br>4<br><br>5  </p><br><p>数组在终端上打印了三次。</p><br><hr><br><p>第二个例子我们提供了两个额外的方法打印数组。</p><br><pre><code>#!/usr/bin/ruby<br><br>integers = [1, 2, 3, 4, 5]<br><br>integers.length.times do |idx|<br>    puts integers[idx]<br>end<br><br>integers.each_with_index do |num, idx|<br>    puts “value #{num} has index #{idx}”<br>end<br></code></pre><br><p>第一种情况我们组合使用了<em>length</em>和<em>times</em>方法。第二种情况我们使用了<em>each_with_index</em>方法。</p><br><pre><code>integers.length.times do |idx|<br>    puts integers[idx]<br>end<br></code></pre><br><p><em>length</em>方法返回数组的长度。<em>times</em>方法将接下来的代码块迭代<em>length</em>次，传递的值从0到length-1。这些数字作为数组的索引使用。</p><br><pre><code>integers.each_with_index do |num, idx|<br>    puts “value #{num} has index #{idx}”<br>end<br></code></pre><br><p><em>each_with_index</em>方法迭代数组并将元素及其索引传递给代码块。用这种方法我们可以简单的打印元素和它的索引。</p><br><p>$ ./printarray2.rb<br><br>1<br><br>2<br><br>3<br><br>4<br><br>5<br><br>value 1 has index 0<br><br>value 2 has index 1<br><br>value 3 has index 2<br><br>value 4 has index 3<br><br>value 5 has index 4  </p><br><p>输出结果。</p><br><h2>读取数组元素</h2><br><p>这节我们将从数组读取数据。</p><br><pre><code>#!/usr/bin/ruby<br><br>lts = %w{ a b c d e f g h}<br><br>puts lts.first<br>puts lts.last<br>puts lts.at(3)<br></code></pre><br><p>第一个例子我们展示了三个简单的方法进行数据检索。</p><br><pre><code>puts lts.first<br>puts lts.last<br></code></pre><br><p><em>first</em>方法读取数组的第一个元素；<em>last</em>方法读取数组的最后一个元素。</p><br><pre><code>puts lts.at(3)<br></code></pre><br><p><em>at</em>方法返回指定索引的元素。</p><br><p>$ ./retrieval.rb<br><br>a<br><br>h<br><br>d  </p><br><p><em>retrieval.rb</em>程序的输出结果。</p><br><hr><br><p><em>[]</em>符号可以用于访问数据。这是传统访问数据的方法，许多语言都使用这种方法。</p><br><pre><code>#!/usr/bin/ruby<br><br>lts = %w{ a b c d e f g h }<br><br>puts lts[0]<br>puts lts[-1]<br>puts lts[0, 3].inspect<br>puts lts[2..6].inspect<br>puts lts[2…6].inspect<br></code></pre><br><p>我们展示了5个使用[]符号的例子。</p><br><pre><code>puts lts[0]<br>puts lts[-1]<br></code></pre><br><p>我们获取数组的第一个和最后一个元素。第一项的索引为0,最后一项的索引为-1。</p><br><pre><code>puts lts[0, 3].inspect<br></code></pre><br><p>当中括号里有两个数时，第一个是开始的索引，第二个是长度。这行代码返回从0开始的3个元素。注意<em>inspect</em>方法仅是为了让输出可读而已。</p><br><pre><code>puts lts[2..6].inspect<br>puts lts[2…6].inspect<br></code></pre><br><p>我们可以在中括号使用范围操作符。第一行读取第2个到第6个元素，第二行读取第2个到第5个元素。</p><br><hr><br><p>接下来展示<em>values_at</em>方法。这个方法的优势是可以选择多个位置的元素。</p><br><pre><code>#!/usr/bin/ruby<br><br>lts = %w{ a b c d e f g h}<br><br>puts lts.values_at(1..5).inspect<br>puts lts.values_at(1, 3, 5).inspect<br>puts lts.values_at(1, 3, 5, 6, 8).inspect<br>puts lts.values_at(-1, -3).inspect<br></code></pre><br><p><em>values_at method</em>方法返回一个数组包含选中的元素。<em>inspect</em>方法仅是为了让输出可读而已。</p><br><pre><code>puts lts.values_at(1..5).inspect<br></code></pre><br><p>这行代码返回索引为1到5的元素。</p><br><pre><code>puts lts.values_at(1, 3, 5).inspect<br></code></pre><br><p>这里我们读取索引为1、3、5的元素。</p><br><pre><code>puts lts.values_at(1, 3, 5, 6, 8).inspect<br></code></pre><br><p>我们可以指定多个索引，如果指定的索引没有元素则返回<em>nil</em>。</p><br><pre><code>puts lts.values_at(-1, -3).inspect<br></code></pre><br><p>负数的索引表示从数组尾部开始。</p><br><p>$ ./retrieval3.rb<br><br>[“b”, “c”, “d”, “e”, “f”]<br><br>[“b”, “d”, “f”]<br><br>[“b”, “d”, “f”, “g”, nil]<br><br>[“h”, “f”]  </p><br><p>脚本的输出结果。</p><br><hr><br><p>我们使用<em>fetch</em>方法从数组读取数据。</p><br><pre><code>#!/usr/bin/ruby<br><br>lts = [0, 1, 2, 3, 4, 5, 6]<br><br>puts lts.fetch(0)<br>puts lts.fetch(-2)<br>puts lts.fetch(8, ‘undefined’)<br>puts lts.fetch(8) { |e| -2<em>e }<br></em></code></pre><br><p>我们展示了<em>fetch</em>方法的一些形式的用法。</p><br><pre><code>puts lts.fetch(0)<br>puts lts.fetch(-2)<br></code></pre><br><p>第一行打印了数组的第一个元素。第二行打印了倒数第二个元素。</p><br><pre><code>puts lts.fetch(8, ‘undefined’)<br></code></pre><br><p>第三种形式是返回指定索引的元素，如果索引超出范围则返回默认值，这里是<em>‘undefined’</em>。没有第二个参数则会抛出IndexError错误。</p><br><pre><code>puts lts.fetch(8) { |e| -2e}<br></code></pre><br><p>最后一种形式我们定义了一个代码块，传递了索引对应的值，这个方法返回了代码块调用的结果。</p><br><p>$ ./retrieval4.rb<br><br>0<br><br>5<br><br>undefined<br><br>-16  </p><br><p>脚本的输出结果。</p><br><hr><br><p>我们将展示<em>take</em>和<em>take_while</em>方法的用法。</p><br><pre><code>#!/usr/bin/ruby<br><br>lts = %w{ a b c d e f g h}<br><br><br>puts lts.take(4).inspect<br><br>lts2 = lts.take_while { |e| e &lt; ‘f’ }<br>puts lts2.inspect<br></code></pre><br><p><em>take</em> n方法返回开头的n个元素。<em>take_while</em>方法将元素传递给一个代码块，直到代码块返回<em>nil</em>或者<em>false</em>才停止迭代，并返回之前的元素。</p><br><pre><code>puts lts.take(4).inspect<br></code></pre><br><p>这里我们返回开头的4个元素。</p><br><pre><code>lts2 = lts.take_while { |e| e &lt; ‘f’ }<br>puts lts2.inspect<br></code></pre><br><p>这里我们从源数组创建了一个新的数组，这个新数组包含了所有小于’f’的字符。</p><br><p>$ ./retrieval5.rb<br><br>[“a”, “b”, “c”, “d”]<br><br>[“a”, “b”, “c”, “d”, “e”]  </p><br><p><em>retrieval5.rb</em>程序的输出结果。</p><br><hr><br><p><em>slice</em>方法与[]符号相同。返回一个或者多个元素。</p><br><pre><code>#!/usr/bin/ruby<br><br>lts = %w{ a b c d e f g h}<br><br>puts lts.slice(0)<br>puts lts.slice(-1)<br>puts lts.slice(0, 3).inspect<br>puts lts.slice(2..6).inspect<br>puts lts.slice(2…6).inspect<br></code></pre><br><p>展示了5个<em>slice</em> 方法的例子。</p><br><pre><code>puts lts.slice(0)<br>puts lts.slice(-1)<br></code></pre><br><p>这些形式的<em>slice</em>方法返回一个数组元素。第行代码返回第一个元素，第二行代码返回最后一个元素。</p><br><pre><code>puts lts.slice(0, 3).inspect<br></code></pre><br><p>第一个参数是起始索引，第二个参数是长度。这一行代码返回从0开始的3个元素。</p><br><pre><code>puts lts.slice(2..6).inspect<br>puts lts.slice(2…6).inspect<br></code></pre><br><p>我们可以在<em>slice</em>方法中使用范围操作符。第一行读取第2到6的元素，第二行读取第2到5的元素。</p><br><p>$ ./retrieval6.rb<br><br>a<br><br>h<br><br>[“a”, “b”, “c”]<br><br>[“c”, “d”, “e”, “f”, “g”]<br><br>[“c”, “d”, “e”, “f”]  </p><br><p><em>slice</em>方法返回数组的一部分，一个或者多个元素。</p><br><hr><br><p>可以随机选择数组的一个元素。Ruby中的<em>sample</em>方法可以实现。</p><br><pre><code>#!/usr/bin/ruby<br><br>lts = %w{ a b c d e f g h}<br><br>puts lts.sample<br>puts lts.sample(3).inspect<br></code></pre><br><p><em>sample</em>方法有两种形式。第一种我们选择一个随机元素。第二种我们选择n个随机元素。</p><br><p>$ ./random.rb<br><br>b<br><br>[“c”, “f”, “d”]<br><br>$ ./random.rb<br><br>d<br><br>[“c”, “d”, “e”]  </p><br><p>执行两次结果不同。</p><br><h2>使用数组</h2><br><p>接下来的例子介绍一些Ruby数组的方法。</p><br><pre><code>#!/usr/bin/ruby<br><br>num1 = [1, 2, 3, 4, 5]<br>num2 = [6, 7, 8, 9, 10]<br><br>puts num1 + num2<br>puts num1.concat num2<br></code></pre><br><p>我们定义了两个数组，将它们相加。</p><br><pre><code>puts num1 + num2<br>puts num1.concat num2<br></code></pre><br><p>有两个数组相加的方法。使用+操作符或者<em>concat</em>方法。</p><br><hr><br><p>Ruby中数组有丰富的方法。例如<em>length</em>方法返回数组的元素个数。</p><br><pre><code>#!/usr/bin/ruby<br><br>lts = %w{ a b c d e f}<br><br>puts lts.inspect<br>puts “Array has #{lts.length} elements”<br>puts “The first element is #{lts.first}”<br>puts “The last element is #{lts.last}”<br><br>puts lts.eql? lts.dup<br>puts lts.eql? lts.dup.delete_at(0)<br><br>lts.clear<br>puts lts.inspect<br>puts lts.empty?<br></code></pre><br><p>上面的脚本我们介绍了7个新方法。</p><br><pre><code>puts “Array has #{lts.length} elements”<br></code></pre><br><p><em>length</em>方法决定数组的大小。</p><br><pre><code>puts “The first element is #{lts.first}”<br>puts “The last element is #{lts.last}”<br></code></pre><br><p>这里我们获取第一个和最后一个元素。</p><br><pre><code>puts lts.eql? lts.dup<br></code></pre><br><p><em>eql?</em>方法指出两个数组是否相等。这里是返回<em>true</em>。<em>dup</em>方法创建一个浅复制对象。</p><br><pre><code>puts lts.eql? lts.dup.delete_at(0)<br></code></pre><br><p><em>delete_at</em>方法从数组的开头删除元素。现在两个数组不相同了。</p><br><pre><code>lts.clear<br></code></pre><br><p><em>clear</em>方法删除数组的所有元素。</p><br><pre><code>puts lts.empty?<br></code></pre><br><p><em>empty?</em>方法检查数组是否为空。这里返回<em>true</em>，因为我们已经将所有元素都删除了。</p><br><p>$ ./basics.rb<br><br>[“a”, “b”, “c”, “d”, “e”, “f”]<br><br>Array has 6 elements<br><br>The first element is a<br><br>The last element is f<br><br>true<br><br>false<br><br>[]<br><br>true  </p><br><p>输出结果。</p><br><hr><br><p>一些Ruby的数组方法以感叹号结尾。这是Ruby的习惯。感叹号告诉程序员这个方法会修改数据。感叹号本身没有什么作用，它只是名字的约定。</p><br><pre><code>#!/usr/bin/ruby<br><br>chars = %w{a b c d e}<br><br>reversed_chars = chars.reverse<br>puts reversed_chars.inspect<br>puts chars.inspect<br><br>reversed_chars = chars.reverse!<br>puts reversed_chars.inspect<br>puts chars.inspect<br></code></pre><br><p>Ruby中有一些比较相似的方法。<em>reverse</em>和<em>reverse!</em>方法都是改为数组元素的顺序，将它们反转。不同在于<em>reverse</em>方法返回反转后的数组，原数组不变。<em>reverse!</em>方法会同时修改原数组。</p><br><p>$ ./twotypes.rb<br><br>[“e”, “d”, “c”, “b”, “a”]<br><br>[“a”, “b”, “c”, “d”, “e”]<br><br>[“e”, “d”, “c”, “b”, “a”]<br><br>[“e”, “d”, “c”, “b”, “a”]  </p><br><p>我们清晰的看到前两个数组不同，第三和第四个数组是相同的。</p><br><hr><br><p>一些其他的方法展示。</p><br><pre><code>#!/usr/bin/ruby<br><br>numbers = [1, 2, 2, 2, 3, 4, 5, 8, 11]<br><br>puts numbers.index 2<br>puts numbers.index 11<br>puts numbers.rindex 2<br><br>puts numbers.include? 3<br>puts numbers.include? 10<br><br>puts numbers.join ‘-‘<br>puts numbers.uniq!.inspect<br></code></pre><br><p>介绍5个额外的方法。</p><br><pre><code>puts numbers.index 2<br>puts numbers.index 11<br></code></pre><br><p><em>index</em>方法返回数组中元素对应的索引。索引是从左算起。第一行返回1,它是第一个2的索引。数组中仅有一个11,它的索引是8。</p><br><pre><code>puts numbers.rindex 2<br></code></pre><br><p><em>rindex</em>方法返回从右边开始的索引。这里2的最右索引为3。</p><br><pre><code>puts numbers.include? 3<br>puts numbers.include? 10<br></code></pre><br><p><em>include?</em>方法检查一个元素是否在数组中。第一行返回<em>true</em>，3在数组中。第二行返回<em>false</em>，数组中没有10。作为约定Ruby中以问号结尾的方法返回一个布尔值，并且对数组没有影响。</p><br><pre><code>puts numbers.join ‘-‘<br></code></pre><br><p><em>join</em>方法返回一个字符串，它是将数组的元素用指定的符号分隔开来。</p><br><pre><code>puts numbers.uniq!.inspect<br></code></pre><br><p><em>uniq!</em>方法移除重复的元素。在数组中有3个2,调用方法之后就只剩一个2了。</p><br><p>$ ./methods2.rb <br><br>1<br><br>8<br><br>3<br><br>true<br><br>false<br><br>1-2-2-2-3-4-5-8-11<br><br>[1, 2, 3, 4, 5, 8, 11]  </p><br><p>注意<em>join</em>方法产生的是一个字符串，它是数组的数字用<em>-</em>符号分隔。</p><br><h2>修改数组</h2><br><p>这一节我们介绍与数组修改相关的方法。基本的我们做一些插入和删除操作。</p><br><pre><code>#!/usr/bin/ruby<br><br>lts = []<br><br>lts.insert 0, ‘E’, ‘F’, ‘G’<br>lts.push ‘H’<br>lts.push ‘I’, ‘J’, ‘K’<br>lts &lt;&lt; ‘L’ &lt;&lt; ‘M’<br>lts.unshift ‘A’, ‘B’, ‘C’<br>lts.insert(3, ‘D’)<br><br>puts lts.inspect<br></code></pre><br><p>从一个空数组开始，我们使用不同的插入方法。</p><br><pre><code>lts.insert 0, ‘E’, ‘F’, ‘G’<br></code></pre><br><p><em>insert</em>方法往<em>lts</em>数组插入了3个元素。</p><br><pre><code>lts.push ‘H’<br>lts.push ‘I’, ‘J’, ‘K’<br></code></pre><br><p><em>push</em>方法往数组添加元素，我们可以添加一个或多个元素。</p><br><pre><code>lts &lt;&lt; ‘L’ &lt;&lt; ‘M’<br></code></pre><br><p><em>&lt;&lt;</em>与<em>push</em>方法相同。这个操作可以链式调用。</p><br><pre><code>lts.unshift ‘A’, ‘B’, ‘C’<br></code></pre><br><p><em>unshift</em>方法将元素插入在数组前端。</p><br><pre><code>lts.insert(3, ‘D’)<br></code></pre><br><p>这里<em>insert</em>方法在指定的位置插入’D’字符。</p><br><p>$ ./insertion.rb<br><br>[“A”, “B”, “C”, “D”, “E”, “F”, “G”, “H”, “I”, “J”, “K”, “L”, “M”]  </p><br><p>使用上面的方法，我们创建了一个包含大写字母的数组。</p><br><hr><br><p>一些删除数组元素的方法。</p><br><pre><code>#!/usr/bin/ruby<br><br>lts = %w{ a b c d e f g h}<br><br>lts.pop<br>lts.pop<br><br>puts lts.inspect<br><br>lts.shift<br>lts.shift<br><br>puts lts.inspect<br><br>lts.delete_at(0)<br>lts.delete(‘d’)<br><br>puts lts.inspect<br><br>puts lts.clear<br>puts lts.inspect<br></code></pre><br><p>这个脚本展示了5个用于删除数组元素的方法。</p><br><pre><code>lts = %w{ a b c d e f g h}<br></code></pre><br><p>创建一个有8个元素的数组。</p><br><pre><code>lts.pop<br></code></pre><br><p><em>pop</em>方法移除最后一个元素。</p><br><pre><code>lts.shift<br></code></pre><br><p><em>shift</em>方法移除数组的第一个元素。</p><br><pre><code>lts.delete_at(0)<br></code></pre><br><p><em>delete_at</em>方法删除指定位置的元素。我们删除剩余元素的第一个元素。</p><br><pre><code>puts lts.clear<br></code></pre><br><p><em>clear</em>方法清除所有元素。</p><br><pre><code>lts.delete(‘d’)<br></code></pre><br><p><em>delete</em>方法删除指定的一项数据。</p><br><p>$ ./deletion.rb<br><br>[“a”, “b”, “c”, “d”, “e”, “f”]<br><br>[“c”, “d”, “e”, “f”]<br><br>[“e”, “f”]<br><br>[]  </p><br><p>输出结果。</p><br><hr><br><p>目前为止我们使用的方法同时只修改一个数组项。Ruby中有一些方法可以一次修改多个数组项的。</p><br><pre><code>#!/usr/bin/ruby<br><br>nms = [2, -1, -4, 0, 4, 3, -2, 3, 5]<br><br>nms.delete_if { |x| x &lt; 0 }<br><br>puts nms.inspect<br></code></pre><br><p>例子介绍了<em>delete_if</em>方法用于删除所有符合条件式的数据项。</p><br><pre><code>nms.delete_if { |x| x &lt; 0 }<br></code></pre><br><p>这行删除所有的负数。</p><br><p>$ ./delete_if.rb<br><br>[2, 0, 4, 3, 3, 5]  </p><br><p>我们从<em>nms</em>数组中删除了所有的负数。</p><br><hr><br><p>我们展示两个其他的方法处理多数据项。</p><br><pre><code>#!/usr/bin/ruby<br><br>lts = %w{ a b c d e f g}<br><br>puts lts.inspect<br><br>lts.reject! do |e|<br>    e =~ /[c language=”-y”][/c]/<br>end<br><br>puts lts.inspect<br><br>lts.replace([“x”, “y”, “z”])<br>puts lts.inspect<br></code></pre><br><p>我们使用了两个方法，<em>reject!</em>和<em>replace</em>。</p><br><pre><code>lts.reject! do |e|<br>    e =~ /[c language=”-y”][/c]/<br>end<br></code></pre><br><p><em>reject!</em>方法移除了所有项满足条件式的数据。这里我们删除所有符合正则式的字母。</p><br><pre><code>lts.replace([“x”, “y”, “z”])<br></code></pre><br><p><em>replace</em>方法将使用给定的数据替换数组项。如果可能它会截断或者扩展数组。</p><br><p>$ ./modify.rb <br><br>[“a”, “b”, “c”, “d”, “e”, “f”, “g”]<br><br>[“a”, “b”]<br><br>[“x”, “y”, “z”]  </p><br><p><em>modify.rb</em>例子的输出结果。</p><br><h2>集合操作</h2><br><p>这一节中我们展示Ruby数组的集合操作。数学中集合是独立对象的收集。</p><br><pre><code>#!/usr/bin/ruby<br><br>A = [1, 2, 3, 4, 5]<br>B = [4, 5, 6, 7, 8]<br><br>union = A | B<br>isect = A &amp; B<br>diff1  = A - B<br>diff2  = B - A<br>sdiff = (A - B) | (B - A)<br><br>puts “Union of arrays: #{union}”<br>puts “Intersection of arrays: #{isect}”<br>puts “Difference of arrays A - B: #{diff1}”<br>puts “Difference of arrays B - A: #{diff2}”<br>puts “Symmetric difference of arrays: #{sdiff}”<br></code></pre><br><p>上面的脚本我们展示了一些集合操作，并集、交集、差集和对称差集。</p><br><pre><code>nums1 = [1, 2, 3, 4, 5]<br>nums2 = [4, 5, 6, 7, 8]<br></code></pre><br><p>字义了两个整数数组。都是集合，因此每个元素都只出现了一次。两个数组有两个相同的数，4和5。</p><br><pre><code>union = nums1 | nums2<br></code></pre><br><p>数组的并集。两个数组相加，每个元素最终也只出现一次。</p><br><pre><code>isect = A &amp; B<br></code></pre><br><p>数组交集。输出两个数组都存在的元素。这里是4和5。</p><br><pre><code>diff1  = A - B<br>diff2  = B - A<br></code></pre><br><p>两个差集，也称补集。第一行我们得到了所有在A中出现B中没有出现的元素。第二行我们得到B中出现A中没有出现的元素。</p><br><pre><code>sdiff = (A - B) | (B - A)<br></code></pre><br><p>对称差集。A或B中存在，但不同时存在于A和B。</p><br><p>$ ./setoperations.rb<br><br>Union of arrays: [1, 2, 3, 4, 5, 6, 7, 8]<br><br>Intersection of arrays: [4, 5]<br><br>Difference of arrays A - B: [1, 2, 3]<br><br>Difference of arrays B - A: [6, 7, 8]<br><br>Symmetric difference of arrays: [1, 2, 3, 6, 7, 8]  </p><br><p>输出结果。</p><br><h2>select、collect、map方法</h2><br><p>下面的例子我们展示三个方法：<em>select</em>、<em>collect</em>和<em>map</em>。</p><br><pre><code>#!/usr/bin/ruby<br><br>nums = [1, 3, 2, 6, 7, 12, 8, 15]<br><br>selected = nums.select do |e|<br>    e &gt; 10<br>end<br><br>puts selected.inspect<br><br>collected = nums.collect do |e|<br>    e &lt; 10<br>end<br><br>puts collected.inspect<br><br>mapped = nums.map do |e|<br>    e<em>2<br>end<br><br>puts mapped.inspect<br></em></code></pre><br><p>所有这些方法都对数组的元素执行许多操作。</p><br><pre><code>selected = nums.select do |e|<br>    e &gt; 10<br>end<br></code></pre><br><p>上面的代码使用<em>collect</em>方法创建了一个新数组。我们只选择了满足条件式的元素。这里我们选择了所有大于10的元素。</p><br><pre><code>collected = nums.collect do |e|<br>    e &lt; 10<br>end<br></code></pre><br><p><em>collect</em>方法稍微不同。它只收集代码块的返回值。新的数组只包含true和false。</p><br><pre><code>mapped = nums.map do |e|<br>    e2<br>end<br></code></pre><br><p><em>map</em>方法与<em>collect</em>方法相同。上面的代码根据已存在的数组创建了一个新的数组。每个元素都乘以2.</p><br><p>$ ./mass.rb<br><br>[12, 15]<br><br>[true, true, true, true, true, false, true, false]<br><br>[2, 6, 4, 12, 14, 24, 16, 30]  </p><br><p>创建了新数组。</p><br><h2>元素排序</h2><br><p>最后我们对数组元素进行排序。</p><br><pre><code>#!/usr/bin/ruby<br><br>planets = %w{ Mercury Venus Earth Mars Jupiter<br>                Saturn Uranus Neptune Pluto }<br><br>puts “#{planets.sort}”<br>puts “#{planets.reverse}”<br>puts “#{planets.shuffle}”<br></code></pre><br><p>例子中使用了三个Ruby数组的方法对数组元素进行重组。</p><br><pre><code>puts “#{planets.sort}”<br></code></pre><br><p><em>sort</em>方法按字母顺序进行排序。</p><br><pre><code>puts “#{planets.reverse}”<br></code></pre><br><p><em>reverse</em>方法反转元素并返回新的数组。</p><br><pre><code>puts “#{planets.shuffle}”<br></code></pre><br><p><em>shuffle</em>方法将数组元素随机重组。</p><br><p>$ ./ordering.rb<br><br>[“Earth”, “Jupiter”, “Mars”, “Mercury”, “Neptune”, “Pluto”, “Saturn”, …]<br><br>[“Pluto”, “Neptune”, “Uranus”, “Saturn”, “Jupiter”, “Mars”, “Earth”, …]<br><br>[“Earth”, “Jupiter”, “Mercury”, “Saturn”, “Mars”, “Venus”, “Uranus”, …]  </p><br><p>例子的输出结果。</p><br><p>在这章我们学习了Ruby的数组。</p><br><hr><br><p>原文地址： <a href="http://zetcode.com/lang/rubytutorial/arrays/" target="_blank" rel="external">http://zetcode.com/lang/rubytutorial/arrays/</a><br><br>翻译：龙昌  admin@longchangjin.cn<br><br>完整教程：<a href="https://github.com/wusuopu/Ruby-tutorial" target="_blank" rel="external">https://github.com/wusuopu/Ruby-tutorial</a> </p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://www.xefan.com/archives/83932.html" data-id="cktcclrvq00isyp4kar5vyx2v" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Ruby/">Ruby</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/翻译/">翻译</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-/archives/83929.html" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/archives/83929.html" class="article-date">
  <time datetime="2013-11-12T20:00:56.000Z" itemprop="datePublished">2013-11-12</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Ruby栏目/">Ruby栏目</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/archives/83929.html">[翻译]Ruby教程9——控制流</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p></p><h1>控制流</h1><p></p>
<p>这章的教程我们将讨论控制流。</p><br><p>条件和循环改变了Ruby程序的流程。条件式是执行条件语句下面的特定语句。循环是执行多次的代码块。程序开始后，语句从源文件顶部到底部一行一行的执行。</p><br><h2>if语句</h2><br><p>if关键字用于检查一个表达式是否为真。如果为真则执行语句。这个语句可以是单一的语句，也可以是复合语句。复合语句是由多条语句构成的闭合代码块。代码块用<em>end</em>关键字闭合，<em>then</em>关键字是可选的。</p><br><pre><code>#!/usr/bin/ruby<br><br>num = gets.to_i<br><br>if num &gt; 0 then<br><br>    puts “num variable is positive”<br>    puts “num variable equals to #{num}”<br>end<br></code></pre><br><p>输入一个数字，如果这个数字大于0则打印两条消息，否则什么也不做。</p><br><p>$ ./simpleif.rb <br><br>4<br><br>num variable is positive<br><br>num variable equals to 4  </p><br><p>条件为真并且消息在终端上打印了。</p><br><hr><br><p>我们可以使用<em>else</em>关键字不创建一个简单的分支。如果<em>if</em>关键字后的表达式求值为假，那么<em>else</em>后面的语句将自动执行。这些代码使用<em>end</em>关键字闭合起来。</p><br><pre><code>#!/usr/bin/ruby<br><br>age = 17<br><br>if age &gt; 18<br><br>    puts “Driving licence issued”<br>else<br><br>    puts “Driving licence not permitted”<br>end<br></code></pre><br><p>这里创建了一个<em>age</em>变量，布尔表达式求值为假，因此在终端上打印”Driving licence not permitted”。</p><br><p>$ ./licence.rb <br><br>Driving licence not permitted  </p><br><p>我们可以使用<em>elsif</em>关键字创建多个分支。仅当前一个条件不为真时<em>elsif</em>关键字才会测试另一个条件。注意我们可以使用多个<em>elsif</em>关键字。</p><br><pre><code>#!/usr/bin/ruby<br><br>print “Enter a number: “<br><br>num = gets.to_i<br><br>if num &lt; 0<br><br>    puts “#{num} is negative”<br>elsif num == 0<br><br>   puts “#{num} is zero”<br>elsif num &gt; 0<br><br>   puts “#{num} is positive”<br>end<br></code></pre><br><p>创建一个数字变量判断它是正数、负数还是0。根据输入值的不同将打印不同的消息。</p><br><h2>case语句</h2><br><p><em>case</em>语句是一个程序控制流语句。它允许一个变量或者表达式的值控制程序的执行流程。相比<em>if</em>、<em>elsif</em>它创建多分支更简单。</p><br><p>我们创建一个变量或者表达式。<em>case</em>关键字用于针对一个列表的值测试这个变量或者表达式的值。这个列表的值是使用<em>when</em>关键字呈现出来。如果值匹配，那么<em>when</em>关键字后面的语句将执行。有一个可选的<em>else</em>语句，如果没有匹配的它将执行。</p><br><pre><code>#!/usr/bin/ruby<br><br>print “Enter top level domain: “<br><br>domain = gets.chomp<br><br>case domain<br>    when “us”<br>        puts “United States”<br>    when “de”<br>        puts “Germany”<br>    when “sk”<br>        puts “Slovakia”<br>    when “hu”<br>        puts “Hungary”<br>    else<br>        puts “Unknown”<br>end<br></code></pre><br><p>这个程序中我们创建了一个<em>domain</em>变量，它的值从命令行读取。使用<em>when</em>语句测试这个变量的值。这有些选项。如果值等于”us”则打印”United States”字符串。</p><br><pre><code>domain = gets.chomp<br></code></pre><br><p>我们使用<em>gets</em>方法获取一个输入值。使用<em>chomp</em>方法去掉换行符。</p><br><p>$ ./domains.rb <br><br>Enter top level domain: hu<br><br>Hungary  </p><br><p>我们输入”hu”，程序返回”Hungary”。</p><br><h2>while、until语句</h2><br><p><em>while</em>语句是一个控制流语句允许代码多次执行。当的条件为真时代码将执行。</p><br><p><em>while</em>关键字执行使用<em>end</em>闭合的代码块语句。每次表达式为真时这些语句将执行。</p><br><pre><code>#!/usr/bin/ruby<br><br>i = 0<br>sum = 0<br><br>while i &lt; 10  do<br>   i = i + 1<br>   sum = sum + i<br>end<br><br>puts “The sum of 0..9 values is #{sum}”<br></code></pre><br><p>这个例子计算了一个范围数的和。</p><br><p>while循环有三部分：初始化、测试和更新。每次执行语句称为周期。</p><br><pre><code>i = 0<br>sum = 0<br></code></pre><br><p>初始化变量<em>i</em>和<em>sum</em>。<em>i</em>用于计数。</p><br><pre><code>while i &lt; 10  do<br>   …<br>end<br></code></pre><br><p><em>while</em>和<em>do</em>之间的表达式是第二阶段，测试。注意<em>do</em>关键字是可选的。，内部的语句将会执行直到表达式的值为假。</p><br><pre><code>i = i + 1<br></code></pre><br><p>这是循环的第三阶段——更新。我们增加计数值。注意不当的处理会导致死循环。</p><br><p>$ ./while.rb <br><br>The sum of 0..9 values is 55  </p><br><p>This is the output of the example. </p><br><hr><br><p>当条件为假时<em>until</em>控制流语句将执行。当条件为真时循环停止。</p><br><pre><code>#!/usr/bin/ruby<br><br>hours_left = 12<br><br>until hours_left == 0<br><br>    if hours_left == 1<br>        puts “There is #{hours_left} hour left”<br>    else<br>        puts “There are #{hours_left} hours left”<br>    end<br><br>    hours_left -= 1<br>end<br></code></pre><br><p>这个例子中创建了一个变量<em>hours_left</em>。我们开始计数，每次循环打印还有几个小时。当变量值等于0时循环停止。</p><br><p>$ ./until.rb <br><br>There are 12 hours left<br><br>There are 11 hours left<br><br>There are 10 hours left<br><br>There are 9 hours left<br><br>There are 8 hours left<br><br>There are 7 hours left<br><br>There are 6 hours left<br><br>There are 5 hours left<br><br>There are 4 hours left<br><br>There are 3 hours left<br><br>There are 2 hours left<br><br>There is 1 hour left  </p><br><p>程序运行的结果。</p><br><h2>for语句</h2><br><p>当循环次数是已知时，我们可以使用<em>for</em>语句。<em>for</em>循环使用<em>in</em>接着一个范围。对这个范围的每个元素都执行代码块的语句。这些语句使用<em>end</em>关键字闭合。<em>do</em>关键字是可选的。</p><br><pre><code>#!/usr/bin/ruby<br><br>for i in 0..9 do<br><br>    puts “#{i}”<br>end<br></code></pre><br><p>这个例子中我们打印了0到9的数。每次循环<em>i</em>变量保存了这个范围的一个数，这个数将在终端上打印。</p><br><p>$ ./forloop.rb <br><br>0<br><br>1<br><br>2<br><br>3<br><br>4<br><br>5<br><br>6<br><br>7<br><br>8<br><br>9  </p><br><p>例子运行结果。</p><br><hr><br><p>要遍历一个数组的元素可以使用数组的<em>length</em>方法。</p><br><pre><code>#!/usr/bin/ruby<br><br>planets = [“Mercury”, “Venus”, “Earth”, “Mars”, “Jupiter”,<br>    “Saturn”, “Uranus”, “Neptune”]<br><br>for i in 0…planets.length<br><br>    puts planets[i]<br>end<br></code></pre><br><p>这个例子中我们创建了一个数组<em>planets</em>，我们遍历这个数组打印这个数组的每个元素。</p><br><pre><code>planets = [“Mercury”, “Venus”, “Earth”, “Mars”, “Jupiter”,<br>    “Saturn”, “Uranus”, “Neptune”]<br></code></pre><br><p><em>planets</em>数组。</p><br><pre><code>for i in 0…planets.length<br></code></pre><br><p><em>length</em>方法返回数组的长度。数组从0开始，最后一个索引是n-1。</p><br><pre><code>puts planets[i]<br></code></pre><br><p>打印数组指定的一个元素。</p><br><p>$ ./planets2.rb <br><br>Mercury<br><br>Venus<br><br>Earth<br><br>Mars<br><br>Jupiter<br><br>Saturn<br><br>Uranus<br><br>Neptune  </p><br><p>程序的运行结果。</p><br><h2>each方法</h2><br><p>在Ruby中我们可以使用<em>each</em>方法遍历数组的每个元素。它接受两个参数。一个元素和一个代码块。元素放在管道之间，它保存了当前循环的数据项。代码块是每次要执行的内容。</p><br><pre><code>#!/usr/bin/ruby<br><br>planets = [“Mercury”, “Venus”, “Earth”, “Mars”, “Jupiter”,<br>    “Saturn”, “Uranus”, “Neptune”]<br><br>planets.each do |planet|<br><br>    puts planet<br>end<br></code></pre><br><p>这个例子我们使用<em>each</em>迭代器遍历<em>planets</em>数组。</p><br><pre><code>planets.each do |planet|<br><br>    puts planet<br>end<br></code></pre><br><p><em>each</em>迭代器是<em>planets</em>数组的一个方法。<em>planet</em>保存了此次迭代的数据项。我们可以使用任何我们想使用的字符。我们可以使用{}代替<em>do</em>和<em>end</em>关键字。</p><br><h2>break、next语句</h2><br><p><em>break</em>语句用于终止<em>while</em>、<em>for</em>或者<em>case</em>的代码块语句。</p><br><pre><code>#!/usr/bin/ruby<br><br>while true<br><br>    r = 1 + rand(30)<br>    print “#{r} “<br><br>    if r == 22<br>        break<br>    end<br>end<br><br>puts<br></code></pre><br><p>我们定义了一个无限循环，使用<em>break</em>语句退出这个循环。我们选择1到30的数，打印它。如果等于22则结束<em>while</em>循环。</p><br><pre><code>while true<br>   …<br>end<br></code></pre><br><p>这是一个无限循环，<em>while</em>的条件总是为真。退出无限循环的唯一方法是使用<em>break</em>。</p><br><pre><code>r = 1 + rand(30)<br>print “#{r} “<br></code></pre><br><p>计算从1到30的随机数，并将其打印。</p><br><pre><code>if r == 22<br>    break<br>end<br></code></pre><br><p>如果数等于22,结束循环。</p><br><p>$ ./break.rb <br><br>20 14 6 26 30 12 2 10 18 29 28 11 30 26 20 22   </p><br><p>可能的输出结果。</p><br><hr><br><p><em>next</em>语句用于跳过此次循环，继续下次循环。它可与<em>for</em>和<em>while</em>联合使用。</p><br><p>接下来的例子我们打印不能被2整除的数一列表。</p><br><pre><code>#!/usr/bin/ruby<br><br>num = 0<br><br>while num &lt; 100<br><br>    num += 1<br><br>    if (num % 2 == 0)<br>        next<br>    end<br><br>    print “#{num} “<br>end<br><br>puts<br></code></pre><br><p>我们使用<em>while</em>循环迭代1到99的数。</p><br><pre><code>if (num % 2 == 0)<br>    next<br>end<br></code></pre><br><p>如果这个数可以被2整除，<em>next</em>语句将执行，循环的其余将跳过。</p><br><p>$ ./next.rb <br><br>1 3 5 7 9 11 13 15 17 19 21 23 25 27 29 31 33 35 37 39 <br><br>41 43 45 47 49 51 53 55 57 59 61 63 65 67 69 71 73 75 77 <br><br>79 81 83 85 87 89 91 93 95 97 99   </p><br><p>程序的输出结果。</p><br><h2>redo语句</h2><br><p><em>redo</em>语句重新开始循环而不检查循环的条件式。下面的例子有点复杂，它展示了<em>redo</em>语句和其它的一些特性。</p><br><pre><code>#!/usr/bin/ruby<br><br>options = [“rock”, “scissors”, “paper”]<br><br>while true<br><br>    print &lt;&lt;TEXT<br>1 - rock<br>2 - scissors<br>3 - paper<br>9 - end game<br>TEXT<br><br>    val = gets.to_i<br><br>    r = rand(3) + 1<br><br>    if val == 9<br>        puts “End”<br>        exit<br>    end<br><br>    if ![1, 2, 3, 9].include?(val)<br>        puts “Invalid option”<br>        redo<br>    end<br><br>    computer = options[r-1]<br>    human = options[val-1]<br><br>    puts “I have #{computer}, you have #{human}”<br><br>    if val == r<br>        puts “Tie, next throw”<br>        redo<br>    end<br><br><br>    if val == 1 and r == 2<br>        puts “Rock blunts scissors, you win”<br><br>    elsif val == 2 and r == 1<br>        puts “Rock blunts scissors, you loose”<br><br>    elsif val == 2 and r == 3<br>        puts “Scissors cut paper, you win”<br><br>    elsif val == 3 and r == 2<br>        puts “Scissors cut paper, you loose”<br><br>    elsif val == 3 and r == 1<br>        puts “Paper covers rock, you win”<br><br>    elsif val == 1 and r == 3<br>        puts “Paper covers rock, you loose”<br><br>    end<br>end<br></code></pre><br><p>这是一个简单的Rock-paper-scissors游戏。这个例子中我们用到了<em>redo</em>语句、条件式、随机数、数组和输入。</p><br><pre><code>options = [“rock”, “scissors”, “paper”]<br></code></pre><br><p>定义了游戏可能用到的选项数组。这三个词在打印消息时会用到。</p><br><pre><code>    print &lt;&lt;TEXT<br>1 - rock<br>2 - scissors<br>3 - paper<br>9 - end game<br>TEXT<br></code></pre><br><p>使用定界符在终端上打印一个菜单。菜单在每次游戏循环时都打印。</p><br><pre><code>val = gets.to_i<br><br>r = rand(3) + 1<br></code></pre><br><p>这几行代码从终端输入一个值，然后选择一个1、2、3的随机数。</p><br><pre><code>if val == 9<br>    puts “End”<br>    exit<br>end<br></code></pre><br><p>如果输入为9，打印’End’并退出程序。</p><br><pre><code>if ![1, 2, 3, 9].include?(val)<br>    puts “Invalid option”<br>    redo<br>end<br></code></pre><br><p>如果用户选择了一个不是菜单的值，我们提示无效选项并重新循环。</p><br><pre><code>computer = options[r-1]<br>human = options[val-1]<br><br>puts “I have #{computer}, you have #{human}”<br></code></pre><br><p>将数字转化为字符串，并同时打印用户的选择和计算机的选择。</p><br><pre><code>if val == r<br>    puts “Tie, next throw”<br>    redo<br>end<br></code></pre><br><p>如果选择相同则是平局，开始新的游戏循环。</p><br><pre><code>if val == 1 and r == 2<br>    puts “Rock blunts scissors, you win”<br><br>elsif val == 2 and r == 1<br>    puts “Rock blunts scissors, you loose”<br>…<br></code></pre><br><p>使用多个<em>if</em>、<em>elsif</em>分支，比较用户和计算机的选择以决定谁是赢家。</p><br><p>$ ./redo.rb <br><br>1 - rock<br><br>2 - scissors<br><br>3 - paper<br><br>9 - end game<br><br>3<br><br>I have paper, you have paper<br><br>Tie, next throw<br><br>1 - rock<br><br>2 - scissors<br><br>3 - paper<br><br>9 - end game<br><br>2<br><br>I have rock, you have scissors<br><br>Rock blunts scissors, you loose<br><br>1 - rock<br><br>2 - scissors<br><br>3 - paper<br><br>9 - end game<br><br>1<br><br>I have scissors, you have rock<br><br>Rock blunts scissors, you win<br><br>1 - rock<br><br>2 - scissors<br><br>3 - paper<br><br>9 - end game<br><br>9<br><br>End  </p><br><p>程序输出结果。</p><br><p>这部分的Ruby教程我们谈论了结构控制流。</p><br><hr><br><p>原文地址： <a href="http://zetcode.com/lang/rubytutorial/flowcontrol/" target="_blank" rel="external">http://zetcode.com/lang/rubytutorial/flowcontrol/</a><br><br>翻译：龙昌  admin@longchangjin.cn<br><br>完整教程：<a href="https://github.com/wusuopu/Ruby-tutorial" target="_blank" rel="external">https://github.com/wusuopu/Ruby-tutorial</a> </p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://www.xefan.com/archives/83929.html" data-id="cktcclrvp00ilyp4kd6ig1wl8" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Ruby/">Ruby</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/翻译/">翻译</a></li></ul>

    </footer>
  </div>
  
</article>



  


  <nav id="page-nav">
    <a class="extend prev" rel="prev" href="/page/10/">&laquo;Prev</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/9/">9</a><a class="page-number" href="/page/10/">10</a><span class="page-number current">11</span><a class="page-number" href="/page/12/">12</a><a class="page-number" href="/page/13/">13</a><span class="space">&hellip;</span><a class="page-number" href="/page/31/">31</a><a class="extend next" rel="next" href="/page/12/">Next&raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Categories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Linux栏目/">Linux栏目</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Python栏目/">Python栏目</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Ruby栏目/">Ruby栏目</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/Ruby栏目/Web开发/">Web开发</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/Web开发/">Web开发</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/Web开发/Python栏目/">Python栏目</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/前端相关/">前端相关</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/嵌入式栏目/">嵌入式栏目</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/开源软件/">开源软件</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/教程/">教程</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/数据库/">数据库</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/数据结构和算法/">数据结构和算法</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/编程开发/">编程开发</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/网络日志/">网络日志</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/资源分享/">资源分享</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/ARM/">ARM</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Android/">Android</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Arch/">Arch</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/C/">C</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Django/">Django</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Docker/">Docker</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Dreamweaver/">Dreamweaver</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Fedora/">Fedora</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Flash/">Flash</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/GObject/">GObject</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Gentoo/">Gentoo</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Hash/">Hash</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Linux/">Linux</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Mac/">Mac</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/PS/">PS</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Qt/">Qt</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Raspberry-pi/">Raspberry pi</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Redis/">Redis</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Ruby/">Ruby</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Scrapy/">Scrapy</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/TQ2440/">TQ2440</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/USB/">USB</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/VirtualBox/">VirtualBox</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Web开发/">Web开发</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/WordPress/">WordPress</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Xcode/">Xcode</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/access/">access</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/adobe/">adobe</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/ajax/">ajax</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/angular/">angular</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/apache/">apache</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/asp/">asp</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/css/">css</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/docker/">docker</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/firefox/">firefox</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/ftp/">ftp</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/gcc/">gcc</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/git/">git</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/grub/">grub</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/gtk/">gtk</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/gulp/">gulp</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/ibus/">ibus</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/js/">js</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/k8s/">k8s</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/mongodb/">mongodb</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/mysql/">mysql</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/nginx/">nginx</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/node/">node</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/php/">php</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/pygame/">pygame</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/python/">python</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/react/">react</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/redis/">redis</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/ruby/">ruby</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/shell/">shell</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/typescript/">typescript</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/ubuntu/">ubuntu</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/vim/">vim</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/vmware/">vmware</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/w3m/">w3m</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/windows/">windows</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/xml/">xml</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/免费/">免费</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/内核/">内核</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/匹配算法/">匹配算法</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/单片机/">单片机</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/嵌入式/">嵌入式</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/开源软件/">开源软件</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/排序算法/">排序算法</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/文件空间/">文件空间</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/无线网/">无线网</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/树莓派/">树莓派</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/正则式/">正则式</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/注册机/">注册机</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/游戏/">游戏</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/电脑技巧/">电脑技巧</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/空间/">空间</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/算法/">算法</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/红旗/">红旗</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/经典语录/">经典语录</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/网络日志/">网络日志</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/翻译/">翻译</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/视频教程/">视频教程</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/资源分享/">资源分享</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/转载/">转载</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/随笔/">随笔</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/ARM/" style="font-size: 13.68px;">ARM</a> <a href="/tags/Android/" style="font-size: 10.53px;">Android</a> <a href="/tags/Arch/" style="font-size: 13.16px;">Arch</a> <a href="/tags/C/" style="font-size: 15.79px;">C</a> <a href="/tags/Django/" style="font-size: 11.05px;">Django</a> <a href="/tags/Docker/" style="font-size: 11.05px;">Docker</a> <a href="/tags/Dreamweaver/" style="font-size: 10px;">Dreamweaver</a> <a href="/tags/Fedora/" style="font-size: 10.53px;">Fedora</a> <a href="/tags/Flash/" style="font-size: 10px;">Flash</a> <a href="/tags/GObject/" style="font-size: 12.63px;">GObject</a> <a href="/tags/Gentoo/" style="font-size: 10.53px;">Gentoo</a> <a href="/tags/Hash/" style="font-size: 10px;">Hash</a> <a href="/tags/Linux/" style="font-size: 20px;">Linux</a> <a href="/tags/Mac/" style="font-size: 10.53px;">Mac</a> <a href="/tags/PS/" style="font-size: 12.63px;">PS</a> <a href="/tags/Qt/" style="font-size: 10.53px;">Qt</a> <a href="/tags/Raspberry-pi/" style="font-size: 10px;">Raspberry pi</a> <a href="/tags/Redis/" style="font-size: 10px;">Redis</a> <a href="/tags/Ruby/" style="font-size: 18.95px;">Ruby</a> <a href="/tags/Scrapy/" style="font-size: 11.05px;">Scrapy</a> <a href="/tags/TQ2440/" style="font-size: 12.11px;">TQ2440</a> <a href="/tags/USB/" style="font-size: 11.05px;">USB</a> <a href="/tags/VirtualBox/" style="font-size: 11.05px;">VirtualBox</a> <a href="/tags/Web开发/" style="font-size: 16.84px;">Web开发</a> <a href="/tags/WordPress/" style="font-size: 10px;">WordPress</a> <a href="/tags/Xcode/" style="font-size: 10px;">Xcode</a> <a href="/tags/access/" style="font-size: 12.63px;">access</a> <a href="/tags/adobe/" style="font-size: 10px;">adobe</a> <a href="/tags/ajax/" style="font-size: 11.05px;">ajax</a> <a href="/tags/angular/" style="font-size: 13.16px;">angular</a> <a href="/tags/apache/" style="font-size: 10px;">apache</a> <a href="/tags/asp/" style="font-size: 13.16px;">asp</a> <a href="/tags/css/" style="font-size: 10.53px;">css</a> <a href="/tags/docker/" style="font-size: 10px;">docker</a> <a href="/tags/firefox/" style="font-size: 11.05px;">firefox</a> <a href="/tags/ftp/" style="font-size: 10px;">ftp</a> <a href="/tags/gcc/" style="font-size: 12.63px;">gcc</a> <a href="/tags/git/" style="font-size: 13.16px;">git</a> <a href="/tags/grub/" style="font-size: 10px;">grub</a> <a href="/tags/gtk/" style="font-size: 17.89px;">gtk</a> <a href="/tags/gulp/" style="font-size: 10px;">gulp</a> <a href="/tags/ibus/" style="font-size: 10px;">ibus</a> <a href="/tags/js/" style="font-size: 16.32px;">js</a> <a href="/tags/k8s/" style="font-size: 10.53px;">k8s</a> <a href="/tags/mongodb/" style="font-size: 15.26px;">mongodb</a> <a href="/tags/mysql/" style="font-size: 11.58px;">mysql</a> <a href="/tags/nginx/" style="font-size: 10px;">nginx</a> <a href="/tags/node/" style="font-size: 10.53px;">node</a> <a href="/tags/php/" style="font-size: 14.74px;">php</a> <a href="/tags/pygame/" style="font-size: 15.26px;">pygame</a> <a href="/tags/python/" style="font-size: 19.47px;">python</a> <a href="/tags/react/" style="font-size: 12.63px;">react</a> <a href="/tags/redis/" style="font-size: 10px;">redis</a> <a href="/tags/ruby/" style="font-size: 10px;">ruby</a> <a href="/tags/shell/" style="font-size: 10px;">shell</a> <a href="/tags/typescript/" style="font-size: 10px;">typescript</a> <a href="/tags/ubuntu/" style="font-size: 13.16px;">ubuntu</a> <a href="/tags/vim/" style="font-size: 18.42px;">vim</a> <a href="/tags/vmware/" style="font-size: 10px;">vmware</a> <a href="/tags/w3m/" style="font-size: 10px;">w3m</a> <a href="/tags/windows/" style="font-size: 13.16px;">windows</a> <a href="/tags/xml/" style="font-size: 10px;">xml</a> <a href="/tags/免费/" style="font-size: 10px;">免费</a> <a href="/tags/内核/" style="font-size: 10px;">内核</a> <a href="/tags/匹配算法/" style="font-size: 12.63px;">匹配算法</a> <a href="/tags/单片机/" style="font-size: 10.53px;">单片机</a> <a href="/tags/嵌入式/" style="font-size: 10px;">嵌入式</a> <a href="/tags/开源软件/" style="font-size: 14.21px;">开源软件</a> <a href="/tags/排序算法/" style="font-size: 14.21px;">排序算法</a> <a href="/tags/文件空间/" style="font-size: 10px;">文件空间</a> <a href="/tags/无线网/" style="font-size: 10px;">无线网</a> <a href="/tags/树莓派/" style="font-size: 10px;">树莓派</a> <a href="/tags/正则式/" style="font-size: 10px;">正则式</a> <a href="/tags/注册机/" style="font-size: 10.53px;">注册机</a> <a href="/tags/游戏/" style="font-size: 14.74px;">游戏</a> <a href="/tags/电脑技巧/" style="font-size: 14.21px;">电脑技巧</a> <a href="/tags/空间/" style="font-size: 10px;">空间</a> <a href="/tags/算法/" style="font-size: 17.37px;">算法</a> <a href="/tags/红旗/" style="font-size: 10px;">红旗</a> <a href="/tags/经典语录/" style="font-size: 10px;">经典语录</a> <a href="/tags/网络日志/" style="font-size: 13.16px;">网络日志</a> <a href="/tags/翻译/" style="font-size: 18.42px;">翻译</a> <a href="/tags/视频教程/" style="font-size: 14.74px;">视频教程</a> <a href="/tags/资源分享/" style="font-size: 15.26px;">资源分享</a> <a href="/tags/转载/" style="font-size: 10.53px;">转载</a> <a href="/tags/随笔/" style="font-size: 10px;">随笔</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/09/">September 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/04/">April 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/11/">November 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/05/">May 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/04/">April 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/02/">February 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/11/">November 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/05/">May 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/03/">March 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/11/">November 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/06/">June 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/05/">May 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/01/">January 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/11/">November 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/08/">August 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/07/">July 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/06/">June 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/04/">April 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/03/">March 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/01/">January 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/12/">December 2015</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/08/">August 2015</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/05/">May 2015</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/04/">April 2015</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/02/">February 2015</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/01/">January 2015</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2014/12/">December 2014</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2014/11/">November 2014</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2014/10/">October 2014</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2014/09/">September 2014</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2014/08/">August 2014</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2014/07/">July 2014</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2014/06/">June 2014</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2014/05/">May 2014</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2014/04/">April 2014</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2014/03/">March 2014</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2014/01/">January 2014</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2013/12/">December 2013</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2013/11/">November 2013</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2013/10/">October 2013</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2013/08/">August 2013</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2013/07/">July 2013</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2013/06/">June 2013</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2013/05/">May 2013</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2013/04/">April 2013</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2013/01/">January 2013</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2012/10/">October 2012</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2012/09/">September 2012</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2012/08/">August 2012</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2012/07/">July 2012</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2012/05/">May 2012</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2012/04/">April 2012</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2012/03/">March 2012</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2012/02/">February 2012</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2011/12/">December 2011</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2011/11/">November 2011</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2011/10/">October 2011</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2011/09/">September 2011</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2011/08/">August 2011</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2011/07/">July 2011</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2011/05/">May 2011</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2011/04/">April 2011</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2011/03/">March 2011</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2011/02/">February 2011</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2011/01/">January 2011</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2010/12/">December 2010</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2010/11/">November 2010</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2010/10/">October 2010</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2010/09/">September 2010</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2010/08/">August 2010</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2010/07/">July 2010</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2010/06/">June 2010</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2010/05/">May 2010</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2010/04/">April 2010</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2010/03/">March 2010</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2009/12/">December 2009</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2009/11/">November 2009</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2009/10/">October 2009</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2009/09/">September 2009</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2009/08/">August 2009</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2009/07/">July 2009</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2009/05/">May 2009</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2008/12/">December 2008</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2008/07/">July 2008</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/archives/84183.html">记录在docker中运行whenever遇到的问题</a>
          </li>
        
          <li>
            <a href="/archives/84182.html">Gitlab Runner 配置</a>
          </li>
        
          <li>
            <a href="/archives/84181.html">Github Runner 配置</a>
          </li>
        
          <li>
            <a href="/archives/84180.html">使用python编写帝国时代2修改器</a>
          </li>
        
          <li>
            <a href="/archives/84179.html">使用Vagrant和Docker搭建Kubernetes集群</a>
          </li>
        
      </ul>
    </div>
  </div>

  
    <div class="widget-wrap">
  <h3 class="widget-title">Link</h3>
    <div class="widget">
      <ul id="category-list">
        <li><a target="_blank" title="我的Github" href="https://github.com/wusuopu">@Github</a></li>
        <li><a target="_blank" title="我的微博" href="http://www.weibo.com/u/1768691343">@Weibo</a></li>
        <li><a target="_blank" title="我的Twitter" href="https://twitter.com/longchangjin">@Twitter</a></li>
        <li><a target="_blank" title="我的豆瓣" href="http://www.douban.com/people/lchj/">@Douban</a></li>

        <li><a target="_blank" title="" href="http://pythoner.net/">python开发者社区</a></li>
        <li><a target="_blank" title="" href="http://simple-is-better.com/">python.cn(news, jobs)</a></li>
        <li><a target="_blank" title="" href="http://gtk.awaysoft.com/">GTK+ 中文社区</a></li>
        <li><a target="_blank" title="小智LOGO - LOGO在线制作神器 - 3分钟完成公司LOGO设计" href="http://xzlogo.com/">小智LOGO</a></li>
      </ul>
    </div>
</div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2021 龍昌<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
<div style="display:none;"><script src="http://s94.cnzz.com/stat.php?id=1259846&web_id=1259846&show=pic" language="JavaScript"></script></div>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
    <a href="/about" class="mobile-nav-link">About</a>
  
    <a href="/gbook" class="mobile-nav-link">留言板</a>
  
</nav>
    

<script src="/js/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>

  </div>
</body>
</html>