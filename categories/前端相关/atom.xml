<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: 前端相关 | 龍昌博客]]></title>
  <link href="http://www.xefan.com/categories/前端相关/atom.xml" rel="self"/>
  <link href="http://www.xefan.com/"/>
  <updated>2016-08-20T17:38:11+08:00</updated>
  <id>http://www.xefan.com/</id>
  <author>
    <name><![CDATA[龍昌]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[gulp+browserSync配置]]></title>
    <link href="http://www.xefan.com/archives/84160.html"/>
    <updated>2016-03-26T14:32:56+08:00</updated>
    <id>http://www.xefan.com/archives/84160-gulp+browserSync配置</id>
    <content type="html"><![CDATA[<p>Browsersync  是一个前端调试的利器，它能够让你在页面文件改动之后自动刷新浏览器，从而方便了前端的调试工作。</p>

<p>本文就是对于 Browsersync + Gulp 的配置作个简单的笔记。</p>

<ol>
<li>首先安装 Browsersync 与 Gulp:</li>
</ol>


<pre><code>$ npm install browser-sync gulp --save-dev
</code></pre>

<ol>
<li>在 <code>gulpfile.js</code> 中创建新任务：</li>
</ol>


<pre><code>var gulp = require('gulp');
var browserSync = require('browser-sync').create();

var config = {
  baseDir: 'src',
  watchFiles: [ 'src/**/*.html', 'src/assets/css/*.css', 'src/assets/js/*.js' ]
}

gulp.task('serve', function() {
  browserSync.init({
    files: config.watchFiles,
    server: {
      baseDir: config.baseDir
    }
  });
})
</code></pre>

<p>这里表示以 <code>src</code> 目录作为根目录启动 HTTP 服务，并监听 <code>src</code> 目录下的所有 <code>html</code>、<code>css</code> 以及 <code>js</code> 类型的文件，当这些文件有改动时 Browsersync 会自动刷新浏览器页面。</p>

<p>如果想配合使用 SASS 之类的，可以参考： <a href="https://www.browsersync.io/docs/gulp/">https://www.browsersync.io/docs/gulp/</a></p>

<p>同时为了避免之后每次都要重新配置一遍，于是我自己写了个简单的 <code>yo</code> 生成器： <a href="https://github.com/wusuopu/my-yeoman-generator">https://github.com/wusuopu/my-yeoman-generator</a></p>

<p>由于这只是我自己 generator，并没有发布到 npm 上，因此只能手动进行安装。各位有兴趣的可以试试。使用方法：</p>

<ol>
<li><p>安装 yo 和 bower： <code>$ npm install -g yo bower</code></p></li>
<li><p>安装 generator:</p></li>
</ol>


<pre><code>$ git clone https://github.com/wusuopu/my-yeoman-generator generator-wusuopu
$ cd generator-wusuopu
$ npm link
</code></pre>

<ol>
<li>生成项目：</li>
</ol>


<pre><code>$ mkdir webpage
$ cd webpage
$ yo wusuopu:bootstrap3
</code></pre>

<p>这里 bootstrap3 generator 包含了 bootstrap3、font-awesome、jquery 这些常用的前端库，省得每次都需要重新下载一遍。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Javascript使用async进行流程控制]]></title>
    <link href="http://www.xefan.com/archives/84157.html"/>
    <updated>2015-12-13T21:39:26+08:00</updated>
    <id>http://www.xefan.com/archives/84157-javascript使用async进行流程控制</id>
    <content type="html"><![CDATA[<h2>前言</h2>

<p>突然发现博客好久没有更新了，主要是因为最近这几个月比较忙。之前由 Python 转向了 Ruby，现在又由后端转向了前端。
这几个月接触的内容略有点多，信息量有点大，主要都是 js 相关的。准备之后抽时间将这些知识整理整理，沉淀沉淀。</p>

<h2>Async</h2>

<p>由于 js 是异步的，之前在使用 loopback 进行 server 端开发时，很容易就出现了比较深层次的回调嵌套。
<a href="https://github.com/caolan/async">async.js</a>是 js 的一个工具，可以用来方便的控制 js 中的异步流程的，类似的库还有 Promise、RxJS 等。
最初它是设计用于 nodejs 的，不过在浏览器端也可以使用。</p>

<h3>安装</h3>

<p>安装方法很简单，直接使用 npm 即可： <code>npm install async</code> 。</p>

<h3>使用方法</h3>

<p>首先是加载 async 库，在 server 端使用 <code>var async = require('async');</code>，
在浏览器端直接引用即可： <code>&lt;script type="text/javascript" src="async.js"&gt;&lt;/script&gt;</code>。</p>

<p>async 提供一些集合操作方法和流程控制方法，我比较常用的是：<code>each</code>、<code>map</code>、<code>series</code>、<code>waterfall</code> 这些方法。
其中 <code>each</code>、<code>map</code> 方法与 <code>lodash</code> 的类似，可以用来遍历某个集合并执行一些操作。</p>

<p><code>each</code> 方法定义如下：</p>

<pre><code class="javascript">async.each(collection, iterator, [callback])
</code></pre>

<p>该方法会对 <code>collection</code> 每个元素都调用 <code>iterator</code> 操作， <code>iterator</code> 函数原型为： <code>iterator(item, callback)</code>。
当 <code>collection</code> 中的所有元素遍历完成或者执行 <code>iterator</code> 时发生错误就会调用 <code>callback</code> 回调，原型为： <code>callback(err)</code>。</p>

<p><code>each</code> 方法只是对每个元素进行操作，如果还需要获取操作的结果，那么可以使用 <code>map</code> 方法。定义如下：</p>

<pre><code class="javascript">async.map(collection, iterator, [callback])
</code></pre>

<p><code>map</code> 与 <code>each</code> 类似，只是 <code>callback</code> 定义为： <code>callback(err, results)</code>。
<code>results</code> 为 <code>iterator</code> 操作的结果集合。</p>

<p>如下是一个例子，一次读取多个文件的内容：</p>

<pre><code class="javascript">async.map(['file1','file2','file3'], fs.readFile, function(err, results){
    // doSomething();
});
</code></pre>

<p><code>series</code> 与 <code>map</code> 类似，不过 <code>series</code> 是遍历一个方法合集并挨个执行，然后返回结果：</p>

<pre><code class="javascript">async.series(tasks, [callback])
</code></pre>

<p>如：</p>

<pre><code class="javascript">async.series([
  function fun1(callback){
    callback(null, 'one');
  },
  function fun2(callback){
    callback(null, 'two');
  }
],
function(err, results){
  // doSomething();
});
</code></pre>

<p>注意，以上这些方法各个任务的完成时间顺序是不确定的。如果有一些操作是需要按照先后顺序执行，可以使用 <code>waterfall</code>。</p>

<pre><code class="javascript">async.waterfall(tasks, [callback])
</code></pre>

<p>例如在 <code>loopback</code> 的一个 <code>controller</code> 中，提供修改用户密码的功能。原始写法如下：</p>

<pre><code class="javascript">router.post('/user/password', function(req, res) {
  User.findById(req.body.id, function(err, user){
    if (err) doSomething();
    user.password = req.body.password;
    user.save(function(err){
      if (err) doSomething();
      res.status(200).end();
    });
  });
});
</code></pre>

<p>上面的例子功能还比较简单，回调层级不是很深。不过如果使用 <code>waterfall</code> 来控制就更为简单：</p>

<pre><code class="javascript">router.post('/user/password', function(req, res) {
  async.waterfall([
    function(callback){
      User.findById(req.body.id, callback);
    },
    function(user, callback){
      user.password = req.body.password;
      user.save(callback);
    }
  ], function(err){
    if (err) doSomething();
    res.status(200).end();
  });
});
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[AngularJS学习笔记7——与rails整合]]></title>
    <link href="http://www.xefan.com/archives/84156.html"/>
    <updated>2015-08-27T13:01:33+08:00</updated>
    <id>http://www.xefan.com/archives/84156-AngularJS学习笔记7——与rails整合</id>
    <content type="html"><![CDATA[<p>要在 rails 中使用 angular 直接在页面中引入进行即可，这个倒是不难。
只是在开发过程中突然发现了一个问题，就是 angular 的模板应该如何组织呢。
如果全写成内联模板这个不太好维护，如果是写成单个文件放在 public 目录下也不太妥。
不过好在这个问题已经有人解决了，有 angular-rails-templates 这么一个库：<a href="https://github.com/pitr/angular-rails-templates">https://github.com/pitr/angular-rails-templates</a></p>

<p>首先安装该库：<code>gem 'angular-rails-templates'</code></p>

<p>然后创建目录 <code>app/assets/javascripts/templates</code>，
并在 <code>app/assets/javascripts/application.js</code> 中加载对应的文件：</p>

<pre><code>//= require angular-rails-templates
//= require_tree ./templates
</code></pre>

<p>该目录下的模板文件命名与 rails 的视图命名类似，如： <code>foo.html</code>，<code>foo.html.erb</code>，<code>foo.html.haml</code>,<code>foo.html.slim</code>。</p>

<p>可以参考我的一个例子： <a href="https://github.com/wusuopu/rails-billing">https://github.com/wusuopu/rails-billing</a></p>

<p>这里我是使用 bower 进行安装 angular 的库，首先安装 <code>gem 'bower-rails'</code> 。</p>

<p>然后初始化 bower_rails： <code>rails g bower_rails:initialize</code><br/>
编辑 <code>Bowerfile</code>，添加所需要的依赖包：</p>

<pre><code>asset 'angular'
asset 'angular-route'
asset 'angular-resource'
asset 'angular-mocks'
asset 'angular-flash'
asset 'angular-loading-bar'
asset 'angular-flash-messages'
asset 'angular-translate'
asset 'angular-bootstrap'
asset 'bootstrap-sass-official'
asset 'components-font-awesome'
</code></pre>

<p>再执行命令： <code>rake bower:install</code> 进行安装。</p>

<p>接着编辑 <code>config/initializers/assets.rb</code> 添加配置： <code>Rails.application.config.assets.paths &lt;&lt; Rails.root.join("vendor","assets","bower_components")</code></p>

<p>最后加载依赖文件 <code>app/assets/javascripts/application.js</code>：</p>

<pre><code>//= require angular/angular
//= require angular-route/angular-route
//= require angular-resource/angular-resource
//= require angular-flash-messages/angular-flash
//= require angular-loading-bar/build/loading-bar
//= require angular-translate/angular-translate
//= require angular-bootstrap/ui-bootstrap-tpls
//= require angular-rails-templates
//= require_tree ./templates
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[AngularJS学习笔记6——与jQuery、Bootstrap结合]]></title>
    <link href="http://www.xefan.com/archives/84155.html"/>
    <updated>2015-08-24T10:25:28+08:00</updated>
    <id>http://www.xefan.com/archives/84155-AngularJS学习笔记6——与jQuery、Bootstrap结合</id>
    <content type="html"><![CDATA[<h2>jQuery</h2>

<p>如果想要在 angular 内部调用 jQuery 的函数（如 jQuery 的 ajax 功能）比较简单，直接调用 <code>$.ajax</code> 即可。<br/>
但是如果想要在 angular 外部调用其函数就稍微麻烦一点，毕竟这也与 angular 的设计理念不符。</p>

<p>&#8220;`</p>

<div ng-controller="PageController">
  &#8230;
</div>




<p><script>
  var appModule = angular.module(&lsquo;myApp&rsquo;, []);
  appModule.controller(&lsquo;PageController&rsquo;, [&lsquo;$scope&rsquo;, &lsquo;$http&rsquo;, function($scope, $http){
      &hellip;
  }]);
```</p>

<p>例如上个这段代码，如果想要从外部访问 <code>PageController</code> 中的某些内容。则可以先获取 <code>PageController</code> 的上下文对象($scope)：<code>angular.element($('[ng-controller="PageController"]')).scope();</code><br/>
在外部修改了 <code>scope</code> 的某些值时会发现对应的视图并没有更新，这时还需要调用 <code>scope</code> 的 <code>$digest</code> 方法进行同步，或者直接调用 <code>$apply</code> 方法进行操作。</p>

<h2>Bootstrap</h2>

<p>之前使用 angularjs 时遇到了 Bootstrap 的控件不能正常使用了，如 dropdown 组件点击了没有效果。<br/>
经过分析发现是 angularjs 将 Bootstrap 的组件的事件给截获了。</p>

<p>好在有 angular-bootstrap 这么一个组件可以将它们整合在一起。</p>

<p><a href="http://angular-ui.github.io/bootstrap/">http://angular-ui.github.io/bootstrap/</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Riot.js之初体验]]></title>
    <link href="http://www.xefan.com/archives/84152.html"/>
    <updated>2015-08-21T09:55:14+08:00</updated>
    <id>http://www.xefan.com/archives/84152-Riot.js之初体验</id>
    <content type="html"><![CDATA[<p>Riot(<a href="http://riotjs.com/">http://riotjs.com/</a>)按照官方的介绍，它是一个类似于 React 的微型框架。
压缩之后的文件只有差不多 15K 的大小，相比其他基本上都是上百K大小的框架来说确实是很微型的。</p>

<p>同时它的官方还给出了与 React 和 Polymer 的对比，各位感兴趣可以看看： <a href="http://riotjs.com/compare/">http://riotjs.com/compare/</a></p>

<p>下面通过一个例子来体验一下。</p>

<p>先下载 Riot 库文件： <a href="https://raw.githubusercontent.com/riot/riot/master/riot+compiler.min.js  ">https://raw.githubusercontent.com/riot/riot/master/riot+compiler.min.js  </a>
然后新建一个文件 <code>index.html</code>，内容如下：</p>

<pre><code class="html">&lt;!DOCTYPE html&gt;
&lt;html&gt;
  &lt;head&gt;
    &lt;meta charset="utf-8"&gt;
    &lt;meta name="viewport" content="width=device-width"&gt;
    &lt;title&gt;Tabs exampe&lt;/title&gt;
    &lt;style type="text/css" media="screen"&gt;
      .tabContent__item{
        display:none;
      }
      .tabContent__item.is-active{
        display:block;
      }
    &lt;/style&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;riot-tabs&gt;&lt;/riot-tabs&gt;

    &lt;script src="tabs.tag" type="riot/tag"&gt;&lt;/script&gt;
    &lt;script src="riot+compiler.min.js"&gt;&lt;/script&gt;
    &lt;script type="text/javascript" charset="utf-8"&gt;
      riot.mount('riot-tabs');
    &lt;/script&gt;
  &lt;/body&gt;
&lt;/html&gt;
</code></pre>

<p>接着再创建文件 <code>tabs.tag</code>：</p>

<pre><code>&lt;riot-tabs&gt;
  &lt;h2&gt;Tabs&lt;/h2&gt;
  &lt;ul&gt;
    &lt;li each={ tab, i in tabs } class="tabItem { is-active: parent.isActiveTab(tab.ref) }" onclick={ parent.toggleTab }&gt;{tab.title}&lt;/li&gt;
  &lt;/ul&gt;
  &lt;div class="tabContent"&gt;
    &lt;div each={ tab, i in tabs } class="tabContent__item { is-active: parent.isActiveTab(tab.ref) }"&gt;{tab.content}&lt;/div&gt;
  &lt;/div&gt;

  this.tabs = [
    { title: 'Tab 1', ref: 'tab1', content: "(1) Lorem ipsum dolor" },
    { title: 'Tab 2', ref: 'tab2', content: "(2) Lorem ipsum dolor" },
    { title: 'Tab 3', ref: 'tab3', content: "(3) Lorem ipsum dolor" }
  ]

  this.activeTab = 'tab1'

  isActiveTab(tab) {
    return this.activeTab === tab
  }

  toggleTab(e) {
    this.activeTab = e.item.tab.ref
    return true
  }
&lt;/riot-tabs&gt;
</code></pre>

<p>这个是 javascript 与 html 的混合。当然还可以使用纯 js 的写法，将 <code>tabs.tag</code> 改为 <code>tabs.js</code>：</p>

<pre><code>riot.tag('riot-tabs', '&lt;h2&gt;Tabs&lt;/h2&gt; &lt;ul&gt; &lt;li each="{ tab, i in tabs }" class="tabItem { is-active: parent.isActiveTab(tab.ref) }" onclick="{ parent.toggleTab }"&gt;{tab.title}&lt;/li&gt; &lt;/ul&gt; &lt;div class="tabContent"&gt; &lt;div each="{ tab, i in tabs }" class="tabContent__item { is-active: parent.isActiveTab(tab.ref) }"&gt;{tab.content}&lt;/div&gt; &lt;/div&gt;', function(opts) {

  this.tabs = [
    { title: 'Tab 1', ref: 'tab1', content: "(1) Lorem ipsum dolor" },
    { title: 'Tab 2', ref: 'tab2', content: "(2) Lorem ipsum dolor" },
    { title: 'Tab 3', ref: 'tab3', content: "(3) Lorem ipsum dolor" }
  ];

  this.activeTab = 'tab1';

  this.isActiveTab = function(tab) {
    return this.activeTab === tab;
  }.bind(this);

  this.toggleTab = function(e) {
    this.activeTab = e.item.tab.ref;
    return true;
  }.bind(this);

});
</code></pre>

<p>同时将 <code>index.html</code> 中的 <code>&lt;script src="tabs.tag" type="riot/tag"&gt;&lt;/script&gt;</code> 修改为 <code>&lt;script src="tabs.js" type="riot/tag"&gt;&lt;/script&gt;</code> 。</p>

<p>好了，现在打开浏览器看下效果吧。</p>

<p>体验了一下，感觉它比 angular 之类的框架的学习成本要低。</p>
]]></content>
  </entry>
  
</feed>
