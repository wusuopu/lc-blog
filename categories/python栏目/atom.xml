<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Python栏目 | 龍昌博客]]></title>
  <link href="http://www.xefan.com/categories/python栏目/atom.xml" rel="self"/>
  <link href="http://www.xefan.com/"/>
  <updated>2016-01-03T17:21:43+08:00</updated>
  <id>http://www.xefan.com/</id>
  <author>
    <name><![CDATA[龍昌]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[使用gunicorn部署Django]]></title>
    <link href="http://www.xefan.com/archives/84138.html"/>
    <updated>2014-12-13T21:03:27+08:00</updated>
    <id>http://www.xefan.com/archives/84138-使用gunicorn部署Django</id>
    <content type="html"><![CDATA[<p><a href="http://gunicorn.org/">Gunicorn</a> 是 Python的 一个 WSGI HTTP服务器，根据它的介绍说是它来自于 Ruby 的 Unicorn。可以方便的部署 Python 的 Web 程序，而且本身支持多种 Python 的框架，如 Django、Paster等。</p>

<p>通过介绍来看貌似很不错的样子，只可惜我现在不玩 Python 了，于是就简单体验一下。</p>

<h2>简单应用</h2>

<p>首先是安装，这个可以直接使用 <code>pip</code> 来完成：</p>

<pre><code>$ pip install gunicorn
</code></pre>

<p>然后再根据官方文档的介绍部署一个简单的例子试试：</p>

<pre><code>$ cd examples
$ cat test.py
# -*- coding: utf-8 -
#
# This file is part of gunicorn released under the MIT license.
# See the NOTICE for more information.

def app(environ, start_response):
    """Simplest possible application object"""
    data = 'Hello, World!\n'
    status = '200 OK'
    response_headers = [
        ('Content-type','text/plain'),
        ('Content-Length', str(len(data)))
    ]
    start_response(status, response_headers)
    return iter([data])

$ gunicorn -b 0.0.0.0:8000 --workers=2 test:app
</code></pre>

<p>好的，现在程序运行起来了，可以访问 <a href="http://localhost:8000">http://localhost:8000</a> 看下效果。</p>

<p>gunicorn 也可以通过配置文件来设置一些内容， 一个配置文件是一个 python 脚本，格式类似 <code>.ini</code> 。通过 <code>-c</code> 参数指定要使用的配置文件。如：</p>

<pre><code># config.ini
bind = ["0.0.0.0:8000", "unix:///tmp/gunicorn.sock"]
workers = 3 
</code></pre>

<p>gunicorn 还能与 Django 和 Paster 应用集成：</p>

<pre><code>$ gunicorn --env DJANGO_SETTINGS_MODULE=myproject.settings myproject.wsgi:application
$ gunicorn --paste development.ini -b :8080 --chdir /path/to/project
</code></pre>

<h2>与 Nginx 部署</h2>

<p>gunicorn 本身也是一个 WSGI 应用，可以与 Nginx 一同使用。
以下是 Nginx + Gunicorn 部署 Django 的事例， Nginx 配置如下：</p>

<pre><code># nginx.conf
http {
    include mime.types;
    default_type application/octet-stream;
    access_log /tmp/nginx.access.log combined;
    sendfile on;

    upstream app_server {
        server unix:/tmp/gunicorn.sock fail_timeout=0;
        # For a TCP configuration:
        # server 192.168.0.7:8000 fail_timeout=0;
    }

    server {
        listen 80 default;
        client_max_body_size 4G;
        server_name _;

        keepalive_timeout 5;

        # path for static files
        root /path/to/app/current/public;

        location / {
            # checks for static file, if not found proxy to app
            try_files $uri @proxy_to_app;
        }

        location @proxy_to_app {
            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
            proxy_set_header Host $http_host;
            proxy_redirect off;

            proxy_pass   http://app_server;
        }

        error_page 500 502 503 504 /500.html;
        location = /500.html {
            root /path/to/app/current/public;
        }
    }
}
</code></pre>

<p>Gunicorn 的配置文件：</p>

<pre><code># gunicorn.ini
import os

bind = ["0.0.0.0:8000", "unix:///tmp/gunicorn.sock"]
workers = 3
chdir = os.path.dirname(os.path.realpath(__file__))
raw_env = ["DJANGO_SETTINGS_MODULE=app.settings"]
accesslog = "/tmp/gunicorn-access.log"
errorlog = "/tmp/gunicorn.log"
daemon = True
pidfile = "/tmp/gunicorn.pid"
</code></pre>

<p>运行：</p>

<pre><code>$ gunicorn -c gunicorn.ini myproject.wsgi:application
$ service nginx start
</code></pre>

<h2>其他内容</h2>

<p>与 WSGI 应用一样，如果之后配置有改动可以向 gunicorn 服务进程发送 <code>HUP</code> 信号让其重新加载配置：</p>

<pre><code>$ kill -s HUP &lt;pid&gt;
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Nginx + Uwsgi + Django环境配置]]></title>
    <link href="http://www.xefan.com/archives/84135.html"/>
    <updated>2014-11-11T21:02:17+08:00</updated>
    <id>http://www.xefan.com/archives/84135-Nginx+uwsgi+Django环境配置</id>
    <content type="html"><![CDATA[<p>有段时间没折腾 Django 了，又有点生疏了。最近又部署了一下 Django 的环境，顺便作个笔记以便之后查阅。</p>

<p>首先安装 nginx、uwsgi 以及 uwsgi 的 python 插件。</p>

<p>然后新建一个 uwsgi 的配置文件：</p>

<pre><code>[uwsgi]
uid = www-data
chdir = /repo/django-blog
virtualenv = /repo/django-blog/pyenv2.7/    # python虚拟环境，没有可以不设置
env = DJANGO_SETTINGS_MODULE=blog.settings
module = blog.wsgi:application
master = true
plugin = python
pidfile = /tmp/blog-master.pid
socket = /tmp/blog.sock
enable-threads = true
post-buffering=1024000
post-buffering-busize=655360
</code></pre>

<p>这里我们的 Django 项目代码位于 <code>/repo/django-blog</code> ，项目的配置文件为： <code>blog/settings.py</code> 。</p>

<p><code>virtualenv</code> 项表明我们使用的是 <code>virtualenv</code> 环境，也可以直接系统的 python 环境。不过还是建议使用虚拟环境，以免软件包版本冲突。</p>

<p><code>post-buffering</code> 和 <code>post-buffering-busize</code> 这两项设置了 POST 请求时缓冲区的大小，该值可根据自己的情况进行调整。之前遇到过由于缓冲区不足导致返回的内容不完整。</p>

<p>再安装对应的 python 依赖包，然后运行 uwsgi 服务。</p>

<p>接着修改 nginx 的配置：</p>

<pre><code>server {
  listen 80;
  server_name localhost;

  client_max_body_size 50m;

  access_log /var/log/nginx/blog-access.log;
  error_log /var/log/nginx/blog-error.log;

  location / {
    uwsgi_pass unix:///tmp/blog.sock;
    include uwsgi_params;
  }

  location /static {
    alias /repo/django-blog/static/;
  }
}
</code></pre>

<p>这个内容比较简单， <code>client_max_body_size</code> 项是用于设置 http 请求的 body 最大大小。如果你的程序中有文件上传的，那么就需要根据自身情况来设置允许上传文件的最大值。</p>

<p>最后再启动 nginx 服务。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[使用C语言编写Python扩展5——垃圾回收管理]]></title>
    <link href="http://www.xefan.com/archives/84096.html"/>
    <updated>2014-04-15T00:00:00+08:00</updated>
    <id>http://www.xefan.com/archives/84096-使用C语言编写Python扩展5——垃圾回收管理</id>
    <content type="html"><![CDATA[<p>上一节介绍了创建一个具有属性的类，由于对象具有属性数据，因此在进行内存管理时要多加注意。这一节就介绍一下Python的垃圾回收管理。<br>
在Python中垃圾回收主要是靠的计数引用方法，但是单凭计数引用还是不够的。先看看下面这段Python代码。  </p>


<pre><code>n = []
m = []
n.append(m)
m.append(n)
del m
del n
</code></pre>


<p>如果只靠计数引用的话执行上面这段代码之后n和m都不能被回收，因为它们的引用计算值都不为0。<br>
像上面例子这样相互循环引用称作循环引用垃圾，在Python中有循环垃圾回收器（cyclic-garbage collector）专门用于回收此类计数引用无法处理的垃圾内存。  </p>


<p>接着上一节的例子，继续编辑<em>noddy.c</em>。  </p>


<p>为了让该对象类型支持垃圾回收，将PyTypeObject的tp_flags字段增加Py_TPFLAGS_HAVE_GC这个标志位。同时与GC(Garbage Collection)相关的tp_traverse和tp_clear这两个字段也要设置。  </p>


<ul>
<li>tp_traverse是用于垃圾回收器（garbage collector）遍历该实例对象中所有需要回收的属性对象。  </li>
<li>tp_clear是用于清除内部各个属性对象的。  </li>
</ul>


<p>首先定义tp_traverse和tp_clear所对应的函数：  </p>


<pre><code>static int Noddy_traverse(noddy_NoddyObject *self, visitproc visit, void *arg)
{
    Py_VISIT(self-&gt;first);
    Py_VISIT(self-&gt;last);
    return 0;
}
static int Noddy_clear(noddy_NoddyObject *self)
{
    Py_CLEAR(self-&gt;first);
    Py_CLEAR(self-&gt;last);
    return 0;
}
</code></pre>


<p>Py_VISIT和Py_CLEAR是两个宏，简化了visit操作和clear操作。  </p>


<p>然后再修改noddy_NoddyType结构体定义：  </p>


<pre><code>static PyTypeObject noddy_NoddyType = {
    PyObject_HEAD_INIT(NULL)
    0,                         /*ob_size*/
    "noddy.Noddy",             /*tp_name*/
    sizeof(noddy_NoddyObject), /*tp_basicsize*/
    0,                         /*tp_itemsize*/
    (destructor)Noddy_dealloc, /*tp_dealloc*/
    0,                         /*tp_print*/
    0,                         /*tp_getattr*/
    0,                         /*tp_setattr*/
    0,                         /*tp_compare*/
    0,                         /*tp_repr*/
    0,                         /*tp_as_number*/
    0,                         /*tp_as_sequence*/
    0,                         /*tp_as_mapping*/
    0,                         /*tp_hash */
    0,                         /*tp_call*/
    0,                         /*tp_str*/
    0,                         /*tp_getattro*/
    0,                         /*tp_setattro*/
    0,                         /*tp_as_buffer*/
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_HAVE_GC,  /*tp_flags*/
    "Noddy objects",           /*tp_doc*/
    (traverseproc)Noddy_traverse,   /* tp_traverse */
    (inquiry)Noddy_clear,      /* tp_clear */
    0,                         /* tp_richcompare */
    0,                         /* tp_weaklistoffset */
    0,                         /* tp_iter */
    0,                         /* tp_iternext */
    Noddy_methods,             /* tp_methods */
    Noddy_members,             /* tp_members */
    0,                         /* tp_getset */
    0,                         /* tp_base */
    0,                         /* tp_dict */
    0,                         /* tp_descr_get */
    0,                         /* tp_descr_set */
    0,                         /* tp_dictoffset */
    (initproc)Noddy_init,      /* tp_init */
    0,                         /* tp_alloc */
    Noddy_new,                 /* tp_new */
};
</code></pre>


<p><strong>注意</strong>：<br>
Python的官方手册中说道如果设置了Py_TPFLAGS_HAVE_GC这个标志位的话，那么就必须使用PyObject_GC_New这个函数来创建实例对象，使用PyObject_GC_Del来销毁已创建了的实例对象。  </p>


<p>使用PyObject_GC_New创建实例对象之后再用PyObject_GC_Track将该实例添加到垃圾回收器所跟踪的对象集合中去。<br>
在对象销毁时再执行PyObject_GC_UnTrack和PyObject_GC_Del函数。  </p>


<p>然后再修改tp_new函数和tp_dealloc函数：  </p>


<pre><code>static PyObject * Noddy_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
    noddy_NoddyObject*self;
    self = (noddy_NoddyObject*)PyObject_GC_New(noddy_NoddyObject, type);
    if (self != NULL) {
        PyObject_GC_Track(self);
        self-&gt;first = PyString_FromString("");
        if (self-&gt;first == NULL)
        {
          Py_DECREF(self);
          return NULL;
        }
        self-&gt;last = PyString_FromString("");
        if (self-&gt;last == NULL)
        {
          Py_DECREF(self);
          return NULL;
        }
        self-&gt;number = 0;
    }
    return (PyObject *)self;
}

static void Noddy_dealloc(noddy_NoddyObject* self)
{
    PyObject_GC_UnTrack(self);
    Noddy_clear(self);
    PyObject_GC_Del(self);
}
</code></pre>


<p>最后再写一段Python程序来测试下该模块：  </p>


<pre><code>import gc
import noddy

gc.set_debug(gc.DEBUG_STATS | gc.DEBUG_LEAK)

o = noddy.Noddy()
l = [o]
o.first = l
del l
del o

gc.collect()
</code></pre>


<p>本文中的示例代码可从 https://github.com/wusuopu/python-c-extension-sample 获取到。  </p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[使用C语言编写Python扩展4——创建自定义类型(2)]]></title>
    <link href="http://www.xefan.com/archives/84093.html"/>
    <updated>2014-04-14T00:00:00+08:00</updated>
    <id>http://www.xefan.com/archives/84093-使用C语言编写Python扩展4——创建自定义类型(2)</id>
    <content type="html"><![CDATA[<p>上一节中我们创建了一个简单的类。这一节我们将对这个类进行扩展，添加属性、方法，并且支持子类。</p>


<h2>为类型添加方法和数据</h2>


<p>接着上一节的例子，继续编辑<em>noddy.c</em>。  </p>


<pre><code>typedef struct {
    PyObject_HEAD
    /* Type-specific fields go here. */
    PyObject *first; /* first name */
    PyObject *last;  /* last name */
    int number;
} noddy_NoddyObject;
</code></pre>


<p>修改 noddy_NoddyObject 结构体，为其添加三个字段。  </p>


<p>然后定义自己的__new__方法，为对象分配内存空间：  </p>


<pre><code>static PyObject * Noddy_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
    noddy_NoddyObject*self;
    self = (noddy_NoddyObject*)type-&gt;tp_alloc(type, 0);
    if (self != NULL) {
        self-&gt;first = PyString_FromString("");
        if (self-&gt;first == NULL)
        {
          Py_DECREF(self);
          return NULL;
        }
        self-&gt;last = PyString_FromString("");
        if (self-&gt;last == NULL)
        {
          Py_DECREF(self);
          return NULL;
        }
        self-&gt;number = 0;
    }
    return (PyObject *)self;
}
</code></pre>


<p>接着定义对象的初始化函数__init__：  </p>


<pre><code>static int Noddy_init(noddy_NoddyObject*self, PyObject *args, PyObject *kwds)
{
    PyObject *first=NULL, *last=NULL, *tmp;
    static char *kwlist[] = {"first", "last", "number", NULL};

    if (! PyArg_ParseTupleAndKeywords(args, kwds, "|OOi", kwlist, 
                                      &amp;first, &amp;last, 
                                      &amp;self-&gt;number))
        return -1;

    if (first) {
        tmp = self-&gt;first;
        Py_INCREF(first);
        self-&gt;first = first;
        Py_XDECREF(tmp);
    }

    if (last) {
        tmp = self-&gt;last;
        Py_INCREF(last);
        self-&gt;last = last;
        Py_XDECREF(tmp);
    }
    return 0;
}
</code></pre>


<p>由于对象包含了几项数据，因此在对象销毁时需要先释放数据的资源。定义资源释放方法：</p>


<pre><code>static void Noddy_dealloc(noddy_NoddyObject* self)
{
    Py_XDECREF(self-&gt;first);
    Py_XDECREF(self-&gt;last);
    Py_TYPE(self)-&gt;tp_free((PyObject*)self);
}
</code></pre>


<p>然后再为该类定义一个方法用于返回该对象的first值和last值：  </p>


<pre><code>static PyObject * Noddy_name(noddy_NoddyObject* self)
{
    static PyObject *format = NULL;
    PyObject *args, *result;
    if (format == NULL) {
        format = PyString_FromString("%s %s");
        if (format == NULL)
            return NULL;
    }
    if (self-&gt;first == NULL) {
        PyErr_SetString(PyExc_AttributeError, "first");
        return NULL;
    }
    if (self-&gt;last == NULL) {
        PyErr_SetString(PyExc_AttributeError, "last");
        return NULL;
    }
    args = Py_BuildValue("OO", self-&gt;first, self-&gt;last);
    if (args == NULL)
        return NULL;
    result = PyString_Format(format, args);
    Py_DECREF(args);
    return result;
}
static PyMethodDef Noddy_methods[] = {
    {"name", (PyCFunction)Noddy_name, METH_NOARGS, "Return the name, combining the first and last name"},
    {NULL}  /* Sentinel */
};
</code></pre>


<p>最后在定义 noddy_NoddyType 变量时将对应字段进行填充：</p>


<pre><code>static PyTypeObject noddy_NoddyType = {
    PyObject_HEAD_INIT(NULL)
    0,                         /*ob_size*/
    "noddy.Noddy",             /*tp_name*/
    sizeof(noddy_NoddyObject), /*tp_basicsize*/
    0,                         /*tp_itemsize*/
    (destructor)Noddy_dealloc, /*tp_dealloc*/
    0,                         /*tp_print*/
    0,                         /*tp_getattr*/
    0,                         /*tp_setattr*/
    0,                         /*tp_compare*/
    0,                         /*tp_repr*/
    0,                         /*tp_as_number*/
    0,                         /*tp_as_sequence*/
    0,                         /*tp_as_mapping*/
    0,                         /*tp_hash */
    0,                         /*tp_call*/
    0,                         /*tp_str*/
    0,                         /*tp_getattro*/
    0,                         /*tp_setattro*/
    0,                         /*tp_as_buffer*/
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,  /*tp_flags*/
    "Noddy objects",           /*tp_doc*/
    0,                         /* tp_traverse */
    0,                         /* tp_clear */
    0,                         /* tp_richcompare */
    0,                         /* tp_weaklistoffset */
    0,                         /* tp_iter */
    0,                         /* tp_iternext */
    Noddy_methods,             /* tp_methods */
    0,                         /* tp_members */
    0,                         /* tp_getset */
    0,                         /* tp_base */
    0,                         /* tp_dict */
    0,                         /* tp_descr_get */
    0,                         /* tp_descr_set */
    0,                         /* tp_dictoffset */
    (initproc)Noddy_init,      /* tp_init */
    0,                         /* tp_alloc */
    Noddy_new,                 /* tp_new */
};
</code></pre>


<p>tp_flags字段增加了  Py_TPFLAGS_BASETYPE 属性，表示该类可以被继承。最后进行编译测试：  </p>


<pre><code>import noddy

o = noddy.Noddy("abc", "def", 12)
print(o, o.name())
print(type(o), type(noddy.Noddy))
print(o.number, o.first, o.last)

class A(noddy.Noddy):
    pass
</code></pre>


<p>运行以上程序会发现Noddy对象没有number、first和last这几个属性。这是因为虽然在noddy_NoddyObject结构体中定义了这几个字段，但是它们仍然在Python中是不可见的。<br>
为了能在Python中访问这几个属性，需要设置noddy_NoddyType的tp_members字段。  </p>


<pre><code>static PyMemberDef Noddy_members[] = {
    {"first", T_OBJECT_EX, offsetof(noddy_NoddyObject, first), 0, "first name"},
    {"last", T_OBJECT_EX, offsetof(noddy_NoddyObject, last), 0, "last name"},
    {"number", T_INT, offsetof(noddy_NoddyObject, number), 0, "noddy number"},
    {NULL}  /* Sentinel */
};
</code></pre>


<p>先定义一个 PyMemberDef 结构体类型的数组，然后将noddy_NoddyType的tp_members字段设为Noddy_members。PyMemberDef和T_OBJECT_EX以及T_INT均是在 <em>structmember.h</em> 头文件中定义的，因此还需要先包含该文件。  </p>


<pre><code>#include &lt;structmember.h&gt;
</code></pre>


<h2>数据属性的访问控制</h2>


<p>数据属性的访问控制可以对属性的设置进行合法性检查，例如这里我们想要确保 Noddy 对象的first属性和last属性都必须是字符串。<br>
首先定义属性的get方法和set方法：  </p>


<pre><code>static PyObject * Noddy_getfirst(noddy_NoddyObject *self, void *closure)
{
    Py_INCREF(self-&gt;first);
    return self-&gt;first;
}
static int Noddy_setfirst(noddy_NoddyObject *self, PyObject *value, void *closure)
{
  if (value == NULL) {
    PyErr_SetString(PyExc_TypeError, "Cannot delete the first attribute");
    return -1;
  }
  if (! PyString_Check(value)) {
    PyErr_SetString(PyExc_TypeError, 
                    "The first attribute value must be a string");
    return -1;
  }
  Py_DECREF(self-&gt;first);
  Py_INCREF(value);
  self-&gt;first = value;    
  return 0;
}
static PyObject * Noddy_getlast(noddy_NoddyObject *self, void *closure)
{
    Py_INCREF(self-&gt;last);
    return self-&gt;last;
}
static int Noddy_setlast(noddy_NoddyObject *self, PyObject *value, void *closure)
{
  if (value == NULL) {
    PyErr_SetString(PyExc_TypeError, "Cannot delete the last attribute");
    return -1;
  }
  if (! PyString_Check(value)) {
    PyErr_SetString(PyExc_TypeError, 
                    "The last attribute value must be a string");
    return -1;
  }
  Py_DECREF(self-&gt;last);
  Py_INCREF(value);
  self-&gt;last = value;    
  return 0;
}
</code></pre>


<p>然后创建一个 PyGetSetDef 结构类型的数组：  </p>


<pre><code>static PyGetSetDef Noddy_getseters[] = {
    {"first", (getter)Noddy_getfirst, (setter)Noddy_setfirst, "first name", NULL},
    {"last", (getter)Noddy_getlast, (setter)Noddy_setlast, "last name", NULL},
    {NULL}  /* Sentinel */
};
</code></pre>


<p>最后再设置 noddy_NoddyType 的tp_getset字段的值为 Noddy_getseters 即可。  </p>


<p><strong>注意</strong>：以上的代码均是针对Python2的，在Python3中略有不同。  </p>


<p>本文中的示例代码可从 https://github.com/wusuopu/python-c-extension-sample 获取到。  </p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[使用C语言编写Python扩展3——创建自定义类型(1)]]></title>
    <link href="http://www.xefan.com/archives/84091.html"/>
    <updated>2014-04-13T00:00:00+08:00</updated>
    <id>http://www.xefan.com/archives/84091-使用C语言编写Python扩展3——创建自定义类型(1)</id>
    <content type="html"><![CDATA[<p>在Python代码中如果要创建一个自定义类使用class关键字即可，但是在C代码中就没那么方便了。<br>
首先简单介绍下Python中的类型。在python中一切皆对象，python中有两种对象：<br>
一种是类型对象（class对象）：表示Python定义的类型，例如int, str, object等；<br>
另一种是实例对象（instance对象）：表示由class对象创建的实例。 
Python中的所有对象都是直接或者间接继承object，然后object又是typy类型。可以运行下面的例子看看输出结果：  </p>


<pre><code>class A(object):
    pass

a = A()

print(type(a))
print(isinstance(a, A))
print(isinstance(a, object))
print(isinstance(a, type))

print(type(A))
print(A.__base__)
print(isinstance(A, object))
print(isinstance(A, type))

print(type(object))
print(isinstance(object, type))

print(type(type))
print(isinstance(type, object))
</code></pre>


<p>python是一门面向对象的编程语言，它是用C写的，而C又是面向过程的编程语言，那么python的类在C中是如何实现的呢？答案就是用结构体来模拟。  </p>


<p>在Python的<em>object.h</em>头文件中定义了一个重要的结构体 PyTypeObject 。创建新的类型就是靠的它，该结构体定义如下：  </p>


<pre><code>typedef struct _typeobject {
    PyObject_VAR_HEAD
    char *tp_name; /* For printing, in format "&lt;module&gt;.&lt;name&gt;" */
    int tp_basicsize, tp_itemsize; /* For allocation */

    /* Methods to implement standard operations */

    destructor tp_dealloc;
    printfunc tp_print;
    getattrfunc tp_getattr;
    setattrfunc tp_setattr;
    cmpfunc tp_compare;
    reprfunc tp_repr;

    /* Method suites for standard classes */

    PyNumberMethods *tp_as_number;
    PySequenceMethods *tp_as_sequence;
    PyMappingMethods *tp_as_mapping;

    /* More standard operations (here for binary compatibility) */

    hashfunc tp_hash;
    ternaryfunc tp_call;
    reprfunc tp_str;
    getattrofunc tp_getattro;
    setattrofunc tp_setattro;

    /* Functions to access object as input/output buffer */
    PyBufferProcs *tp_as_buffer;

    /* Flags to define presence of optional/expanded features */
    long tp_flags;

    char *tp_doc; /* Documentation string */

    /* Assigned meaning in release 2.0 */
    /* call function for all accessible objects */
    traverseproc tp_traverse;

    /* delete references to contained objects */
    inquiry tp_clear;

    /* Assigned meaning in release 2.1 */
    /* rich comparisons */
    richcmpfunc tp_richcompare;

    /* weak reference enabler */
    long tp_weaklistoffset;

    /* Added in release 2.2 */
    /* Iterators */
    getiterfunc tp_iter;
    iternextfunc tp_iternext;

    /* Attribute descriptor and subclassing stuff */
    struct PyMethodDef *tp_methods;
    struct PyMemberDef *tp_members;
    struct PyGetSetDef *tp_getset;
    struct _typeobject *tp_base;
    PyObject *tp_dict;
    descrgetfunc tp_descr_get;
    descrsetfunc tp_descr_set;
    long tp_dictoffset;
    initproc tp_init;
    allocfunc tp_alloc;
    newfunc tp_new;
    freefunc tp_free; /* Low-level free-memory routine */
    inquiry tp_is_gc; /* For PyObject_IS_GC */
    PyObject *tp_bases;
    PyObject *tp_mro; /* method resolution order */
    PyObject *tp_cache;
    PyObject *tp_subclasses;
    PyObject *tp_weaklist;
} PyTypeObject;
</code></pre>


<p>这个比较庞大，里面包含的数据比较多，大部分都是一些函数指针而且可以为空，至于每个字段是什么意思请查看Python文档。  </p>


<h2>创建自定义类型</h2>


<p>创建一个新的C代码文件 <em>noddy.c</em> ，然后我们编写一个名为 noddy 的扩展模块，该模块包含了一个名为 Noddy 的类。  </p>


<p>首先创建一个新的 PyTypeObject 类型的变量：</p>


<pre><code>typedef struct {
    PyObject_HEAD
    /* Type-specific fields go here. */
} noddy_NoddyObject;
static PyTypeObject noddy_NoddyType = {
    PyVarObject_HEAD_INIT(NULL, 0)
    "noddy.Noddy",             /*tp_name*/
    sizeof(noddy_NoddyObject), /*tp_basicsize*/
    0,                         /*tp_itemsize*/
    0,                         /*tp_dealloc*/
    0,                         /*tp_print*/
    0,                         /*tp_getattr*/
    0,                         /*tp_setattr*/
    0,                         /*tp_compare*/
    0,                         /*tp_repr*/
    0,                         /*tp_as_number*/
    0,                         /*tp_as_sequence*/
    0,                         /*tp_as_mapping*/
    0,                         /*tp_hash */
    0,                         /*tp_call*/
    0,                         /*tp_str*/
    0,                         /*tp_getattro*/
    0,                         /*tp_setattro*/
    0,                         /*tp_as_buffer*/
    Py_TPFLAGS_DEFAULT,        /*tp_flags*/
    "Noddy objects",           /*tp_doc*/
};
</code></pre>


<p>这里是定义了一个noddy_NoddyObject结构体，它的第一个字段为 PyObject_HEAD ，因此相当于一个PyObject类型；然后还有一个 noddy_NoddyType 变量，它的第一个字段为 <em>PyVarObject_HEAD_INIT(NULL, 0)</em> ，这个很很重要，按理说这个应该写成 <em>PyVarObject_HEAD_INIT(&amp;PyType_Type, 0)</em> ，即表示Noddy这个类是一个type类型的对象。不过有的C编译器会对这个报错，因此这一项将在后面调用PyType_Ready函数来填充。<br>
noddy_NoddyType 即是 Noddy 类，它保存了该类的元信息；noddy_NoddyObject结构体用于保存该类的实例对象的数据。<br>
<em>只要是定义的结构体以PyObject_HEAD开始就属于是一个PyObject类型。PyObject_VAR_HEAD与PyObject_HEAD相似，只是PyObject_HEAD表示的是该类型占用内存大小是固定的如int、float；而PyObject_VAR_HEAD表示该类型占用的内存是可变的如list、dict。</em>   </p>


<p>然后创建一个新扩展模块，并完成初始化：</p>


<pre><code>static PyMethodDef noddy_methods[] = {
    {NULL}  /* Sentinel */
};
PyMODINIT_FUNC
initnoddy(void) 
{
    PyObject* m;

    noddy_NoddyType.tp_new = PyType_GenericNew;
    if (PyType_Ready(&amp;noddy_NoddyType) &lt; 0)
        return;

    m = Py_InitModule3("noddy", noddy_methods,
                       "Example module that creates an extension type.");

    Py_INCREF(&amp;noddy_NoddyType);
    PyModule_AddObject(m, "Noddy", (PyObject *)&amp;noddy_NoddyType);
}
</code></pre>


<p><strong><em>注意</em></strong>：以上是针对Python2的，在Python3中模块的初始化操作略有不同。请参考第一节的内容。  </p>


<p>noddy_NoddyType即是我们要创建的 Noddy 类，它是 PyTypeObject 类型的结构变量。为了创建新的类型，我们需要指明 tp_new 方法，它相当于Python中的 __new__，这里我们使用默认的 PyType_GenericNew 即可。<br>
然后调用 PyType_Ready 完成新类型的创建。<br>
最后调用 PyModule_AddObject 在该模块中添加刚刚创建的新类型。  </p>


<h2>测试</h2>


<p>最后就是编写一个小程序来测试刚刚的模块是否可用。</p>


<pre><code>import noddy

o = noddy.Noddy()
print(o)
print(type(o), type(noddy.Noddy))

# 这个会报错，noddy.Noddy 类不能被继承
class A(noddy.Noddy):
    pass
</code></pre>

]]></content>
  </entry>
  
</feed>
