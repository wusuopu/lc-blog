<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: 数据库 | 龍昌博客]]></title>
  <link href="http://www.xefan.com/categories/数据库/atom.xml" rel="self"/>
  <link href="http://www.xefan.com/"/>
  <updated>2015-08-24T10:28:02+08:00</updated>
  <id>http://www.xefan.com/</id>
  <author>
    <name><![CDATA[龍昌]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Redis集群配置实例]]></title>
    <link href="http://www.xefan.com/archives/84140.html"/>
    <updated>2015-01-14T18:11:36+08:00</updated>
    <id>http://www.xefan.com/archives/84140-Redis集群配置实例</id>
    <content type="html"><![CDATA[<p>通过配置 redis 的主从集群可将请求的负荷分散到多台服务器上。</p>

<p>redis 的集群配置比较简单，以下是一个例子。
假设有如下三台主机：</p>

<ul>
<li>172.17.0.11 (主)</li>
<li>172.17.0.12 (从)</li>
<li>172.17.0.13 (从)</li>
</ul>


<p>在从服务器上添加如下配置：</p>

<pre><code>slaveof 172.17.0.11 6379
</code></pre>

<p>如果主服务器设置了认证密码，那么还需要再添加一条配置：</p>

<pre><code>masterauth &lt;password&gt;
</code></pre>

<p>然后分别启动三台服务器的 redis 服务即可。</p>

<p>接下来连接主服务器添加一些数据测试一下。</p>

<pre><code>$ redis-cli -h 172.17.0.11
172.17.0.11:6379&gt; set foo1 bar1
OK
</code></pre>

<p>然后再连接到从服务器查询结果。</p>

<pre><code>$ redis-cli -h 172.17.0.12
172.17.0.12:6379&gt; get foo1
"bar1"
</code></pre>

<p>这时发现数据已经同步过来了。</p>

<p>注意：从服务器默认是只读的。如果需要设置为可写，可将 <code>slave-read-only</code> 设置项的值设为 <code>no</code> 即可。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Mongodb分片配置实例]]></title>
    <link href="http://www.xefan.com/archives/84139.html"/>
    <updated>2014-12-29T16:52:37+08:00</updated>
    <id>http://www.xefan.com/archives/84139-Mongodb分片配置实例</id>
    <content type="html"><![CDATA[<p>数据分片即是从一个集合中选择一个片键(shard key)作为数据拆分的依据，原理与索引类似，然后将集合的数据拆分并保存到不同的服务器上。
以下通过一个例子来介绍一下Mongodb的分片配置。</p>

<p>有四台主机：</p>

<ul>
<li>172.17.0.6    (配置服务器)</li>
<li>172.17.0.7    (mongos)</li>
<li>172.17.0.8    (片服务器)</li>
<li>172.17.0.9    (片服务器)</li>
</ul>


<p>1.在 172.17.0.6 上启动 mongod 服务作为配置服务器；<br/>
修改配置，使其作为一个配置服务器，默认监听 27019 端口。</p>

<pre><code>configsvr = true
</code></pre>

<p>启动服务 <code>$ service mongodb start</code></p>

<p>2.在 172.17.0.7 上启动 mongos 服务作为路由服务;<br/>
建立mongos进程。(可以有多台配置服务器)，用法如下：</p>

<pre><code>$ mongos --configdb &lt;config server hostnames&gt;[,&lt;config server hostnames&gt;]
</code></pre>

<p>例如： <code>$ mongos --configdb 172.17.0.6:27019</code></p>

<p>注意：在同一个分片集群中的每个 mongos 必须使用相同的 configDB 配置。</p>

<p>3.添加分片<br/>
一个片服务既可以是单个 mongod 实例，也可以是一个副本集。<br/>
1).先分别在 172.17.0.8 和 172.17.0.9 上启动片服务器，即就是一个普通的 mongod 服务。</p>

<pre><code>$ service mongodb start
</code></pre>

<p>2).使用 mongo 客户端连接到 mongos 服务</p>

<pre><code>$ mongo --host &lt;hostname of machine running mongos&gt; --port &lt;port mongos listens on&gt;
</code></pre>

<p>如： <code>$ mongo --host 172.17.0.7 --port 27017</code></p>

<p>3).在 mongo 客户端上执行命令添加分片：</p>

<pre><code>&gt; use admin
&gt; db.auth(&lt;user&gt;, &lt;pswd&gt;)
&gt; sh.addShard("172.17.0.8:27017")
&gt; sh.addShard("172.17.0.9:27017")
</code></pre>

<p>4.切片数据<br/>
1).首先对数据库进行切片<br/>
使用 mongo 客户端连接到 mongos ，执行命令打开数据库的分片功能，用法如下：</p>

<pre><code>&gt; sh.enableSharding("&lt;database&gt;")
</code></pre>

<p>例如要打开 mydb 数据库的分片功能： <code>&gt; sh.enableSharding("mydb")</code></p>

<p>2).然后对数据集合进行切片<br/>
命令用法如下：</p>

<pre><code>&gt; sh.shardCollection("&lt;database&gt;.&lt;collection&gt;", shard-key-pattern)
</code></pre>

<p><code>shard-key-pattern</code> 与索引的用法一样，例如，要对 mydb 数据库的 test 集合按照 <code>_id</code> 字段进行分片： <code>&gt; sh.shardCollection("mydb.test", {"_id": "hashed"})</code></p>

<p>接下来通过一个程序来测试一下，向数据库中添加10000条数据：</p>

<pre><code class="ruby">#!/usr/bin/env ruby
#-*- coding:utf-8 -*-

require "mongo"

begin
  conn = Mongo::Connection.new '172.17.0.7'
  db = conn['mydb']
rescue Exception=&gt;e
  p e
  exit 1
end

i = 0
while i &lt; 10000
  d = {'no' =&gt; i}
  d = db['test'].insert(d)
  i += 1
  puts d
end
</code></pre>

<p>然后分别查看 172.17.0.8 和 172.17.0.9 的状态：</p>

<pre><code>172.17.0.8:
&gt; db.test.count()
4952

172.17.0.9:
&gt; db.test.count()
5048
</code></pre>

<p>数据基本上是平均的分布在两台服务器上。</p>

<p>参考： <a href="http://docs.mongodb.org/manual/tutorial/deploy-shard-cluster/">http://docs.mongodb.org/manual/tutorial/deploy-shard-cluster/</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Mongodb集群配置实例]]></title>
    <link href="http://www.xefan.com/archives/84137.html"/>
    <updated>2014-12-10T20:33:02+08:00</updated>
    <id>http://www.xefan.com/archives/84137-Mongodb集群配置实例</id>
    <content type="html"><![CDATA[<p>Mongodb的集群有两种，一个是主从复制，另一种是副本集。</p>

<h2>主从复制</h2>

<p>根据 Mongodb 的官方文档说明，在生产环境中建议使用副本集代替主从复制。 <a href="http://docs.mongodb.org/manual/core/master-slave/">http://docs.mongodb.org/manual/core/master-slave/</a></p>

<p>不过对于主从复制还是可以了解一下。假设有如下三台主机：</p>

<ul>
<li>172.17.0.4    (主)</li>
<li>172.17.0.5    (从)</li>
<li>172.17.0.6    (从)</li>
</ul>


<p>要进行主从复制的配置，首先修改主服务器的配置信息：</p>

<pre><code>master = true         # 以主服务器模式启动
bind_ip = 0.0.0.0
</code></pre>

<p>然后修改另两台从服务器配置信息：</p>

<pre><code>slave = true
source = 172.17.0.4
bind_ip = 0.0.0.0
</code></pre>

<p>最后启动三台主机上的 Mongodb 服务，再通过一个简单的程序来测试一下。</p>

<pre><code class="ruby">#!/usr/bin/env ruby
#-*- coding:utf-8 -*-

require "mongo"

begin
  conn = Mongo::Connection.new '172.17.0.4'
  db = conn['test']
rescue Exception=&gt;e
  p e
  exit 1
end

i = 0
while i &lt; 100
  d = {'no' =&gt; i}
  d = db['data'].insert(d)
  i += 1
  puts d
end
</code></pre>

<p>执行该脚本，向 <code>172.17.0.4</code> 主机的 Mongodb 中插入一些数据。然后发现数据被同步到了另外两台主机上。</p>

<p>主从之间安全认证：<br/>
如果启动了 <code>auth</code> 项，那么主从之间的认证需要使用 <code>keyFile</code> 选项。</p>

<p>执行如下命令生成 key 文件，并设置为只有 mongodb 的进程用户可读写：</p>

<pre><code>$ openssl rand -base64 741 &gt; /path/mongodb_keyFile
$ chmow 600 /path/mongodb_keyFile
$ chown mongodb:mongodb /path/mongodb_keyFile
</code></pre>

<p>将该文件复制到这三台主机中，然后分别修改主从的配置信息：</p>

<pre><code>keyFile = /path/mongodb_keyFile
</code></pre>

<h2>副本集</h2>

<p>同样的对于这三台主机，我们重新修改配置设置为副本集的形式。</p>

<ul>
<li>172.17.0.4</li>
<li>172.17.0.5</li>
<li>172.17.0.6</li>
</ul>


<p>首先修改配置文件，设置副本集的名字。<br/>
注意：副本集中所有主机设置的名字需要一样。这里我们设为 <code>myrepl0</code>。<br/>
注意：设置副本集之前各个 mongodb 的数据目录必须都为空。</p>

<pre><code>replSet = myrepl0
</code></pre>

<p>接着启动所有 mongodb 服务，然后对副本集进行初始化。<br/>
连接任意一台 mongodb 服务，执行如下操作：</p>

<pre><code>&gt; rs.initiate({'_id': 'myrepl0', 'members': [
    {'_id': 1, 'host': '172.17.0.4:27017'},
    {'_id': 2, 'host': '172.17.0.7:27017'},
    {'_id': 3, 'host': '172.17.0.8:27017'}
]})
</code></pre>

<p>现在副本集的初始化已完成，可以通过如下命令查看状态：</p>

<pre><code>&gt; rs.status()
</code></pre>

<p>在运行过程中可以随时添加或移除一个节点，如：</p>

<pre><code>rs.add("172.17.0.8:27017")
rs.remove("172.17.0.8:27017")
</code></pre>

<p>可以再通过上面的程序添加一些数据。然后再连接到任意一台主机进行查询，看看数据是否已同步。</p>

<p>详细内容可参考文档： <a href="http://docs.mongodb.org/manual/core/replication/">http://docs.mongodb.org/manual/core/replication/</a></p>

<p>安全认证：</p>

<p>1.禁用 auth 选项和 replSet 选项再运行 mongodb</p>

<p>2.连接到该 mongodb 服务并创建用户</p>

<pre><code>&gt; use admin
switched to db admin
&gt; db.addUser('root','root')
{
        "user" : "root",
        "readOnly" : false,
        "pwd" : "2a8025f0885adad5a8ce0044070032b3",
        "_id" : ObjectId("54745351f79804bd44b596fb")
}
&gt; 
</code></pre>

<p>3.重新以 auth、keyFile 和 replSet 模式启动 mongodb</p>

<p>4.连接到刚刚创建用户的 mongodb 服务</p>

<p>5.跟之前的步骤一样，配置副本集</p>

<pre><code>&gt; rs.initiate({'_id': 'myrepl0', 'members': [
    {'_id': 1, 'host': '172.17.0.4:27017'},
    {'_id': 2, 'host': '172.17.0.7:27017'},
    {'_id': 3, 'host': '172.17.0.8:27017'}
]})
</code></pre>

<p>参考： <a href="http://docs.mongodb.org/manual/tutorial/deploy-replica-set-with-auth/">http://docs.mongodb.org/manual/tutorial/deploy-replica-set-with-auth/</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Redis使用笔记]]></title>
    <link href="http://www.xefan.com/archives/84110.html"/>
    <updated>2014-06-21T00:00:00+08:00</updated>
    <id>http://www.xefan.com/archives/84110-Redis使用笔记</id>
    <content type="html"><![CDATA[<p>Redis是一个键值型数据库，之前花了些时间体验了一下Redis，感觉还是很不错的。而且Redis学习起来也很容易，差不多花几个小时应该就能入门了。当时我是看的<a href="https://github.com/karlseguin/the-little-redis-book">《the little redis book》</a>，初学者可以看看。</p>


<h2>安装</h2>


<p>下载软件包： http://redis.io/download</p>


<p>首先运行服务器程序：</p>


<pre><code>$ redis-server
</code></pre>


<p>程序默认是监听6379端口。</p>


<p>然后再运行客户端程序：</p>


<pre><code>$ redis-cli
</code></pre>


<h2>基本数据类型</h2>


<p>运行客户端程序连接上Redis服务之后，所有的操作都可以通过该命令行交互完成。</p>


<p>Redis有5种不同的数据类型：字符串、散列表、列表、集合、有序集合。所有的数据在Redis中都是以键值对的形式保存的。</p>


<p>以下介绍这几种类型数据的基本操作。</p>


<h3>String</h3>


<p>设置一个键的值为字符串：  </p>


<pre><code>set &lt;key&gt; &lt;value&gt;
</code></pre>


<p>获取该键的值：  </p>


<pre><code>get &lt;key&gt;
</code></pre>


<p>字符串相关的命令：  </p>


<pre><code>help @string
</code></pre>


<h3>Hashes</h3>


<p>设置一个散列值：  </p>


<pre><code>hset &lt;key&gt; &lt;k&gt; &lt;v&gt;
</code></pre>


<p>获取该键的值：  </p>


<pre><code>hget &lt;key&gt; &lt;k&gt;  
hgetall &lt;key&gt;
</code></pre>


<p>散列相关的命令：  </p>


<pre><code>help @hash
</code></pre>


<h3>Lists</h3>


<p>添加值：  </p>


<pre><code>lpush &lt;key&gt; &lt;v&gt;
</code></pre>


<p>移除值：  </p>


<pre><code>lpop &lt;key&gt;  
help @list
</code></pre>


<h3>Set</h3>


<p>添加值：  </p>


<pre><code>sadd &lt;key&gt; &lt;v&gt;[ &lt;v&gt; ..]  
help set
</code></pre>


<h3>Sorted Sets</h3>


<p>类似于集合(Set)，但是提供了排序（sorting）和秩划分（ranking）的功能。</p>


<p>添加值：  </p>


<pre><code>zadd key score member [score] [member]   
help @sorted_set
</code></pre>


<h2>其他</h2>


<h3>有效期</h3>


<p>设置某个值在seconds秒后到期：  </p>


<pre><code>expire &lt;key&gt; seconds
</code></pre>


<p>设置某个值在time时刻到期：  </p>


<pre><code>expireat &lt;key&gt; time
</code></pre>


<p>查看到期时间：  </p>


<pre><code>ttl &lt;key&gt;
</code></pre>


<p>清除到期时间：  </p>


<pre><code>persist &lt;key&gt;
</code></pre>


<h3>事务（Transactions）</h3>


<pre><code>multi  
do something  
exec
</code></pre>


<p>multi和exec之间的命令作为原子操作。</p>


<p>在multi之前调用watch可监听值的变化，若该值被其他客户端修改，事务将会运行失败。</p>


<h3>杂项</h3>


<p>选择数据库：</p>


<pre><code>select index
</code></pre>


<p>清除当前数据库所属key:</p>


<pre><code>flushdb
</code></pre>


<p>清除所有数据库所属key:</p>


<pre><code>flushall
</code></pre>


<p>查看key所储存的值的类型：</p>


<pre><code>type key
</code></pre>


<p>Redis相关的命令手册： http://redis.io/commands</p>


<h2>在应用程序中使用Redis</h2>


<p>Redis提供了多种语言的绑定，以Ruby为例：</p>


<pre><code>require 'redis'
r = Redis.new
r.set 'key', 1234
puts r.get 'key'
puts r.keys
</code></pre>


<p>输出结果应该为：</p>


<pre><code>"1234"
["key"]
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Mongoengine教程(5)——信号]]></title>
    <link href="http://www.xefan.com/archives/84076.html"/>
    <updated>2014-04-06T00:00:00+08:00</updated>
    <id>http://www.xefan.com/archives/84076-mongoengine教程(5)——信号</id>
    <content type="html"><![CDATA[<p>MongoEngine在进行数据操作时会发出一些信号，我们可以连接这些信号进行一些额外的操作。注意：要在MongoEngine中使用信号，需要安装 <em>blinker</em> 这个库。  </p>


<pre><code>$ pip install blinker
</code></pre>


<p>MongoEngine提供的信号如下：  </p>


<ul>
<li>pre_init: 在创建一个新的 Document 或者 EmbeddedDocument 实例对象之后，并且对象初始化之前调用。  </li>
<li>post_init:在 Document 或者 EmbeddedDocument 实例对象初始化完成之后调用。  </li>
<li>pre_save:在 save 方法执行之前调用。  </li>
<li>pre_save_post_validation:在数据检验完成之后，数据保存之前调用。  </li>
<li>post_save:在数据保存完成之后调用。  </li>
<li>pre_delete:在 delete 方法执行之前调用。  </li>
<li>post_delete:在记录成功删除之后调用。  </li>
<li>pre_bulk_insert:在数据检验之后，数据插入之前调用。  </li>
<li>post_bulk_insert:在数据成功插入之后调用。</li>
</ul>


<h2>事件连接</h2>


<p>使用 signals 将信号与回调函数进行连接。</p>


<pre><code>from mongoengine import *
from mongoengine import signals

class Author(Document):
    name = StringField()

    @classmethod
    def pre_save(cls, sender, document, **kwargs):
        print("Pre Save: %s" % document.name)

    @classmethod
    def post_save(cls, sender, document, **kwargs):
        print("Post Save: %s" % document.name)
        if 'created' in kwargs:
            if kwargs['created']:
                print("Created")
            else:
                print("Updated")

signals.pre_save.connect(Author.pre_save, sender=Author)
signals.post_save.connect(Author.post_save, sender=Author)
</code></pre>


<p>注意：对于 RefereneField 的<em>reverse_delete_rules</em>参数不会触发信号。</p>

]]></content>
  </entry>
  
</feed>
