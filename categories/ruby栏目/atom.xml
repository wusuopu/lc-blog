<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Ruby栏目 | 龍昌博客]]></title>
  <link href="http://www.xefan.com/categories/ruby栏目/atom.xml" rel="self"/>
  <link href="http://www.xefan.com/"/>
  <updated>2015-08-23T11:53:17+08:00</updated>
  <id>http://www.xefan.com/</id>
  <author>
    <name><![CDATA[龍昌]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[在Ruby中使用DATA和__END__将代码和数据混合]]></title>
    <link href="http://www.xefan.com/archives/84154.html"/>
    <updated>2015-08-23T10:12:08+08:00</updated>
    <id>http://www.xefan.com/archives/84154-在Ruby中使用DATA和__END__将代码和数据混合</id>
    <content type="html"><![CDATA[<p>之前一直不理解 <code>__END__</code> 的用法，现在看了这篇文章后才算是了解了，于是便翻译之。<br/>
《Mixing code and data in Ruby with DATA and __END__》: <a href="http://blog.honeybadger.io/data-and-end-in-ruby/">http://blog.honeybadger.io/data-and-end-in-ruby/</a></p>

<hr />

<p>你知道 Ruby 提供了一种方法在你的脚本中可以将源文件作为数据源来使用吗？当你在写一些一次性的脚本用于验证概念时这个小技巧会为你节约一些时间。让我们来看看吧。</p>

<h2>DATA 和 __END__</h2>

<p>在下面这个例子中，我使用了一个有趣的关键字 <code>__END__</code>。所有在 <code>__END__</code> 下面的内容将会被 Ruby 解释器所忽略。但是有趣的是 ruby 为你提供了一个称为 <code>DATA</code> 的 IO 对象，就像你可以读取其他任何文件一样，它能让你读取到 <code>__END__</code> 以下的所有内容。</p>

<p>下面这个例子中，我们遍历每一行并进行输出。</p>

<pre><code class="ruby">DATA.each_line do |line|
  puts line
end

__END__
Doom
Quake
Diablo
</code></pre>

<p>关于这个技术我最喜欢的实例是使用 <code>DATA</code> 来包含一个 ERB 模板。它同样也可用于 YAML、CSV等等。</p>

<pre><code class="ruby">require 'erb'

time = Time.now
renderer = ERB.new(DATA.read)
puts renderer.result()

__END__
The current time is &lt;%= time %&gt;.
</code></pre>

<p>实际上你也可以使用 <code>DATA</code> 来读取 <code>__END__</code> 关键字以上的内容。那是因为 <code>DATA</code> 实际上是一个指向了整个源文件，并定位到 <code>__END__</code> 关键字的位置。你可以试试看在输出之前将 IO 对象反转。下面这个例子将会输出整个源文件。</p>

<pre><code class="ruby">DATA.rewind
puts DATA.read # prints the entire source file

__END__
meh
</code></pre>

<h2>多文件问题</h2>

<p>这个技术最大的缺点是它只能用于单个文件的脚本，直接运行该文件，不能在其他文件进行导入。</p>

<p>下面这个例子，我们有两个文件，并且每个都有它们自己的 <code>__END__</code> 部分。然而却只有一个全局 <code>DATA</code> 对象。因此第二个文件的 <code>__END__</code> 部分刚访问不到了。</p>

<pre><code class="ruby"># first.rb
require "./second"

puts "First file\n----------------------"
puts DATA.read

print_second_data()

__END__
First end clause
</code></pre>

<pre><code class="ruby"># second.rb

def print_second_data
  puts "Second file\n----------------------"
  puts DATA.read # Won't output anything, since first.rb read the entire file
end

__END__

Second end clause
</code></pre>

<pre><code>snhorne ~/tmp $ ruby first.rb
First file
----------------------
First end clause

Second file
----------------------
</code></pre>

<h2>对于多文件的一个解决方案</h2>

<p>在 Sinatra 中有一个很酷的特性是它允许你在你应用的 <code>__END__</code> 部分添加多个内联模板。它看起来像下面这样：</p>

<pre><code class="ruby"># This code is from the Sinatra docs at http://www.sinatrarb.com/intro.html
require 'sinatra'

get '/' do
  haml :index
end

__END__

@@ layout
%html

  = yield

@@ index
%div.title Hello world.
</code></pre>

<p>sinatra 是如何实现的呢？毕竟你的应用可能是运行在 rack 上。在生产环境中你不能再通过 <code>ruby myapp.rb</code> 来运行！他们必须有一种在多文件中使用 <code>DATA</code> 的解决方案。</p>

<p>因此如果你稍微深入一下 Sinatra 的源代码，你会发现它们并没有使用 <code>DATA</code>。而是使用了跟下面这段代码类似的方案。</p>

<pre><code class="ruby"># I'm paraphrasing. See the original at https://github.com/sinatra/sinatra/blob/master/lib/sinatra/base.rb#L1284
app, data = File.read(__FILE__).split(/^__END__$/, 2)
</code></pre>

<p>实际上它比这个要更复杂一些，因为它们不想读取 <code>__FILE__</code>，它只是 <code>sinatra/base.rb</code> 文件。它们其实是需要获取调用了该方法的文件的内容。它们通过解析 <code>caller</code> 的结果来获取。</p>

<p><code>caller</code> 方法将会告诉你当前运行的方法是从哪调用的。这里是个简单的例子：</p>

<pre><code class="ruby">def some_method
  puts caller
end

some_method # =&gt; caller.rb:5:in `&lt;main&gt;'
</code></pre>

<p>现在可以简单地获取到文件名了，然后从该文件中再提取出与 <code>DATA</code> 等价的内容。</p>

<pre><code class="ruby">def get_caller_data
  puts File.read(caller.first.split(":").first).split("__END__", 2).last
end
</code></pre>

<h2>请善用它，不要作恶</h2>

<p>希望对于这些技巧你不要经常使用。它们不会使得代码干净、可维护。</p>

<p>然后，你偶尔需要一些又快又脏的实现一个一次性的脚本或者验证一些概念。此时 <code>DATA</code> 和 <code>__END__</code> 就非常有用了。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Unicorn是如何与nginx通讯的——介绍ruby中的unix Socket]]></title>
    <link href="http://www.xefan.com/archives/84146.html"/>
    <updated>2015-08-03T16:01:52+08:00</updated>
    <id>http://www.xefan.com/archives/84146-unicorn是如何与nginx通讯的——介绍ruby中的unix socket</id>
    <content type="html"><![CDATA[<p>Ruby 应用服务典型地是与一个 web 服务一同使用的，如 nginx。当用户请求你的 Rails 应用中的页面时，nginx 将请求指派给应用服务。
然而这个过程是如何完成的呢？nginx 与 unicorn 是如何通讯的呢？</p>

<p>最有效的一种选择是使用 unix 套接字(sockets)。让我们来看看它们是如何工作的！
在这篇文章中我们将从一个基本的套接字(sockets)开始，最后将创建一个使用 nginx 代理的简单应用服务。</p>

<p><img src="/wp-content/uploads/2015/07/socket.png" alt="socket" /></p>

<p><em>套接字(sockets)允许进程之间通过对一个文件读或者写进行相互通讯。</em>
<em>在这个例子中 Unicorn 创建 socket 并监听它的连接。然后 Nginx 就可以连接到这个 socket 并与 Unicorn 通讯了。</em></p>

<h2>什么是 unix socket？</h2>

<p>Unix socket 使得一个进程通过类似文件的方式与另一个进程进行通讯。它是 IPC(Interprocess Communication) 的一种。</p>

<p>要使得可以通过 socket 访问进程，首先需要创建一个 socket 并作为一个文件保存在磁盘中。
然后监听这个 socket 的连入连接。当接收到一个连接时，就可以使用<a href="http://ruby-doc.org/core-2.2.2/IO.html#method-i-readline">标准 IO 方法</a>进行读写数据。</p>

<p>Ruby 通过以下一组类提供了 unix socket 所需的所有内容：</p>

<ul>
<li>UNIXServer - 创建 socket 并保存到磁盘中，并且让你可以监听新连接。</li>
<li>UNIXSocket - 打开已存在的套接字(sockets)。</li>
</ul>


<p><strong>注意：</strong>还存在着其它类型的 socket，最突出的是 TCP socket。不过这篇文章只处理 unix socket。那么它们之间的区别是什么呢？unix  socket 具有文件名。</p>

<h2>最简单的 Socket</h2>

<p>我们接下来看两个小程序。</p>

<p>第一个是服务端，它创建一个 <code>UnixServer</code> 实例，然后使用 <code>server.accept</code> 等待连接。当收到连接后则相互问候。</p>

<p>需要说明一下，<code>accept</code> 和 <code>readline</code> 方法都会阻塞程序的执行，直到收到内容。</p>

<pre><code class="ruby">require "socket"

server = UNIXServer.new('/tmp/simple.sock')

puts "==== Waiting for connection"
socket = server.accept

puts "==== Got Request:"
puts socket.readline

puts "==== Sending Response"
socket.write("I read you loud and clear, good buddy!")

socket.close
</code></pre>

<p>这里我们有了服务端，现在还需要客户端。</p>

<p>在下面这个例子中，我们打开由服务端创建的 socket，然后使用普通的 IO 方法进行发送和接收问候。</p>

<pre><code class="ruby">require "socket"

socket = UNIXSocket.new('/tmp/simple.sock')

puts "==== Sending"
socket.write("Hello server, can you hear me?\n")

puts "==== Getting Response"
puts socket.readline

socket.close
</code></pre>

<p>演示一下程序，先运行服务端，然后再运行客户端。你可以看到以下结果：</p>

<p><img src="/wp-content/uploads/2015/07/simple_ruby_socket_example.png" alt="simple_ruby_socket_example" />
<em>简单的 Unix socket 服务端/客户端交互的例子。左边是客户端，右边是服务端。</em></p>

<h2>与 nginx 接合</h2>

<p>现在我们知道如何创建一个 unix socket 的服务端了，我们可以很容易地与 nginx 接合。</p>

<p>不相信我？让我们来做一个快速的概念验证吧。我修改上面的代码使其输出从 socket 接收到的所有内容。</p>

<pre><code class="ruby">require "socket"

# Create the socket and "save it" to the file system
server = UNIXServer.new('/tmp/socktest.sock')

# Wait until for a connection (by nginx)
socket = server.accept

# Read everything from the socket
while line = socket.readline
  puts line.inspect
end

socket.close
</code></pre>

<p>现在如果我修改 nginx 配置，将请求转发到 <code>/tmp/socktest.sock</code> socket 上。
我就能看到 nginx 发送来的数据了。(别担心，我们稍后会讨论它的配置的)</p>

<p>当我发起一个 web 请求时，nginx 将如下数据发送到我的服务端上：</p>

<p><img src="/wp-content/uploads/2015/07/request_http.png" alt="request_http" /></p>

<p>太酷了！这就是一个包含了额外头信息的 HTTP 请求。现在我们准备来构建一个真正的应用服务。
但是，首先让我们讨论一个 nginx 的配置吧。</p>

<h2>安装配置 Nginx</h2>

<p>如果你还没有安装 nginx 的话，请先安装。对于 OSX 可以 homebrew 简单完成：</p>

<pre><code>brew install nginx
</code></pre>

<p>现在我们配置 nginx 将 localhost:2048 的请求通过名为 <code>/tmp/socktest.sock</code> 的 socket 转发到上游服务端。
名字可以是任意的，它仅需要与我们 web 服务的 socket 名字匹配即可。</p>

<p>你可以将其保存至 <code>/tmp/nginx.conf</code> 并通过命令 <code>nginx -c /tmp/nginx.conf</code> 运行 nginx。</p>

<pre><code># Run nginx as a normal console program, not as a daemon
daemon off;

# Log errors to stdout
error_log /dev/stdout info;

events {} # Boilerplate

http {

  # Print the access log to stdout
  access_log /dev/stdout;

  # Tell nginx that there's an external server called @app living at our socket
  upstream app {
    server unix:/tmp/socktest.sock fail_timeout=0;
  }

  server {

    # Accept connections on localhost:2048
    listen 2048;
    server_name localhost;

    # Application root
    root /tmp;

    # If a path doesn't exist on disk, forward the request to @app
    try_files $uri/index.html $uri @app;

    # Set some configuration options on requests forwarded to @app
    location @app {
      proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
      proxy_set_header Host $http_host;
      proxy_redirect off;
      proxy_pass http://app;
    }

  }
}
</code></pre>

<p>以非后台模式运行 nginx。当你运行 nginx 时它应该看起来像如下这样：</p>

<p><img src="/wp-content/uploads/2015/07/nginx_non_daemon.png" alt="nginx_non_daemon" />
<em>Nginx 以非后台模式运行</em></p>

<h2>自定义应用服务</h2>

<p>既然我们已经知道了如何将 nginx 与我们程序进行连接，那么我们就来构建一个简单的应用服务。
当 nginx 将请求转发到我们的 socket 时，它是一个标准的 HTTP 请求。
经过一些处理后我可以决定 socket 是否会返回一个有效的 HTTP 响应，它会在浏览器中显示。</p>

<p>下面这个应用接受任何请求并显示时间戳。</p>

<pre><code class="ruby">require "socket"

# Connection creates the socket and accepts new connections
class Connection

  attr_accessor :path

  def initialize(path:)
    @path = path
    File.unlink(path) if File.exists?(path)
  end

  def server
    @server ||= UNIXServer.new(@path)
  end

  def on_request
    socket = server.accept
    yield(socket)
    socket.close
  end
end


# AppServer logs incoming requests and renders a view in response
class AppServer

  attr_reader :connection
  attr_reader :view

  def initialize(connection:, view:)
    @connection = connection
    @view = view
  end

  def run
    while true
      connection.on_request do |socket|
        while (line = socket.readline) != "\r\n"
          puts line
        end
        socket.write(view.render)
      end
    end
  end

end

# TimeView simply provides the HTTP response
class TimeView
  def render
%[HTTP/1.1 200 OK


The current timestamp is: #{ Time.now.to_i }

]
  end
end


AppServer.new(connection: Connection.new(path: '/tmp/socktest.sock'), view: TimeView.new).run
</code></pre>

<p>现在运行 nginx 和脚本，然后访问 localhost:2048。请求会发送到我的应用上，然后响应被浏览器渲染。太酷了！</p>

<p><img src="/wp-content/uploads/2015/07/appserver.png" alt="appserver" />
<em>HTTP 请求信息由我们的应用服务输出到 STDOUT</em></p>

<p>以下就是我们的劳动成果。</p>

<p><img src="/wp-content/uploads/2015/07/timestamp.png" alt="timestamp" />
<em>浏览器中显示服务端返回的时间戳</em></p>

<p>原文地址： <a href="http://blog.honeybadger.io/how-unicorn-talks-to-nginx-an-introduction-to-unix-sockets-in-ruby/">http://blog.honeybadger.io/how-unicorn-talks-to-nginx-an-introduction-to-unix-sockets-in-ruby/</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Ruby的内存陷阱]]></title>
    <link href="http://www.xefan.com/archives/84145.html"/>
    <updated>2015-05-14T21:24:21+08:00</updated>
    <id>http://www.xefan.com/archives/84145-Ruby的内存陷阱</id>
    <content type="html"><![CDATA[<p>Ruby有一套自动的内存管理机制。这在大多数情况下是不错的，但是有时它却是个麻烦。</p>

<p>Ruby的内存管理既简洁又笨重。它将对象（名为 <code>RVALUE</code>）存储在大约有16KB大小的堆中。
从底层上，<code>RVALUE</code> 是一个 <code>C</code> 的结构体，它包含了一个共同体表示不同的标准ruby对象。</p>

<p>因此在堆中存储着大小不超过40字节的 <code>RVALUE</code> 对象，如 <code>String</code>、<code>Array</code>、<code>Hash</code>等。
这意味着小的对象在堆中很合适，但是一旦它们达到到阈值，那么就需要在Ruby的堆之外再分配一片额外的内存。</p>

<p><strong>这块额外的内存空间是灵活的。一旦对象被垃圾回收了它就会被释放掉。但是堆本身的内存是不会被释放给操作系统的。</strong></p>

<p>让我们来看一个简单的例子：</p>

<pre><code class="ruby">def report
  puts 'Memory ' + `ps ax -o pid,rss | grep -E "^[[:space:]]*#{$$}"`
          .strip.split.map(&amp;:to_i)[1].to_s + 'KB'
end

report
big_var = " " * 10_000_000
report
big_var = nil
report
ObjectSpace.garbage_collect
sleep 1
report

# ⇒ Memory 11788KB
# ⇒ Memory 65188KB
# ⇒ Memory 65188KB
# ⇒ Memory 11788KB
</code></pre>

<p>这里我们分配了大量的内存，使用完后又释放给操作系统。这一切看起来似乎没有问题。现在让我们稍微修改一下代码：</p>

<pre><code class="ruby">-  big_var = " " * 10_000_000
+  big_var = 1_000_000.times.map(&amp;:to_s)
</code></pre>

<p>这只是一个简单的修改，不是吗。但是结果：</p>

<pre><code># ⇒ Memory 11788KB
# ⇒ Memory 65188KB
# ⇒ Memory 65188KB
# ⇒ Memory 57448KB
</code></pre>

<p>怎么回事？内存没有释放归还给操作系统。这是因为数组中的每个元素符合 <code>RVALUE</code> 的大小并存储在ruby的堆中。</p>

<p>在大多情况下这是正常的。现在ruby堆中多了许多空的位置，再次运行代码将不会再消耗额外的内存了。
每次我们处理 <code>big_var</code> 和一些空的堆时， <code>GC[:heap_used]</code>的值果然减小了。
对于这些操作Ruby是早有准备，注意这里是Ruby而不是操作系统。</p>

<p>因此，对于创建大量的符合40个字节的临时变量就要注意了：</p>

<pre><code>big_var = " " * 10_000_000
big_var.gsub(/\s/) { |c| '-' }
</code></pre>

<p>结果同样是Ruby的内存疯狂增长，并且这部分内存在程序运行期间是不会归还给操作系统的：</p>

<pre><code># ⇒ Memory 10156KB
# ⇒ Memory 13788KB
# ⇒ Memory 13788KB
# ⇒ Memory 12808KB
</code></pre>

<p>这个问题不是太重要，稍微注意一下即可。</p>

<p>原文地址：<a href="http://rocket-science.ru/hacking/2013/12/17/ruby-memory-pitfalls/">http://rocket-science.ru/hacking/2013/12/17/ruby-memory-pitfalls/</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[未来的Ruby 3.0]]></title>
    <link href="http://www.xefan.com/archives/84144.html"/>
    <updated>2015-05-13T21:33:08+08:00</updated>
    <id>http://www.xefan.com/archives/84144-未来的Ruby 3.0</id>
    <content type="html"><![CDATA[<p>原文地址：<a href="http://hrnabi.com/2015/05/12/7035/  ">http://hrnabi.com/2015/05/12/7035/  </a>
谁日语好的为大家做下贡献，把原文翻译一下吧。</p>

<p>反正我不会日语，根据文中的一些汉字连蒙带猜的，大致看了一遍，现在简单总结一下。
如果有总结得不对的，本人不负责哦。</p>

<p>看来要玩好Ruby不仅需要学英语，也还得学日语啊。</p>

<hr />

<p>在2014年9月举行的 RubyKaigi 2014 大会上，Matz在演讲过程中首次提到了 Ruby 3.0。<br/>
文中说的Ruby 3.0的三个工作方向：</p>

<ul>
<li>Concurrency (并行性)</li>
<li>JIT (即时编译)</li>
<li>Static typing (静态类型)</li>
</ul>


<p>Ruby要引入静态类型检查？<br/>
Matz说，在20世纪出生的语言大多是脚本语言，如：Ruby、PHP和Perl、JavaScript，这些都不是静态类型的。
另一方面，最近推出的如Scala和Dart、Go是属于静态类型的。
在Ruby中可以考虑引入Python这种通过注释来进行检查的方法。</p>

<p>Ruby要引入并行计算？<br/>
Matz详细讨论了静态类型，但没有提到并行计算。详细的内容是由笹田氏来说的。<br/>
（这部分内容我没看懂，只是大概知道这位笹田氏的博士论文与这个相关。）<br/>
关于并行计算，Matz提到了Erlang和Scala的actor模型。</p>

<p>最后期待下一个Ruby开发者大会。</p>

<hr />

<p>好了，我只看懂了这么多。其余的各位感兴趣的自己去看原文吧。
(怎么感觉好坑啊，这总结得跟没总结一样啊。没办法了我的日语水平有限。)</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Ruby中一些重要的钩子方法]]></title>
    <link href="http://www.xefan.com/archives/84143.html"/>
    <updated>2015-04-30T22:35:42+08:00</updated>
    <id>http://www.xefan.com/archives/84143-Ruby中一些重要的钩子方法</id>
    <content type="html"><![CDATA[<p>Ruby的哲学理念是基于一个基本的要素，那就是让程序员快乐。Ruby非常注重程序员的快乐，并且也提供了许多不同的方法来实现它。
它的元编程能力能够让程序员编写在运行时动态生成的代码。它的线程功能使得程序员有一种优雅的的方式编写多线程代码。
它的钩子方法能让程序员在程序运行时扩展它的行为。</p>

<p>上述的这些特性，以及一些其他很酷的语言方面，使得Ruby成为编写代码的优先选择之一。
本文将探讨Ruby中的一些重要的钩子方法。我们将从不同方面讨论钩子方法，如它们是什么，它们用于什么，以及我们如何使用它们来解决不同的问题。
我们同时也了解一下一些流行的Ruby框架/Gem包/库是如何使用它们来提供非常酷的特性的。</p>

<p>我们开始吧。</p>

<h1>什么是钩子方法？</h1>

<p>钩子方法提供了一种方式用于在程序运行时扩展程序的行为。
假设有这样的功能，可以在无论何时一个子类继承了一些特定的父类时收到通知，
或者是比较优雅地处理一个对象上的不可调用的方法而不是让编译器抛出异常。
这些情况就是使用钩子方法，但是它们的用法并不仅限于此。
不同的框架/库使用了不同的钩子方法来实现它们的功能。</p>

<p>在本文中我们将会讨论如下几个钩子方法：</p>

<ul>
<li>included</li>
<li>extended</li>
<li>prepended</li>
<li>inherited</li>
<li>method_missing</li>
</ul>


<h2>included</h2>

<p>Ruby给我们提供了一种方式使用 <code>模块(modules)</code> （在其他语言中被称作 <code>混入类(mixins)</code>）来编写模块化的代码供其他的 <code>模块</code>/<code>类</code> 使用。
<code>模块</code> 的概念很简单，它就是一个可以在其他地方使用的独立代码块。</p>

<p>例如，如果我们想要编写一些代码在任何时候调用特定的方法都会返回一个静态字符串。
我们姑且将这个方法称作 <code>name</code>。你可能在其他地方也会想使用同一块代码。
这样最好是新建一个模块。让我们来创建一个：</p>

<pre><code class="ruby">module Person
  def name
    puts "My name is Person"
  end
end
</code></pre>

<p>这是一个非常简单的模块，仅有一个 <code>name</code> 方法用于返回一个静态字符串。在我们的程序中使用这个模块：</p>

<pre><code class="ruby">class User
  include Person
end
</code></pre>

<p>Ruby提供了一些不同的方法来使用<code>模块</code>。<code>include</code> 是其中之一。<code>include</code> 所做的就是将在 <code>module</code> 内定义的方法在一个 <code>class</code> 的实例变量上可用。
在我们的例子中，是将 <code>Person</code> 模块中定义的方法变为一个 <code>User</code> 类实例对象的方法。
这就相当于我们是将 <code>name</code> 方法写在 <code>User</code> 类里一样，但是定义在 <code>module</code> 里的好处是可复用。
要调用 <code>name</code> 方法我们需要创建一个 <code>User</code> 的实例对象，然后再在这个对象上调用 <code>name</code> 方法。例如：</p>

<pre><code class="ruby">User.new.name
=&gt; My name is Person
</code></pre>

<p>让我们看看基于 <code>include</code> 的钩子方法。<code>included</code> 是Ruby提供的一个钩子方法，当你在一些 <code>module</code> 或者 <code>class</code> 中 <code>include</code> 了一个 <code>module</code> 时它会被调用。
更新 <code>Person</code> 模块：</p>

<pre><code class="ruby">module Person
  def self.included(base)
    puts "#{base} included #{self}"
  end

  def name
    "My name is Person"
  end
end
</code></pre>

<p>你可以看到一个新的方法 <code>included</code> 被定义为 <code>Person</code> 模块的类方法。当你在其他的模块或者类中执行 <code>include Person</code> 时，这个 <code>included</code> 方法会被调用。
该方法接收的一个参数是对包含该模块的类的引用。试试运行 <code>User.new.name</code>，你会看到如下的输出：</p>

<pre><code class="ruby">User included Person
My name is Person
</code></pre>

<p>正如你所见，<code>base</code> 返回的是包含该模块的类名。现在我们有了一个包含 <code>Person</code> 模块的类的引用，我们可以通过元编程来实现我们想要的功能。
让我们来看看 <strong>Devise</strong>是如何使用 <code>included</code> 钩子的。</p>

<h3>Devise中的 <code>included</code></h3>

<p>Devise是Ruby中使用最广泛的身份验证gem包之一。它主要是由我喜欢的程序员 <a href="https://twitter.com/josevalim">José Valim</a> 开发的，现在是由一些了不起的贡献者在维护。
Devise为我们提供了从注册到登录，从忘记密码到找回密码等等完善的功能。它可以让我们在用户模型中使用简单的语法来配置各种模块：</p>

<pre><code class="ruby">devise :database_authenticatable, :registerable, :validatable
</code></pre>

<p>在我们模型中使用的 <code>devise</code> 方法在<a href="https://github.com/plataformatec/devise/blob/v3.4.1/lib/devise/models.rb#L77">这里</a>定义。
为了方便我将这段代码粘贴在下面：</p>

<pre><code class="ruby">def devise(*modules)
  options = modules.extract_options!.dup

  selected_modules = modules.map(&amp;:to_sym).uniq.sort_by do |s|
    Devise::ALL.index(s) || -1  # follow Devise::ALL order
  end

  devise_modules_hook! do
    include Devise::Models::Authenticatable

    selected_modules.each do |m|
      mod = Devise::Models.const_get(m.to_s.classify)

      if mod.const_defined?("ClassMethods")
        class_mod = mod.const_get("ClassMethods")
        extend class_mod

        if class_mod.respond_to?(:available_configs)
          available_configs = class_mod.available_configs
          available_configs.each do |config|
            next unless options.key?(config)
            send(:"#{config}=", options.delete(config))
          end
        end
      end

      include mod
    end

    self.devise_modules |= selected_modules
    options.each { |key, value| send(:"#{key}=", value) }
  end
end
</code></pre>

<p>在我们的模型中传给 <code>devise</code> 方法的模块名将会作为一个数组保存在 <code>*modules</code> 中。
对于传入的模块调用 <code>extract_options!</code> 方法提取可能传入的选项。
在11行中调用 <code>each</code> 方法，并且每个模块在代码块中用 <code>m</code> 表示。
在12行中 <code>m</code> 将会转化为一个常量（类名），因此使用 <code>m.to.classify</code> 一个例如 <code>:validatable</code> 这样的符号会变为 <code>Validatable</code> 。
随便说一下 <code>classify</code> 是ActiveSupport的方法。<br/>
<code>Devise::Models.const_get(m.to_classify)</code> 会获取该模块的引用，并赋值给 <code>mod</code>。
在27行使用 <code>include mod</code> 包含该模块。
例子中的 <code>Validatable</code> 模块是定义在<a href="https://github.com/plataformatec/devise/blob/v3.4.1/lib/devise/models/validatable.rb">这里</a>。
<code>Validatable</code> 的 <code>included</code> 钩子方法定义如下：</p>

<pre><code class="ruby">def self.included(base)
  base.extend ClassMethods
  assert_validations_api!(base)

  base.class_eval do
    validates_presence_of   :email, if: :email_required?
    validates_uniqueness_of :email, allow_blank: true, if: :email_changed?
    validates_format_of     :email, with: email_regexp, allow_blank: true, if: :email_changed?

    validates_presence_of     :password, if: :password_required?
    validates_confirmation_of :password, if: :password_required?
    validates_length_of       :password, within: password_length, allow_blank: true
  end
end
</code></pre>

<p>此时模型是 <code>base</code>。在第5行的 <code>class_eval</code> 代码块会以该类作为上下文进行求值运算。
通过 <code>class_eval</code> 编写的代码与直接打开该类的文件将代码粘贴进去效果是一样的。
Devise是通过 <code>class_eval</code> 将验证包含到我们的用户模型中的。</p>

<p>当我们试着使用Devise注册或者登录时，我们会看到这些验证，但是我们并没有编写这些验证代码。
Devise是利用了 <code>included</code> 钩子来实现这些的。非常的优雅吧。</p>

<h2>extended</h2>

<p>Ruby也允许开发者 <code>扩展(extend)</code> 一个模块，这与 <code>包含(include)</code> 有点不同。
<code>extend</code> 是将定义在 <code>模块(module)</code> 内的方法应用为类的方法，而不是实例的方法。
让我们来看一个简单的例子：</p>

<pre><code class="ruby">module Person
  def name
    "My name is Person"
  end
end

class User
  extend Person
end

puts User.name # =&gt; My name is Person
</code></pre>

<p>正如你所看到的，我们将 <code>Person</code> 模块内定义的 <code>name</code> 方法作为了 <code>User</code> 的类方法调用。
<code>extend</code> 将 <code>Person</code> 模块内的方法添加到了 <code>User</code> 类中。<code>extend</code> 同样也可以用于将模块内的方法作为单例方法(singleton methods)。
让我们再来看另外一个例子：</p>

<pre><code class="ruby"># We are using same Person module and User class from previous example.     

u1 = User.new
u2 = User.new

u1.extend Person

puts u1.name # =&gt; My name is Person
puts u2.name # =&gt; undefined method `name' for #&lt;User:0x007fb8aaa2ab38&gt; (NoMethodError)
</code></pre>

<p>我们创建了两个 <code>User</code> 的实例对象，并将 <code>Person</code> 作为参数在 <code>u1</code> 上调用 <code>extend</code> 方法。
使用这种调用方式，<code>Person</code> 的 <code>name</code> 方法仅对 <code>u1</code> 有效，对于其他实例是无效的。</p>

<p>正如 <code>included</code> 一样，与 <code>extend</code> 相对应的钩子方法是 <code>extended</code>。
当一个模块被其他模块或者类执行了 <code>extend</code> 操作时，该方法将会被调用。
让我们来看一个例子：</p>

<pre><code class="ruby"># Modified version of Person module

module Person
  def self.extended(base)
    puts "#{base} extended #{self}"
  end

  def name
    "My name is Person"
  end
end

class User
  extend Person
end
</code></pre>

<p>该代码的运行结果是输出 <code>User extended Person</code>。</p>

<p>关于 <code>extended</code> 的介绍已经完了，让我们来看看 <code>ActiveRecord</code> 是如何使用它的。</p>

<h3>ActiveRecord中的 <code>extended</code></h3>

<p><code>ActiveRecord</code> 是在 Ruby 以及 Rails 中广泛使用的ORM框架。它具有许多酷的特性，
因此使用它在很多情况下成为了ORM的首选。让我们进入 <code>ActiveRecord</code> 内部看看 <code>ActiveRecord</code> 是如何使用回调的。
(我们使用的是 Rails v3.2.21)</p>

<p><code>ActiveRecord</code> 在<a href="https://github.com/rails/rails/blob/v3.2.21/activerecord/lib/active_record/callbacks.rb#L246">这里</a> <code>extend</code> 了 <code>ActiveRecord::Models</code> 模块。</p>

<pre><code class="ruby">extend ActiveModel::Callbacks
</code></pre>

<p><code>ActiveModel</code> 提供了一套在模型类中使用的接口。它们允许 ActionPack 与不是 ActiveRecord 的模型进行交互。
在<a href="https://github.com/rails/rails/blob/v3.2.21/activemodel/lib/active_model/callbacks.rb#L49-L53">这里</a>， <code>ActiveModel::Callbacks</code> 内部你将会看到如下代码：</p>

<pre><code class="ruby">def self.extended(base)
  base.class_eval do
    include ActiveSupport::Callbacks
  end
end
</code></pre>

<p><code>ActiveModel::Callbacks</code> 对 <code>base</code> 即就是 <code>ActiveRecord::Callbacks</code> 调用了 <code>class_eval</code> 方法，
并包含了 <code>ActiveSupport::Callbacks</code> 模块。我们前面已经提到过了，对一个类调用 <code>class_eval</code> 与手动地将代码写在这个类里是一样的。
<code>ActiveSupport::Callbacks</code> 为 <code>ActiveRecord::Callbacks</code> 提供了 Rails 中的回调方法。</p>

<p>这里我们讨论了 <code>extend</code> 方法，以及与之对应的钩子 <code>extended</code>。并且也了解了 <code>ActiveRecord</code> / <code>ActiveModel</code>
是如何使用上述方法为我们提供可用功能的。</p>

<h2>prepended</h2>

<p>另一个使用定义在模块内部方法的方式称为 <code>prepend</code>。<code>prepend</code> 是在Ruby 2.0中引入的，并且与 <code>include</code> 和 <code>extend</code> 很不一样。
使用 <code>include</code> 和 <code>extend</code> 引入的方法可以被目标模块/类重新定义覆盖。
例如，如果我们在某个模块中定义了一个名为 <code>name</code> 的方法，并且在目标模块/类中也定义同名的方法。
那么这个在我们类在定义的 <code>name</code> 方法将会覆盖模块中的。而 <code>prepend</code> 是不一样的，它会将 <code>prepend</code> 引入的模块
中的方法覆盖掉我们模块/类中定义的方法。让我们来看一个简单的例子：</p>

<pre><code class="ruby">module Person
  def name
    "My name belongs to Person"
  end
end

class User
  include Person
  def name
    "My name belongs to User"
  end
end

puts User.new.name 
=&gt; My name belongs to User
</code></pre>

<p>现在再来看看 <code>prepend</code> 的情况：</p>

<pre><code class="ruby">module Person
  def name
    "My name belongs to Person"
  end
end

class User
  prepend Person
  def name
    "My name belongs to User"
  end
end

puts User.new.name 
=&gt; My name belongs to Person
</code></pre>

<p>使用 <code>prepend Person</code> 会将 <code>User</code> 中的同名方法给覆盖掉，因此在终端输出的结果为 <code>My name belongs to Person</code>。
<code>prepend</code> 实际上是将方法添加到方法链的前端。在调用 <code>User</code> 类内定义的 <code>name</code> 方法时，会调用 <code>super</code> 从而调用 <code>Person</code> 模块的 <code>name</code>。</p>

<p>与 <code>prepend</code> 对应的回调名为（你应该猜到了） <code>prepended</code>。当一个模块被预置到另一个模块/类中时它会被调用。
我们来看下效果。更新 <code>Person</code> 模块的定义：</p>

<pre><code class="ruby">module Person
  def self.prepended(base)
    puts "#{self} prepended to #{base}"
  end

  def name
    "My name belongs to Person"
  end
end
</code></pre>

<p>你再运行这段代码应该会看到如下结果：</p>

<pre><code>Person prepended to User
My name belongs to Person
</code></pre>

<p><code>prepend</code> 的引入是为了去除 <code>alias_method_chain</code> hack的丑陋，它曾被Rails以及其他库广泛地使用以达到与 <code>prepend</code> 相同的功能。
因为 <code>prepend</code> 只有在 Ruby >= 2.0 的版本中才能使用，因此如果你打算使用 <code>prepend</code> 的话，那么你就应该升级你的Ruby版本。</p>

<h2>inherited</h2>

<p>继承是面向对象中一个最重要的概念。Ruby是一门面向对象的编程语言，并且提供了从基/父类继承一个子类的功能。
我们来看一个简单的例子：</p>

<pre><code class="ruby">class Person
  def name
     "My name is Person"
  end
end

class User &lt; Person
end

puts User.new.name # =&gt; My name is Person
</code></pre>

<p>我们创建了一个 <code>Person</code> 类和一个子类 <code>User</code>。在 <code>Person</code> 中定义的方法也成为了 <code>User</code> 的一部分。
这是非常简单的继承。你可能会好奇，是否有什么方法可以在一个类被其他类继承时收到通知呢？
是的，Ruby有一个名为 <code>inherited</code> 的钩子可以实现。我们再看看这个例子：</p>

<pre><code class="ruby">class Person
  def self.inherited(child_class)
    puts "#{child_class} inherits #{self}"
  end

  def name
    "My name is Person"
  end
end

class User &lt; Person
end

puts User.new.name
</code></pre>

<p>正如你所见，当 <code>Person</code> 类被其他子类继承时 <code>inherited</code> 类方法将会被调用。
运行以上代码结果如下：</p>

<pre><code>User inherits Person
My name is Person
</code></pre>

<p>让我们看看 <code>Rails</code> 在它的代码中是如何使用 <code>inherited</code> 的。</p>

<h3>Rails中的 <code>inherited</code></h3>

<p>Rails应用中有一个重要的类名为 <code>Application</code> ，定义中 <strong>config/application.rb</strong> 文件内。
这个类执行了许多不同的任务，如运行所有的Railties，引擎以及插件的初始化。
关于 <code>Application</code> 类的一个有趣的事件是，在同一个进程中不能运行两个实例。
如果我们尝试修改这个行为，Rails将会抛出一个异常。让我们来看看Rails是如何实现这个特性的。</p>

<p><code>Application</code> 类继承自 <code>Rails::Application</code>，它是在<a href="https://github.com/rails/rails/blob/v3.2.21/railties/lib/rails/application.rb">这里</a>定义的。
在62行定义了 <code>inherited</code> 钩子，它会在我们的Rails应用 <code>Application</code> 类继承 <code>Rails::Application</code> 时被调用。
<code>inherited</code> 钩子的代码如下：</p>

<pre><code class="ruby">class &lt;&lt; self
  def inherited(base)
    raise "You cannot have more than one Rails::Application" if Rails.application
    super
    Rails.application = base.instance
    Rails.application.add_lib_to_load_path!
    ActiveSupport.run_load_hooks(:before_configuration, base.instance)
  end
end
</code></pre>

<p><code>class &lt;&lt; self</code> 是Ruby中的另一个定义类方法的方式。在 <code>inherited</code> 中的第1行是检查 <code>Rails.application</code> 是否已存在。
如果存在则抛出异常。第一次运行这段代码时 <code>Rails.application</code> 会返回false然后调用 <code>super</code>。
在这里 <code>super</code> 即是 <code>Rails::Engine</code> 的 <code>inherited</code> 钩子，因为 <code>Rails::Application</code> 继承自 <code>Rails::Engine</code>。</p>

<p>在下一行，你会看到 <code>Rails.application</code> 被赋值为 <code>base.instance</code> 。其余就是设置Rails应用了。</p>

<p>这就是Rails如何巧妙地使用 <code>inherited</code> 钩子来实现我们的Rails <code>Application</code> 类的单实例。</p>

<h2>method_missing</h2>

<p><code>method_missing</code> 可能是Ruby中使用最广的钩子。在许多流行的Ruby框架/gem包/库中都有使用它。
当我们试图访问一个对象上不存在的方法时则会调用这个钩子方法。
让我们来看一个简单的例子：</p>

<pre><code class="ruby">class Person
  def name
    "My name is Person"
  end
end

p = Person.new

puts p.name     # =&gt; My name is Person 
puts p.address  # =&gt; undefined method `address' for #&lt;Person:0x007fb730a2b450&gt; (NoMethodError)
</code></pre>

<p>我们定义了一个简单的 <code>Person</code> 类， 它只有一个 <code>name</code> 方法。然后创建一个 <code>Person</code> 的实例对象，
并分别调用 <code>name</code> 和 <code>address</code>　两个方法。因为 <code>Person</code> 中定义了 <code>name</code>，因此这个运行没问题。
然而 <code>Person</code> 并没有定义 <code>address</code>，这将会抛出一个异常。
<code>method_missing</code> 钩子可以优雅地捕捉到这些未定义的方法，避免此类异常。
让我们修改一下 <code>Person</code> 类：</p>

<pre><code class="ruby">class Person
  def method_missing(sym, *args)
     "#{sym} not defined on #{self}"
  end

  def name
    "My name is Person"
  end
end

p = Person.new

puts p.name     # =&gt; My name is Person
puts p.address  # =&gt; address not defined on #&lt;Person:0x007fb2bb022fe0&gt;
</code></pre>

<p><code>method_missing</code> 接收两个参数：被调用的方法名和传递给该方法的参数。
首先Ruby会寻找我们试图调用的方法，如果方法没找到则会寻找 <code>method_missing</code> 方法。
现在我们重载了 <code>Person</code> 中的 <code>method_missing</code>，因此Ruby将会调用它而不是抛出异常。</p>

<p>让我们来看看 <code>Rake</code> 是如何使用 <code>method_missing</code> 的。</p>

<h3>Rake中的 <code>method_missing</code></h3>

<p><code>Rake</code> 是Ruby中使用最广泛的gem包之一。<code>Rake</code> 使用 <code>method_missing</code> 来提供访问传递给Rake任务的参数。
首先创建一个简单的rake任务：</p>

<pre><code class="ruby">task :hello do
  puts "Hello"
end
</code></pre>

<p>如果你通过调用 <code>rake hello</code> 来执行这个任务，你会看到输出 <code>Hello</code>。
让我们扩展这个rake任务，以便接收一个参数（一个人名）并向他打招呼：</p>

<pre><code class="ruby">task :hello, :name do |t, args|
  puts "Hello #{args.name}"
end
</code></pre>

<p><code>t</code> 是任务名，<code>args</code> 保存了传递过来的参数。正如你所见，我们调用 <code>args.name</code> 来获取传递给 <code>hello</code> 任务的 <code>name</code> 参数。
运行该任务，并传递一个参数：</p>

<pre><code class="ruby">rake hello["Imran Latif"]
=&gt; Hello Imran Latif
</code></pre>

<p>让我们来看看 <code>Rake</code> 是如何使用 <code>method_missing</code> 为我们提供了传递给任务的参数的。</p>

<p>在上面任务中的 <code>args</code> 对象是一个 <code>Rake::TaskArguments</code> 实例，它是在<a href="https://github.com/ruby/rake/blob/v10.4.2/lib/rake/task_arguments.rb">这里</a>所定义。
这个类负责管理传递给Rake任务的参数。查看 <code>Rake::TaskArguments</code> 的代码，你会发现并没有定义相关的方法将参数传给任务。
那么 <code>Rake</code> 是如何将参数提供给任务的呢？答案是 <code>Rake</code> 是使用了 <code>method_missing</code> 巧妙地实现了这个功能。
看看第64行 <code>method_missing</code> 的定义：</p>

<pre><code class="ruby">def method_missing(sym, *args)
  lookup(sym.to_sym)
end
</code></pre>

<p>在这个类中定义 <code>method_missing</code> 是为了保证能够访问到那些未定义的方法，而不是由Ruby抛出异常。
在 <code>method_missing</code> 中它调用了 <code>lookup</code> 方法：</p>

<pre><code class="ruby">def lookup(name)
  if @hash.has_key?(name)
   @hash[name]
  elsif @parent
    @parent.lookup(name)
  end
end
</code></pre>

<p><code>method_missing</code> 调用 <code>lookup</code>，并将方法名以 <code>Symbol(符号)</code> 的形式传递给它。
<code>lookup</code> 方法将会在 <code>@hash</code> 中进行查找，它是在 <code>Rake::TaskArguments</code> 的构造函数中创建的。
如果 <code>@hash</code> 中包含该参数则返回，如果在 <code>@hash</code> 中没有则 <code>Rake</code> 会尝试调用 <code>@parent</code> 的 <code>lookup</code>。
如果该参数没有找到，则什么都不返回。</p>

<p>这就是 <code>Rake</code> 如何巧妙地使用 <code>method_missing</code> 提供了访问传递给Rake任务的参数的。
感谢<a href="https://twitter.com/jimweirich">Jim Weirich</a>编写了Rake。</p>

<h1>结束语</h1>

<p>我们讨论了5个重要的Ruby钩子方法，探索了它们是如何工作的，以及一些流行的框架/gem包是如何使用它们来提供一些优雅的功能。
我希望你能喜欢这篇文章。请在评论中告诉我们你所喜欢的Ruby钩子，以及你使用它们所解决的问题。</p>

<p>原文地址： <a href="http://www.sitepoint.com/rubys-important-hook-methods/">http://www.sitepoint.com/rubys-important-hook-methods/</a></p>
]]></content>
  </entry>
  
</feed>
