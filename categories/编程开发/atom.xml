<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: 编程开发 | 龍昌博客]]></title>
  <link href="http://www.xefan.com/categories/编程开发/atom.xml" rel="self"/>
  <link href="http://www.xefan.com/"/>
  <updated>2016-06-26T14:00:18+08:00</updated>
  <id>http://www.xefan.com/</id>
  <author>
    <name><![CDATA[龍昌]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[ReactNative Jsbundle管理]]></title>
    <link href="http://www.xefan.com/archives/84163.html"/>
    <updated>2016-06-26T12:02:30+08:00</updated>
    <id>http://www.xefan.com/archives/84163-ReactNative jsbundle管理</id>
    <content type="html"><![CDATA[<p>在<a href="http://www.xefan.com/archives/84162.html">上一篇文章</a>中介绍了 RN(ReactNative) 自动设置 development server IP 的方法。
这在开发过程中方便了不少，然而我在想能否更加方便一些呢。首先我们知道在开发 RN 应用时，jsbundle 有两种加载方式。
第一种是指定 url 通过网络进行加载；第二种是 pre-bundled 将 jsbundle 文件打包进 app 安装包中。
编译生成的安装包有 Debug 和 Release 两种模式，在 Debug 模式下默认是使用第一种方式加载 jsbundle，在 Release 模式下默认是使用第二种方式。</p>

<p>现在我的需求是编译生成三种模式的安装包：Debug、Release 和 Stage。前两种跟之前一样，
而 Stage 模式下是使用第二种方式加载 jsbundle， 但是生成的 jsbundle 是 DEV 状态下的。
这样在开发过程中给他人安装app进行测试时就不需要反复的修改配置了。</p>

<h2>修改 Android 的配置</h2>

<p>对于的 android 的配置比较简单。只需修改 <code>android/app/build.gradle</code> 文件，新添加一个 <code>buildTypes</code> 即可。</p>

<p>在 <code>apply from: "react.gradle"</code> 之前添加如下内容：</p>

<pre><code>project.ext.react = [
  bundleInStage: true
]
</code></pre>

<p>然后再修改配置如下：</p>

<pre><code>android {
    buildTypes {
        debug {
            applicationIdSuffix ".debug"
            resValue 'string', 'app_name', '"XXXX(Debug)"'
            ......
        }
        release {
            minifyEnabled enableProguardInReleaseBuilds
            proguardFiles getDefaultProguardFile("proguard-android.txt"), "proguard-rules.pro"
            resValue 'string', 'app_name', '"XXXX"'
            ......
        }
        stage {
            initWith(buildTypes.debug)
            applicationIdSuffix ".stage"
            resValue 'string', 'app_name', '"XXXX(Stage)"'
        }
    }
}
</code></pre>

<p>这里添加了一个 <code>stage</code> buildTypes 继承至 <code>debug</code>。并且为了能够同时安装不同模式下的app，这里设置了不同模式 bundleID 的后缀。
同时还设置了不同模式下app的名称，以便区分。</p>

<p>然后进行 <code>android</code> 目录下执行 <code>./gradlew assemble</code> 命令，即可在 <code>android/app/build/outputs/apk</code> 目录生成 app-debug.apk、app-release.apk 和 app-stage.apk 三个 apk 包。</p>

<h2>修改 iOS 的配置</h2>

<p>首先将 Debug Configuration 复制为 Stage
<img src="/wp-content/uploads/2016/06/26/Xcode-configuration.png" alt="Xcode-configuration" /></p>

<p>然后进入 <code>Build Settings</code> 修改 <code>Preprocessor Macros</code>，对 <code>Stage</code> 添加一项配置： <code>STAGE=1</code>
<img src="/wp-content/uploads/2016/06/26/Xcode-buildSettings.png" alt="Xcode-buildSettings" /></p>

<p>然后再编辑 <code>AppDelegate.m</code> 文件，修改 <code>jsCodeLocation</code> 相关配置。</p>

<pre><code>#if STAGE
#warning "STAGE"
  jsCodeLocation = [[NSBundle mainBundle] URLForResource:@"main" withExtension:@"jsbundle"];
#elif DEBUG
#if TARGET_OS_SIMULATOR
#warning "DEBUG SIMULATOR"
  jsCodeLocation = [NSURL URLWithString:@"http://localhost:8081/index.ios.bundle?platform=ios&amp;dev=true"];
#else
#warning "DEBUG DEVICE"
  NSString *serverIP = [[NSBundle mainBundle] objectForInfoDictionaryKey:@"SERVER_IP"];
  NSString *jsCodeUrlString = [NSString stringWithFormat:@"http://%@:8081/index.ios.bundle?platform=ios&amp;dev=true", serverIP];
  NSString *jsBundleUrlString = [jsCodeUrlString stringByAddingPercentEscapesUsingEncoding:NSUTF8StringEncoding];
  jsCodeLocation = [NSURL URLWithString:jsBundleUrlString];
#endif
#else
#warning "PRODUCTION DEVICE"
  jsCodeLocation = [[NSBundle mainBundle] URLForResource:@"main" withExtension:@"jsbundle"];
#endif
</code></pre>

<p>为了能够同时安装多个应用，还需要设置各个模式下的 Bundle Identifier。进入 <code>Build Settings</code> -> <code>Packaging</code> -> <code>Product Bundle Identifier</code>
<img src="/wp-content/uploads/2016/06/26/Xcode-bundleID.png" alt="Xcode-bundleID" /></p>

<p>为了便于区分，最好给各个模式下的应用设置不同的AppName。进入 <code>Build Settings</code> -> <code>User-Defined</code>，添加一项设置
<img src="/wp-content/uploads/2016/06/26/Xcode-User-Defined.png" alt="Xcode-User-Defined" /></p>

<p>然后再进入 <code>Info</code>，设置 <code>CFBundleDisplayName</code> 的值为 <code>$(BUNDLE_DISPLAY_NAME)</code></p>

<p>至此，配置已经修改完成。如果之前有使用 cocoapods 安装过第三方库的话，那么可能还需要再重新安装一遍。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[ReactNative自动设置开发服务器IP]]></title>
    <link href="http://www.xefan.com/archives/84162.html"/>
    <updated>2016-06-18T21:40:01+08:00</updated>
    <id>http://www.xefan.com/archives/84162-ReactNative自动设置开发服务器IP</id>
    <content type="html"><![CDATA[<p>在开发 ReactNative 应用时，jsbundle 有两种加载方式。第一种是指定 url 通过网络进行加载；第二种是 pre-bundled 将 jsbundle 文件打包进 app 安装包中。</p>

<p>以下就是创建项目之后 ios 的默认配置。</p>

<pre><code>  /**
   * Loading JavaScript code - uncomment the one you want.
   *
   * OPTION 1
   * Load from development server. Start the server from the repository root:
   *
   * $ npm start
   *
   * To run on device, change `localhost` to the IP address of your computer
   * (you can get this by typing `ifconfig` into the terminal and selecting the
   * `inet` value under `en0:`) and make sure your computer and iOS device are
   * on the same Wi-Fi network.
   */

  jsCodeLocation = [NSURL URLWithString:@"http://localhost:8081/index.ios.bundle?platform=ios&amp;dev=true"];

  /**
   * OPTION 2
   * Load from pre-bundled file on disk. The static bundle is automatically
   * generated by the "Bundle React Native code and images" build step when
   * running the project on an actual device or running the project on the
   * simulator in the "Release" build configuration.
   */

//   jsCodeLocation = [[NSBundle mainBundle] URLForResource:@"main" withExtension:@"jsbundle"];
</code></pre>

<p>这里有个麻烦的地方就是，当我在真机设备上调试时。每次都需要执行 <code>ifconfig</code> 命令，然后将 <code>localhost</code> 修改为我的 ip 地址。并且在使用 git 进行代码管理时，一不小心将修改后的文件提交上去了，其他同事在 pull 时又会与自己的冲突。
最终实在忍受不了了，在想能不能编译时自动获取到本机的 ip 呢，这样就不用每次都手动修改了。于是找到了这篇文章： <a href="http://moduscreate.com/automated-ip-configuration-for-react-native-development/">http://moduscreate.com/automated-ip-configuration-for-react-native-development/</a>
我这里参考了他的方案并做了一点小调整。</p>

<p>按照他的步骤，首先添加 Run Script。
在 Xcode 中选择“Build Phases”，然后点击左上角的&#8221;+&ldquo;选择“New Run Script Phase”。
在列表最后出现了“Run Script”，将其展开，然后编辑代码块的内容：</p>

<pre><code>INFOPLIST="${TARGET_BUILD_DIR}/${INFOPLIST_PATH}"
echo "writing to $INFOPLIST"
PLISTCMD="Add :SERVER_IP string $(ifconfig | grep inet\ | tail -1 | cut -d " " -f 2)"
echo -n "$INFOPLIST" | xargs -0 /usr/libexec/PlistBuddy -c "$PLISTCMD" || true
PLISTCMD="Set :SERVER_IP $(hostname)"
echo -n "$INFOPLIST" | xargs -0 /usr/libexec/PlistBuddy -c "$PLISTCMD" || true
</code></pre>

<p>第二步编辑 <code>AppDelegate.m</code> 文件。
将项目默认生成的 <code>jsCodeLocation</code> 配置删除掉，并添加代码：</p>

<pre><code>#if DEBUG
#if TARGET_OS_SIMULATOR
#warning "DEBUG SIMULATOR"
  jsCodeLocation = [NSURL URLWithString:@"http://localhost:8081/index.ios.bundle?platform=ios&amp;dev=true"];
#else
#warning "DEBUG DEVICE"
  NSString *serverIP = [[NSBundle mainBundle] objectForInfoDictionaryKey:@"SERVER_IP"];
  NSString *jsCodeUrlString = [NSString stringWithFormat:@"http://%@:8081/index.ios.bundle?platform=ios&amp;dev=true", serverIP];
  NSString *jsBundleUrlString = [jsCodeUrlString stringByAddingPercentEscapesUsingEncoding:NSUTF8StringEncoding];
  jsCodeLocation = [NSURL URLWithString:jsBundleUrlString];
#endif
#else
#warning "PRODUCTION DEVICE"
  jsCodeLocation = [[NSBundle mainBundle] URLForResource:@"main" withExtension:@"jsbundle"];
#endif
</code></pre>

<p>这里如果在模拟器中进行调试，那么 development server 则为 localhost；如果在真机设备中调试,那么 development server 则为电脑的 ip 地址。
到此已经可以实现自动设置 ip 地址了，如果还想要在 Chrome 中对设备进行调试，那么还需要修改一下 WebSocket 的配置。</p>

<p>第三步编辑 <code>RCTWebSocketExecutor.m</code> 文件。
在 Xcode 中打开 <YourProject> -> Libraries -> RCTWebSocket.xcodeproj -> RCTWebSocketExecutor.m 文件，大概在文件 53 行左右的位置，将 <code>NSString *URLString = [NSString stringWithFormat:@"http://localhost:%zd/debugger-proxy?role=client", port];</code> 修改为：</p>

<pre><code>#if TARGET_OS_SIMULATOR
    NSString *serverIP = @"localhost";
#else
    NSString *serverIP = [[NSBundle mainBundle] objectForInfoDictionaryKey:@"SERVER_IP"];
#endif
    NSString *URLString = [NSString stringWithFormat:@"http://%@:%zd/debugger-proxy?role=client", serverIP, port];
</code></pre>

<p>现在配置已经完成了，接下来就试试看是否有效吧。</p>

<p>经过修改之后相对于之前已经方便了不少，只是我还遇到一个问题。那就是我的 MacBook 在办公室时的 ip 跟在家里的 ip 是不同的。
这样的话每次切换环境都需要重新编译一下应用，还是有点麻烦。于是乎我自己将第一步的脚本作了下修改，新的内容如下：</p>

<pre><code>INFOPLIST="${TARGET_BUILD_DIR}/${INFOPLIST_PATH}"
echo "writing to $INFOPLIST"
PLISTCMD="Add :SERVER_IP string $(hostname)"
echo -n "$INFOPLIST" | xargs -0 /usr/libexec/PlistBuddy -c "$PLISTCMD" || true
PLISTCMD="Set :SERVER_IP $(hostname)"
echo -n "$INFOPLIST" | xargs -0 /usr/libexec/PlistBuddy -c "$PLISTCMD" || true
</code></pre>

<p>这里我使用 hostname 来作为 development server 的地址，而不是 ip。这样的话即便是网络环境发生了变化，只要手机设备跟电脑处于同一个局域网内就不需要再重新编译应用了。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Mac OS中VirtualBox的Android蓝牙设置]]></title>
    <link href="http://www.xefan.com/archives/84161.html"/>
    <updated>2016-04-03T11:05:11+08:00</updated>
    <id>http://www.xefan.com/archives/84161-VirtualBox中Android蓝牙设置</id>
    <content type="html"><![CDATA[<p>在做手机开发时，由于没有 Android 设备，只得在模拟器中进行测试。然而在模拟器却没法访问本机的蓝牙设备，这对于要做蓝牙开发来说很不方便。</p>

<p>经过各种搜索终于找到了一个解决方案。首先需要以下工具：</p>

<ul>
<li>Mac OS系统</li>
<li>VirtualBox (<a href="https://www.virtualbox.org/">https://www.virtualbox.org/</a>)</li>
<li>Android x86 (<a href="https://sourceforge.net/projects/android-x86/">https://sourceforge.net/projects/android-x86/</a>)</li>
</ul>


<p>1.禁用系统的蓝牙服务：</p>

<pre><code>$ sudo launchctl unload /System/Library/LaunchDaemons/com.apple.blued.plist
# 对于 Mountain Lion 系统执行如下命令：
$ sudo kextunload -b com.apple.iokit.IOBluetoothSerialManager
$ sudo kextunload -b com.apple.iokit.BroadcomBluetoothHCIControllerUSBTransport
# 对于 Snow Leopard 系统执行如下命令：
$ sudo kextunload -b com.apple.driver.BroadcomUSBBluetoothHCIController
$ sudo kextunload -b com.apple.driver.AppleUSBBluetoothHCIController
</code></pre>

<p>2.运行 VirtualBox</p>

<p>设置启用 USB 控制器，添加蓝牙设备，如图：</p>

<p><img src="/wp-content/uploads/2016/04/03/virtualbox-android-bluetooth.png" alt="" /></p>

<p>然后运行 android 系统即可。</p>

<p>3.在退出 VirtualBox 之后，重新启用系统的蓝牙服务：</p>

<pre><code>$ sudo launchctl load /System/Library/LaunchDaemons/com.apple.blued.plist
# 对于 Mountain Lion 系统执行如下命令：
$ sudo kextload -b com.apple.iokit.IOBluetoothSerialManager
$ sudo kextload -b com.apple.iokit.BroadcomBluetoothHCIControllerUSBTransport
# 对于 Snow Leopard 系统执行如下命令：
$ sudo kextload -b com.apple.driver.BroadcomUSBBluetoothHCIController
$ sudo kextload -b com.apple.driver.AppleUSBBluetoothHCIController 
</code></pre>

<p>参考：<br/>
<a href="https://www.virtualbox.org/ticket/2372#comment:17">https://www.virtualbox.org/ticket/2372#comment:17</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[使用distcc加快编译速度]]></title>
    <link href="http://www.xefan.com/archives/84027.html"/>
    <updated>2014-01-07T00:00:00+08:00</updated>
    <id>http://www.xefan.com/archives/84027-使用distcc加快编译速度</id>
    <content type="html"><![CDATA[<p>distcc是一个分布式的C/C++编译工具，它可以组织一个网络内的多台计算机同时进行某个编译任务。</p>


<p>对于Debian系列的系统可以执行如下命令进行安装：</p>


<p>$ sudo apt-get install distcc</p>


<h3>使用</h3>


<p>1、首先得先运行服务器软件</p>


<p>运行如下命令启动distccd服务，并接收192.168.1网段内的所有TCP连接：</p>


<pre><code>$ distccd --allow 192.168.1.0/24 --log-level error --log-file /tmp/distccd.log --daemon
</code></pre>


<p>2、运行客户端软件</p>


<p>设置服务器列表：<br>
设置DISTCC_HOSTS环境变量；或者修改 ~/.distcc/hosts 或者 /etc/distcc/hosts 文件。<br>
每行一个服务器主机地址，主机地址可以是如下格式：  </p>


<pre><code>localhost       表示本地
HOST            TCP连接到该主机的3632端口
HOST:PORT       TCP连接到该主机的指定端口
@HOST           使用ssh连接
USER@HOST       使用指定用户进行ssh连接
</code></pre>


<p>所有的服务器的架构最好是相同的。都是32位或者都是64位。  </p>


<p>3、在编译的时候使用distcc</p>


<p>如果工程使用automake机制：<br>
在configure阶段执行&#8221;CC=distcc ./configure&#8221; ，然后再执行&#8221;make -j XX; make install&#8221;。</p>


<p>如果工程由GNU make管理：<br>
修改Makefile使得在原来C/C++编译器名称前加上&#8221;distcc &#8220;，例如设置CC=&#8221;distcc arm-linux-gcc&#8221;。然后执行&#8221;make -j XX&#8221;。</p>


<p>如果工程由SCons管理：<br>
修改SConstruct使得在原来C/C++编译器名称前加上&#8221;distcc &#8220;。导出环境变量HOME和DISTCC_HOSTS到构建环境（注意SCons不会自动把系统环境变量导出到builder子进程）：</p>


<pre><code>Environment(ENV={'HOME': os.environ['HOME'],'DISTCC_HOSTS': ‘localhost 10.0.0.2’},...)
</code></pre>


<p>然后执行&#8221;scons -j XX&#8221;。</p>


<h3>实例</h3>


<p>接下来编译Python源代码，测试一下distcc。</p>


<pre><code>$ tar xfv Python-2.7.5.tar
$ cd Python-2.7.5
$ ./configure
$ time make
make  124.32s user 7.11s system 94% cpu 2:19.24 total
$ time make
make  0.17s user 0.04s system 89% cpu 0.241 total
$ make clean
$ time make
make  123.52s user 7.32s system 96% cpu 2:16.12 total
</code></pre>


<p>正常编译花了2分10多秒的时间。</p>


<pre><code>$ cat /etc/distcc/hosts
10.0.0.129
localhost
$ tar xfv Python-2.7.5.tar
$ cd Python-2.7.5
$ CC=distcc ./configure
$ time make -j 3
make -j 3  49.58s user 5.53s system 30% cpu 3:01.40 total
$ time make -j 3
make -j 3  0.60s user 0.24s system 7% cpu 11.482 total
$ make clean
$ time make -j 3
make -j 3  46.17s user 5.20s system 40% cpu 2:05.66 total
</code></pre>


<p>使用129这台主机和本机一起进行编译，结果花了3分钟的时间。好像使用distcc编译还比正常的编译方式更耗时，有可能是时间花费在了网络传输上。</p>


<p>如果有多台主机的话效果应该会好些。还有可以配合使用ccache和distcc进一步加快编译速度。</p>


<p>下图是distcc提供的监控工具，用于查看编译执行的情况：</p>


<p><a href="http://www.xefan.com/wp-content/uploads/2014/01/distcc-Monitor.png"><img src="http://www.xefan.com/wp-content/uploads/2014/01/distcc-Monitor-300x194.png" alt="" title="distcc Monitor" width="300" height="194" class="aligncenter size-medium wp-image-84028" /></a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[使用ccache加快编译速度]]></title>
    <link href="http://www.xefan.com/archives/84024.html"/>
    <updated>2014-01-04T00:00:00+08:00</updated>
    <id>http://www.xefan.com/archives/84024-使用ccache加快编译速度</id>
    <content type="html"><![CDATA[<p>ccache是一个编译器缓存，可以将编译的结果缓存起来。这样尽管第一次编译会花费长一点的时间，不过之后再次编译将变得非常非常快。 </p>


<h3>1、安装</h3>


<p>主流的linux发行版应该都有这个包，对于Debian系列的可以执行以下命令安装：</p>


<pre><code>sudo apt-get install ccache
</code></pre>


<h3>2、使用</h3>


<p>安装之后基本不用进行什么配置就可以直接使用了。<br>
例如之前要编译一个hello.c文件要执行命令：  </p>


<pre><code>gcc hello.c -o hello
</code></pre>


<p>现在是：</p>


<pre><code>ccache gcc hello.c -o hello
</code></pre>


<p>ccache默认是将结果缓存保存到 $HOME/.ccache 目录下。如果想要修改这个目录，可以修改 CCACHE_DIR 环境变量。例如：</p>


<pre><code>export CCACHE_DIR=/ramdisk/ccache
</code></pre>


<p>如果觉得每次都在命令前加上ccache比较麻烦的话，有一个一劳永逸的办法。执行如下命令：</p>


<pre><code>cp ccache /usr/local/bin/
ln -s ccache /usr/local/bin/gcc
ln -s ccache /usr/local/bin/g++
ln -s ccache /usr/local/bin/cc
ln -s ccache /usr/local/bin/c++
</code></pre>


<p>不过这样的话每次都是使用的ccache，不太灵活。这个就要自己取舍了。</p>


<h3>3、实例</h3>


<p>接下来通过一个例子来看看使用ccache和不使用的差别。<br>
作为一个Python程序员，我们就来编译一个Python试试。</p>


<pre><code>$ tar xf Python-2.7.3.tar.gz
$ cd Python-2.7.3
$ ./configure
$ time make
make  96.49s user 5.10s system 93% cpu 1:48.77 total
</code></pre>


<p>首次编译花了1分48秒。</p>


<pre><code>$ time make
make  0.12s user 0.03s system 88% cpu 0.172 total
$ make clean
$ time make
make  96.46s user 4.98s system 95% cpu 1:46.43 total
</code></pre>


<p>清除结果之后再次编译，还是花了1分46秒。</p>


<p>再来看看使用ccache后的结果：</p>


<pre><code>$ tar xf Python-2.7.3.tar.gz
$ cd Python-2.7.3
$ ./configure
$ time make
make  99.42s user 5.84s system 93% cpu 1:52.95 total

$ time make
make  0.16s user 0.00s system 89% cpu 0.178 total
$ make clean
$ time make
make  3.36s user 1.41s system 52% cpu 9.093 total
</code></pre>


<p>首次编译花了1分52秒，之后都是只花了几秒。</p>


<p>查看ccache的统计信息：</p>


<pre><code>$ ccache -s
cache directory                     /home/longchang/.ccache
cache hit (direct)                   250
cache hit (preprocessed)               4
cache miss                           349
called for link                      132
alled for preprocessing              84
compile failed                        29
preprocessor error                    28
bad compiler arguments                 5
unsupported source language            6
autoconf compile/link                224
no input file                         24
files in cache                       710
cache size                          30.3 Mbytes
max cache size                       1.0 Gbytes
</code></pre>


<p>清除掉缓存后再次编译：</p>


<pre><code>$ ccache -c
Cleaned cache

$ make clean
$ time make
make  99.36s user 5.94s system 92% cpu 1:53.47 total

$ make clean
$ time make
make  3.48s user 1.42s system 54% cpu 9.049 total
</code></pre>


<p>ccache手册： <a href="http://ccache.samba.org/manual.html">http://ccache.samba.org/manual.html</a></p>

]]></content>
  </entry>
  
</feed>
